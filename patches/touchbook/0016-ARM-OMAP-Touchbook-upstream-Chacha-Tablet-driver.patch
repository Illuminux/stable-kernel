From d8152dbd06f28411a7adb2d0f4366ade617363ed Mon Sep 17 00:00:00 2001
From: Robert Nelson <robertcnelson@gmail.com>
Date: Thu, 16 Sep 2010 15:14:21 -0500
Subject: [PATCH 16/22] ARM OMAP Touchbook upstream Chacha Tablet driver

---
 drivers/input/touchscreen/Kconfig  |   13 +
 drivers/input/touchscreen/Makefile |    1 +
 drivers/input/touchscreen/chacha.c |  488 ++++++++++++++++++++++++++++++++++++
 include/linux/i2c/chacha.h         |   50 ++++
 4 files changed, 552 insertions(+), 0 deletions(-)
 create mode 100644 drivers/input/touchscreen/chacha.c
 create mode 100644 include/linux/i2c/chacha.h

diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 0069d97..e7c3a7c 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -98,6 +98,19 @@ config TOUCHSCREEN_BITSY
 	  To compile this driver as a module, choose M here: the
 	  module will be called h3600_ts_input.
 
+config TOUCHSCREEN_CHACHA
+	tristate "Chacha based touchscreens"
+	depends on I2C
+	help
+	  Say Y here if you have a touchscreen interface using the
+	  Chacha controller, and your board-specific
+	  setup code includes that in its table of I2C devices.
+
+	  If unsure, say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called chacha.
+
 config TOUCHSCREEN_CY8CTMG110
 	tristate "cy8ctmg110 touchscreen"
 	depends on I2C
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 28217e1..16496c5 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -14,6 +14,7 @@ obj-$(CONFIG_TOUCHSCREEN_AD7879_SPI)	+= ad7879-spi.o
 obj-$(CONFIG_TOUCHSCREEN_ADS7846)	+= ads7846.o
 obj-$(CONFIG_TOUCHSCREEN_ATMEL_TSADCC)	+= atmel_tsadcc.o
 obj-$(CONFIG_TOUCHSCREEN_BITSY)		+= h3600_ts_input.o
+obj-$(CONFIG_TOUCHSCREEN_CHACHA)	+= chacha.o
 obj-$(CONFIG_TOUCHSCREEN_CY8CTMG110)	+= cy8ctmg110_ts.o
 obj-$(CONFIG_TOUCHSCREEN_DA9034)	+= da9034-ts.o
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
diff --git a/drivers/input/touchscreen/chacha.c b/drivers/input/touchscreen/chacha.c
new file mode 100644
index 0000000..cf9d168
--- /dev/null
+++ b/drivers/input/touchscreen/chacha.c
@@ -0,0 +1,488 @@
+/* Linux kernel driver for the Chacha touchscreen I2C controller
+ *
+ * Copyright (C) 2010 by Always Innovating, Inc.
+ * Author: Gregoire Gentil <gregoire@gentil.com>
+ * Author: Tim Yamin <plasm@roo.me.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <linux/i2c.h>
+#include <linux/i2c/chacha.h>
+#include <linux/timer.h>
+
+struct chacha_priv {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct input_dev *input2;
+	struct work_struct work;
+	int irq;
+
+	/* Issue mode change... */
+	u8 modeChange;
+
+	/* Should we listen? */
+	u8 active;
+};
+
+static void chacha_unFreeze(struct i2c_client *client)
+{
+	/* UNTESTED */
+
+	struct i2c_msg msgs[] = {
+		{ .addr = client->addr, },
+		{ .addr = client->addr, },
+	};
+
+	i2c_transfer(client->adapter, msgs, 2);
+}
+
+static void chacha_worker(struct work_struct *work)
+{
+	u8  buf[12], fingers;
+	u16 posX, posY, pos2X, pos2Y, strength;
+
+	struct chacha_priv *priv = container_of(work,
+						  struct chacha_priv,
+						  work);
+
+	struct chacha_platform_data *pdata = priv->client->dev.platform_data;
+
+	if(pdata->calibrate != 0) {
+		printk("Calibration of the Touchscreen - Don't touch it\n");
+		if (pdata->version == 3) {
+			int ret;
+			unsigned char buf;
+			while (gpio_get_value(pdata->gpio) != 0)
+				;
+			if (pdata->calibrate == 1)
+				buf = 0x01;
+			else if (pdata->calibrate == 2)
+				buf = 0x40;
+			else if (pdata->calibrate == 3)
+				buf = 0xF3;
+			i2c_smbus_write_byte_data(priv->client, REG_CALIBRATION_VERSION3 - 1 + pdata->calibrate, buf);
+			(pdata->calibrate)++;
+			if (pdata->calibrate == 4)
+				pdata->calibrate = 0;
+		}
+		enable_irq(priv->irq);
+		return;
+	}
+
+	/* Is a mode change pending? If so, set the new mode... */
+	if(priv->modeChange) {
+		printk("Chacha (version %d) Mode changing %d \n", pdata->version, priv->modeChange);
+		if (pdata->version == 3)
+			i2c_smbus_write_byte_data(priv->client, REG_MODE_VERSION3, priv->modeChange);
+		else {
+			/*FIXME: Pull low Attn line*/
+			i2c_smbus_write_byte_data(priv->client, REG_MODE_VERSION4, priv->modeChange);
+			/*FIXME: Release Attn line*/
+		}
+		priv->modeChange = 0;
+		enable_irq(priv->irq);
+		return;
+	}
+
+	/* Nothing more to do if we're not active... */
+	if(!priv->active) {
+		enable_irq(priv->irq);
+		return;
+	}
+
+	if (gpio_get_value(pdata->gpio) != 0) {
+		enable_irq(priv->irq);
+		return;
+	}
+
+	/* Read the status registers */
+	if (i2c_master_recv(priv->client, buf, sizeof(buf)) != sizeof(buf)) {
+		/*dev_err(&priv->client->dev, "Unable to read status registers!\n");*/
+		enable_irq(priv->irq);
+		return;
+	}
+
+	if (pdata->version == 3) {
+		fingers  = buf[0x00] & 0x03;
+		posX     = (buf[0x03] << 8) | buf[0x02];
+		posY     = (buf[0x05] << 8) | buf[0x04];
+		pos2X     = (buf[0x07] << 8) | buf[0x06];
+		pos2Y     = (buf[0x09] << 8) | buf[0x08];
+		strength = (buf[0x0B] << 8) | buf[0x0A];
+	} else {
+		fingers  = buf[0x00] & 0x03;
+		posX     = (buf[0x02] << 8) | buf[0x01];
+		posY     = (buf[0x04] << 8) | buf[0x03];
+		pos2X     = (buf[0x06] << 8) | buf[0x05];
+		pos2Y     = (buf[0x08] << 8) | buf[0x07];
+		strength = (buf[0x0A] << 8) | buf[0x09];
+	}
+
+	if (fingers >= 2) {
+		if (pdata->debug)
+			printk("%d fingers, two positions: x1 %d y1 %d    x2 %d y2 %d\n", fingers, posX, 0xFFFF - posY, pos2X, 0xFFFF - pos2Y);
+		input_report_key(priv->input, BTN_TOUCH, 1);
+		input_report_abs(priv->input, ABS_X, posX);
+		input_report_abs(priv->input, ABS_Y, 0xFFFF - posY);
+		input_report_abs(priv->input, ABS_PRESSURE, strength);
+		input_report_key(priv->input2, BTN_TOUCH, 1);
+		input_report_abs(priv->input2, ABS_X, pos2X);
+		input_report_abs(priv->input2, ABS_Y, 0xFFFF - pos2Y);
+		input_report_abs(priv->input2, ABS_PRESSURE, strength);
+		pdata->secondfinger = 1;
+		input_sync(priv->input);
+		input_sync(priv->input2);
+	}
+	if (fingers == 1) {
+		if (pdata->debug)
+			printk("One position: x1 %d    y1 %d\n", posX, 0xFFFF - posY);
+		input_report_key(priv->input, BTN_TOUCH, 1);
+		input_report_abs(priv->input, ABS_X, posX);
+		input_report_abs(priv->input, ABS_Y, 0xFFFF - posY);
+		input_report_abs(priv->input, ABS_PRESSURE, strength);
+		input_sync(priv->input);
+		if (pdata->secondfinger == 1) {
+			input_report_key(priv->input2, BTN_TOUCH, 0);
+			input_sync(priv->input2);
+			pdata->secondfinger = 0;
+		}
+	}
+	if (fingers == 0) {
+		input_report_key(priv->input, BTN_TOUCH, 0);
+		input_sync(priv->input);
+		if (pdata->secondfinger == 1) {
+			input_report_key(priv->input2, BTN_TOUCH, 0);
+			input_sync(priv->input2);
+			pdata->secondfinger = 0;
+		}
+	}
+
+	enable_irq(priv->irq);
+}
+
+static irqreturn_t chacha_isr(int irq, void *dev_id)
+{
+	struct chacha_priv *priv = dev_id;
+
+	/* The touch screen controller chip is hooked up to the CPU
+	 * using I2C and a single interrupt line. The interrupt line
+	 * is pulled low periodically. While it's pulled low, you may
+	 * communicate with the chip. If you try to communicate when
+	 * the line is high, the chip ignores you.
+	 *
+	 * FIXME: Implement 'freeze mode' -- that way we don't have to
+	 * handle interrupts when nobody is listening to the chip.
+	 */
+
+	/* If nobody is listening and a mode change isn't pending,
+	 * just ignore the chip... */
+	if(!priv->active && !priv->modeChange)
+		return IRQ_HANDLED;
+
+	schedule_work(&priv->work);
+	disable_irq_nosync(irq);
+	return IRQ_HANDLED;
+}
+
+static int chacha_open(struct input_dev *dev)
+{
+	struct chacha_priv *priv = input_get_drvdata(dev);
+
+	struct chacha_platform_data *pdata = priv->client->dev.platform_data;
+
+	priv->active = 1;
+	if (pdata->version == 3)
+		priv->modeChange = MODE_ACTIVE_VERSION3;
+	else
+		priv->modeChange = MODE_ACTIVE_VERSION4;
+
+	return 0;
+}
+
+static void chacha_close(struct input_dev *dev)
+{
+	struct chacha_priv *priv = input_get_drvdata(dev);
+
+	struct chacha_platform_data *pdata = priv->client->dev.platform_data;
+
+	priv->active = 0;
+	if (pdata->version == 3)
+		priv->modeChange = MODE_INACTIVE_VERSION3;
+	else
+		priv->modeChange = MODE_INACTIVE_VERSION4;
+}
+
+static ssize_t do_calibrate(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+
+	if (pdata->version == 3)
+		pdata->calibrate = 1;
+	else {
+		gpio_direction_output(pdata->gpio, 1);
+		gpio_set_value(pdata->gpio, 0);
+		i2c_smbus_write_byte_data(client, REG_CALIBRATION_VERSION4, 0x01);
+		gpio_set_value(pdata->gpio, 1);
+		gpio_set_value(pdata->gpio, 0);
+		i2c_smbus_write_byte_data(client, REG_CALIBRATION_VERSION4, 0x40);
+		gpio_set_value(pdata->gpio, 1);
+		gpio_set_value(pdata->gpio, 0);
+		i2c_smbus_write_byte_data(client, REG_CALIBRATION_VERSION4, 0xF3);
+		gpio_set_value(pdata->gpio, 1);
+		gpio_direction_input(pdata->gpio);
+	}
+	return count;
+}
+
+static DEVICE_ATTR(calibrate, S_IWUGO, NULL, do_calibrate);
+
+static ssize_t show_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+
+	return sprintf(buf, "%u\n", pdata->version);
+}
+
+static ssize_t write_version(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+	struct chacha_priv *priv = dev_get_drvdata(dev);
+
+	unsigned long i;
+
+        if (strict_strtoul(buf, 10, &i))
+		return -EINVAL;
+
+	if ((i==3) || (i==4)) {
+		pdata->version = i;
+		priv->active = 1;
+		if (pdata->version == 3)
+			priv->modeChange = MODE_ACTIVE_VERSION3;
+		else
+			priv->modeChange = MODE_ACTIVE_VERSION4;
+	}
+
+	return count;
+}
+
+static DEVICE_ATTR(version, S_IRUGO | S_IWUGO, show_version, write_version);
+
+static ssize_t show_debug(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+
+	return sprintf(buf, "%u\n", pdata->debug);
+}
+
+static ssize_t write_debug(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+
+	unsigned long i;
+
+        if (strict_strtoul(buf, 10, &i))
+		return -EINVAL;
+
+	pdata->debug = i;
+	return count;
+}
+
+static DEVICE_ATTR(debug, S_IRUGO | S_IWUGO, show_debug, write_debug);
+
+static struct attribute *chacha_attributes[] = {
+	&dev_attr_calibrate.attr,
+	&dev_attr_version.attr,
+	&dev_attr_debug.attr,
+	NULL,
+};
+
+static struct attribute_group chacha_attr_group = {
+	.attrs = chacha_attributes,
+};
+
+static int chacha_probe(struct i2c_client *client,
+			  const struct i2c_device_id *idp)
+{
+	struct chacha_priv *priv;
+	struct chacha_platform_data *data;
+	struct input_dev *input, *input2;
+	int error;
+	struct chacha_platform_data *pdata = client->dev.platform_data;
+	char *name2 = kzalloc(256, GFP_KERNEL);;
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "failed to allocate driver private data\n");
+		error = -ENOMEM;
+		goto err0;
+	}
+
+	dev_set_drvdata(&client->dev, priv);
+
+	input = input_allocate_device();
+	if (!input) {
+		dev_err(&client->dev, "Failed to allocate input device.\n");
+		error = -ENOMEM;
+		goto err1;
+	}
+
+	input->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input, ABS_X, pdata->minX, pdata->maxX, 0, 0);
+	input_set_abs_params(input, ABS_Y, pdata->minY, pdata->maxY, 0, 0);
+	input_set_abs_params(input, ABS_PRESSURE, 0, 0xFFFF, 0, 0);
+
+	input->name = pdata->name;
+	input->id.bustype = BUS_I2C;
+	input->dev.parent = &client->dev;
+
+	input->open = chacha_open;
+	input->close = chacha_close;
+
+	input_set_drvdata(input, priv);
+
+	input2 = input_allocate_device();
+	if (!input2) {
+		dev_err(&client->dev, "Failed to allocate second input device.\n");
+		error = -ENOMEM;
+		goto err1;
+	}
+
+	input2->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input2->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input2, ABS_X, pdata->minX, pdata->maxX, 0, 0);
+	input_set_abs_params(input2, ABS_Y, pdata->minY, pdata->maxY, 0, 0);
+	input_set_abs_params(input2, ABS_PRESSURE, 0, 0xFFFF, 0, 0);
+
+	strcpy(name2, pdata->name);
+	strcat(name2, " 2nd-touch");
+	input2->name = name2;
+	input2->id.bustype = BUS_I2C;
+	input2->dev.parent = &client->dev;
+
+	input2->open = NULL;
+	input2->close = NULL;
+
+	input_set_drvdata(input2, priv);
+
+	priv->client = client;
+	priv->input = input;
+	priv->input2 = input2;
+	INIT_WORK(&priv->work, chacha_worker);
+	priv->irq = client->irq;
+
+	error = input_register_device(input);
+	if (error)
+		goto err1;
+
+	error = input_register_device(input2);
+	if (error)
+		goto err1;
+
+	error = request_irq(priv->irq, chacha_isr, IRQF_TRIGGER_FALLING,
+			    client->name, priv);
+	if (error) {
+		dev_err(&client->dev, "Unable to request touchscreen IRQ.\n");
+		goto err2;
+	}
+
+	data = kzalloc(sizeof(struct chacha_platform_data), GFP_KERNEL);
+	if (!data) {
+		dev_err(&client->dev, "failed to allocate driver data\n");
+		error = -ENOMEM;
+		goto err2;
+	}
+
+	i2c_set_clientdata(client, data);
+
+	error = sysfs_create_group(&client->dev.kobj, &chacha_attr_group);
+
+	return 0;
+
+ err2:
+	input_unregister_device(input);
+	input = NULL; /* so we dont try to free it below */
+ err1:
+	input_free_device(input);
+	kfree(priv);
+	kfree(name2);
+ err0:
+	dev_set_drvdata(&client->dev, NULL);
+	return error;
+}
+
+static int chacha_remove(struct i2c_client *client)
+{
+	struct chacha_priv *priv = dev_get_drvdata(&client->dev);
+
+	free_irq(priv->irq, priv);
+	input_unregister_device(priv->input);
+	kfree(priv);
+
+	dev_set_drvdata(&client->dev, NULL);
+
+	sysfs_remove_group(&client->dev.kobj, &chacha_attr_group);
+
+	return 0;
+}
+
+static const struct i2c_device_id chacha_id[] = {
+	{ "chacha", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, chacha);
+
+static struct i2c_driver chacha_driver = {
+	.driver = {
+		.name = "chacha",
+	},
+	.probe = chacha_probe,
+	.remove = chacha_remove,
+	.id_table = chacha_id,
+};
+
+static int __init chacha_init(void)
+{
+	return i2c_add_driver(&chacha_driver);
+}
+
+static void __exit chacha_exit(void)
+{
+	i2c_del_driver(&chacha_driver);
+}
+
+module_init(chacha_init);
+module_exit(chacha_exit);
+
+MODULE_DESCRIPTION("Touchscreen driver for Chacha controller");
+MODULE_AUTHOR("Gregoire Gentil");
+MODULE_LICENSE("GPL");
diff --git a/include/linux/i2c/chacha.h b/include/linux/i2c/chacha.h
new file mode 100644
index 0000000..f9f23d1
--- /dev/null
+++ b/include/linux/i2c/chacha.h
@@ -0,0 +1,50 @@
+/* Linux kernel driver for the Chacha touchscreen I2C controller
+ *
+ * Copyright (C) 2010 by Always Innovating, Inc.
+ * Author: Gregoire Gentil <gregoire@gentil.com>
+ * Author: Tim Yamin <plasm@roo.me.uk>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+
+#ifndef __CHACHA_H_
+#define __CHACHA_H_
+
+#define REG_MODE_VERSION3		0xC2
+#define MODE_ACTIVE_VERSION3		0x0A
+#define MODE_INACTIVE_VERSION3 	0x04
+#define REG_CALIBRATION_VERSION3	0xC1
+
+#define REG_MODE_VERSION4		0x14
+#define MODE_ACTIVE_VERSION4		0x00
+#define MODE_INACTIVE_VERSION4		0x04
+#define REG_CALIBRATION_VERSION4	0x13
+
+struct chacha_platform_data {
+	int gpio;
+	int version;
+	int calibrate;
+	int debug;
+	int secondfinger;
+	const char *name;
+	int minX;
+	int maxX;
+	int minY;
+	int maxY;
+};
+
+#endif
-- 
1.7.1

