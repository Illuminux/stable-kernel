From 32471cd19e094f860744df8dfba3d89b0415d0fd Mon Sep 17 00:00:00 2001
From: Paul Walmsley <paul@pwsan.com>
Date: Thu, 10 Mar 2011 22:17:45 -0700
Subject: [PATCH 237/258] OMAP2+: voltage: reorganize, split code from data

This is a first pass at reorganizing mach-omap2/voltage.c:

- Separate almost all of the data from the code of mach-omap2/voltage.c.
  The code remains in mach-omap2/voltage.c.  The data goes into one
  of several places, depending on what type of data it is:

  - Silicon process/validation data: mach-omap2/opp*_data.c
  - VC (Voltage Controller) data: mach-omap2/vc*_data.c
  - VP (Voltage Processor) data: mach-omap2/vp*_data.c
  - Voltage domain data: mach-omap2/voltagedomains*_data.c

  The ultimate goal is for all this data to be autogenerated, the same
  way we autogenerate the rest of our data.

- Separate VC and VP common data from VDD-specific VC and VP data.

- Separate common voltage.c code from SoC-specific code; reuse common code.

- Reorganize structures to avoid unnecessary memory loss due to unpacked
  fields.

There is much left to be done.  VC code and VP code should be separated out
into vc*.c and vp*.c files.  Many fields in the existing structures are
superfluous, and should be removed.  Some code in voltage.c seems to be
duplicated; that code should be moved into functions of its own.  Proper
voltage domain code should be created, as was done with the powerdomain
and clockdomains, and powerdomains should reference voltagedomains.

Thanks to Shweta Gulati <shweta.gulati@ti.com> for comments.  Thanks
to Rajendra Nayak <rnayak@ti.com> for finding and fixing some bugs
that prevented OMAP4 from booting:

   https://patchwork.kernel.org/patch/587311/

His patch has been folded into this one to avoid breaking OMAP4
between patches.  Thanks also to Kevin Hilman <khilman@ti.com> for
finding and fixing a compile problem when !CONFIG_PM:

   http://www.spinics.net/lists/arm-kernel/msg118067.html

His patch has also been folded into this one to avoid breaking
!CONFIG_PM builds.

Signed-off-by: Paul Walmsley <paul@pwsan.com>
Cc: Shweta Gulati <shweta.gulati@ti.com>
Cc: Rajendra Nayak <rnayak@ti.com>
Cc: Kevin Hilman <khilman@ti.com>
---
 arch/arm/mach-omap2/Makefile                  |   22 +-
 arch/arm/mach-omap2/omap_opp_data.h           |   24 +
 arch/arm/mach-omap2/opp3xxx_data.c            |   66 ++-
 arch/arm/mach-omap2/opp4xxx_data.c            |   43 +-
 arch/arm/mach-omap2/vc.h                      |   83 ++
 arch/arm/mach-omap2/vc3xxx_data.c             |   63 ++
 arch/arm/mach-omap2/vc44xx_data.c             |   75 ++
 arch/arm/mach-omap2/voltage.c                 | 1017 +++++++------------------
 arch/arm/mach-omap2/voltage.h                 |   89 ++-
 arch/arm/mach-omap2/voltagedomains3xxx_data.c |   95 +++
 arch/arm/mach-omap2/voltagedomains44xx_data.c |  102 +++
 arch/arm/mach-omap2/vp.h                      |  143 ++++
 arch/arm/mach-omap2/vp3xxx_data.c             |   82 ++
 arch/arm/mach-omap2/vp44xx_data.c             |  100 +++
 14 files changed, 1226 insertions(+), 778 deletions(-)
 create mode 100644 arch/arm/mach-omap2/vc.h
 create mode 100644 arch/arm/mach-omap2/vc3xxx_data.c
 create mode 100644 arch/arm/mach-omap2/vc44xx_data.c
 create mode 100644 arch/arm/mach-omap2/voltagedomains3xxx_data.c
 create mode 100644 arch/arm/mach-omap2/voltagedomains44xx_data.c
 create mode 100644 arch/arm/mach-omap2/vp.h
 create mode 100644 arch/arm/mach-omap2/vp3xxx_data.c
 create mode 100644 arch/arm/mach-omap2/vp44xx_data.c

diff --git a/arch/arm/mach-omap2/Makefile b/arch/arm/mach-omap2/Makefile
index 534d89a..82b2a67 100644
--- a/arch/arm/mach-omap2/Makefile
+++ b/arch/arm/mach-omap2/Makefile
@@ -59,10 +59,10 @@ endif
 # Power Management
 ifeq ($(CONFIG_PM),y)
 obj-$(CONFIG_ARCH_OMAP2)		+= pm24xx.o
-obj-$(CONFIG_ARCH_OMAP2)		+= sleep24xx.o pm_bus.o voltage.o
-obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o voltage.o \
+obj-$(CONFIG_ARCH_OMAP2)		+= sleep24xx.o pm_bus.o
+obj-$(CONFIG_ARCH_OMAP3)		+= pm34xx.o sleep34xx.o \
 					   cpuidle34xx.o pm_bus.o
-obj-$(CONFIG_ARCH_OMAP4)		+= pm44xx.o voltage.o pm_bus.o
+obj-$(CONFIG_ARCH_OMAP4)		+= pm44xx.o pm_bus.o
 obj-$(CONFIG_PM_DEBUG)			+= pm-debug.o
 obj-$(CONFIG_OMAP_SMARTREFLEX)          += sr_device.o smartreflex.o
 obj-$(CONFIG_OMAP_SMARTREFLEX_CLASS3)	+= smartreflex-class3.o
@@ -78,13 +78,25 @@ endif
 
 # PRCM
 obj-$(CONFIG_ARCH_OMAP2)		+= prcm.o cm2xxx_3xxx.o prm2xxx_3xxx.o
-obj-$(CONFIG_ARCH_OMAP3)		+= prcm.o cm2xxx_3xxx.o prm2xxx_3xxx.o
+obj-$(CONFIG_ARCH_OMAP3)		+= prcm.o cm2xxx_3xxx.o prm2xxx_3xxx.o \
+					   vc3xxx_data.o vp3xxx_data.o
 # XXX The presence of cm2xxx_3xxx.o on the line below is temporary and
 # will be removed once the OMAP4 part of the codebase is converted to
 # use OMAP4-specific PRCM functions.
 obj-$(CONFIG_ARCH_OMAP4)		+= prcm.o cm2xxx_3xxx.o cminst44xx.o \
 					   cm44xx.o prcm_mpu44xx.o \
-					   prminst44xx.o
+					   prminst44xx.o vc44xx_data.o \
+					   vp44xx_data.o
+
+# OMAP voltage domains
+ifeq ($(CONFIG_PM),y)
+voltagedomain-common			:= voltage.o
+obj-$(CONFIG_ARCH_OMAP2)		+= $(voltagedomain-common)
+obj-$(CONFIG_ARCH_OMAP3)		+= $(voltagedomain-common) \
+					   voltagedomains3xxx_data.o
+obj-$(CONFIG_ARCH_OMAP4)		+= $(voltagedomain-common) \
+					   voltagedomains44xx_data.o
+endif
 
 # OMAP powerdomain framework
 powerdomain-common			+= powerdomain.o powerdomain-common.o
diff --git a/arch/arm/mach-omap2/omap_opp_data.h b/arch/arm/mach-omap2/omap_opp_data.h
index 46ac27d..c784c12 100644
--- a/arch/arm/mach-omap2/omap_opp_data.h
+++ b/arch/arm/mach-omap2/omap_opp_data.h
@@ -21,6 +21,8 @@
 
 #include <plat/omap_hwmod.h>
 
+#include "voltage.h"
+
 /*
  * *BIG FAT WARNING*:
  * USE the following ONLY in opp data initialization common to an SoC.
@@ -65,8 +67,30 @@ struct omap_opp_def {
 	.u_volt		= _uv,					\
 }
 
+/*
+ * Initialization wrapper used to define SmartReflex process data
+ * XXX Is this needed?  Just use C99 initializers in data files?
+ */
+#define VOLT_DATA_DEFINE(_v_nom, _efuse_offs, _errminlimit, _errgain)  \
+{								       \
+	.volt_nominal	= _v_nom,				       \
+	.sr_efuse_offs	= _efuse_offs,				       \
+	.sr_errminlimit = _errminlimit,				       \
+	.vp_errgain	= _errgain				       \
+}
+
 /* Use this to initialize the default table */
 extern int __init omap_init_opp_table(struct omap_opp_def *opp_def,
 		u32 opp_def_size);
 
+
+extern struct omap_volt_data omap34xx_vddmpu_volt_data[];
+extern struct omap_volt_data omap34xx_vddcore_volt_data[];
+extern struct omap_volt_data omap36xx_vddmpu_volt_data[];
+extern struct omap_volt_data omap36xx_vddcore_volt_data[];
+
+extern struct omap_volt_data omap44xx_vdd_mpu_volt_data[];
+extern struct omap_volt_data omap44xx_vdd_iva_volt_data[];
+extern struct omap_volt_data omap44xx_vdd_core_volt_data[];
+
 #endif		/* __ARCH_ARM_MACH_OMAP2_OMAP_OPP_DATA_H */
diff --git a/arch/arm/mach-omap2/opp3xxx_data.c b/arch/arm/mach-omap2/opp3xxx_data.c
index fd3a1af..d2bd1bd 100644
--- a/arch/arm/mach-omap2/opp3xxx_data.c
+++ b/arch/arm/mach-omap2/opp3xxx_data.c
@@ -4,8 +4,9 @@
  * Copyright (C) 2009-2010 Texas Instruments Incorporated - http://www.ti.com/
  *	Nishanth Menon
  *	Kevin Hilman
- * Copyright (C) 2010 Nokia Corporation.
+ * Copyright (C) 2010-2011 Nokia Corporation.
  *      Eduardo Valentin
+ *      Paul Walmsley
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -20,9 +21,72 @@
 
 #include <plat/cpu.h>
 
+#include "control.h"
 #include "omap_opp_data.h"
 #include "pm.h"
 
+/* 34xx */
+
+/* VDD1 */
+
+#define OMAP3430_VDD_MPU_OPP1_UV		975000
+#define OMAP3430_VDD_MPU_OPP2_UV		1075000
+#define OMAP3430_VDD_MPU_OPP3_UV		1200000
+#define OMAP3430_VDD_MPU_OPP4_UV		1270000
+#define OMAP3430_VDD_MPU_OPP5_UV		1350000
+
+struct omap_volt_data omap34xx_vddmpu_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP1_UV, OMAP343X_CONTROL_FUSE_OPP1_VDD1, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP2_UV, OMAP343X_CONTROL_FUSE_OPP2_VDD1, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP3_UV, OMAP343X_CONTROL_FUSE_OPP3_VDD1, 0xf9, 0x18),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP4_UV, OMAP343X_CONTROL_FUSE_OPP4_VDD1, 0xf9, 0x18),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP5_UV, OMAP343X_CONTROL_FUSE_OPP5_VDD1, 0xf9, 0x18),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+/* VDD2 */
+
+#define OMAP3430_VDD_CORE_OPP1_UV		975000
+#define OMAP3430_VDD_CORE_OPP2_UV		1050000
+#define OMAP3430_VDD_CORE_OPP3_UV		1150000
+
+struct omap_volt_data omap34xx_vddcore_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP1_UV, OMAP343X_CONTROL_FUSE_OPP1_VDD2, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP2_UV, OMAP343X_CONTROL_FUSE_OPP2_VDD2, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP3_UV, OMAP343X_CONTROL_FUSE_OPP3_VDD2, 0xf9, 0x18),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+/* 36xx */
+
+/* VDD1 */
+
+#define OMAP3630_VDD_MPU_OPP50_UV		1012500
+#define OMAP3630_VDD_MPU_OPP100_UV		1200000
+#define OMAP3630_VDD_MPU_OPP120_UV		1325000
+#define OMAP3630_VDD_MPU_OPP1G_UV		1375000
+
+struct omap_volt_data omap36xx_vddmpu_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP50_UV, OMAP3630_CONTROL_FUSE_OPP50_VDD1, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP100_UV, OMAP3630_CONTROL_FUSE_OPP100_VDD1, 0xf9, 0x16),
+	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP120_UV, OMAP3630_CONTROL_FUSE_OPP120_VDD1, 0xfa, 0x23),
+	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP1G_UV, OMAP3630_CONTROL_FUSE_OPP1G_VDD1, 0xfa, 0x27),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+/* VDD2 */
+
+#define OMAP3630_VDD_CORE_OPP50_UV		1000000
+#define OMAP3630_VDD_CORE_OPP100_UV		1200000
+
+struct omap_volt_data omap36xx_vddcore_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP3630_VDD_CORE_OPP50_UV, OMAP3630_CONTROL_FUSE_OPP50_VDD2, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP3630_VDD_CORE_OPP100_UV, OMAP3630_CONTROL_FUSE_OPP100_VDD2, 0xf9, 0x16),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+/* OPP data */
+
 static struct omap_opp_def __initdata omap34xx_opp_def_list[] = {
 	/* MPU OPP1 */
 	OPP_INITIALIZER("mpu", true, 125000000, 975000),
diff --git a/arch/arm/mach-omap2/opp4xxx_data.c b/arch/arm/mach-omap2/opp4xxx_data.c
index f0e9939..5030794 100644
--- a/arch/arm/mach-omap2/opp4xxx_data.c
+++ b/arch/arm/mach-omap2/opp4xxx_data.c
@@ -5,8 +5,9 @@
  *	Nishanth Menon
  *	Kevin Hilman
  *	Thara Gopinath
- * Copyright (C) 2010 Nokia Corporation.
+ * Copyright (C) 2010-2011 Nokia Corporation.
  *      Eduardo Valentin
+ *      Paul Walmsley
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -21,9 +22,49 @@
 
 #include <plat/cpu.h>
 
+#include "control.h"
 #include "omap_opp_data.h"
 #include "pm.h"
 
+/*
+ * Structures containing OMAP4430 voltage supported and various
+ * voltage dependent data for each VDD.
+ */
+
+#define OMAP4430_VDD_MPU_OPP50_UV		930000
+#define OMAP4430_VDD_MPU_OPP100_UV		1100000
+#define OMAP4430_VDD_MPU_OPPTURBO_UV		1260000
+#define OMAP4430_VDD_MPU_OPPNITRO_UV		1350000
+
+struct omap_volt_data omap44xx_vdd_mpu_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPP50_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP50, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPP100_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP100, 0xf9, 0x16),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPTURBO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPTURBO, 0xfa, 0x23),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITRO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO, 0xfa, 0x27),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+#define OMAP4430_VDD_IVA_OPP50_UV		930000
+#define OMAP4430_VDD_IVA_OPP100_UV		1100000
+#define OMAP4430_VDD_IVA_OPPTURBO_UV		1260000
+
+struct omap_volt_data omap44xx_vdd_iva_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPP50_UV, OMAP44XX_CONTROL_FUSE_IVA_OPP50, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPP100_UV, OMAP44XX_CONTROL_FUSE_IVA_OPP100, 0xf9, 0x16),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPPTURBO_UV, OMAP44XX_CONTROL_FUSE_IVA_OPPTURBO, 0xfa, 0x23),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+#define OMAP4430_VDD_CORE_OPP50_UV		930000
+#define OMAP4430_VDD_CORE_OPP100_UV		1100000
+
+struct omap_volt_data omap44xx_vdd_core_volt_data[] = {
+	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP50_UV, OMAP44XX_CONTROL_FUSE_CORE_OPP50, 0xf4, 0x0c),
+	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP100_UV, OMAP44XX_CONTROL_FUSE_CORE_OPP100, 0xf9, 0x16),
+	VOLT_DATA_DEFINE(0, 0, 0, 0),
+};
+
+
 static struct omap_opp_def __initdata omap44xx_opp_def_list[] = {
 	/* MPU OPP1 - OPP50 */
 	OPP_INITIALIZER("mpu", true, 300000000, 1100000),
diff --git a/arch/arm/mach-omap2/vc.h b/arch/arm/mach-omap2/vc.h
new file mode 100644
index 0000000..e776777
--- /dev/null
+++ b/arch/arm/mach-omap2/vc.h
@@ -0,0 +1,83 @@
+/*
+ * OMAP3/4 Voltage Controller (VC) structure and macro definitions
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ */
+#ifndef __ARCH_ARM_MACH_OMAP2_VC_H
+#define __ARCH_ARM_MACH_OMAP2_VC_H
+
+#include <linux/kernel.h>
+
+/**
+ * struct omap_vc_common_data - per-VC register/bitfield data
+ * @cmd_on_mask: ON bitmask in PRM_VC_CMD_VAL* register
+ * @valid: VALID bitmask in PRM_VC_BYPASS_VAL register
+ * @smps_sa_reg: Offset of PRM_VC_SMPS_SA reg from PRM start
+ * @smps_volra_reg: Offset of PRM_VC_SMPS_VOL_RA reg from PRM start
+ * @bypass_val_reg: Offset of PRM_VC_BYPASS_VAL reg from PRM start
+ * @data_shift: DATA field shift in PRM_VC_BYPASS_VAL register
+ * @slaveaddr_shift: SLAVEADDR field shift in PRM_VC_BYPASS_VAL register
+ * @regaddr_shift: REGADDR field shift in PRM_VC_BYPASS_VAL register
+ * @cmd_on_shift: ON field shift in PRM_VC_CMD_VAL_* register
+ * @cmd_onlp_shift: ONLP field shift in PRM_VC_CMD_VAL_* register
+ * @cmd_ret_shift: RET field shift in PRM_VC_CMD_VAL_* register
+ * @cmd_off_shift: OFF field shift in PRM_VC_CMD_VAL_* register
+ *
+ * XXX One of cmd_on_mask and cmd_on_shift are not needed
+ * XXX VALID should probably be a shift, not a mask
+ */
+struct omap_vc_common_data {
+	u32 cmd_on_mask;
+	u32 valid;
+	u8 smps_sa_reg;
+	u8 smps_volra_reg;
+	u8 bypass_val_reg;
+	u8 data_shift;
+	u8 slaveaddr_shift;
+	u8 regaddr_shift;
+	u8 cmd_on_shift;
+	u8 cmd_onlp_shift;
+	u8 cmd_ret_shift;
+	u8 cmd_off_shift;
+};
+
+/**
+ * struct omap_vc_instance_data - VC per-instance data
+ * @vc_common: pointer to VC common data for this platform
+ * @smps_sa_mask: SA* bitmask in the PRM_VC_SMPS_SA register
+ * @smps_volra_mask: VOLRA* bitmask in the PRM_VC_VOL_RA register
+ * @smps_sa_shift: SA* field shift in the PRM_VC_SMPS_SA register
+ * @smps_volra_shift: VOLRA* field shift in the PRM_VC_VOL_RA register
+ *
+ * XXX It is not necessary to have both a *_mask and a *_shift -
+ *     remove one
+ */
+struct omap_vc_instance_data {
+	const struct omap_vc_common_data *vc_common;
+	u32 smps_sa_mask;
+	u32 smps_volra_mask;
+	u8 cmdval_reg;
+	u8 smps_sa_shift;
+	u8 smps_volra_shift;
+};
+
+extern struct omap_vc_instance_data omap3_vc1_data;
+extern struct omap_vc_instance_data omap3_vc2_data;
+
+extern struct omap_vc_instance_data omap4_vc_mpu_data;
+extern struct omap_vc_instance_data omap4_vc_iva_data;
+extern struct omap_vc_instance_data omap4_vc_core_data;
+
+#endif
+
diff --git a/arch/arm/mach-omap2/vc3xxx_data.c b/arch/arm/mach-omap2/vc3xxx_data.c
new file mode 100644
index 0000000..f37dc4b
--- /dev/null
+++ b/arch/arm/mach-omap2/vc3xxx_data.c
@@ -0,0 +1,63 @@
+/*
+ * OMAP3 Voltage Controller (VC) data
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+
+#include "prm-regbits-34xx.h"
+#include "voltage.h"
+
+#include "vc.h"
+
+/*
+ * VC data common to 34xx/36xx chips
+ * XXX This stuff presumably belongs in the vc3xxx.c or vc.c file.
+ */
+static struct omap_vc_common_data omap3_vc_common = {
+	.smps_sa_reg	 = OMAP3_PRM_VC_SMPS_SA_OFFSET,
+	.smps_volra_reg	 = OMAP3_PRM_VC_SMPS_VOL_RA_OFFSET,
+	.bypass_val_reg	 = OMAP3_PRM_VC_BYPASS_VAL_OFFSET,
+	.data_shift	 = OMAP3430_DATA_SHIFT,
+	.slaveaddr_shift = OMAP3430_SLAVEADDR_SHIFT,
+	.regaddr_shift	 = OMAP3430_REGADDR_SHIFT,
+	.valid		 = OMAP3430_VALID_MASK,
+	.cmd_on_shift	 = OMAP3430_VC_CMD_ON_SHIFT,
+	.cmd_on_mask	 = OMAP3430_VC_CMD_ON_MASK,
+	.cmd_onlp_shift	 = OMAP3430_VC_CMD_ONLP_SHIFT,
+	.cmd_ret_shift	 = OMAP3430_VC_CMD_RET_SHIFT,
+	.cmd_off_shift	 = OMAP3430_VC_CMD_OFF_SHIFT,
+};
+
+struct omap_vc_instance_data omap3_vc1_data = {
+	.vc_common = &omap3_vc_common,
+	.cmdval_reg = OMAP3_PRM_VC_CMD_VAL_0_OFFSET,
+	.smps_sa_shift = OMAP3430_PRM_VC_SMPS_SA_SA0_SHIFT,
+	.smps_sa_mask = OMAP3430_PRM_VC_SMPS_SA_SA0_MASK,
+	.smps_volra_shift = OMAP3430_VOLRA0_SHIFT,
+	.smps_volra_mask = OMAP3430_VOLRA0_MASK,
+};
+
+struct omap_vc_instance_data omap3_vc2_data = {
+	.vc_common = &omap3_vc_common,
+	.cmdval_reg = OMAP3_PRM_VC_CMD_VAL_1_OFFSET,
+	.smps_sa_shift = OMAP3430_PRM_VC_SMPS_SA_SA1_SHIFT,
+	.smps_sa_mask = OMAP3430_PRM_VC_SMPS_SA_SA1_MASK,
+	.smps_volra_shift = OMAP3430_VOLRA1_SHIFT,
+	.smps_volra_mask = OMAP3430_VOLRA1_MASK,
+};
diff --git a/arch/arm/mach-omap2/vc44xx_data.c b/arch/arm/mach-omap2/vc44xx_data.c
new file mode 100644
index 0000000..a98da8d
--- /dev/null
+++ b/arch/arm/mach-omap2/vc44xx_data.c
@@ -0,0 +1,75 @@
+/*
+ * OMAP4 Voltage Controller (VC) data
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+
+#include "prm44xx.h"
+#include "prm-regbits-44xx.h"
+#include "voltage.h"
+
+#include "vc.h"
+
+/*
+ * VC data common to 44xx chips
+ * XXX This stuff presumably belongs in the vc3xxx.c or vc.c file.
+ */
+static const struct omap_vc_common_data omap4_vc_common = {
+	.smps_sa_reg = OMAP4_PRM_VC_SMPS_SA_OFFSET,
+	.smps_volra_reg = OMAP4_PRM_VC_VAL_SMPS_RA_VOL_OFFSET,
+	.bypass_val_reg = OMAP4_PRM_VC_VAL_BYPASS_OFFSET,
+	.data_shift = OMAP4430_DATA_SHIFT,
+	.slaveaddr_shift = OMAP4430_SLAVEADDR_SHIFT,
+	.regaddr_shift = OMAP4430_REGADDR_SHIFT,
+	.valid = OMAP4430_VALID_MASK,
+	.cmd_on_shift = OMAP4430_ON_SHIFT,
+	.cmd_on_mask = OMAP4430_ON_MASK,
+	.cmd_onlp_shift = OMAP4430_ONLP_SHIFT,
+	.cmd_ret_shift = OMAP4430_RET_SHIFT,
+	.cmd_off_shift = OMAP4430_OFF_SHIFT,
+};
+
+/* VC instance data for each controllable voltage line */
+struct omap_vc_instance_data omap4_vc_mpu_data = {
+	.vc_common = &omap4_vc_common,
+	.cmdval_reg = OMAP4_PRM_VC_VAL_CMD_VDD_MPU_L_OFFSET,
+	.smps_sa_shift = OMAP4430_SA_VDD_MPU_L_PRM_VC_SMPS_SA_SHIFT,
+	.smps_sa_mask = OMAP4430_SA_VDD_MPU_L_PRM_VC_SMPS_SA_MASK,
+	.smps_volra_shift = OMAP4430_VOLRA_VDD_MPU_L_SHIFT,
+	.smps_volra_mask = OMAP4430_VOLRA_VDD_MPU_L_MASK,
+};
+
+struct omap_vc_instance_data omap4_vc_iva_data = {
+	.vc_common = &omap4_vc_common,
+	.cmdval_reg = OMAP4_PRM_VC_VAL_CMD_VDD_IVA_L_OFFSET,
+	.smps_sa_shift = OMAP4430_SA_VDD_IVA_L_PRM_VC_SMPS_SA_SHIFT,
+	.smps_sa_mask = OMAP4430_SA_VDD_IVA_L_PRM_VC_SMPS_SA_MASK,
+	.smps_volra_shift = OMAP4430_VOLRA_VDD_IVA_L_SHIFT,
+	.smps_volra_mask = OMAP4430_VOLRA_VDD_IVA_L_MASK,
+};
+
+struct omap_vc_instance_data omap4_vc_core_data = {
+	.vc_common = &omap4_vc_common,
+	.cmdval_reg = OMAP4_PRM_VC_VAL_CMD_VDD_CORE_L_OFFSET,
+	.smps_sa_shift = OMAP4430_SA_VDD_CORE_L_0_6_SHIFT,
+	.smps_sa_mask = OMAP4430_SA_VDD_CORE_L_0_6_MASK,
+	.smps_volra_shift = OMAP4430_VOLRA_VDD_CORE_L_SHIFT,
+	.smps_volra_mask = OMAP4430_VOLRA_VDD_CORE_L_MASK,
+};
+
diff --git a/arch/arm/mach-omap2/voltage.c b/arch/arm/mach-omap2/voltage.c
index 3c9bcdc..c6facf7 100644
--- a/arch/arm/mach-omap2/voltage.c
+++ b/arch/arm/mach-omap2/voltage.c
@@ -7,8 +7,9 @@
  * Rajendra Nayak <rnayak@ti.com>
  * Lesly A M <x0080970@ti.com>
  *
- * Copyright (C) 2008 Nokia Corporation
+ * Copyright (C) 2008, 2011 Nokia Corporation
  * Kalle Jokiniemi
+ * Paul Walmsley
  *
  * Copyright (C) 2010 Texas Instruments, Inc.
  * Thara Gopinath <thara@ti.com>
@@ -36,284 +37,28 @@
 
 #include "voltage.h"
 
-#define VP_IDLE_TIMEOUT		200
-#define VP_TRANXDONE_TIMEOUT	300
+#include "vc.h"
+#include "vp.h"
+
 #define VOLTAGE_DIR_SIZE	16
 
-/* Voltage processor register offsets */
-struct vp_reg_offs {
-	u8 vpconfig;
-	u8 vstepmin;
-	u8 vstepmax;
-	u8 vlimitto;
-	u8 vstatus;
-	u8 voltage;
-};
-
-/* Voltage Processor bit field values, shifts and masks */
-struct vp_reg_val {
-	/* PRM module */
-	u16 prm_mod;
-	/* VPx_VPCONFIG */
-	u32 vpconfig_erroroffset;
-	u16 vpconfig_errorgain;
-	u32 vpconfig_errorgain_mask;
-	u8 vpconfig_errorgain_shift;
-	u32 vpconfig_initvoltage_mask;
-	u8 vpconfig_initvoltage_shift;
-	u32 vpconfig_timeouten;
-	u32 vpconfig_initvdd;
-	u32 vpconfig_forceupdate;
-	u32 vpconfig_vpenable;
-	/* VPx_VSTEPMIN */
-	u8 vstepmin_stepmin;
-	u16 vstepmin_smpswaittimemin;
-	u8 vstepmin_stepmin_shift;
-	u8 vstepmin_smpswaittimemin_shift;
-	/* VPx_VSTEPMAX */
-	u8 vstepmax_stepmax;
-	u16 vstepmax_smpswaittimemax;
-	u8 vstepmax_stepmax_shift;
-	u8 vstepmax_smpswaittimemax_shift;
-	/* VPx_VLIMITTO */
-	u8 vlimitto_vddmin;
-	u8 vlimitto_vddmax;
-	u16 vlimitto_timeout;
-	u8 vlimitto_vddmin_shift;
-	u8 vlimitto_vddmax_shift;
-	u8 vlimitto_timeout_shift;
-	/* PRM_IRQSTATUS*/
-	u32 tranxdone_status;
-};
-
-/* Voltage controller registers and offsets */
-struct vc_reg_info {
-	/* PRM module */
-	u16 prm_mod;
-	/* VC register offsets */
-	u8 smps_sa_reg;
-	u8 smps_volra_reg;
-	u8 bypass_val_reg;
-	u8 cmdval_reg;
-	u8 voltsetup_reg;
-	/*VC_SMPS_SA*/
-	u8 smps_sa_shift;
-	u32 smps_sa_mask;
-	/* VC_SMPS_VOL_RA */
-	u8 smps_volra_shift;
-	u32 smps_volra_mask;
-	/* VC_BYPASS_VAL */
-	u8 data_shift;
-	u8 slaveaddr_shift;
-	u8 regaddr_shift;
-	u32 valid;
-	/* VC_CMD_VAL */
-	u8 cmd_on_shift;
-	u8 cmd_onlp_shift;
-	u8 cmd_ret_shift;
-	u8 cmd_off_shift;
-	u32 cmd_on_mask;
-	/* PRM_VOLTSETUP */
-	u8 voltsetup_shift;
-	u32 voltsetup_mask;
-};
 
-/**
- * omap_vdd_info - Per Voltage Domain info
- *
- * @volt_data		: voltage table having the distinct voltages supported
- *			  by the domain and other associated per voltage data.
- * @pmic_info		: pmic specific parameters which should be populted by
- *			  the pmic drivers.
- * @vp_offs		: structure containing the offsets for various
- *			  vp registers
- * @vp_reg		: the register values, shifts, masks for various
- *			  vp registers
- * @vc_reg		: structure containing various various vc registers,
- *			  shifts, masks etc.
- * @voltdm		: pointer to the voltage domain structure
- * @debug_dir		: debug directory for this voltage domain.
- * @curr_volt		: current voltage for this vdd.
- * @ocp_mod		: The prm module for accessing the prm irqstatus reg.
- * @prm_irqst_reg	: prm irqstatus register.
- * @vp_enabled		: flag to keep track of whether vp is enabled or not
- * @volt_scale		: API to scale the voltage of the vdd.
- */
-struct omap_vdd_info {
-	struct omap_volt_data *volt_data;
-	struct omap_volt_pmic_info *pmic_info;
-	struct vp_reg_offs vp_offs;
-	struct vp_reg_val vp_reg;
-	struct vc_reg_info vc_reg;
-	struct voltagedomain voltdm;
-	struct dentry *debug_dir;
-	u32 curr_volt;
-	u16 ocp_mod;
-	u8 prm_irqst_reg;
-	bool vp_enabled;
-	u32 (*read_reg) (u16 mod, u8 offset);
-	void (*write_reg) (u32 val, u16 mod, u8 offset);
-	int (*volt_scale) (struct omap_vdd_info *vdd,
-		unsigned long target_volt);
-};
-
-static struct omap_vdd_info *vdd_info;
+static struct omap_vdd_info **vdd_info;
+
 /*
  * Number of scalable voltage domains.
  */
 static int nr_scalable_vdd;
 
-/* OMAP3 VDD sturctures */
-static struct omap_vdd_info omap3_vdd_info[] = {
-	{
-		.vp_offs = {
-			.vpconfig = OMAP3_PRM_VP1_CONFIG_OFFSET,
-			.vstepmin = OMAP3_PRM_VP1_VSTEPMIN_OFFSET,
-			.vstepmax = OMAP3_PRM_VP1_VSTEPMAX_OFFSET,
-			.vlimitto = OMAP3_PRM_VP1_VLIMITTO_OFFSET,
-			.vstatus = OMAP3_PRM_VP1_STATUS_OFFSET,
-			.voltage = OMAP3_PRM_VP1_VOLTAGE_OFFSET,
-		},
-		.voltdm = {
-			.name = "mpu",
-		},
-	},
-	{
-		.vp_offs = {
-			.vpconfig = OMAP3_PRM_VP2_CONFIG_OFFSET,
-			.vstepmin = OMAP3_PRM_VP2_VSTEPMIN_OFFSET,
-			.vstepmax = OMAP3_PRM_VP2_VSTEPMAX_OFFSET,
-			.vlimitto = OMAP3_PRM_VP2_VLIMITTO_OFFSET,
-			.vstatus = OMAP3_PRM_VP2_STATUS_OFFSET,
-			.voltage = OMAP3_PRM_VP2_VOLTAGE_OFFSET,
-		},
-		.voltdm = {
-			.name = "core",
-		},
-	},
-};
-
-#define OMAP3_NR_SCALABLE_VDD ARRAY_SIZE(omap3_vdd_info)
-
-/* OMAP4 VDD sturctures */
-static struct omap_vdd_info omap4_vdd_info[] = {
-	{
-		.vp_offs = {
-			.vpconfig = OMAP4_PRM_VP_MPU_CONFIG_OFFSET,
-			.vstepmin = OMAP4_PRM_VP_MPU_VSTEPMIN_OFFSET,
-			.vstepmax = OMAP4_PRM_VP_MPU_VSTEPMAX_OFFSET,
-			.vlimitto = OMAP4_PRM_VP_MPU_VLIMITTO_OFFSET,
-			.vstatus = OMAP4_PRM_VP_MPU_STATUS_OFFSET,
-			.voltage = OMAP4_PRM_VP_MPU_VOLTAGE_OFFSET,
-		},
-		.voltdm = {
-			.name = "mpu",
-		},
-	},
-	{
-		.vp_offs = {
-			.vpconfig = OMAP4_PRM_VP_IVA_CONFIG_OFFSET,
-			.vstepmin = OMAP4_PRM_VP_IVA_VSTEPMIN_OFFSET,
-			.vstepmax = OMAP4_PRM_VP_IVA_VSTEPMAX_OFFSET,
-			.vlimitto = OMAP4_PRM_VP_IVA_VLIMITTO_OFFSET,
-			.vstatus = OMAP4_PRM_VP_IVA_STATUS_OFFSET,
-			.voltage = OMAP4_PRM_VP_IVA_VOLTAGE_OFFSET,
-		},
-		.voltdm = {
-			.name = "iva",
-		},
-	},
-	{
-		.vp_offs = {
-			.vpconfig = OMAP4_PRM_VP_CORE_CONFIG_OFFSET,
-			.vstepmin = OMAP4_PRM_VP_CORE_VSTEPMIN_OFFSET,
-			.vstepmax = OMAP4_PRM_VP_CORE_VSTEPMAX_OFFSET,
-			.vlimitto = OMAP4_PRM_VP_CORE_VLIMITTO_OFFSET,
-			.vstatus = OMAP4_PRM_VP_CORE_STATUS_OFFSET,
-			.voltage = OMAP4_PRM_VP_CORE_VOLTAGE_OFFSET,
-		},
-		.voltdm = {
-			.name = "core",
-		},
-	},
-};
-
-#define OMAP4_NR_SCALABLE_VDD ARRAY_SIZE(omap4_vdd_info)
-
-/*
- * Structures containing OMAP3430/OMAP3630 voltage supported and various
- * voltage dependent data for each VDD.
- */
-#define VOLT_DATA_DEFINE(_v_nom, _efuse_offs, _errminlimit, _errgain)	\
-{									\
-	.volt_nominal	= _v_nom,					\
-	.sr_efuse_offs	= _efuse_offs,					\
-	.sr_errminlimit	= _errminlimit,					\
-	.vp_errgain	= _errgain					\
-}
-
-/* VDD1 */
-static struct omap_volt_data omap34xx_vddmpu_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP1_UV, OMAP343X_CONTROL_FUSE_OPP1_VDD1, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP2_UV, OMAP343X_CONTROL_FUSE_OPP2_VDD1, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP3_UV, OMAP343X_CONTROL_FUSE_OPP3_VDD1, 0xf9, 0x18),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP4_UV, OMAP343X_CONTROL_FUSE_OPP4_VDD1, 0xf9, 0x18),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_MPU_OPP5_UV, OMAP343X_CONTROL_FUSE_OPP5_VDD1, 0xf9, 0x18),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-static struct omap_volt_data omap36xx_vddmpu_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP50_UV, OMAP3630_CONTROL_FUSE_OPP50_VDD1, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP100_UV, OMAP3630_CONTROL_FUSE_OPP100_VDD1, 0xf9, 0x16),
-	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP120_UV, OMAP3630_CONTROL_FUSE_OPP120_VDD1, 0xfa, 0x23),
-	VOLT_DATA_DEFINE(OMAP3630_VDD_MPU_OPP1G_UV, OMAP3630_CONTROL_FUSE_OPP1G_VDD1, 0xfa, 0x27),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-/* VDD2 */
-static struct omap_volt_data omap34xx_vddcore_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP1_UV, OMAP343X_CONTROL_FUSE_OPP1_VDD2, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP2_UV, OMAP343X_CONTROL_FUSE_OPP2_VDD2, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3430_VDD_CORE_OPP3_UV, OMAP343X_CONTROL_FUSE_OPP3_VDD2, 0xf9, 0x18),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-static struct omap_volt_data omap36xx_vddcore_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP3630_VDD_CORE_OPP50_UV, OMAP3630_CONTROL_FUSE_OPP50_VDD2, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP3630_VDD_CORE_OPP100_UV, OMAP3630_CONTROL_FUSE_OPP100_VDD2, 0xf9, 0x16),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-/*
- * Structures containing OMAP4430 voltage supported and various
- * voltage dependent data for each VDD.
- */
-static struct omap_volt_data omap44xx_vdd_mpu_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPP50_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP50, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPP100_UV, OMAP44XX_CONTROL_FUSE_MPU_OPP100, 0xf9, 0x16),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPTURBO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPTURBO, 0xfa, 0x23),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_MPU_OPPNITRO_UV, OMAP44XX_CONTROL_FUSE_MPU_OPPNITRO, 0xfa, 0x27),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-static struct omap_volt_data omap44xx_vdd_iva_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPP50_UV, OMAP44XX_CONTROL_FUSE_IVA_OPP50, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPP100_UV, OMAP44XX_CONTROL_FUSE_IVA_OPP100, 0xf9, 0x16),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_IVA_OPPTURBO_UV, OMAP44XX_CONTROL_FUSE_IVA_OPPTURBO, 0xfa, 0x23),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
-
-static struct omap_volt_data omap44xx_vdd_core_volt_data[] = {
-	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP50_UV, OMAP44XX_CONTROL_FUSE_CORE_OPP50, 0xf4, 0x0c),
-	VOLT_DATA_DEFINE(OMAP4430_VDD_CORE_OPP100_UV, OMAP44XX_CONTROL_FUSE_CORE_OPP100, 0xf9, 0x16),
-	VOLT_DATA_DEFINE(0, 0, 0, 0),
-};
+/* XXX document */
+static s16 prm_mod_offs;
+static s16 prm_irqst_ocp_mod_offs;
 
 static struct dentry *voltage_dir;
 
 /* Init function pointers */
-static void (*vc_init) (struct omap_vdd_info *vdd);
-static int (*vdd_data_configure) (struct omap_vdd_info *vdd);
+static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
+					unsigned long target_volt);
 
 static u32 omap3_voltage_read_reg(u16 mod, u8 offset)
 {
@@ -336,6 +81,62 @@ static void omap4_voltage_write_reg(u32 val, u16 mod, u8 offset)
 	omap4_prminst_write_inst_reg(val, OMAP4430_PRM_PARTITION, mod, offset);
 }
 
+static int __init _config_common_vdd_data(struct omap_vdd_info *vdd)
+{
+	char *sys_ck_name;
+	struct clk *sys_ck;
+	u32 sys_clk_speed, timeout_val, waittime;
+
+	/*
+	 * XXX Clockfw should handle this, or this should be in a
+	 * struct record
+	 */
+	if (cpu_is_omap24xx() || cpu_is_omap34xx())
+		sys_ck_name = "sys_ck";
+	else if (cpu_is_omap44xx())
+		sys_ck_name = "sys_clkin_ck";
+	else
+		return -EINVAL;
+
+	/*
+	 * Sys clk rate is require to calculate vp timeout value and
+	 * smpswaittimemin and smpswaittimemax.
+	 */
+	sys_ck = clk_get(NULL, sys_ck_name);
+	if (IS_ERR(sys_ck)) {
+		pr_warning("%s: Could not get the sys clk to calculate"
+			"various vdd_%s params\n", __func__, vdd->voltdm.name);
+		return -EINVAL;
+	}
+	sys_clk_speed = clk_get_rate(sys_ck);
+	clk_put(sys_ck);
+	/* Divide to avoid overflow */
+	sys_clk_speed /= 1000;
+
+	/* Generic voltage parameters */
+	vdd->curr_volt = 1200000;
+	vdd->volt_scale = vp_forceupdate_scale_voltage;
+	vdd->vp_enabled = false;
+
+	vdd->vp_rt_data.vpconfig_erroroffset =
+		(vdd->pmic_info->vp_erroroffset <<
+		 vdd->vp_data->vp_common->vpconfig_erroroffset_shift);
+
+	timeout_val = (sys_clk_speed * vdd->pmic_info->vp_timeout_us) / 1000;
+	vdd->vp_rt_data.vlimitto_timeout = timeout_val;
+	vdd->vp_rt_data.vlimitto_vddmin = vdd->pmic_info->vp_vddmin;
+	vdd->vp_rt_data.vlimitto_vddmax = vdd->pmic_info->vp_vddmax;
+
+	waittime = ((vdd->pmic_info->step_size / vdd->pmic_info->slew_rate) *
+				sys_clk_speed) / 1000;
+	vdd->vp_rt_data.vstepmin_smpswaittimemin = waittime;
+	vdd->vp_rt_data.vstepmax_smpswaittimemax = waittime;
+	vdd->vp_rt_data.vstepmin_stepmin = vdd->pmic_info->vp_vstepmin;
+	vdd->vp_rt_data.vstepmax_stepmax = vdd->pmic_info->vp_vstepmax;
+
+	return 0;
+}
+
 /* Voltage debugfs support */
 static int vp_volt_debug_get(void *data, u64 *val)
 {
@@ -347,7 +148,7 @@ static int vp_volt_debug_get(void *data, u64 *val)
 		return -EINVAL;
 	}
 
-	vsel = vdd->read_reg(vdd->vp_reg.prm_mod, vdd->vp_offs.voltage);
+	vsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);
 	pr_notice("curr_vsel = %x\n", vsel);
 
 	if (!vdd->pmic_info->vsel_to_uv) {
@@ -380,7 +181,6 @@ DEFINE_SIMPLE_ATTRIBUTE(nom_volt_debug_fops, nom_volt_debug_get, NULL,
 static void vp_latch_vsel(struct omap_vdd_info *vdd)
 {
 	u32 vpconfig;
-	u16 mod;
 	unsigned long uvdc;
 	char vsel;
 
@@ -397,30 +197,27 @@ static void vp_latch_vsel(struct omap_vdd_info *vdd)
 		return;
 	}
 
-	mod = vdd->vp_reg.prm_mod;
-
 	vsel = vdd->pmic_info->uv_to_vsel(uvdc);
 
-	vpconfig = vdd->read_reg(mod, vdd->vp_offs.vpconfig);
-	vpconfig &= ~(vdd->vp_reg.vpconfig_initvoltage_mask |
-			vdd->vp_reg.vpconfig_initvdd);
-	vpconfig |= vsel << vdd->vp_reg.vpconfig_initvoltage_shift;
+	vpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);
+	vpconfig &= ~(vdd->vp_data->vp_common->vpconfig_initvoltage_mask |
+			vdd->vp_data->vp_common->vpconfig_initvdd);
+	vpconfig |= vsel << vdd->vp_data->vp_common->vpconfig_initvoltage_shift;
 
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
-	vdd->write_reg((vpconfig | vdd->vp_reg.vpconfig_initvdd), mod,
-			vdd->vp_offs.vpconfig);
+	vdd->write_reg((vpconfig | vdd->vp_data->vp_common->vpconfig_initvdd),
+		       prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/* Clear initVDD copy trigger bit */
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 }
 
 /* Generic voltage init functions */
 static void __init vp_init(struct omap_vdd_info *vdd)
 {
 	u32 vp_val;
-	u16 mod;
 
 	if (!vdd->read_reg || !vdd->write_reg) {
 		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
@@ -428,33 +225,31 @@ static void __init vp_init(struct omap_vdd_info *vdd)
 		return;
 	}
 
-	mod = vdd->vp_reg.prm_mod;
-
-	vp_val = vdd->vp_reg.vpconfig_erroroffset |
-		(vdd->vp_reg.vpconfig_errorgain <<
-		vdd->vp_reg.vpconfig_errorgain_shift) |
-		vdd->vp_reg.vpconfig_timeouten;
-	vdd->write_reg(vp_val, mod, vdd->vp_offs.vpconfig);
-
-	vp_val = ((vdd->vp_reg.vstepmin_smpswaittimemin <<
-		vdd->vp_reg.vstepmin_smpswaittimemin_shift) |
-		(vdd->vp_reg.vstepmin_stepmin <<
-		vdd->vp_reg.vstepmin_stepmin_shift));
-	vdd->write_reg(vp_val, mod, vdd->vp_offs.vstepmin);
-
-	vp_val = ((vdd->vp_reg.vstepmax_smpswaittimemax <<
-		vdd->vp_reg.vstepmax_smpswaittimemax_shift) |
-		(vdd->vp_reg.vstepmax_stepmax <<
-		vdd->vp_reg.vstepmax_stepmax_shift));
-	vdd->write_reg(vp_val, mod, vdd->vp_offs.vstepmax);
-
-	vp_val = ((vdd->vp_reg.vlimitto_vddmax <<
-		vdd->vp_reg.vlimitto_vddmax_shift) |
-		(vdd->vp_reg.vlimitto_vddmin <<
-		vdd->vp_reg.vlimitto_vddmin_shift) |
-		(vdd->vp_reg.vlimitto_timeout <<
-		vdd->vp_reg.vlimitto_timeout_shift));
-	vdd->write_reg(vp_val, mod, vdd->vp_offs.vlimitto);
+	vp_val = vdd->vp_rt_data.vpconfig_erroroffset |
+		(vdd->vp_rt_data.vpconfig_errorgain <<
+		vdd->vp_data->vp_common->vpconfig_errorgain_shift) |
+		vdd->vp_data->vp_common->vpconfig_timeouten;
+	vdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vpconfig);
+
+	vp_val = ((vdd->vp_rt_data.vstepmin_smpswaittimemin <<
+		vdd->vp_data->vp_common->vstepmin_smpswaittimemin_shift) |
+		(vdd->vp_rt_data.vstepmin_stepmin <<
+		vdd->vp_data->vp_common->vstepmin_stepmin_shift));
+	vdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vstepmin);
+
+	vp_val = ((vdd->vp_rt_data.vstepmax_smpswaittimemax <<
+		vdd->vp_data->vp_common->vstepmax_smpswaittimemax_shift) |
+		(vdd->vp_rt_data.vstepmax_stepmax <<
+		vdd->vp_data->vp_common->vstepmax_stepmax_shift));
+	vdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vstepmax);
+
+	vp_val = ((vdd->vp_rt_data.vlimitto_vddmax <<
+		vdd->vp_data->vp_common->vlimitto_vddmax_shift) |
+		(vdd->vp_rt_data.vlimitto_vddmin <<
+		vdd->vp_data->vp_common->vlimitto_vddmin_shift) |
+		(vdd->vp_rt_data.vlimitto_timeout <<
+		vdd->vp_data->vp_common->vlimitto_timeout_shift));
+	vdd->write_reg(vp_val, prm_mod_offs, vdd->vp_data->vlimitto);
 }
 
 static void __init vdd_debugfs_init(struct omap_vdd_info *vdd)
@@ -481,23 +276,23 @@ static void __init vdd_debugfs_init(struct omap_vdd_info *vdd)
 	}
 
 	(void) debugfs_create_x16("vp_errorgain", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vpconfig_errorgain));
+				&(vdd->vp_rt_data.vpconfig_errorgain));
 	(void) debugfs_create_x16("vp_smpswaittimemin", S_IRUGO,
 				vdd->debug_dir,
-				&(vdd->vp_reg.vstepmin_smpswaittimemin));
+				&(vdd->vp_rt_data.vstepmin_smpswaittimemin));
 	(void) debugfs_create_x8("vp_stepmin", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vstepmin_stepmin));
+				&(vdd->vp_rt_data.vstepmin_stepmin));
 	(void) debugfs_create_x16("vp_smpswaittimemax", S_IRUGO,
 				vdd->debug_dir,
-				&(vdd->vp_reg.vstepmax_smpswaittimemax));
+				&(vdd->vp_rt_data.vstepmax_smpswaittimemax));
 	(void) debugfs_create_x8("vp_stepmax", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vstepmax_stepmax));
+				&(vdd->vp_rt_data.vstepmax_stepmax));
 	(void) debugfs_create_x8("vp_vddmax", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vlimitto_vddmax));
+				&(vdd->vp_rt_data.vlimitto_vddmax));
 	(void) debugfs_create_x8("vp_vddmin", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vlimitto_vddmin));
+				&(vdd->vp_rt_data.vlimitto_vddmin));
 	(void) debugfs_create_x16("vp_timeout", S_IRUGO, vdd->debug_dir,
-				&(vdd->vp_reg.vlimitto_timeout));
+				&(vdd->vp_rt_data.vlimitto_timeout));
 	(void) debugfs_create_file("curr_vp_volt", S_IRUGO, vdd->debug_dir,
 				(void *) vdd, &vp_volt_debug_fops);
 	(void) debugfs_create_file("curr_nominal_volt", S_IRUGO,
@@ -510,8 +305,12 @@ static int _pre_volt_scale(struct omap_vdd_info *vdd,
 		unsigned long target_volt, u8 *target_vsel, u8 *current_vsel)
 {
 	struct omap_volt_data *volt_data;
+	const struct omap_vc_common_data *vc_common;
+	const struct omap_vp_common_data *vp_common;
 	u32 vc_cmdval, vp_errgain_val;
-	u16 vp_mod, vc_mod;
+
+	vc_common = vdd->vc_data->vc_common;
+	vp_common = vdd->vp_data->vp_common;
 
 	/* Check if suffiecient pmic info is available for this vdd */
 	if (!vdd->pmic_info) {
@@ -533,33 +332,30 @@ static int _pre_volt_scale(struct omap_vdd_info *vdd,
 		return -EINVAL;
 	}
 
-	vp_mod = vdd->vp_reg.prm_mod;
-	vc_mod = vdd->vc_reg.prm_mod;
-
 	/* Get volt_data corresponding to target_volt */
 	volt_data = omap_voltage_get_voltdata(&vdd->voltdm, target_volt);
 	if (IS_ERR(volt_data))
 		volt_data = NULL;
 
 	*target_vsel = vdd->pmic_info->uv_to_vsel(target_volt);
-	*current_vsel = vdd->read_reg(vp_mod, vdd->vp_offs.voltage);
+	*current_vsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);
 
 	/* Setting the ON voltage to the new target voltage */
-	vc_cmdval = vdd->read_reg(vc_mod, vdd->vc_reg.cmdval_reg);
-	vc_cmdval &= ~vdd->vc_reg.cmd_on_mask;
-	vc_cmdval |= (*target_vsel << vdd->vc_reg.cmd_on_shift);
-	vdd->write_reg(vc_cmdval, vc_mod, vdd->vc_reg.cmdval_reg);
+	vc_cmdval = vdd->read_reg(prm_mod_offs, vdd->vc_data->cmdval_reg);
+	vc_cmdval &= ~vc_common->cmd_on_mask;
+	vc_cmdval |= (*target_vsel << vc_common->cmd_on_shift);
+	vdd->write_reg(vc_cmdval, prm_mod_offs, vdd->vc_data->cmdval_reg);
 
 	/* Setting vp errorgain based on the voltage */
 	if (volt_data) {
-		vp_errgain_val = vdd->read_reg(vp_mod,
-				vdd->vp_offs.vpconfig);
-		vdd->vp_reg.vpconfig_errorgain = volt_data->vp_errgain;
-		vp_errgain_val &= ~vdd->vp_reg.vpconfig_errorgain_mask;
-		vp_errgain_val |= vdd->vp_reg.vpconfig_errorgain <<
-				vdd->vp_reg.vpconfig_errorgain_shift;
-		vdd->write_reg(vp_errgain_val, vp_mod,
-				vdd->vp_offs.vpconfig);
+		vp_errgain_val = vdd->read_reg(prm_mod_offs,
+					       vdd->vp_data->vpconfig);
+		vdd->vp_rt_data.vpconfig_errorgain = volt_data->vp_errgain;
+		vp_errgain_val &= ~vp_common->vpconfig_errorgain_mask;
+		vp_errgain_val |= vdd->vp_rt_data.vpconfig_errorgain <<
+			vp_common->vpconfig_errorgain_shift;
+		vdd->write_reg(vp_errgain_val, prm_mod_offs,
+			       vdd->vp_data->vpconfig);
 	}
 
 	return 0;
@@ -585,7 +381,6 @@ static int vc_bypass_scale_voltage(struct omap_vdd_info *vdd,
 {
 	u32 loop_cnt = 0, retries_cnt = 0;
 	u32 vc_valid, vc_bypass_val_reg, vc_bypass_value;
-	u16 mod;
 	u8 target_vsel, current_vsel;
 	int ret;
 
@@ -593,20 +388,19 @@ static int vc_bypass_scale_voltage(struct omap_vdd_info *vdd,
 	if (ret)
 		return ret;
 
-	mod = vdd->vc_reg.prm_mod;
-
-	vc_valid = vdd->vc_reg.valid;
-	vc_bypass_val_reg = vdd->vc_reg.bypass_val_reg;
-	vc_bypass_value = (target_vsel << vdd->vc_reg.data_shift) |
+	vc_valid = vdd->vc_data->vc_common->valid;
+	vc_bypass_val_reg = vdd->vc_data->vc_common->bypass_val_reg;
+	vc_bypass_value = (target_vsel << vdd->vc_data->vc_common->data_shift) |
 			(vdd->pmic_info->pmic_reg <<
-			vdd->vc_reg.regaddr_shift) |
+			vdd->vc_data->vc_common->regaddr_shift) |
 			(vdd->pmic_info->i2c_slave_addr <<
-			vdd->vc_reg.slaveaddr_shift);
+			vdd->vc_data->vc_common->slaveaddr_shift);
 
-	vdd->write_reg(vc_bypass_value, mod, vc_bypass_val_reg);
-	vdd->write_reg(vc_bypass_value | vc_valid, mod, vc_bypass_val_reg);
+	vdd->write_reg(vc_bypass_value, prm_mod_offs, vc_bypass_val_reg);
+	vdd->write_reg(vc_bypass_value | vc_valid, prm_mod_offs,
+		       vc_bypass_val_reg);
 
-	vc_bypass_value = vdd->read_reg(mod, vc_bypass_val_reg);
+	vc_bypass_value = vdd->read_reg(prm_mod_offs, vc_bypass_val_reg);
 	/*
 	 * Loop till the bypass command is acknowledged from the SMPS.
 	 * NOTE: This is legacy code. The loop count and retry count needs
@@ -625,7 +419,8 @@ static int vc_bypass_scale_voltage(struct omap_vdd_info *vdd,
 			loop_cnt = 0;
 			udelay(10);
 		}
-		vc_bypass_value = vdd->read_reg(mod, vc_bypass_val_reg);
+		vc_bypass_value = vdd->read_reg(prm_mod_offs,
+						vc_bypass_val_reg);
 	}
 
 	_post_volt_scale(vdd, target_volt, target_vsel, current_vsel);
@@ -637,7 +432,6 @@ static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 		unsigned long target_volt)
 {
 	u32 vpconfig;
-	u16 mod, ocp_mod;
 	u8 target_vsel, current_vsel, prm_irqst_reg;
 	int ret, timeout = 0;
 
@@ -645,20 +439,18 @@ static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 	if (ret)
 		return ret;
 
-	mod = vdd->vp_reg.prm_mod;
-	ocp_mod = vdd->ocp_mod;
-	prm_irqst_reg = vdd->prm_irqst_reg;
+	prm_irqst_reg = vdd->vp_data->prm_irqst_data->prm_irqst_reg;
 
 	/*
 	 * Clear all pending TransactionDone interrupt/status. Typical latency
 	 * is <3us
 	 */
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vdd->write_reg(vdd->vp_reg.tranxdone_status,
-				ocp_mod, prm_irqst_reg);
-		if (!(vdd->read_reg(ocp_mod, prm_irqst_reg) &
-				vdd->vp_reg.tranxdone_status))
-				break;
+		vdd->write_reg(vdd->vp_data->prm_irqst_data->tranxdone_status,
+			       prm_irqst_ocp_mod_offs, prm_irqst_reg);
+		if (!(vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &
+		      vdd->vp_data->prm_irqst_data->tranxdone_status))
+			break;
 		udelay(1);
 	}
 	if (timeout >= VP_TRANXDONE_TIMEOUT) {
@@ -668,30 +460,30 @@ static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 	}
 
 	/* Configure for VP-Force Update */
-	vpconfig = vdd->read_reg(mod, vdd->vp_offs.vpconfig);
-	vpconfig &= ~(vdd->vp_reg.vpconfig_initvdd |
-			vdd->vp_reg.vpconfig_forceupdate |
-			vdd->vp_reg.vpconfig_initvoltage_mask);
+	vpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);
+	vpconfig &= ~(vdd->vp_data->vp_common->vpconfig_initvdd |
+			vdd->vp_data->vp_common->vpconfig_forceupdate |
+			vdd->vp_data->vp_common->vpconfig_initvoltage_mask);
 	vpconfig |= ((target_vsel <<
-			vdd->vp_reg.vpconfig_initvoltage_shift));
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+			vdd->vp_data->vp_common->vpconfig_initvoltage_shift));
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/* Trigger initVDD value copy to voltage processor */
-	vpconfig |= vdd->vp_reg.vpconfig_initvdd;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig |= vdd->vp_data->vp_common->vpconfig_initvdd;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/* Force update of voltage */
-	vpconfig |= vdd->vp_reg.vpconfig_forceupdate;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig |= vdd->vp_data->vp_common->vpconfig_forceupdate;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/*
 	 * Wait for TransactionDone. Typical latency is <200us.
 	 * Depends on SMPSWAITTIMEMIN/MAX and voltage change
 	 */
 	timeout = 0;
-	omap_test_timeout((vdd->read_reg(ocp_mod, prm_irqst_reg) &
-			vdd->vp_reg.tranxdone_status),
-			VP_TRANXDONE_TIMEOUT, timeout);
+	omap_test_timeout((vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &
+			   vdd->vp_data->prm_irqst_data->tranxdone_status),
+			  VP_TRANXDONE_TIMEOUT, timeout);
 	if (timeout >= VP_TRANXDONE_TIMEOUT)
 		pr_err("%s: vdd_%s TRANXDONE timeout exceeded."
 			"TRANXDONE never got set after the voltage update\n",
@@ -705,11 +497,11 @@ static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 	 */
 	timeout = 0;
 	while (timeout++ < VP_TRANXDONE_TIMEOUT) {
-		vdd->write_reg(vdd->vp_reg.tranxdone_status,
-				ocp_mod, prm_irqst_reg);
-		if (!(vdd->read_reg(ocp_mod, prm_irqst_reg) &
-				vdd->vp_reg.tranxdone_status))
-				break;
+		vdd->write_reg(vdd->vp_data->prm_irqst_data->tranxdone_status,
+			       prm_irqst_ocp_mod_offs, prm_irqst_reg);
+		if (!(vdd->read_reg(prm_irqst_ocp_mod_offs, prm_irqst_reg) &
+		      vdd->vp_data->prm_irqst_data->tranxdone_status))
+			break;
 		udelay(1);
 	}
 
@@ -718,222 +510,95 @@ static int vp_forceupdate_scale_voltage(struct omap_vdd_info *vdd,
 			"to clear the TRANXDONE status\n",
 			__func__, vdd->voltdm.name);
 
-	vpconfig = vdd->read_reg(mod, vdd->vp_offs.vpconfig);
+	vpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);
 	/* Clear initVDD copy trigger bit */
-	vpconfig &= ~vdd->vp_reg.vpconfig_initvdd;;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig &= ~vdd->vp_data->vp_common->vpconfig_initvdd;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 	/* Clear force bit */
-	vpconfig &= ~vdd->vp_reg.vpconfig_forceupdate;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig &= ~vdd->vp_data->vp_common->vpconfig_forceupdate;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	return 0;
 }
 
-/* OMAP3 specific voltage init functions */
+static void __init omap3_vfsm_init(struct omap_vdd_info *vdd)
+{
+	/*
+	 * Voltage Manager FSM parameters init
+	 * XXX This data should be passed in from the board file
+	 */
+	vdd->write_reg(OMAP3_CLKSETUP, prm_mod_offs, OMAP3_PRM_CLKSETUP_OFFSET);
+	vdd->write_reg(OMAP3_VOLTOFFSET, prm_mod_offs,
+		       OMAP3_PRM_VOLTOFFSET_OFFSET);
+	vdd->write_reg(OMAP3_VOLTSETUP2, prm_mod_offs,
+		       OMAP3_PRM_VOLTSETUP2_OFFSET);
+}
 
-/*
- * Intializes the voltage controller registers with the PMIC and board
- * specific parameters and voltage setup times for OMAP3.
- */
 static void __init omap3_vc_init(struct omap_vdd_info *vdd)
 {
-	u32 vc_val;
-	u16 mod;
-	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
 	static bool is_initialized;
+	u8 on_vsel, onlp_vsel, ret_vsel, off_vsel;
+	u32 vc_val;
 
-	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
-		pr_err("%s: PMIC info requried to configure vc for"
-			"vdd_%s not populated.Hence cannot initialize vc\n",
-			__func__, vdd->voltdm.name);
-		return;
-	}
-
-	if (!vdd->read_reg || !vdd->write_reg) {
-		pr_err("%s: No read/write API for accessing vdd_%s regs\n",
-			__func__, vdd->voltdm.name);
+	if (is_initialized)
 		return;
-	}
-
-	mod = vdd->vc_reg.prm_mod;
-
-	/* Set up the SMPS_SA(i2c slave address in VC */
-	vc_val = vdd->read_reg(mod, vdd->vc_reg.smps_sa_reg);
-	vc_val &= ~vdd->vc_reg.smps_sa_mask;
-	vc_val |= vdd->pmic_info->i2c_slave_addr << vdd->vc_reg.smps_sa_shift;
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.smps_sa_reg);
-
-	/* Setup the VOLRA(pmic reg addr) in VC */
-	vc_val = vdd->read_reg(mod, vdd->vc_reg.smps_volra_reg);
-	vc_val &= ~vdd->vc_reg.smps_volra_mask;
-	vc_val |= vdd->pmic_info->pmic_reg << vdd->vc_reg.smps_volra_shift;
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.smps_volra_reg);
-
-	/*Configure the setup times */
-	vc_val = vdd->read_reg(mod, vdd->vc_reg.voltsetup_reg);
-	vc_val &= ~vdd->vc_reg.voltsetup_mask;
-	vc_val |= vdd->pmic_info->volt_setup_time <<
-			vdd->vc_reg.voltsetup_shift;
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.voltsetup_reg);
 
 	/* Set up the on, inactive, retention and off voltage */
 	on_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->on_volt);
 	onlp_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->onlp_volt);
 	ret_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->ret_volt);
 	off_vsel = vdd->pmic_info->uv_to_vsel(vdd->pmic_info->off_volt);
-	vc_val	= ((on_vsel << vdd->vc_reg.cmd_on_shift) |
-		(onlp_vsel << vdd->vc_reg.cmd_onlp_shift) |
-		(ret_vsel << vdd->vc_reg.cmd_ret_shift) |
-		(off_vsel << vdd->vc_reg.cmd_off_shift));
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.cmdval_reg);
-
-	if (is_initialized)
-		return;
+	vc_val	= ((on_vsel << vdd->vc_data->vc_common->cmd_on_shift) |
+		(onlp_vsel << vdd->vc_data->vc_common->cmd_onlp_shift) |
+		(ret_vsel << vdd->vc_data->vc_common->cmd_ret_shift) |
+		(off_vsel << vdd->vc_data->vc_common->cmd_off_shift));
+	vdd->write_reg(vc_val, prm_mod_offs, vdd->vc_data->cmdval_reg);
 
-	/* Generic VC parameters init */
-	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, mod,
+	/*
+	 * Generic VC parameters init
+	 * XXX This data should be abstracted out
+	 */
+	vdd->write_reg(OMAP3430_CMD1_MASK | OMAP3430_RAV1_MASK, prm_mod_offs,
 			OMAP3_PRM_VC_CH_CONF_OFFSET);
-	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, mod,
+	vdd->write_reg(OMAP3430_MCODE_SHIFT | OMAP3430_HSEN_MASK, prm_mod_offs,
 			OMAP3_PRM_VC_I2C_CFG_OFFSET);
-	vdd->write_reg(OMAP3_CLKSETUP, mod, OMAP3_PRM_CLKSETUP_OFFSET);
-	vdd->write_reg(OMAP3_VOLTOFFSET, mod, OMAP3_PRM_VOLTOFFSET_OFFSET);
-	vdd->write_reg(OMAP3_VOLTSETUP2, mod, OMAP3_PRM_VOLTSETUP2_OFFSET);
+
+	omap3_vfsm_init(vdd);
+
 	is_initialized = true;
 }
 
-/* Sets up all the VDD related info for OMAP3 */
-static int __init omap3_vdd_data_configure(struct omap_vdd_info *vdd)
+
+/* OMAP4 specific voltage init functions */
+static void __init omap4_vc_init(struct omap_vdd_info *vdd)
 {
-	struct clk *sys_ck;
-	u32 sys_clk_speed, timeout_val, waittime;
+	static bool is_initialized;
+	u32 vc_val;
 
-	if (!vdd->pmic_info) {
-		pr_err("%s: PMIC info requried to configure vdd_%s not"
-			"populated.Hence cannot initialize vdd_%s\n",
-			__func__, vdd->voltdm.name, vdd->voltdm.name);
-		return -EINVAL;
-	}
+	if (is_initialized)
+		return;
 
-	if (!strcmp(vdd->voltdm.name, "mpu")) {
-		if (cpu_is_omap3630())
-			vdd->volt_data = omap36xx_vddmpu_volt_data;
-		else
-			vdd->volt_data = omap34xx_vddmpu_volt_data;
-
-		vdd->vp_reg.tranxdone_status = OMAP3430_VP1_TRANXDONE_ST_MASK;
-		vdd->vc_reg.cmdval_reg = OMAP3_PRM_VC_CMD_VAL_0_OFFSET;
-		vdd->vc_reg.smps_sa_shift = OMAP3430_PRM_VC_SMPS_SA_SA0_SHIFT;
-		vdd->vc_reg.smps_sa_mask = OMAP3430_PRM_VC_SMPS_SA_SA0_MASK;
-		vdd->vc_reg.smps_volra_shift = OMAP3430_VOLRA0_SHIFT;
-		vdd->vc_reg.smps_volra_mask = OMAP3430_VOLRA0_MASK;
-		vdd->vc_reg.voltsetup_shift = OMAP3430_SETUP_TIME1_SHIFT;
-		vdd->vc_reg.voltsetup_mask = OMAP3430_SETUP_TIME1_MASK;
-	} else if (!strcmp(vdd->voltdm.name, "core")) {
-		if (cpu_is_omap3630())
-			vdd->volt_data = omap36xx_vddcore_volt_data;
-		else
-			vdd->volt_data = omap34xx_vddcore_volt_data;
-
-		vdd->vp_reg.tranxdone_status = OMAP3430_VP2_TRANXDONE_ST_MASK;
-		vdd->vc_reg.cmdval_reg = OMAP3_PRM_VC_CMD_VAL_1_OFFSET;
-		vdd->vc_reg.smps_sa_shift = OMAP3430_PRM_VC_SMPS_SA_SA1_SHIFT;
-		vdd->vc_reg.smps_sa_mask = OMAP3430_PRM_VC_SMPS_SA_SA1_MASK;
-		vdd->vc_reg.smps_volra_shift = OMAP3430_VOLRA1_SHIFT;
-		vdd->vc_reg.smps_volra_mask = OMAP3430_VOLRA1_MASK;
-		vdd->vc_reg.voltsetup_shift = OMAP3430_SETUP_TIME2_SHIFT;
-		vdd->vc_reg.voltsetup_mask = OMAP3430_SETUP_TIME2_MASK;
-	} else {
-		pr_warning("%s: vdd_%s does not exisit in OMAP3\n",
-			__func__, vdd->voltdm.name);
-		return -EINVAL;
-	}
+	/* TODO: Configure setup times and CMD_VAL values*/
 
 	/*
-	 * Sys clk rate is require to calculate vp timeout value and
-	 * smpswaittimemin and smpswaittimemax.
+	 * Generic VC parameters init
+	 * XXX This data should be abstracted out
 	 */
-	sys_ck = clk_get(NULL, "sys_ck");
-	if (IS_ERR(sys_ck)) {
-		pr_warning("%s: Could not get the sys clk to calculate"
-			"various vdd_%s params\n", __func__, vdd->voltdm.name);
-		return -EINVAL;
-	}
-	sys_clk_speed = clk_get_rate(sys_ck);
-	clk_put(sys_ck);
-	/* Divide to avoid overflow */
-	sys_clk_speed /= 1000;
-
-	/* Generic voltage parameters */
-	vdd->curr_volt = 1200000;
-	vdd->ocp_mod = OCP_MOD;
-	vdd->prm_irqst_reg = OMAP3_PRM_IRQSTATUS_MPU_OFFSET;
-	vdd->read_reg = omap3_voltage_read_reg;
-	vdd->write_reg = omap3_voltage_write_reg;
-	vdd->volt_scale = vp_forceupdate_scale_voltage;
-	vdd->vp_enabled = false;
+	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
+		  OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
+		  OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
+	vdd->write_reg(vc_val, prm_mod_offs, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
 
-	/* VC parameters */
-	vdd->vc_reg.prm_mod = OMAP3430_GR_MOD;
-	vdd->vc_reg.smps_sa_reg = OMAP3_PRM_VC_SMPS_SA_OFFSET;
-	vdd->vc_reg.smps_volra_reg = OMAP3_PRM_VC_SMPS_VOL_RA_OFFSET;
-	vdd->vc_reg.bypass_val_reg = OMAP3_PRM_VC_BYPASS_VAL_OFFSET;
-	vdd->vc_reg.voltsetup_reg = OMAP3_PRM_VOLTSETUP1_OFFSET;
-	vdd->vc_reg.data_shift = OMAP3430_DATA_SHIFT;
-	vdd->vc_reg.slaveaddr_shift = OMAP3430_SLAVEADDR_SHIFT;
-	vdd->vc_reg.regaddr_shift = OMAP3430_REGADDR_SHIFT;
-	vdd->vc_reg.valid = OMAP3430_VALID_MASK;
-	vdd->vc_reg.cmd_on_shift = OMAP3430_VC_CMD_ON_SHIFT;
-	vdd->vc_reg.cmd_on_mask = OMAP3430_VC_CMD_ON_MASK;
-	vdd->vc_reg.cmd_onlp_shift = OMAP3430_VC_CMD_ONLP_SHIFT;
-	vdd->vc_reg.cmd_ret_shift = OMAP3430_VC_CMD_RET_SHIFT;
-	vdd->vc_reg.cmd_off_shift = OMAP3430_VC_CMD_OFF_SHIFT;
-
-	vdd->vp_reg.prm_mod = OMAP3430_GR_MOD;
-
-	/* VPCONFIG bit fields */
-	vdd->vp_reg.vpconfig_erroroffset = (vdd->pmic_info->vp_erroroffset <<
-				 OMAP3430_ERROROFFSET_SHIFT);
-	vdd->vp_reg.vpconfig_errorgain_mask = OMAP3430_ERRORGAIN_MASK;
-	vdd->vp_reg.vpconfig_errorgain_shift = OMAP3430_ERRORGAIN_SHIFT;
-	vdd->vp_reg.vpconfig_initvoltage_shift = OMAP3430_INITVOLTAGE_SHIFT;
-	vdd->vp_reg.vpconfig_initvoltage_mask = OMAP3430_INITVOLTAGE_MASK;
-	vdd->vp_reg.vpconfig_timeouten = OMAP3430_TIMEOUTEN_MASK;
-	vdd->vp_reg.vpconfig_initvdd = OMAP3430_INITVDD_MASK;
-	vdd->vp_reg.vpconfig_forceupdate = OMAP3430_FORCEUPDATE_MASK;
-	vdd->vp_reg.vpconfig_vpenable = OMAP3430_VPENABLE_MASK;
-
-	/* VSTEPMIN VSTEPMAX bit fields */
-	waittime = ((vdd->pmic_info->step_size / vdd->pmic_info->slew_rate) *
-				sys_clk_speed) / 1000;
-	vdd->vp_reg.vstepmin_smpswaittimemin = waittime;
-	vdd->vp_reg.vstepmax_smpswaittimemax = waittime;
-	vdd->vp_reg.vstepmin_stepmin = vdd->pmic_info->vp_vstepmin;
-	vdd->vp_reg.vstepmax_stepmax = vdd->pmic_info->vp_vstepmax;
-	vdd->vp_reg.vstepmin_smpswaittimemin_shift =
-				OMAP3430_SMPSWAITTIMEMIN_SHIFT;
-	vdd->vp_reg.vstepmax_smpswaittimemax_shift =
-				OMAP3430_SMPSWAITTIMEMAX_SHIFT;
-	vdd->vp_reg.vstepmin_stepmin_shift = OMAP3430_VSTEPMIN_SHIFT;
-	vdd->vp_reg.vstepmax_stepmax_shift = OMAP3430_VSTEPMAX_SHIFT;
-
-	/* VLIMITTO bit fields */
-	timeout_val = (sys_clk_speed * vdd->pmic_info->vp_timeout_us) / 1000;
-	vdd->vp_reg.vlimitto_timeout = timeout_val;
-	vdd->vp_reg.vlimitto_vddmin = vdd->pmic_info->vp_vddmin;
-	vdd->vp_reg.vlimitto_vddmax = vdd->pmic_info->vp_vddmax;
-	vdd->vp_reg.vlimitto_vddmin_shift = OMAP3430_VDDMIN_SHIFT;
-	vdd->vp_reg.vlimitto_vddmax_shift = OMAP3430_VDDMAX_SHIFT;
-	vdd->vp_reg.vlimitto_timeout_shift = OMAP3430_TIMEOUT_SHIFT;
+	/* XXX These are magic numbers and do not belong! */
+	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
+	vdd->write_reg(vc_val, prm_mod_offs, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
 
-	return 0;
+	is_initialized = true;
 }
 
-/* OMAP4 specific voltage init functions */
-static void __init omap4_vc_init(struct omap_vdd_info *vdd)
+static void __init omap_vc_init(struct omap_vdd_info *vdd)
 {
 	u32 vc_val;
-	u16 mod;
-	static bool is_initialized;
 
 	if (!vdd->pmic_info || !vdd->pmic_info->uv_to_vsel) {
 		pr_err("%s: PMIC info requried to configure vc for"
@@ -948,173 +613,61 @@ static void __init omap4_vc_init(struct omap_vdd_info *vdd)
 		return;
 	}
 
-	mod = vdd->vc_reg.prm_mod;
-
 	/* Set up the SMPS_SA(i2c slave address in VC */
-	vc_val = vdd->read_reg(mod, vdd->vc_reg.smps_sa_reg);
-	vc_val &= ~vdd->vc_reg.smps_sa_mask;
-	vc_val |= vdd->pmic_info->i2c_slave_addr << vdd->vc_reg.smps_sa_shift;
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.smps_sa_reg);
+	vc_val = vdd->read_reg(prm_mod_offs,
+			       vdd->vc_data->vc_common->smps_sa_reg);
+	vc_val &= ~vdd->vc_data->smps_sa_mask;
+	vc_val |= vdd->pmic_info->i2c_slave_addr << vdd->vc_data->smps_sa_shift;
+	vdd->write_reg(vc_val, prm_mod_offs,
+		       vdd->vc_data->vc_common->smps_sa_reg);
 
 	/* Setup the VOLRA(pmic reg addr) in VC */
-	vc_val = vdd->read_reg(mod, vdd->vc_reg.smps_volra_reg);
-	vc_val &= ~vdd->vc_reg.smps_volra_mask;
-	vc_val |= vdd->pmic_info->pmic_reg << vdd->vc_reg.smps_volra_shift;
-	vdd->write_reg(vc_val, mod, vdd->vc_reg.smps_volra_reg);
-
-	/* TODO: Configure setup times and CMD_VAL values*/
-
-	if (is_initialized)
-		return;
-
-	/* Generic VC parameters init */
-	vc_val = (OMAP4430_RAV_VDD_MPU_L_MASK | OMAP4430_CMD_VDD_MPU_L_MASK |
-		OMAP4430_RAV_VDD_IVA_L_MASK | OMAP4430_CMD_VDD_IVA_L_MASK |
-		OMAP4430_RAV_VDD_CORE_L_MASK | OMAP4430_CMD_VDD_CORE_L_MASK);
-	vdd->write_reg(vc_val, mod, OMAP4_PRM_VC_CFG_CHANNEL_OFFSET);
-
-	vc_val = (0x60 << OMAP4430_SCLL_SHIFT | 0x26 << OMAP4430_SCLH_SHIFT);
-	vdd->write_reg(vc_val, mod, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);
+	vc_val = vdd->read_reg(prm_mod_offs,
+			       vdd->vc_data->vc_common->smps_volra_reg);
+	vc_val &= ~vdd->vc_data->smps_volra_mask;
+	vc_val |= vdd->pmic_info->pmic_reg << vdd->vc_data->smps_volra_shift;
+	vdd->write_reg(vc_val, prm_mod_offs,
+		       vdd->vc_data->vc_common->smps_volra_reg);
+
+	/* Configure the setup times */
+	vc_val = vdd->read_reg(prm_mod_offs, vdd->vfsm->voltsetup_reg);
+	vc_val &= ~vdd->vfsm->voltsetup_mask;
+	vc_val |= vdd->pmic_info->volt_setup_time <<
+			vdd->vfsm->voltsetup_shift;
+	vdd->write_reg(vc_val, prm_mod_offs, vdd->vfsm->voltsetup_reg);
 
-	is_initialized = true;
+	if (cpu_is_omap34xx())
+		omap3_vc_init(vdd);
+	else if (cpu_is_omap44xx())
+		omap4_vc_init(vdd);
 }
 
-/* Sets up all the VDD related info for OMAP4 */
-static int __init omap4_vdd_data_configure(struct omap_vdd_info *vdd)
+static int __init omap_vdd_data_configure(struct omap_vdd_info *vdd)
 {
-	struct clk *sys_ck;
-	u32 sys_clk_speed, timeout_val, waittime;
+	int ret = -EINVAL;
 
 	if (!vdd->pmic_info) {
 		pr_err("%s: PMIC info requried to configure vdd_%s not"
 			"populated.Hence cannot initialize vdd_%s\n",
 			__func__, vdd->voltdm.name, vdd->voltdm.name);
-		return -EINVAL;
+		goto ovdc_out;
 	}
 
-	if (!strcmp(vdd->voltdm.name, "mpu")) {
-		vdd->volt_data = omap44xx_vdd_mpu_volt_data;
-		vdd->vp_reg.tranxdone_status =
-				OMAP4430_VP_MPU_TRANXDONE_ST_MASK;
-		vdd->vc_reg.cmdval_reg = OMAP4_PRM_VC_VAL_CMD_VDD_MPU_L_OFFSET;
-		vdd->vc_reg.smps_sa_shift =
-				OMAP4430_SA_VDD_MPU_L_PRM_VC_SMPS_SA_SHIFT;
-		vdd->vc_reg.smps_sa_mask =
-				OMAP4430_SA_VDD_MPU_L_PRM_VC_SMPS_SA_MASK;
-		vdd->vc_reg.smps_volra_shift = OMAP4430_VOLRA_VDD_MPU_L_SHIFT;
-		vdd->vc_reg.smps_volra_mask = OMAP4430_VOLRA_VDD_MPU_L_MASK;
-		vdd->vc_reg.voltsetup_reg =
-				OMAP4_PRM_VOLTSETUP_MPU_RET_SLEEP_OFFSET;
-		vdd->prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_2_OFFSET;
-	} else if (!strcmp(vdd->voltdm.name, "core")) {
-		vdd->volt_data = omap44xx_vdd_core_volt_data;
-		vdd->vp_reg.tranxdone_status =
-				OMAP4430_VP_CORE_TRANXDONE_ST_MASK;
-		vdd->vc_reg.cmdval_reg =
-				OMAP4_PRM_VC_VAL_CMD_VDD_CORE_L_OFFSET;
-		vdd->vc_reg.smps_sa_shift = OMAP4430_SA_VDD_CORE_L_0_6_SHIFT;
-		vdd->vc_reg.smps_sa_mask = OMAP4430_SA_VDD_CORE_L_0_6_MASK;
-		vdd->vc_reg.smps_volra_shift = OMAP4430_VOLRA_VDD_CORE_L_SHIFT;
-		vdd->vc_reg.smps_volra_mask = OMAP4430_VOLRA_VDD_CORE_L_MASK;
-		vdd->vc_reg.voltsetup_reg =
-				OMAP4_PRM_VOLTSETUP_CORE_RET_SLEEP_OFFSET;
-		vdd->prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_OFFSET;
-	} else if (!strcmp(vdd->voltdm.name, "iva")) {
-		vdd->volt_data = omap44xx_vdd_iva_volt_data;
-		vdd->vp_reg.tranxdone_status =
-				OMAP4430_VP_IVA_TRANXDONE_ST_MASK;
-		vdd->vc_reg.cmdval_reg = OMAP4_PRM_VC_VAL_CMD_VDD_IVA_L_OFFSET;
-		vdd->vc_reg.smps_sa_shift =
-				OMAP4430_SA_VDD_IVA_L_PRM_VC_SMPS_SA_SHIFT;
-		vdd->vc_reg.smps_sa_mask =
-				OMAP4430_SA_VDD_IVA_L_PRM_VC_SMPS_SA_MASK;
-		vdd->vc_reg.smps_volra_shift = OMAP4430_VOLRA_VDD_IVA_L_SHIFT;
-		vdd->vc_reg.smps_volra_mask = OMAP4430_VOLRA_VDD_IVA_L_MASK;
-		vdd->vc_reg.voltsetup_reg =
-				OMAP4_PRM_VOLTSETUP_IVA_RET_SLEEP_OFFSET;
-		vdd->prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_OFFSET;
-	} else {
-		pr_warning("%s: vdd_%s does not exisit in OMAP4\n",
-			__func__, vdd->voltdm.name);
-		return -EINVAL;
-	}
+	if (IS_ERR_VALUE(_config_common_vdd_data(vdd)))
+		goto ovdc_out;
 
-	/*
-	 * Sys clk rate is require to calculate vp timeout value and
-	 * smpswaittimemin and smpswaittimemax.
-	 */
-	sys_ck = clk_get(NULL, "sys_clkin_ck");
-	if (IS_ERR(sys_ck)) {
-		pr_warning("%s: Could not get the sys clk to calculate"
-			"various vdd_%s params\n", __func__, vdd->voltdm.name);
-		return -EINVAL;
+	if (cpu_is_omap34xx()) {
+		vdd->read_reg = omap3_voltage_read_reg;
+		vdd->write_reg = omap3_voltage_write_reg;
+		ret = 0;
+	} else if (cpu_is_omap44xx()) {
+		vdd->read_reg = omap4_voltage_read_reg;
+		vdd->write_reg = omap4_voltage_write_reg;
+		ret = 0;
 	}
-	sys_clk_speed = clk_get_rate(sys_ck);
-	clk_put(sys_ck);
-	/* Divide to avoid overflow */
-	sys_clk_speed /= 1000;
-
-	/* Generic voltage parameters */
-	vdd->curr_volt = 1200000;
-	vdd->ocp_mod = OMAP4430_PRM_OCP_SOCKET_INST;
-	vdd->read_reg = omap4_voltage_read_reg;
-	vdd->write_reg = omap4_voltage_write_reg;
-	vdd->volt_scale = vp_forceupdate_scale_voltage;
-	vdd->vp_enabled = false;
 
-	/* VC parameters */
-	vdd->vc_reg.prm_mod = OMAP4430_PRM_DEVICE_INST;
-	vdd->vc_reg.smps_sa_reg = OMAP4_PRM_VC_SMPS_SA_OFFSET;
-	vdd->vc_reg.smps_volra_reg = OMAP4_PRM_VC_VAL_SMPS_RA_VOL_OFFSET;
-	vdd->vc_reg.bypass_val_reg = OMAP4_PRM_VC_VAL_BYPASS_OFFSET;
-	vdd->vc_reg.data_shift = OMAP4430_DATA_SHIFT;
-	vdd->vc_reg.slaveaddr_shift = OMAP4430_SLAVEADDR_SHIFT;
-	vdd->vc_reg.regaddr_shift = OMAP4430_REGADDR_SHIFT;
-	vdd->vc_reg.valid = OMAP4430_VALID_MASK;
-	vdd->vc_reg.cmd_on_shift = OMAP4430_ON_SHIFT;
-	vdd->vc_reg.cmd_on_mask = OMAP4430_ON_MASK;
-	vdd->vc_reg.cmd_onlp_shift = OMAP4430_ONLP_SHIFT;
-	vdd->vc_reg.cmd_ret_shift = OMAP4430_RET_SHIFT;
-	vdd->vc_reg.cmd_off_shift = OMAP4430_OFF_SHIFT;
-
-	vdd->vp_reg.prm_mod = OMAP4430_PRM_DEVICE_INST;
-
-	/* VPCONFIG bit fields */
-	vdd->vp_reg.vpconfig_erroroffset = (vdd->pmic_info->vp_erroroffset <<
-				 OMAP4430_ERROROFFSET_SHIFT);
-	vdd->vp_reg.vpconfig_errorgain_mask = OMAP4430_ERRORGAIN_MASK;
-	vdd->vp_reg.vpconfig_errorgain_shift = OMAP4430_ERRORGAIN_SHIFT;
-	vdd->vp_reg.vpconfig_initvoltage_shift = OMAP4430_INITVOLTAGE_SHIFT;
-	vdd->vp_reg.vpconfig_initvoltage_mask = OMAP4430_INITVOLTAGE_MASK;
-	vdd->vp_reg.vpconfig_timeouten = OMAP4430_TIMEOUTEN_MASK;
-	vdd->vp_reg.vpconfig_initvdd = OMAP4430_INITVDD_MASK;
-	vdd->vp_reg.vpconfig_forceupdate = OMAP4430_FORCEUPDATE_MASK;
-	vdd->vp_reg.vpconfig_vpenable = OMAP4430_VPENABLE_MASK;
-
-	/* VSTEPMIN VSTEPMAX bit fields */
-	waittime = ((vdd->pmic_info->step_size / vdd->pmic_info->slew_rate) *
-				sys_clk_speed) / 1000;
-	vdd->vp_reg.vstepmin_smpswaittimemin = waittime;
-	vdd->vp_reg.vstepmax_smpswaittimemax = waittime;
-	vdd->vp_reg.vstepmin_stepmin = vdd->pmic_info->vp_vstepmin;
-	vdd->vp_reg.vstepmax_stepmax = vdd->pmic_info->vp_vstepmax;
-	vdd->vp_reg.vstepmin_smpswaittimemin_shift =
-			OMAP4430_SMPSWAITTIMEMIN_SHIFT;
-	vdd->vp_reg.vstepmax_smpswaittimemax_shift =
-			OMAP4430_SMPSWAITTIMEMAX_SHIFT;
-	vdd->vp_reg.vstepmin_stepmin_shift = OMAP4430_VSTEPMIN_SHIFT;
-	vdd->vp_reg.vstepmax_stepmax_shift = OMAP4430_VSTEPMAX_SHIFT;
-
-	/* VLIMITTO bit fields */
-	timeout_val = (sys_clk_speed * vdd->pmic_info->vp_timeout_us) / 1000;
-	vdd->vp_reg.vlimitto_timeout = timeout_val;
-	vdd->vp_reg.vlimitto_vddmin = vdd->pmic_info->vp_vddmin;
-	vdd->vp_reg.vlimitto_vddmax = vdd->pmic_info->vp_vddmax;
-	vdd->vp_reg.vlimitto_vddmin_shift = OMAP4430_VDDMIN_SHIFT;
-	vdd->vp_reg.vlimitto_vddmax_shift = OMAP4430_VDDMAX_SHIFT;
-	vdd->vp_reg.vlimitto_timeout_shift = OMAP4430_TIMEOUT_SHIFT;
-
-	return 0;
+ovdc_out:
+	return ret;
 }
 
 /* Public functions */
@@ -1162,8 +715,7 @@ unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm)
 		return 0;
 	}
 
-	curr_vsel = vdd->read_reg(vdd->vp_reg.prm_mod,
-			vdd->vp_offs.voltage);
+	curr_vsel = vdd->read_reg(prm_mod_offs, vdd->vp_data->voltage);
 
 	if (!vdd->pmic_info || !vdd->pmic_info->vsel_to_uv) {
 		pr_warning("%s: PMIC function to convert vsel to voltage"
@@ -1185,7 +737,6 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 {
 	struct omap_vdd_info *vdd;
 	u32 vpconfig;
-	u16 mod;
 
 	if (!voltdm || IS_ERR(voltdm)) {
 		pr_warning("%s: VDD specified does not exist!\n", __func__);
@@ -1199,8 +750,6 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 		return;
 	}
 
-	mod = vdd->vp_reg.prm_mod;
-
 	/* If VP is already enabled, do nothing. Return */
 	if (vdd->vp_enabled)
 		return;
@@ -1208,9 +757,9 @@ void omap_vp_enable(struct voltagedomain *voltdm)
 	vp_latch_vsel(vdd);
 
 	/* Enable VP */
-	vpconfig = vdd->read_reg(mod, vdd->vp_offs.vpconfig);
-	vpconfig |= vdd->vp_reg.vpconfig_vpenable;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);
+	vpconfig |= vdd->vp_data->vp_common->vpconfig_vpenable;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 	vdd->vp_enabled = true;
 }
 
@@ -1225,7 +774,6 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 {
 	struct omap_vdd_info *vdd;
 	u32 vpconfig;
-	u16 mod;
 	int timeout;
 
 	if (!voltdm || IS_ERR(voltdm)) {
@@ -1240,8 +788,6 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 		return;
 	}
 
-	mod = vdd->vp_reg.prm_mod;
-
 	/* If VP is already disabled, do nothing. Return */
 	if (!vdd->vp_enabled) {
 		pr_warning("%s: Trying to disable VP for vdd_%s when"
@@ -1250,14 +796,14 @@ void omap_vp_disable(struct voltagedomain *voltdm)
 	}
 
 	/* Disable VP */
-	vpconfig = vdd->read_reg(mod, vdd->vp_offs.vpconfig);
-	vpconfig &= ~vdd->vp_reg.vpconfig_vpenable;
-	vdd->write_reg(vpconfig, mod, vdd->vp_offs.vpconfig);
+	vpconfig = vdd->read_reg(prm_mod_offs, vdd->vp_data->vpconfig);
+	vpconfig &= ~vdd->vp_data->vp_common->vpconfig_vpenable;
+	vdd->write_reg(vpconfig, prm_mod_offs, vdd->vp_data->vpconfig);
 
 	/*
 	 * Wait for VP idle Typical latency is <2us. Maximum latency is ~100us
 	 */
-	omap_test_timeout((vdd->read_reg(mod, vdd->vp_offs.vstatus)),
+	omap_test_timeout((vdd->read_reg(prm_mod_offs, vdd->vp_data->vstatus)),
 				VP_IDLE_TIMEOUT, timeout);
 
 	if (timeout >= VP_IDLE_TIMEOUT)
@@ -1510,8 +1056,8 @@ struct voltagedomain *omap_voltage_domain_lookup(char *name)
 	}
 
 	for (i = 0; i < nr_scalable_vdd; i++) {
-		if (!(strcmp(name, vdd_info[i].voltdm.name)))
-			return &vdd_info[i].voltdm;
+		if (!(strcmp(name, vdd_info[i]->voltdm.name)))
+			return &vdd_info[i]->voltdm;
 	}
 
 	return ERR_PTR(-EINVAL);
@@ -1539,35 +1085,24 @@ int __init omap_voltage_late_init(void)
 		pr_err("%s: Unable to create voltage debugfs main dir\n",
 			__func__);
 	for (i = 0; i < nr_scalable_vdd; i++) {
-		if (vdd_data_configure(&vdd_info[i]))
+		if (omap_vdd_data_configure(vdd_info[i]))
 			continue;
-		vc_init(&vdd_info[i]);
-		vp_init(&vdd_info[i]);
-		vdd_debugfs_init(&vdd_info[i]);
+		omap_vc_init(vdd_info[i]);
+		vp_init(vdd_info[i]);
+		vdd_debugfs_init(vdd_info[i]);
 	}
 
 	return 0;
 }
 
-/**
- * omap_voltage_early_init()- Volatage driver early init
- */
-static int __init omap_voltage_early_init(void)
+/* XXX document */
+int __init omap_voltage_early_init(s16 prm_mod, s16 prm_irqst_ocp_mod,
+				   struct omap_vdd_info *omap_vdd_array[],
+				   u8 omap_vdd_count)
 {
-	if (cpu_is_omap34xx()) {
-		vdd_info = omap3_vdd_info;
-		nr_scalable_vdd = OMAP3_NR_SCALABLE_VDD;
-		vc_init = omap3_vc_init;
-		vdd_data_configure = omap3_vdd_data_configure;
-	} else if (cpu_is_omap44xx()) {
-		vdd_info = omap4_vdd_info;
-		nr_scalable_vdd = OMAP4_NR_SCALABLE_VDD;
-		vc_init = omap4_vc_init;
-		vdd_data_configure = omap4_vdd_data_configure;
-	} else {
-		pr_warning("%s: voltage driver support not added\n", __func__);
-	}
-
+	prm_mod_offs = prm_mod;
+	prm_irqst_ocp_mod_offs = prm_irqst_ocp_mod;
+	vdd_info = omap_vdd_array;
+	nr_scalable_vdd = omap_vdd_count;
 	return 0;
 }
-core_initcall(omap_voltage_early_init);
diff --git a/arch/arm/mach-omap2/voltage.h b/arch/arm/mach-omap2/voltage.h
index 5bd204e..e9f5408 100644
--- a/arch/arm/mach-omap2/voltage.h
+++ b/arch/arm/mach-omap2/voltage.h
@@ -16,6 +16,10 @@
 
 #include <linux/err.h>
 
+#include "vc.h"
+#include "vp.h"
+
+/* XXX document */
 #define VOLTSCALE_VPFORCEUPDATE		1
 #define VOLTSCALE_VCBYPASS		2
 
@@ -27,36 +31,22 @@
 #define OMAP3_VOLTOFFSET	0xff
 #define OMAP3_VOLTSETUP2	0xff
 
-/* Voltage value defines */
-#define OMAP3430_VDD_MPU_OPP1_UV		975000
-#define OMAP3430_VDD_MPU_OPP2_UV		1075000
-#define OMAP3430_VDD_MPU_OPP3_UV		1200000
-#define OMAP3430_VDD_MPU_OPP4_UV		1270000
-#define OMAP3430_VDD_MPU_OPP5_UV		1350000
-
-#define OMAP3430_VDD_CORE_OPP1_UV		975000
-#define OMAP3430_VDD_CORE_OPP2_UV		1050000
-#define OMAP3430_VDD_CORE_OPP3_UV		1150000
-
-#define OMAP3630_VDD_MPU_OPP50_UV		1012500
-#define OMAP3630_VDD_MPU_OPP100_UV		1200000
-#define OMAP3630_VDD_MPU_OPP120_UV		1325000
-#define OMAP3630_VDD_MPU_OPP1G_UV		1375000
-
-#define OMAP3630_VDD_CORE_OPP50_UV		1000000
-#define OMAP3630_VDD_CORE_OPP100_UV		1200000
-
-#define OMAP4430_VDD_MPU_OPP50_UV		930000
-#define OMAP4430_VDD_MPU_OPP100_UV		1100000
-#define OMAP4430_VDD_MPU_OPPTURBO_UV		1260000
-#define OMAP4430_VDD_MPU_OPPNITRO_UV		1350000
-
-#define OMAP4430_VDD_IVA_OPP50_UV		930000
-#define OMAP4430_VDD_IVA_OPP100_UV		1100000
-#define OMAP4430_VDD_IVA_OPPTURBO_UV		1260000
-
-#define OMAP4430_VDD_CORE_OPP50_UV		930000
-#define OMAP4430_VDD_CORE_OPP100_UV		1100000
+/**
+ * struct omap_vfsm_instance_data - per-voltage manager FSM register/bitfield
+ * data
+ * @voltsetup_mask: SETUP_TIME* bitmask in the PRM_VOLTSETUP* register
+ * @voltsetup_reg: register offset of PRM_VOLTSETUP from PRM base
+ * @voltsetup_shift: SETUP_TIME* field shift in the PRM_VOLTSETUP* register
+ *
+ * XXX What about VOLTOFFSET/VOLTCTRL?
+ * XXX It is not necessary to have both a _mask and a _shift for the same
+ *     bitfield - remove one!
+ */
+struct omap_vfsm_instance_data {
+	u32 voltsetup_mask;
+	u8 voltsetup_reg;
+	u8 voltsetup_shift;
+};
 
 /**
  * struct voltagedomain - omap voltage domain global structure.
@@ -113,6 +103,42 @@ struct omap_volt_pmic_info {
 	u8 (*uv_to_vsel) (unsigned long uV);
 };
 
+/**
+ * omap_vdd_info - Per Voltage Domain info
+ *
+ * @volt_data		: voltage table having the distinct voltages supported
+ *			  by the domain and other associated per voltage data.
+ * @pmic_info		: pmic specific parameters which should be populted by
+ *			  the pmic drivers.
+ * @vp_data		: the register values, shifts, masks for various
+ *			  vp registers
+ * @vp_rt_data          : VP data derived at runtime, not predefined
+ * @vc_data		: structure containing various various vc registers,
+ *			  shifts, masks etc.
+ * @vfsm                : voltage manager FSM data
+ * @voltdm		: pointer to the voltage domain structure
+ * @debug_dir		: debug directory for this voltage domain.
+ * @curr_volt		: current voltage for this vdd.
+ * @vp_enabled		: flag to keep track of whether vp is enabled or not
+ * @volt_scale		: API to scale the voltage of the vdd.
+ */
+struct omap_vdd_info {
+	struct omap_volt_data *volt_data;
+	struct omap_volt_pmic_info *pmic_info;
+	struct omap_vp_instance_data *vp_data;
+	struct omap_vp_runtime_data vp_rt_data;
+	struct omap_vc_instance_data *vc_data;
+	const struct omap_vfsm_instance_data *vfsm;
+	struct voltagedomain voltdm;
+	struct dentry *debug_dir;
+	u32 curr_volt;
+	bool vp_enabled;
+	u32 (*read_reg) (u16 mod, u8 offset);
+	void (*write_reg) (u32 val, u16 mod, u8 offset);
+	int (*volt_scale) (struct omap_vdd_info *vdd,
+		unsigned long target_volt);
+};
+
 unsigned long omap_vp_get_curr_volt(struct voltagedomain *voltdm);
 void omap_vp_enable(struct voltagedomain *voltdm);
 void omap_vp_disable(struct voltagedomain *voltdm);
@@ -125,6 +151,9 @@ struct omap_volt_data *omap_voltage_get_voltdata(struct voltagedomain *voltdm,
 		unsigned long volt);
 unsigned long omap_voltage_get_nom_volt(struct voltagedomain *voltdm);
 struct dentry *omap_voltage_get_dbgdir(struct voltagedomain *voltdm);
+int __init omap_voltage_early_init(s16 prm_mod, s16 prm_irqst_mod,
+				   struct omap_vdd_info *omap_vdd_array[],
+				   u8 omap_vdd_count);
 #ifdef CONFIG_PM
 int omap_voltage_register_pmic(struct voltagedomain *voltdm,
 		struct omap_volt_pmic_info *pmic_info);
diff --git a/arch/arm/mach-omap2/voltagedomains3xxx_data.c b/arch/arm/mach-omap2/voltagedomains3xxx_data.c
new file mode 100644
index 0000000..def230f
--- /dev/null
+++ b/arch/arm/mach-omap2/voltagedomains3xxx_data.c
@@ -0,0 +1,95 @@
+/*
+ * OMAP3 voltage domain data
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+#include <plat/cpu.h>
+
+#include "prm-regbits-34xx.h"
+#include "omap_opp_data.h"
+#include "voltage.h"
+#include "vc.h"
+#include "vp.h"
+
+/*
+ * VDD data
+ */
+
+static const struct omap_vfsm_instance_data omap3_vdd1_vfsm_data = {
+	.voltsetup_reg = OMAP3_PRM_VOLTSETUP1_OFFSET,
+	.voltsetup_shift = OMAP3430_SETUP_TIME1_SHIFT,
+	.voltsetup_mask = OMAP3430_SETUP_TIME1_MASK,
+};
+
+static struct omap_vdd_info omap3_vdd1_info = {
+	.vp_data = &omap3_vp1_data,
+	.vc_data = &omap3_vc1_data,
+	.vfsm = &omap3_vdd1_vfsm_data,
+	.voltdm = {
+		.name = "mpu",
+	},
+};
+
+static const struct omap_vfsm_instance_data omap3_vdd2_vfsm_data = {
+	.voltsetup_reg = OMAP3_PRM_VOLTSETUP1_OFFSET,
+	.voltsetup_shift = OMAP3430_SETUP_TIME2_SHIFT,
+	.voltsetup_mask = OMAP3430_SETUP_TIME2_MASK,
+};
+
+static struct omap_vdd_info omap3_vdd2_info = {
+	.vp_data = &omap3_vp2_data,
+	.vc_data = &omap3_vc2_data,
+	.vfsm = &omap3_vdd2_vfsm_data,
+	.voltdm = {
+		.name = "core",
+	},
+};
+
+/* OMAP3 VDD structures */
+static struct omap_vdd_info *omap3_vdd_info[] = {
+	&omap3_vdd1_info,
+	&omap3_vdd2_info,
+};
+
+/* OMAP3 specific voltage init functions */
+static int __init omap3xxx_voltage_early_init(void)
+{
+	s16 prm_mod = OMAP3430_GR_MOD;
+	s16 prm_irqst_ocp_mod = OCP_MOD;
+
+	if (!cpu_is_omap34xx())
+		return 0;
+
+	/*
+	 * XXX Will depend on the process, validation, and binning
+	 * for the currently-running IC
+	 */
+	if (cpu_is_omap3630()) {
+		omap3_vdd1_info.volt_data = omap36xx_vddmpu_volt_data;
+		omap3_vdd2_info.volt_data = omap36xx_vddcore_volt_data;
+	} else {
+		omap3_vdd1_info.volt_data = omap34xx_vddmpu_volt_data;
+		omap3_vdd2_info.volt_data = omap34xx_vddcore_volt_data;
+	}
+
+	return omap_voltage_early_init(prm_mod, prm_irqst_ocp_mod,
+				       omap3_vdd_info,
+				       ARRAY_SIZE(omap3_vdd_info));
+};
+core_initcall(omap3xxx_voltage_early_init);
diff --git a/arch/arm/mach-omap2/voltagedomains44xx_data.c b/arch/arm/mach-omap2/voltagedomains44xx_data.c
new file mode 100644
index 0000000..cb64996
--- /dev/null
+++ b/arch/arm/mach-omap2/voltagedomains44xx_data.c
@@ -0,0 +1,102 @@
+/*
+ * OMAP3/OMAP4 Voltage Management Routines
+ *
+ * Author: Thara Gopinath	<thara@ti.com>
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ *
+ * Copyright (C) 2008 Nokia Corporation
+ * Kalle Jokiniemi
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc.
+ * Thara Gopinath <thara@ti.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+
+#include "prm-regbits-44xx.h"
+#include "prm44xx.h"
+#include "prcm44xx.h"
+#include "prminst44xx.h"
+#include "voltage.h"
+#include "omap_opp_data.h"
+#include "vc.h"
+#include "vp.h"
+
+static const struct omap_vfsm_instance_data omap4_vdd_mpu_vfsm_data = {
+	.voltsetup_reg = OMAP4_PRM_VOLTSETUP_MPU_RET_SLEEP_OFFSET,
+};
+
+static struct omap_vdd_info omap4_vdd_mpu_info = {
+	.vp_data = &omap4_vp_mpu_data,
+	.vc_data = &omap4_vc_mpu_data,
+	.vfsm = &omap4_vdd_mpu_vfsm_data,
+	.voltdm = {
+		.name = "mpu",
+	},
+};
+
+static const struct omap_vfsm_instance_data omap4_vdd_iva_vfsm_data = {
+	.voltsetup_reg = OMAP4_PRM_VOLTSETUP_IVA_RET_SLEEP_OFFSET,
+};
+
+static struct omap_vdd_info omap4_vdd_iva_info = {
+	.vp_data = &omap4_vp_iva_data,
+	.vc_data = &omap4_vc_iva_data,
+	.vfsm = &omap4_vdd_iva_vfsm_data,
+	.voltdm = {
+		.name = "iva",
+	},
+};
+
+static const struct omap_vfsm_instance_data omap4_vdd_core_vfsm_data = {
+	.voltsetup_reg = OMAP4_PRM_VOLTSETUP_CORE_RET_SLEEP_OFFSET,
+};
+
+static struct omap_vdd_info omap4_vdd_core_info = {
+	.vp_data = &omap4_vp_core_data,
+	.vc_data = &omap4_vc_core_data,
+	.vfsm = &omap4_vdd_core_vfsm_data,
+	.voltdm = {
+		.name = "core",
+	},
+};
+
+/* OMAP4 VDD structures */
+static struct omap_vdd_info *omap4_vdd_info[] = {
+	&omap4_vdd_mpu_info,
+	&omap4_vdd_iva_info,
+	&omap4_vdd_core_info,
+};
+
+/* OMAP4 specific voltage init functions */
+static int __init omap44xx_voltage_early_init(void)
+{
+	s16 prm_mod = OMAP4430_PRM_DEVICE_INST;
+	s16 prm_irqst_ocp_mod = OMAP4430_PRM_OCP_SOCKET_INST;
+
+	if (!cpu_is_omap44xx())
+		return 0;
+
+	/*
+	 * XXX Will depend on the process, validation, and binning
+	 * for the currently-running IC
+	 */
+	omap4_vdd_mpu_info.volt_data = omap44xx_vdd_mpu_volt_data;
+	omap4_vdd_iva_info.volt_data = omap44xx_vdd_iva_volt_data;
+	omap4_vdd_core_info.volt_data = omap44xx_vdd_core_volt_data;
+
+	return omap_voltage_early_init(prm_mod, prm_irqst_ocp_mod,
+				       omap4_vdd_info,
+				       ARRAY_SIZE(omap4_vdd_info));
+};
+core_initcall(omap44xx_voltage_early_init);
diff --git a/arch/arm/mach-omap2/vp.h b/arch/arm/mach-omap2/vp.h
new file mode 100644
index 0000000..7ce134f
--- /dev/null
+++ b/arch/arm/mach-omap2/vp.h
@@ -0,0 +1,143 @@
+/*
+ * OMAP3/4 Voltage Processor (VP) structure and macro definitions
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License version
+ * 2 as published by the Free Software Foundation.
+ */
+#ifndef __ARCH_ARM_MACH_OMAP2_VP_H
+#define __ARCH_ARM_MACH_OMAP2_VP_H
+
+#include <linux/kernel.h>
+
+/* XXX document */
+#define VP_IDLE_TIMEOUT		200
+#define VP_TRANXDONE_TIMEOUT	300
+
+
+/**
+ * struct omap_vp_common_data - register data common to all VDDs
+ * @vpconfig_errorgain_mask: ERRORGAIN bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_initvoltage_mask: INITVOLTAGE bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_timeouten_mask: TIMEOUT bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_initvdd: INITVDD bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_forceupdate: FORCEUPDATE bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_vpenable: VPENABLE bitmask in the PRM_VP*_CONFIG reg
+ * @vpconfig_erroroffset_shift: ERROROFFSET field shift in PRM_VP*_CONFIG reg
+ * @vpconfig_errorgain_shift: ERRORGAIN field shift in PRM_VP*_CONFIG reg
+ * @vpconfig_initvoltage_shift: INITVOLTAGE field shift in PRM_VP*_CONFIG reg
+ * @vpconfig_stepmin_shift: VSTEPMIN field shift in the PRM_VP*_VSTEPMIN reg
+ * @vpconfig_smpswaittimemin_shift: SMPSWAITTIMEMIN field shift in PRM_VP*_VSTEPMIN reg
+ * @vpconfig_stepmax_shift: VSTEPMAX field shift in the PRM_VP*_VSTEPMAX reg
+ * @vpconfig_smpswaittimemax_shift: SMPSWAITTIMEMAX field shift in PRM_VP*_VSTEPMAX reg
+ * @vpconfig_vlimitto_vddmin_shift: VDDMIN field shift in PRM_VP*_VLIMITTO reg
+ * @vpconfig_vlimitto_vddmax_shift: VDDMAX field shift in PRM_VP*_VLIMITTO reg
+ * @vpconfig_vlimitto_timeout_shift: TIMEOUT field shift in PRM_VP*_VLIMITTO reg
+ *
+ * XXX It it not necessary to have both a mask and a shift for the same
+ *     bitfield - remove one
+ * XXX Many of these fields are wrongly named -- e.g., vpconfig_smps* -- fix!
+ */
+struct omap_vp_common_data {
+	u32 vpconfig_errorgain_mask;
+	u32 vpconfig_initvoltage_mask;
+	u32 vpconfig_timeouten;
+	u32 vpconfig_initvdd;
+	u32 vpconfig_forceupdate;
+	u32 vpconfig_vpenable;
+	u8 vpconfig_erroroffset_shift;
+	u8 vpconfig_errorgain_shift;
+	u8 vpconfig_initvoltage_shift;
+	u8 vstepmin_stepmin_shift;
+	u8 vstepmin_smpswaittimemin_shift;
+	u8 vstepmax_stepmax_shift;
+	u8 vstepmax_smpswaittimemax_shift;
+	u8 vlimitto_vddmin_shift;
+	u8 vlimitto_vddmax_shift;
+	u8 vlimitto_timeout_shift;
+};
+
+/**
+ * struct omap_vp_prm_irqst_data - PRM_IRQSTATUS_MPU.VP_TRANXDONE_ST data
+ * @prm_irqst_reg: reg offset for PRM_IRQSTATUS_MPU from top of PRM
+ * @tranxdone_status: VP_TRANXDONE_ST bitmask in PRM_IRQSTATUS_MPU reg
+ *
+ * XXX prm_irqst_reg does not belong here
+ * XXX Note that on OMAP3, VP_TRANXDONE interrupt may not work due to a
+ *     hardware bug
+ * XXX This structure is probably not needed
+ */
+struct omap_vp_prm_irqst_data {
+	u8 prm_irqst_reg;
+	u32 tranxdone_status;
+};
+
+/**
+ * struct omap_vp_instance_data - VP register offsets (per-VDD)
+ * @vp_common: pointer to struct omap_vp_common_data * for this SoC
+ * @prm_irqst_data: pointer to struct omap_vp_prm_irqst_data for this VDD
+ * @vpconfig: PRM_VP*_CONFIG reg offset from PRM start
+ * @vstepmin: PRM_VP*_VSTEPMIN reg offset from PRM start
+ * @vlimitto: PRM_VP*_VLIMITTO reg offset from PRM start
+ * @vstatus: PRM_VP*_VSTATUS reg offset from PRM start
+ * @voltage: PRM_VP*_VOLTAGE reg offset from PRM start
+ *
+ * XXX vp_common is probably not needed since it is per-SoC
+ */
+struct omap_vp_instance_data {
+	const struct omap_vp_common_data *vp_common;
+	const struct omap_vp_prm_irqst_data *prm_irqst_data;
+	u8 vpconfig;
+	u8 vstepmin;
+	u8 vstepmax;
+	u8 vlimitto;
+	u8 vstatus;
+	u8 voltage;
+};
+
+/**
+ * struct omap_vp_runtime_data - VP data populated at runtime by code
+ * @vpconfig_erroroffset: value of ERROROFFSET bitfield in PRM_VP*_CONFIG
+ * @vpconfig_errorgain: value of ERRORGAIN bitfield in PRM_VP*_CONFIG
+ * @vstepmin_smpswaittimemin: value of SMPSWAITTIMEMIN bitfield in PRM_VP*_VSTEPMIN
+ * @vstepmax_smpswaittimemax: value of SMPSWAITTIMEMAX bitfield in PRM_VP*_VSTEPMAX
+ * @vlimitto_timeout: value of TIMEOUT bitfield in PRM_VP*_VLIMITTO
+ * @vstepmin_stepmin: value of VSTEPMIN bitfield in PRM_VP*_VSTEPMIN
+ * @vstepmax_stepmax: value of VSTEPMAX bitfield in PRM_VP*_VSTEPMAX
+ * @vlimitto_vddmin: value of VDDMIN bitfield in PRM_VP*_VLIMITTO
+ * @vlimitto_vddmax: value of VDDMAX bitfield in PRM_VP*_VLIMITTO
+ *
+ * XXX Is this structure really needed?  Why not just program the
+ * device directly?  They are in PRM space, therefore in the WKUP
+ * powerdomain, so register contents should not be lost in off-mode.
+ * XXX Some of these fields are incorrectly named, e.g., vstep*
+ */
+struct omap_vp_runtime_data {
+	u32 vpconfig_erroroffset;
+	u16 vpconfig_errorgain;
+	u16 vstepmin_smpswaittimemin;
+	u16 vstepmax_smpswaittimemax;
+	u16 vlimitto_timeout;
+	u8 vstepmin_stepmin;
+	u8 vstepmax_stepmax;
+	u8 vlimitto_vddmin;
+	u8 vlimitto_vddmax;
+};
+
+extern struct omap_vp_instance_data omap3_vp1_data;
+extern struct omap_vp_instance_data omap3_vp2_data;
+
+extern struct omap_vp_instance_data omap4_vp_mpu_data;
+extern struct omap_vp_instance_data omap4_vp_iva_data;
+extern struct omap_vp_instance_data omap4_vp_core_data;
+
+#endif
diff --git a/arch/arm/mach-omap2/vp3xxx_data.c b/arch/arm/mach-omap2/vp3xxx_data.c
new file mode 100644
index 0000000..6452170
--- /dev/null
+++ b/arch/arm/mach-omap2/vp3xxx_data.c
@@ -0,0 +1,82 @@
+/*
+ * OMAP3 Voltage Processor (VP) data
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+
+#include "prm-regbits-34xx.h"
+#include "voltage.h"
+
+#include "vp.h"
+
+/*
+ * VP data common to 34xx/36xx chips
+ * XXX This stuff presumably belongs in the vp3xxx.c or vp.c file.
+ */
+static const struct omap_vp_common_data omap3_vp_common = {
+	.vpconfig_erroroffset_shift = OMAP3430_ERROROFFSET_SHIFT,
+	.vpconfig_errorgain_mask = OMAP3430_ERRORGAIN_MASK,
+	.vpconfig_errorgain_shift = OMAP3430_ERRORGAIN_SHIFT,
+	.vpconfig_initvoltage_shift = OMAP3430_INITVOLTAGE_SHIFT,
+	.vpconfig_initvoltage_mask = OMAP3430_INITVOLTAGE_MASK,
+	.vpconfig_timeouten = OMAP3430_TIMEOUTEN_MASK,
+	.vpconfig_initvdd = OMAP3430_INITVDD_MASK,
+	.vpconfig_forceupdate = OMAP3430_FORCEUPDATE_MASK,
+	.vpconfig_vpenable = OMAP3430_VPENABLE_MASK,
+	.vstepmin_smpswaittimemin_shift = OMAP3430_SMPSWAITTIMEMIN_SHIFT,
+	.vstepmax_smpswaittimemax_shift = OMAP3430_SMPSWAITTIMEMAX_SHIFT,
+	.vstepmin_stepmin_shift = OMAP3430_VSTEPMIN_SHIFT,
+	.vstepmax_stepmax_shift = OMAP3430_VSTEPMAX_SHIFT,
+	.vlimitto_vddmin_shift = OMAP3430_VDDMIN_SHIFT,
+	.vlimitto_vddmax_shift = OMAP3430_VDDMAX_SHIFT,
+	.vlimitto_timeout_shift = OMAP3430_TIMEOUT_SHIFT,
+};
+
+static const struct omap_vp_prm_irqst_data omap3_vp1_prm_irqst_data = {
+	.prm_irqst_reg = OMAP3_PRM_IRQSTATUS_MPU_OFFSET,
+	.tranxdone_status = OMAP3430_VP1_TRANXDONE_ST_MASK,
+};
+
+struct omap_vp_instance_data omap3_vp1_data = {
+	.vp_common = &omap3_vp_common,
+	.vpconfig = OMAP3_PRM_VP1_CONFIG_OFFSET,
+	.vstepmin = OMAP3_PRM_VP1_VSTEPMIN_OFFSET,
+	.vstepmax = OMAP3_PRM_VP1_VSTEPMAX_OFFSET,
+	.vlimitto = OMAP3_PRM_VP1_VLIMITTO_OFFSET,
+	.vstatus = OMAP3_PRM_VP1_STATUS_OFFSET,
+	.voltage = OMAP3_PRM_VP1_VOLTAGE_OFFSET,
+	.prm_irqst_data = &omap3_vp1_prm_irqst_data,
+};
+
+static const struct omap_vp_prm_irqst_data omap3_vp2_prm_irqst_data = {
+	.prm_irqst_reg = OMAP3_PRM_IRQSTATUS_MPU_OFFSET,
+	.tranxdone_status = OMAP3430_VP2_TRANXDONE_ST_MASK,
+};
+
+struct omap_vp_instance_data omap3_vp2_data = {
+	.vp_common = &omap3_vp_common,
+	.vpconfig = OMAP3_PRM_VP2_CONFIG_OFFSET,
+	.vstepmin = OMAP3_PRM_VP2_VSTEPMIN_OFFSET,
+	.vstepmax = OMAP3_PRM_VP2_VSTEPMAX_OFFSET,
+	.vlimitto = OMAP3_PRM_VP2_VLIMITTO_OFFSET,
+	.vstatus = OMAP3_PRM_VP2_STATUS_OFFSET,
+	.voltage = OMAP3_PRM_VP2_VOLTAGE_OFFSET,
+	.prm_irqst_data = &omap3_vp2_prm_irqst_data,
+};
diff --git a/arch/arm/mach-omap2/vp44xx_data.c b/arch/arm/mach-omap2/vp44xx_data.c
new file mode 100644
index 0000000..65d1ad6
--- /dev/null
+++ b/arch/arm/mach-omap2/vp44xx_data.c
@@ -0,0 +1,100 @@
+/*
+ * OMAP3 Voltage Processor (VP) data
+ *
+ * Copyright (C) 2007, 2010 Texas Instruments, Inc.
+ * Rajendra Nayak <rnayak@ti.com>
+ * Lesly A M <x0080970@ti.com>
+ * Thara Gopinath <thara@ti.com>
+ *
+ * Copyright (C) 2008, 2011 Nokia Corporation
+ * Kalle Jokiniemi
+ * Paul Walmsley
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/io.h>
+#include <linux/err.h>
+#include <linux/init.h>
+
+#include <plat/common.h>
+
+#include "prm44xx.h"
+#include "prm-regbits-44xx.h"
+#include "voltage.h"
+
+#include "vp.h"
+
+/*
+ * VP data common to 44xx chips
+ * XXX This stuff presumably belongs in the vp44xx.c or vp.c file.
+ */
+static const struct omap_vp_common_data omap4_vp_common = {
+	.vpconfig_erroroffset_shift = OMAP4430_ERROROFFSET_SHIFT,
+	.vpconfig_errorgain_mask = OMAP4430_ERRORGAIN_MASK,
+	.vpconfig_errorgain_shift = OMAP4430_ERRORGAIN_SHIFT,
+	.vpconfig_initvoltage_shift = OMAP4430_INITVOLTAGE_SHIFT,
+	.vpconfig_initvoltage_mask = OMAP4430_INITVOLTAGE_MASK,
+	.vpconfig_timeouten = OMAP4430_TIMEOUTEN_MASK,
+	.vpconfig_initvdd = OMAP4430_INITVDD_MASK,
+	.vpconfig_forceupdate = OMAP4430_FORCEUPDATE_MASK,
+	.vpconfig_vpenable = OMAP4430_VPENABLE_MASK,
+	.vstepmin_smpswaittimemin_shift = OMAP4430_SMPSWAITTIMEMIN_SHIFT,
+	.vstepmax_smpswaittimemax_shift = OMAP4430_SMPSWAITTIMEMAX_SHIFT,
+	.vstepmin_stepmin_shift = OMAP4430_VSTEPMIN_SHIFT,
+	.vstepmax_stepmax_shift = OMAP4430_VSTEPMAX_SHIFT,
+	.vlimitto_vddmin_shift = OMAP4430_VDDMIN_SHIFT,
+	.vlimitto_vddmax_shift = OMAP4430_VDDMAX_SHIFT,
+	.vlimitto_timeout_shift = OMAP4430_TIMEOUT_SHIFT,
+};
+
+static const struct omap_vp_prm_irqst_data omap4_vp_mpu_prm_irqst_data = {
+	.prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_2_OFFSET,
+	.tranxdone_status = OMAP4430_VP_MPU_TRANXDONE_ST_MASK,
+};
+
+struct omap_vp_instance_data omap4_vp_mpu_data = {
+	.vp_common = &omap4_vp_common,
+	.vpconfig = OMAP4_PRM_VP_MPU_CONFIG_OFFSET,
+	.vstepmin = OMAP4_PRM_VP_MPU_VSTEPMIN_OFFSET,
+	.vstepmax = OMAP4_PRM_VP_MPU_VSTEPMAX_OFFSET,
+	.vlimitto = OMAP4_PRM_VP_MPU_VLIMITTO_OFFSET,
+	.vstatus = OMAP4_PRM_VP_MPU_STATUS_OFFSET,
+	.voltage = OMAP4_PRM_VP_MPU_VOLTAGE_OFFSET,
+	.prm_irqst_data = &omap4_vp_mpu_prm_irqst_data,
+};
+
+static const struct omap_vp_prm_irqst_data omap4_vp_iva_prm_irqst_data = {
+	.prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_OFFSET,
+	.tranxdone_status = OMAP4430_VP_IVA_TRANXDONE_ST_MASK,
+};
+
+struct omap_vp_instance_data omap4_vp_iva_data = {
+	.vp_common = &omap4_vp_common,
+	.vpconfig = OMAP4_PRM_VP_IVA_CONFIG_OFFSET,
+	.vstepmin = OMAP4_PRM_VP_IVA_VSTEPMIN_OFFSET,
+	.vstepmax = OMAP4_PRM_VP_IVA_VSTEPMAX_OFFSET,
+	.vlimitto = OMAP4_PRM_VP_IVA_VLIMITTO_OFFSET,
+	.vstatus = OMAP4_PRM_VP_IVA_STATUS_OFFSET,
+	.voltage = OMAP4_PRM_VP_IVA_VOLTAGE_OFFSET,
+	.prm_irqst_data = &omap4_vp_iva_prm_irqst_data,
+};
+
+static const struct omap_vp_prm_irqst_data omap4_vp_core_prm_irqst_data = {
+	.prm_irqst_reg = OMAP4_PRM_IRQSTATUS_MPU_OFFSET,
+	.tranxdone_status = OMAP4430_VP_CORE_TRANXDONE_ST_MASK,
+};
+
+struct omap_vp_instance_data omap4_vp_core_data = {
+	.vp_common = &omap4_vp_common,
+	.vpconfig = OMAP4_PRM_VP_CORE_CONFIG_OFFSET,
+	.vstepmin = OMAP4_PRM_VP_CORE_VSTEPMIN_OFFSET,
+	.vstepmax = OMAP4_PRM_VP_CORE_VSTEPMAX_OFFSET,
+	.vlimitto = OMAP4_PRM_VP_CORE_VLIMITTO_OFFSET,
+	.vstatus = OMAP4_PRM_VP_CORE_STATUS_OFFSET,
+	.voltage = OMAP4_PRM_VP_CORE_VOLTAGE_OFFSET,
+	.prm_irqst_data = &omap4_vp_core_prm_irqst_data,
+};
+
-- 
1.7.1

