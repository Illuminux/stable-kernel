From cebfe714f295c87c5fa91ee804b6b759501696bc Mon Sep 17 00:00:00 2001
From: Steve Sakoman <steve@sakoman.com>
Date: Fri, 2 Apr 2010 20:01:46 -0700
Subject: [PATCH 23/31] ARM: OMAP: Beagle: use new gpmc nand infrastructure

---
 arch/arm/mach-omap2/board-omap3beagle.c |  152 +++++++++++++++++++-----------
 1 files changed, 96 insertions(+), 56 deletions(-)

diff --git a/arch/arm/mach-omap2/board-omap3beagle.c b/arch/arm/mach-omap2/board-omap3beagle.c
index 568a574..6a1767e 100644
--- a/arch/arm/mach-omap2/board-omap3beagle.c
+++ b/arch/arm/mach-omap2/board-omap3beagle.c
@@ -96,6 +96,10 @@ static void __init omap3beagle_enc28j60_init(void)
 static inline void __init omap3beagle_enc28j60_init(void) { return; }
 #endif
 
+struct flash_partitions {
+	struct mtd_partition *parts;
+	int nr_parts;
+};
 
 static struct mtd_partition omap3beagle_nand_partitions[] = {
 	/* All the partition sizes are listed in terms of NAND block size */
@@ -127,29 +131,103 @@ static struct mtd_partition omap3beagle_nand_partitions[] = {
 	},
 };
 
-static struct omap_nand_platform_data omap3beagle_nand_data = {
-	.options	= NAND_BUSWIDTH_16,
-	.parts		= omap3beagle_nand_partitions,
-	.nr_parts	= ARRAY_SIZE(omap3beagle_nand_partitions),
-	.dma_channel	= -1,		/* disable DMA in OMAP NAND driver */
-	.nand_setup	= NULL,
-	.dev_ready	= NULL,
+static struct flash_partitions omap3beagle_flash_partitions[] = {
+	{
+		/* NOR flash */
+	},
+	{
+		/* OneNAND */
+	},
+	{
+		/* NAND */
+		.parts = omap3beagle_nand_partitions,
+		.nr_parts = ARRAY_SIZE(omap3beagle_nand_partitions),
+       },
 };
 
-static struct resource omap3beagle_nand_resource = {
-	.flags		= IORESOURCE_MEM,
+#if defined(CONFIG_MTD_NAND_OMAP2) || \
+       defined(CONFIG_MTD_NAND_OMAP2_MODULE)
+
+/* Note that all values in this struct are in nanoseconds */
+static struct gpmc_timings nand_timings = {
+
+	.sync_clk	= 0,
+
+	.cs_on		= 0,
+	.cs_rd_off	= 36,
+	.cs_wr_off	= 36,
+
+	.adv_on		= 6,
+	.adv_rd_off	= 24,
+	.adv_wr_off	= 36,
+
+	.we_off		= 30,
+	.oe_off		= 48,
+
+	.access		= 54,
+	.rd_cycle	= 72,
+	.wr_cycle	= 72,
+
+	.wr_access	= 30,
+	.wr_data_mux_bus= 0,
 };
 
-static struct platform_device omap3beagle_nand_device = {
-	.name		= "omap2-nand",
-	.id		= -1,
-	.dev		= {
-		.platform_data	= &omap3beagle_nand_data,
-	},
-	.num_resources	= 1,
-	.resource	= &omap3beagle_nand_resource,
+static struct omap_nand_platform_data omap3beagle_nand_data = {
+       .nand_setup	= NULL,
+       .gpmc_t		= &nand_timings,
+       .dma_channel	= -1,	/* disable DMA in OMAP NAND driver */
+       .dev_ready	= NULL,
+       .devsize		= 1,	/* '0' for 8-bit, '1' for 16-bit device */
 };
 
+static void
+__init board_nand_init(struct flash_partitions omap3beagle_nand_parts, u8 cs)
+{
+	omap3beagle_nand_data.cs	= cs;
+	omap3beagle_nand_data.parts	= omap3beagle_nand_parts.parts;
+	omap3beagle_nand_data.nr_parts	= omap3beagle_nand_parts.nr_parts;
+	omap3beagle_nand_data.gpmc_baseaddr = (void *) (OMAP34XX_GPMC_VIRT);
+
+	omap3beagle_nand_data.gpmc_cs_baseaddr = (void *)(OMAP34XX_GPMC_VIRT +
+					GPMC_CS0_BASE + cs * GPMC_CS_SIZE);
+
+	gpmc_nand_init(&omap3beagle_nand_data);
+}
+#else
+static void
+__init board_nand_init(struct flash_partitions omap3beagle_nand_parts, u8 cs)
+{
+}
+#endif /* CONFIG_MTD_NAND_OMAP2 || CONFIG_MTD_NAND_OMAP2_MODULE */
+
+static void
+__init omap3beagle_flash_init(struct flash_partitions partition_info[]){
+	u8 cs = 0;
+	u8 nandcs = GPMC_CS_NUM + 1;
+
+	/* find out the chip-select on which NAND exists */
+	while (cs < GPMC_CS_NUM) {
+		u32 ret = 0;
+		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
+
+		if ((ret & 0xC00) == 0x800) {
+			printk(KERN_INFO "Found NAND on CS%d\n", cs);
+			if (nandcs > GPMC_CS_NUM)
+				nandcs = cs;
+		}
+		cs++;
+	}
+
+	if (nandcs > GPMC_CS_NUM) {
+		printk(KERN_INFO "NAND: Unable to find configuration "
+				 "in GPMC\n ");
+		return;
+	}
+
+	if (nandcs < GPMC_CS_NUM)
+		board_nand_init(partition_info[2], nandcs);
+}
+
 /* DSS */
 
 static int beagle_enable_dvi(struct omap_dss_device *dssdev)
@@ -489,44 +567,6 @@ static struct platform_device *omap3_beagle_devices[] __initdata = {
 	&beagle_dss_device,
 };
 
-static void __init omap3beagle_flash_init(void)
-{
-	u8 cs = 0;
-	u8 nandcs = GPMC_CS_NUM + 1;
-
-	u32 gpmc_base_add = OMAP34XX_GPMC_VIRT;
-
-	/* find out the chip-select on which NAND exists */
-	while (cs < GPMC_CS_NUM) {
-		u32 ret = 0;
-		ret = gpmc_cs_read_reg(cs, GPMC_CS_CONFIG1);
-
-		if ((ret & 0xC00) == 0x800) {
-			printk(KERN_INFO "Found NAND on CS%d\n", cs);
-			if (nandcs > GPMC_CS_NUM)
-				nandcs = cs;
-		}
-		cs++;
-	}
-
-	if (nandcs > GPMC_CS_NUM) {
-		printk(KERN_INFO "NAND: Unable to find configuration "
-				 "in GPMC\n ");
-		return;
-	}
-
-	if (nandcs < GPMC_CS_NUM) {
-		omap3beagle_nand_data.cs = nandcs;
-		omap3beagle_nand_data.gpmc_cs_baseaddr = (void *)
-			(gpmc_base_add + GPMC_CS0_BASE + nandcs * GPMC_CS_SIZE);
-		omap3beagle_nand_data.gpmc_baseaddr = (void *) (gpmc_base_add);
-
-		printk(KERN_INFO "Registering NAND on CS%d\n", nandcs);
-		if (platform_device_register(&omap3beagle_nand_device) < 0)
-			printk(KERN_ERR "Unable to register NAND device\n");
-	}
-}
-
 static const struct ehci_hcd_omap_platform_data ehci_pdata __initconst = {
 
 	.port_mode[0] = EHCI_HCD_OMAP_MODE_PHY,
@@ -574,7 +614,7 @@ static void __init omap3_beagle_init(void)
 
 	usb_musb_init(&musb_board_data);
 	usb_ehci_init(&ehci_pdata);
-	omap3beagle_flash_init();
+	omap3beagle_flash_init(omap3beagle_flash_partitions);
 
 	omap3beagle_enc28j60_init();
 
-- 
1.7.1

