From 2b4f63e5621c9e0276e4a8aea5ed390a7da7887e Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <omar.ramirez@ti.com>
Date: Thu, 8 Apr 2010 23:16:04 +0000
Subject: [PATCH 112/135] DSPBRIDGE: use one call for both ick and fck clocks

Instead of two calls to enable/disable for ick and fck use
one call to enable/disable both.

Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/clk.h |   35 +++++++++------------------
 drivers/dsp/bridge/services/clk.c          |   14 +++++-----
 drivers/dsp/bridge/wmd/_tiomap.h           |   25 +++++++++----------
 drivers/dsp/bridge/wmd/tiomap3430.c        |    8 +++---
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c    |   35 ++++++++--------------------
 5 files changed, 45 insertions(+), 72 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/clk.h b/arch/arm/plat-omap/include/dspbridge/clk.h
index 2602d9f..e6b09c7 100644
--- a/arch/arm/plat-omap/include/dspbridge/clk.h
+++ b/arch/arm/plat-omap/include/dspbridge/clk.h
@@ -20,29 +20,18 @@
 #define _CLK_H
 
 enum dsp_clk_id {
-	DSP_CLK_IVA2_CK = 0,
-	DSP_CLK_GPT5_FCK,
-	DSP_CLK_GPT5_ICK,
-	DSP_CLK_GPT6_FCK,
-	DSP_CLK_GPT6_ICK,
-	DSP_CLK_GPT7_FCK,
-	DSP_CLK_GPT7_ICK,
-	DSP_CLK_GPT8_FCK,
-	DSP_CLK_GPT8_ICK,
-	DSP_CLK_WDT3_FCK,
-	DSP_CLK_WDT3_ICK,
-	DSP_CLK_MCBSP1_FCK,
-	DSP_CLK_MCBSP1_ICK,
-	DSP_CLK_MCBSP2_FCK,
-	DSP_CLK_MCBSP2_ICK,
-	DSP_CLK_MCBSP3_FCK,
-	DSP_CLK_MCBSP3_ICK,
-	DSP_CLK_MCBSP4_FCK,
-	DSP_CLK_MCBSP4_ICK,
-	DSP_CLK_MCBSP5_FCK,
-	DSP_CLK_MCBSP5_ICK,
-	DSP_CLK_SSI_FCK,
-	DSP_CLK_SSI_ICK,
+	DSP_CLK_IVA2 = 0,
+	DSP_CLK_GPT5,
+	DSP_CLK_GPT6,
+	DSP_CLK_GPT7,
+	DSP_CLK_GPT8,
+	DSP_CLK_WDT3,
+	DSP_CLK_MCBSP1,
+	DSP_CLK_MCBSP2,
+	DSP_CLK_MCBSP3,
+	DSP_CLK_MCBSP4,
+	DSP_CLK_MCBSP5,
+	DSP_CLK_SSI,
 	DSP_CLK_NOT_DEFINED
 };
 
diff --git a/drivers/dsp/bridge/services/clk.c b/drivers/dsp/bridge/services/clk.c
index c72f574..9a439c7 100644
--- a/drivers/dsp/bridge/services/clk.c
+++ b/drivers/dsp/bridge/services/clk.c
@@ -52,8 +52,8 @@
 /* Bridge GPT id (1 - 4), DM Timer id (5 - 8) */
 #define DMT_ID(id) ((id) + 4)
 
-/* Bridge MCBSP id (6 - 10), OMAP Mcbsp id (1 - 5) */
-#define MCBSP_ID(id) ((id) - 13)
+/* Bridge MCBSP id (6 - 10), OMAP Mcbsp id (0 - 4) */
+#define MCBSP_ID(id) ((id) - 6)
 
 static struct omap_dm_timer *timer[4];
 
@@ -71,15 +71,15 @@ static s8 get_clk_type(u8 id)
 {
 	s8 type;
 
-	if (id == DSP_CLK_IVA2_CK)
+	if (id == DSP_CLK_IVA2)
 		type = IVA2_CLK;
-	else if (id <= DSP_CLK_GPT8_ICK)
+	else if (id <= DSP_CLK_GPT8)
 		type = GPT_CLK;
-	else if (id <= DSP_CLK_WDT3_ICK)
+	else if (id == DSP_CLK_WDT3)
 		type = WDT_CLK;
-	else if (id <= DSP_CLK_MCBSP5_ICK)
+	else if (id <= DSP_CLK_MCBSP5)
 		type = MCBSP_CLK;
-	else if (id < DSP_CLK_SSI_ICK)
+	else if (id == DSP_CLK_SSI)
 		type = SSI_CLK;
 	else
 		type = -1;
diff --git a/drivers/dsp/bridge/wmd/_tiomap.h b/drivers/dsp/bridge/wmd/_tiomap.h
index 887232b..56efb84 100644
--- a/drivers/dsp/bridge/wmd/_tiomap.h
+++ b/drivers/dsp/bridge/wmd/_tiomap.h
@@ -246,22 +246,21 @@ static const u32 bpwr_clkid[] = {
 
 struct bpwr_clk_t {
 	u32 clk_id;
-	enum dsp_clk_id fun_clk;
-	enum dsp_clk_id int_clk;
+	enum dsp_clk_id clk;
 };
 
 static const struct bpwr_clk_t bpwr_clks[] = {
-	{(u32) BPWR_GP_TIMER5, DSP_CLK_GPT5_FCK, DSP_CLK_GPT5_ICK},
-	{(u32) BPWR_GP_TIMER6, DSP_CLK_GPT6_FCK, DSP_CLK_GPT6_ICK},
-	{(u32) BPWR_GP_TIMER7, DSP_CLK_GPT7_FCK, DSP_CLK_GPT7_ICK},
-	{(u32) BPWR_GP_TIMER8, DSP_CLK_GPT8_FCK, DSP_CLK_GPT8_ICK},
-	{(u32) BPWR_WD_TIMER3, DSP_CLK_WDT3_FCK, DSP_CLK_WDT3_ICK},
-	{(u32) BPWR_MCBSP1, DSP_CLK_MCBSP1_FCK, DSP_CLK_MCBSP1_ICK},
-	{(u32) BPWR_MCBSP2, DSP_CLK_MCBSP2_FCK, DSP_CLK_MCBSP2_ICK},
-	{(u32) BPWR_MCBSP3, DSP_CLK_MCBSP3_FCK, DSP_CLK_MCBSP3_ICK},
-	{(u32) BPWR_MCBSP4, DSP_CLK_MCBSP4_FCK, DSP_CLK_MCBSP4_ICK},
-	{(u32) BPWR_MCBSP5, DSP_CLK_MCBSP5_FCK, DSP_CLK_MCBSP5_ICK},
-	{(u32) BPWR_SSI, DSP_CLK_SSI_FCK, DSP_CLK_SSI_ICK}
+	{(u32) BPWR_GP_TIMER5, DSP_CLK_GPT5},
+	{(u32) BPWR_GP_TIMER6, DSP_CLK_GPT6},
+	{(u32) BPWR_GP_TIMER7, DSP_CLK_GPT7},
+	{(u32) BPWR_GP_TIMER8, DSP_CLK_GPT8},
+	{(u32) BPWR_WD_TIMER3, DSP_CLK_WDT3},
+	{(u32) BPWR_MCBSP1, DSP_CLK_MCBSP1},
+	{(u32) BPWR_MCBSP2, DSP_CLK_MCBSP2},
+	{(u32) BPWR_MCBSP3, DSP_CLK_MCBSP3},
+	{(u32) BPWR_MCBSP4, DSP_CLK_MCBSP4},
+	{(u32) BPWR_MCBSP5, DSP_CLK_MCBSP5},
+	{(u32) BPWR_SSI, DSP_CLK_SSI}
 };
 
 /* Interrupt Register Offsets */
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 38338d1..4ac53ea 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -305,7 +305,7 @@ static dsp_status bridge_brd_monitor(struct wmd_dev_context *hDevContext)
 	}
 	(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST2_IVA2, 0,
 					OMAP3430_IVA2_MOD, RM_RSTCTRL);
-	dsp_clk_enable(DSP_CLK_IVA2_CK);
+	dsp_clk_enable(DSP_CLK_IVA2);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the device state to IDLE */
@@ -675,7 +675,7 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 		sm_interrupt_dsp(dev_context, MBX_PM_DSPIDLE);
 		mdelay(10);
 
-		clk_status = dsp_clk_disable(DSP_CLK_IVA2_CK);
+		clk_status = dsp_clk_disable(DSP_CLK_IVA2);
 
 		/* IVA2 is not in OFF state */
 		/* Set PM_PWSTCTRL_IVA2  to OFF */
@@ -685,7 +685,7 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 		(*pdata->dsp_cm_write)(OMAP34XX_CLKSTCTRL_FORCE_SLEEP,
 					OMAP3430_IVA2_MOD, CM_CLKSTCTRL);
 	} else {
-		clk_status = dsp_clk_disable(DSP_CLK_IVA2_CK);
+		clk_status = dsp_clk_disable(DSP_CLK_IVA2);
 	}
 	udelay(10);
 	/* Release the Ext Base virtual Address as the next DSP Program
@@ -743,7 +743,7 @@ static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 	 * to ensure that there are no pending L3 or other transactons from
 	 * IVA2 */
 	status = sleep_dsp(dev_context, PWR_EMERGENCYDEEPSLEEP, NULL);
-	clk_status = dsp_clk_disable(DSP_CLK_IVA2_CK);
+	clk_status = dsp_clk_disable(DSP_CLK_IVA2);
 
 	/* Release the Ext Base virtual Address as the next DSP Program
 	 * may have a different load address */
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index 2e08746..879f99e 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -288,7 +288,6 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 	u32 tmp_index;
 	u32 dsp_per_clks_before;
 	dsp_status status = DSP_SOK;
-	dsp_status status1 = DSP_SOK;
 	struct cfg_hostres *resources = dev_context->resources;
 	u32 value;
 
@@ -318,9 +317,6 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 	ext_clk_cmd = (ext_clk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
 	switch (ext_clk_cmd) {
 	case BPWR_DISABLE_CLOCK:
-		/* Call BP to disable the needed clock */
-		status1 = dsp_clk_disable(bpwr_clks[clk_id_index].int_clk);
-		status = dsp_clk_disable(bpwr_clks[clk_id_index].fun_clk);
 		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
 			/* clear MCBSP1_CLKS, on McBSP1 OFF */
 			value = __raw_readl(
@@ -336,16 +332,16 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 			__raw_writel(value,
 				resources->dw_sys_ctrl_base + 0x274);
 		}
+		status = dsp_clk_disable(bpwr_clks[clk_id_index].clk);
 		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id,
 					  false);
-		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
+		if (DSP_SUCCEEDED(status)) {
 			(dev_context->dsp_per_clks) &=
 			    (~((u32) (1 << clk_id_index)));
 		}
 		break;
 	case BPWR_ENABLE_CLOCK:
-		status1 = dsp_clk_enable(bpwr_clks[clk_id_index].int_clk);
-		status = dsp_clk_enable(bpwr_clks[clk_id_index].fun_clk);
+		status = dsp_clk_enable(bpwr_clks[clk_id_index].clk);
 		if (bpwr_clkid[clk_id_index] == BPWR_MCBSP1) {
 			/* set MCBSP1_CLKS, on McBSP1 ON */
 			value = __raw_readl(
@@ -362,9 +358,8 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 				resources->dw_sys_ctrl_base + 0x274);
 		}
 		dsp_clk_wakeup_event_ctrl(bpwr_clks[clk_id_index].clk_id, true);
-		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
+		if (DSP_SUCCEEDED(status))
 			(dev_context->dsp_per_clks) |= (1 << clk_id_index);
-		}
 		break;
 	default:
 		dev_dbg(bridge, "%s: Unsupported CMD\n", __func__);
@@ -467,9 +462,6 @@ dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
 
 	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
 		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
-			/* Disables the interface clock of the peripheral */
-			status =
-			    dsp_clk_disable(bpwr_clks[clk_idx].int_clk);
 			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
 				/* clear MCBSP1_CLKS, on McBSP1 OFF */
 				value = __raw_readl(resources->dw_sys_ctrl_base
@@ -486,9 +478,8 @@ dsp_status dsp_peripheral_clocks_disable(struct wmd_dev_context *dev_context,
 					     + 0x274);
 			}
 
-			/* Disables the functional clock of the periphearl */
-			status =
-			    dsp_clk_disable(bpwr_clks[clk_idx].fun_clk);
+			/* Disables the clocks of the peripheral */
+			status = dsp_clk_disable(bpwr_clks[clk_idx].clk);
 		}
 	}
 	return status;
@@ -502,7 +493,7 @@ dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
 					IN void *pargs)
 {
 	u32 clk_idx;
-	dsp_status int_clk_status = -EPERM, fun_clk_status = -EPERM;
+	dsp_status clk_status = -EPERM;
 	struct cfg_hostres *resources = dev_context->resources;
 	u32 value;
 
@@ -511,9 +502,8 @@ dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
 
 	for (clk_idx = 0; clk_idx < MBX_PM_MAX_RESOURCES; clk_idx++) {
 		if (((dev_context->dsp_per_clks) >> clk_idx) & 0x01) {
-			/* Enable the interface clock of the peripheral */
-			int_clk_status =
-			    dsp_clk_enable(bpwr_clks[clk_idx].int_clk);
+			/* Enable the clocks of the peripheral */
+			clk_status = dsp_clk_enable(bpwr_clks[clk_idx].clk);
 			if (bpwr_clkid[clk_idx] == BPWR_MCBSP1) {
 				/* set MCBSP1_CLKS, on McBSP1 ON */
 				value = __raw_readl(resources->dw_sys_ctrl_base
@@ -529,14 +519,9 @@ dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
 				__raw_writel(value, resources->dw_sys_ctrl_base
 					     + 0x274);
 			}
-			/* Enable the functional clock of the periphearl */
-			fun_clk_status =
-			    dsp_clk_enable(bpwr_clks[clk_idx].fun_clk);
 		}
 	}
-	if ((int_clk_status | fun_clk_status) != DSP_SOK)
-		return -EPERM;
-	return DSP_SOK;
+	return clk_status;
 }
 
 void dsp_clk_wakeup_event_ctrl(u32 ClkId, bool enable)
-- 
1.7.0.4

