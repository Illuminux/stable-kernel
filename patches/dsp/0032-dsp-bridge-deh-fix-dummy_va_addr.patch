From 2e81e7ac2b835be9777752a47efc83aa1d3180b9 Mon Sep 17 00:00:00 2001
From: Felipe Contreras <felipe.contreras@gmail.com>
Date: Tue, 23 Mar 2010 21:25:42 +0000
Subject: [PATCH 032/135] dsp-bridge: deh: fix dummy_va_addr

It's supposed to be virtual, so u32 doesn't make sense.

Signed-off-by: Felipe Contreras <felipe.contreras@gmail.com>
---
 drivers/dsp/bridge/wmd/ue_deh.c |   19 +++++++++----------
 1 files changed, 9 insertions(+), 10 deletions(-)

diff --git a/drivers/dsp/bridge/wmd/ue_deh.c b/drivers/dsp/bridge/wmd/ue_deh.c
index 2533546..9597f5d 100644
--- a/drivers/dsp/bridge/wmd/ue_deh.c
+++ b/drivers/dsp/bridge/wmd/ue_deh.c
@@ -52,14 +52,14 @@
 #include "_tiomap_pwr.h"
 #include <dspbridge/io_sm.h>
 
+#define ALIGN_DOWN(x, a)  ((x)&(~((a)-1)))
+
 static struct hw_mmu_map_attrs_t map_attrs = { HW_LITTLE_ENDIAN,
 	HW_ELEM_SIZE16BIT,
 	HW_MMU_CPUES
 };
 
-#define VIRT_TO_PHYS(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
-
-static u32 dummy_va_addr;
+static void *dummy_va_addr;
 
 dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
 		struct dev_object *hdev_obj)
@@ -76,7 +76,7 @@ dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
 	/* Get WMD context info. */
 	dev_get_wmd_context(hdev_obj, &hwmd_context);
 	DBC_ASSERT(hwmd_context);
-	dummy_va_addr = 0;
+	dummy_va_addr = NULL;
 	/* Allocate IO manager object: */
 	MEM_ALLOC_OBJECT(deh_mgr, struct deh_mgr, SIGNATURE);
 	if (!deh_mgr) {
@@ -217,13 +217,12 @@ void bridge_deh_notify(struct deh_mgr *deh_mgr, u32 ulEventMask, u32 dwErrInfo)
 			(unsigned int) deh_mgr->err_info.dw_val1,
 			(unsigned int) deh_mgr->err_info.dw_val2,
 			(unsigned int) fault_addr);
-		dummy_va_addr =
-			(u32) mem_calloc(sizeof(char) * 0x1000, MEM_PAGED);
+		dummy_va_addr = mem_calloc(0x1000, MEM_PAGED);
 		mem_physical =
-			VIRT_TO_PHYS(PG_ALIGN_LOW
-					((u32) dummy_va_addr, PG_SIZE4K));
+			ALIGN_DOWN(virt_to_phys(dummy_va_addr), PAGE_SIZE);
 		dev_context = (struct wmd_dev_context *)
 			deh_mgr->hwmd_context;
+
 		/*
 		 * Reset the dynamic mmu index to fixed count if it exceeds
 		 * 31. So that the dynmmuindex is always between the range of
@@ -302,6 +301,6 @@ dsp_status bridge_deh_get_info(struct deh_mgr *deh_mgr,
 
 void bridge_deh_release_dummy_mem(void)
 {
-	kfree((void *)dummy_va_addr);
-	dummy_va_addr = 0;
+	kfree(dummy_va_addr);
+	dummy_va_addr = NULL;
 }
-- 
1.7.0.4

