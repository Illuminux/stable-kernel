From 69b5a31d982ea0b7d7368a3435b9779e4fafbd00 Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <omar.ramirez@ti.com>
Date: Thu, 8 Apr 2010 23:15:59 +0000
Subject: [PATCH 106/135] DSPBRIDGE: function to get the type of clock requested by dsp

DSP can request between 5 types of clocks: IVA2, GPT (5-8), WDT (3),
MCBSP (1-5) or SSI clock. This function will be useful in case
a specific clock framework is associated with the clock.

Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
---
 drivers/dsp/bridge/services/clk.c |   89 ++++++++++++++++++++++++++++---------
 1 files changed, 68 insertions(+), 21 deletions(-)

diff --git a/drivers/dsp/bridge/services/clk.c b/drivers/dsp/bridge/services/clk.c
index e35b929..d5c3d4e 100644
--- a/drivers/dsp/bridge/services/clk.c
+++ b/drivers/dsp/bridge/services/clk.c
@@ -40,6 +40,13 @@
 #define SSI_SIDLE_SMARTIDLE		(2 << 3)
 #define SSI_MIDLE_NOIDLE		(1 << 12)
 
+/* Clk types requested by the dsp */
+#define IVA2_CLK	0
+#define GPT_CLK		1
+#define WDT_CLK		2
+#define MCBSP_CLK	3
+#define SSI_CLK		4
+
 struct dsp_clk_t {
 	struct clk *clk_handle;
 	const char *clk_name;
@@ -76,6 +83,26 @@ static struct dsp_clk_t dsp_clks[] = {
 	{NULL, ""}
 };
 
+static s8 get_clk_type(u8 id)
+{
+	s8 type;
+
+	if (id == DSP_CLK_IVA2_CK)
+		type = IVA2_CLK;
+	else if (id <= DSP_CLK_GPT8_ICK)
+		type = GPT_CLK;
+	else if (id <= DSP_CLK_WDT3_ICK)
+		type = WDT_CLK;
+	else if (id <= DSP_CLK_MCBSP5_ICK)
+		type = MCBSP_CLK;
+	else if (id < DSP_CLK_SSI_ICK)
+		type = SSI_CLK;
+	else
+		type = -1;
+
+	return type;
+}
+
 /*
  *  ======== dsp_clk_exit ========
  *  Purpose:
@@ -141,23 +168,33 @@ dsp_status dsp_clk_enable(IN enum dsp_clk_id clk_id)
 	dsp_status status = DSP_SOK;
 	struct clk *clk_handle;
 
-	DBC_REQUIRE(clk_id < DSP_CLK_NOT_DEFINED);
+	switch (get_clk_type(clk_id)) {
+	case IVA2_CLK:
+	case GPT_CLK:
+	case MCBSP_CLK:
+	case WDT_CLK:
+	case SSI_CLK:
+		clk_handle = dsp_clks[clk_id].clk_handle;
+		if (clk_enable(clk_handle)) {
+			pr_err("dsp_clk_enable: failed to Enable CLK %s, "
+				"CLK dev id = %d\n", dsp_clks[clk_id].clk_name,
+				dsp_clks[clk_id].id);
+			status = -EPERM;
+		}
 
-	clk_handle = dsp_clks[clk_id].clk_handle;
-	if (clk_enable(clk_handle)) {
-		pr_err("dsp_clk_enable: failed to Enable CLK %s, "
-		       "CLK dev id = %d\n",
-		       dsp_clks[clk_id].clk_name,
-		       dsp_clks[clk_id].id);
-		status = -EPERM;
+		/*
+		 * The SSI module need to configured not to have the Forced
+		 * idle for master interface. If it is set to forced idle,
+		 * the SSI module is transitioning to standby thereby causing
+		 * the client in the DSP hang waiting for the SSI module to
+		 * be active after enabling the clocks
+		 */
+		if (clk_id == DSP_CLK_SSI_ICK)
+			ssi_clk_prepare(true);
+		break;
+	default:
+		dev_err(bridge, "Invalid clock id for enable\n");
 	}
-	/* The SSI module need to configured not to have the Forced idle for
-	 * master interface. If it is set to forced idle, the SSI module is
-	 * transitioning to standby thereby causing the client in the DSP hang
-	 * waiting for the SSI module to be active after enabling the clocks
-	 */
-	if (clk_id == DSP_CLK_SSI_FCK)
-		ssi_clk_prepare(true);
 
 	return status;
 }
@@ -175,12 +212,22 @@ dsp_status dsp_clk_disable(IN enum dsp_clk_id clk_id)
 
 	DBC_REQUIRE(clk_id < DSP_CLK_NOT_DEFINED);
 
-	clk_handle = dsp_clks[clk_id].clk_handle;
-
-	if (clk_id == DSP_CLK_SSI_ICK)
-		ssi_clk_prepare(false);
-
-	clk_disable(clk_handle);
+	switch (get_clk_type(clk_id)) {
+	case IVA2_CLK:
+	case GPT_CLK:
+	case MCBSP_CLK:
+	case WDT_CLK:
+	case SSI_CLK:
+		clk_handle = dsp_clks[clk_id].clk_handle;
+
+		if (clk_id == DSP_CLK_SSI_ICK)
+			ssi_clk_prepare(false);
+
+		clk_disable(clk_handle);
+		break;
+	default:
+		dev_err(bridge, "Invalid clock id for disable\n");
+	}
 
 	return status;
 }
-- 
1.7.0.4

