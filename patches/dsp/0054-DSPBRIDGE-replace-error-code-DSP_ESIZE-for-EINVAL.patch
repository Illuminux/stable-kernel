From e287e4818a982ecdaabb167cb59117b178528194 Mon Sep 17 00:00:00 2001
From: Shivananda Hebbar <x0hebbar@ti.com>
Date: Mon, 19 Apr 2010 18:15:31 -0500
Subject: [PATCH 054/135] DSPBRIDGE: replace error code DSP_ESIZE for -EINVAL

This patch replaces DSP_ESIZE with -EINVAL.

Signed-off-by: Shivananda Hebbar <x0hebbar@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/node.h |    6 +++---
 arch/arm/plat-omap/include/dspbridge/proc.h |    2 +-
 arch/arm/plat-omap/include/dspbridge/strm.h |    4 ++--
 drivers/dsp/bridge/pmgr/wcd.c               |   18 +++++++++---------
 drivers/dsp/bridge/rmgr/node.c              |    2 +-
 drivers/dsp/bridge/rmgr/proc.c              |    2 +-
 drivers/dsp/bridge/rmgr/strm.c              |    4 ++--
 drivers/dsp/bridge/services/cfg.c           |    2 +-
 8 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/node.h b/arch/arm/plat-omap/include/dspbridge/node.h
index c298b94..e4bd16e 100644
--- a/arch/arm/plat-omap/include/dspbridge/node.h
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -79,7 +79,7 @@ extern dsp_status node_allocate(struct proc_object *hprocessor,
  *      DSP_EHANDLE:    Invalid node handle.
  *      DSP_EMEMORY:    Insufficent memory.
  *      -EPERM:      General Failure.
- *      DSP_ESIZE:      Invalid Size.
+ *      -EINVAL:      Invalid Size.
  *  Requires:
  *      node_init(void) called.
  *      pbuffer != NULL.
@@ -292,14 +292,14 @@ extern dsp_status node_delete_mgr(struct node_mgr *hnode_mgr);
  *      pu_allocated:    Location to write total number of allocated nodes.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_ESIZE:      node_tab is too small to hold all node handles.
+ *      -EINVAL:      node_tab is too small to hold all node handles.
  *  Requires:
  *      Valid hnode_mgr.
  *      node_tab != NULL || node_tab_size == 0.
  *      pu_num_nodes != NULL.
  *      pu_allocated != NULL.
  *  Ensures:
- *      - (DSP_ESIZE && *pu_num_nodes == 0)
+ *      - (-EINVAL && *pu_num_nodes == 0)
  *      - || (DSP_SOK && *pu_num_nodes <= node_tab_size)  &&
  *        (*pu_allocated == *pu_num_nodes)
  */
diff --git a/arch/arm/plat-omap/include/dspbridge/proc.h b/arch/arm/plat-omap/include/dspbridge/proc.h
index 95193af..53a2429 100644
--- a/arch/arm/plat-omap/include/dspbridge/proc.h
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -138,7 +138,7 @@ extern dsp_status proc_detach(struct process_context *pr_ctxt);
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_ESIZE   :   The amount of memory allocated for node_tab is
+ *      -EINVAL   :   The amount of memory allocated for node_tab is
  *		      insufficent. That is the number of nodes actually
  *		      allocated on the DSP is greater than the value
  *		      specified for node_tab_size.
diff --git a/arch/arm/plat-omap/include/dspbridge/strm.h b/arch/arm/plat-omap/include/dspbridge/strm.h
index f729a2c..a43ef62 100644
--- a/arch/arm/plat-omap/include/dspbridge/strm.h
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -38,7 +38,7 @@
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory.
  *      -EPERM:      Failure occurred, unable to allocate buffers.
- *      DSP_ESIZE:      usize must be > 0 bytes.
+ *      -EINVAL:      usize must be > 0 bytes.
  *  Requires:
  *      strm_init(void) called.
  *      ap_buffer != NULL.
@@ -172,7 +172,7 @@ extern dsp_status strm_get_event_handle(struct strm_object *hStrm,
  *  Returns:
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
- *      DSP_ESIZE:          stream_info_size < sizeof(dsp_streaminfo).
+ *      -EINVAL:          stream_info_size < sizeof(dsp_streaminfo).
  *      -EPERM:          Unable to get stream info.
  *  Requires:
  *      strm_init(void) called.
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index 99f6218..6e3c8b8 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -418,7 +418,7 @@ u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 	u32 size = args->args_mgr_enumnode_info.undb_props_size;
 
 	if (size < sizeof(struct dsp_ndbprops))
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	pndb_props = mem_alloc(size, MEM_NONPAGED);
 	if (pndb_props == NULL)
@@ -450,7 +450,7 @@ u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
 	u32 size = args->args_mgr_enumproc_info.processor_info_size;
 
 	if (size < sizeof(struct dsp_processorinfo))
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	processor_info = mem_alloc(size, MEM_NONPAGED);
 	if (processor_info == NULL)
@@ -662,7 +662,7 @@ u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 	u32 alloc_cnt;
 
 	if (!args->args_proc_enumnode_info.node_tab_size)
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
 				 node_tab,
@@ -719,7 +719,7 @@ u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt)
 
 	if (args->args_proc_enumresources.resource_info_size <
 	    sizeof(struct dsp_resourceinfo))
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	status =
 	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
@@ -745,7 +745,7 @@ u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt)
 
 	if (args->args_proc_getstate.state_info_size <
 	    sizeof(struct dsp_processorstate))
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	status =
 	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
@@ -765,7 +765,7 @@ u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
 	u8 *pbuf;
 
 	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	pbuf = mem_calloc(args->args_proc_gettrace.max_size, MEM_NONPAGED);
 	if (pbuf != NULL) {
@@ -907,7 +907,7 @@ u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt)
 	void *map_addr;
 
 	if (!args->args_proc_mapmem.ul_size)
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	status = proc_map(args->args_proc_mapmem.hprocessor,
 			  args->args_proc_mapmem.pmpu_addr,
@@ -957,7 +957,7 @@ u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
 
 	if ((args->args_proc_rsvmem.ul_size <= 0) ||
 	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
 				     args->args_proc_rsvmem.ul_size, &prsv_addr,
@@ -1090,7 +1090,7 @@ u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 	u8 *pbuffer = NULL;
 
 	if (!args->args_node_allocmsgbuf.usize)
-		return DSP_ESIZE;
+		return -EINVAL;
 
 	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
 		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
index f65d287..7cceb46 100644
--- a/drivers/dsp/bridge/rmgr/node.c
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -1639,7 +1639,7 @@ dsp_status node_enum_nodes(struct node_mgr *hnode_mgr, void **node_tab,
 	if (hnode_mgr->num_nodes > node_tab_size) {
 		*pu_allocated = hnode_mgr->num_nodes;
 		*pu_num_nodes = 0;
-		status = DSP_ESIZE;
+		status = -EINVAL;
 	} else {
 		hnode = (struct node_object *)lst_first(hnode_mgr->
 			node_list);
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 461a521..5b4ec46 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -1371,7 +1371,7 @@ dsp_status proc_stop(void *hprocessor)
 	if (DSP_SUCCEEDED(status) && hnode_mgr) {
 		status = node_enum_nodes(hnode_mgr, &hnode, node_tab_size,
 					 &num_nodes, &nodes_allocated);
-		if ((status == DSP_ESIZE) || (nodes_allocated > 0)) {
+		if ((status == -EINVAL) || (nodes_allocated > 0)) {
 			pr_err("%s: Can't stop device, active nodes = %d \n",
 			       __func__, nodes_allocated);
 			return DSP_EWRONGSTATE;
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
index 8bbca78..4811154 100644
--- a/drivers/dsp/bridge/rmgr/strm.c
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -120,7 +120,7 @@ dsp_status strm_allocate_buffer(struct strm_object *hStrm, u32 usize,
 		 * Allocate from segment specified at time of stream open.
 		 */
 		if (usize == 0)
-			status = DSP_ESIZE;
+			status = -EINVAL;
 
 	} else {
 		status = DSP_EHANDLE;
@@ -333,7 +333,7 @@ dsp_status strm_get_info(struct strm_object *hStrm,
 	} else {
 		if (stream_info_size < sizeof(struct stream_info)) {
 			/* size of users info */
-			status = DSP_ESIZE;
+			status = -EINVAL;
 		}
 	}
 	if (DSP_FAILED(status))
diff --git a/drivers/dsp/bridge/services/cfg.c b/drivers/dsp/bridge/services/cfg.c
index a472fef..b05b602 100644
--- a/drivers/dsp/bridge/services/cfg.c
+++ b/drivers/dsp/bridge/services/cfg.c
@@ -162,7 +162,7 @@ dsp_status cfg_get_exec_file(struct cfg_devnode *dev_node_obj, u32 ul_buf_size,
 		if (DSP_FAILED(status))
 			status = -ENODATA;
 		else if (exec_size > ul_buf_size)
-			status = DSP_ESIZE;
+			status = -EINVAL;
 
 	}
 	if (DSP_FAILED(status))
-- 
1.7.0.4

