From 9bcc71b7d575d4612e75dd995c38f69aa5a876a3 Mon Sep 17 00:00:00 2001
From: Shivananda Hebbar <x0hebbar@ti.com>
Date: Mon, 19 Apr 2010 18:15:36 -0500
Subject: [PATCH 056/135] DSPBRIDGE: replace error code DSP_EPOINTER for -EFAULT

This patch replaces DSP_EPOINTER with -EFAULT.

Signed-off-by: Shivananda Hebbar <x0hebbar@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/wmd.h |    8 ++++----
 drivers/dsp/bridge/pmgr/cmm.c              |    2 +-
 drivers/dsp/bridge/pmgr/wcd.c              |   18 +++++++++---------
 drivers/dsp/bridge/wmd/chnl_sm.c           |   14 +++++++-------
 drivers/dsp/bridge/wmd/io_sm.c             |    2 +-
 drivers/dsp/bridge/wmd/msg_sm.c            |    6 +++---
 6 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
index b4bef38..b57de2c 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmd.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -451,7 +451,7 @@ typedef dsp_status(*fxn_chnl_close) (struct chnl_object *chnl_obj);
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EHANDLE:    Invalid chnl_obj.
- *      DSP_EPOINTER:   pHostBuf is invalid.
+ *      -EFAULT:   pHostBuf is invalid.
  *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
  *      -ECANCELED: I/O has been cancelled on this channel.  No further
  *                      I/O is allowed.
@@ -492,7 +492,7 @@ typedef dsp_status(*fxn_chnl_addioreq) (struct chnl_object
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid chnl_obj.
- *      DSP_EPOINTER:   pIOC is invalid.
+ *      -EFAULT:   pIOC is invalid.
  *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
  *                      yet no I/O completions were queued.
  *  Requires:
@@ -556,7 +556,7 @@ typedef dsp_status(*fxn_chnl_flushio) (struct chnl_object *chnl_obj,
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EHANDLE:    Invalid chnl_obj.
- *      DSP_EPOINTER:   pInfo == NULL.
+ *      -EFAULT:   pInfo == NULL.
  *  Requires:
  *  Ensures:
  *      DSP_SOK:        pInfo points to a filled in chnl_info struct,
@@ -576,7 +576,7 @@ typedef dsp_status(*fxn_chnl_getinfo) (struct chnl_object *chnl_obj,
  *  Returns:
  *      DSP_SOK:            Success;
  *      DSP_EHANDLE:        Invalid hchnl_mgr.
- *      DSP_EPOINTER:       pMgrInfo == NULL.
+ *      -EFAULT:       pMgrInfo == NULL.
  *      CHNL_E_BADCHANID:   Invalid channel ID.
  *  Requires:
  *  Ensures:
diff --git a/drivers/dsp/bridge/pmgr/cmm.c b/drivers/dsp/bridge/pmgr/cmm.c
index 72cd311..0ef6024 100644
--- a/drivers/dsp/bridge/pmgr/cmm.c
+++ b/drivers/dsp/bridge/pmgr/cmm.c
@@ -391,7 +391,7 @@ dsp_status cmm_free_buf(struct cmm_object *hcmm_mgr, void *buf_pa,
 			u32 ul_seg_id)
 {
 	struct cmm_object *cmm_mgr_obj = (struct cmm_object *)hcmm_mgr;
-	dsp_status status = DSP_EPOINTER;
+	dsp_status status = -EFAULT;
 	struct cmm_mnode *mnode_obj = NULL;
 	struct cmm_allocator *allocator = NULL;
 	struct cmm_attrs *pattrs;
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index 6e3c8b8..5a4f284 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -174,12 +174,12 @@ static inline void _cp_fm_usr(void *to, const void __user * from,
 		return;
 
 	if (unlikely(!from)) {
-		*err = DSP_EPOINTER;
+		*err = -EFAULT;
 		return;
 	}
 
 	if (unlikely(copy_from_user(to, from, bytes)))
-		*err = DSP_EPOINTER;
+		*err = -EFAULT;
 }
 
 #define CP_FM_USR(to, from, err, n)				\
@@ -192,12 +192,12 @@ static inline void _cp_to_usr(void __user *to, const void *from,
 		return;
 
 	if (unlikely(!to)) {
-		*err = DSP_EPOINTER;
+		*err = -EFAULT;
 		return;
 	}
 
 	if (unlikely(copy_to_user(to, from, bytes)))
-		*err = DSP_EPOINTER;
+		*err = -EFAULT;
 }
 
 #define CP_TO_USR(to, from, err, n)				\
@@ -498,7 +498,7 @@ u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt)
 				(char *)args->args_mgr_registerobject.
 				psz_path_name, path_size);
 	if (!ret) {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 		goto func_end;
 	}
 
@@ -1069,7 +1069,7 @@ u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 	if (DSP_SUCCEEDED(status)) {
 		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
 		if (DSP_FAILED(status)) {
-			status = DSP_EPOINTER;
+			status = -EFAULT;
 			node_delete(hnode, pr_ctxt);
 		}
 	}
@@ -1212,7 +1212,7 @@ u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt)
 	}
 
 	if (!args->args_node_freemsgbuf.pbuffer)
-		return DSP_EPOINTER;
+		return -EFAULT;
 
 	if (DSP_SUCCEEDED(status)) {
 		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
@@ -1386,7 +1386,7 @@ u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt)
 		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
 			  status, num_bufs);
 		if (DSP_FAILED(status)) {
-			status = DSP_EPOINTER;
+			status = -EFAULT;
 			strm_free_buffer(args->args_strm_allocatebuffer.hstream,
 					 ap_buffer, num_bufs, pr_ctxt);
 		}
@@ -1490,7 +1490,7 @@ u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt)
 	dsp_status status = DSP_SOK;
 
 	if (!args->args_strm_issue.pbuffer)
-		return DSP_EPOINTER;
+		return -EFAULT;
 
 	/* No need of doing CP_FM_USR for the user buffer (pbuffer)
 	   as this is done in Bridge internal function bridge_chnl_add_io_req
diff --git a/drivers/dsp/bridge/wmd/chnl_sm.c b/drivers/dsp/bridge/wmd/chnl_sm.c
index 3d70cc2..bb6b02a 100644
--- a/drivers/dsp/bridge/wmd/chnl_sm.c
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -110,7 +110,7 @@ dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *pHostBuf,
 
 	/* Validate args */
 	if (!pHostBuf) {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else if (is_eos && CHNL_IS_INPUT(pchnl->chnl_mode)) {
@@ -158,7 +158,7 @@ dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *pHostBuf,
 			if (status) {
 				kfree(host_sys_buf);
 				host_sys_buf = NULL;
-				status = DSP_EPOINTER;
+				status = -EFAULT;
 				goto func_end;
 			}
 		}
@@ -561,7 +561,7 @@ dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
 			status = DSP_EHANDLE;
 		}
 	} else {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 	}
 	return status;
 }
@@ -588,7 +588,7 @@ dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
 
 	/* Check args: */
 	if (pIOC == NULL) {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 	} else if (!MEM_IS_VALID_HANDLE(pchnl, CHNL_SIGNATURE)) {
 		status = DSP_EHANDLE;
 	} else if (dwTimeOut == CHNL_IOCNOWAIT) {
@@ -690,7 +690,7 @@ dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
 
 		/* If the addr is in user mode, then copy it */
 		if (!host_sys_buf || !ioc.pbuf) {
-			status = DSP_EPOINTER;
+			status = -EFAULT;
 			goto func_cont;
 		}
 		if (!CHNL_IS_INPUT(pchnl->chnl_mode))
@@ -703,7 +703,7 @@ dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
 				status = 0;
 		}
 		if (status)
-			status = DSP_EPOINTER;
+			status = -EFAULT;
 func_cont1:
 		kfree(host_sys_buf);
 	}
@@ -743,7 +743,7 @@ dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr, u32 uChnlID,
 			status = CHNL_E_BADCHANID;
 		}
 	} else {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 	}
 
 	return status;
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
index bc55992..c634f7c 100644
--- a/drivers/dsp/bridge/wmd/io_sm.c
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -711,7 +711,7 @@ dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 		ul_shm_base = (u32) MEM_LINEAR_ADDRESS((void *)ul_shm_base,
 						       ul_mem_length);
 		if (ul_shm_base == 0) {
-			status = DSP_EPOINTER;
+			status = -EFAULT;
 			goto func_end;
 		}
 		/* Register SM */
diff --git a/drivers/dsp/bridge/wmd/msg_sm.c b/drivers/dsp/bridge/wmd/msg_sm.c
index ee11ef7..ede098d 100644
--- a/drivers/dsp/bridge/wmd/msg_sm.c
+++ b/drivers/dsp/bridge/wmd/msg_sm.c
@@ -62,12 +62,12 @@ dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 	dsp_status status = DSP_SOK;
 
 	if (!phMsgMgr || !msgCallback || !hdev_obj) {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 		goto func_end;
 	}
 	dev_get_io_mgr(hdev_obj, &hio_mgr);
 	if (!hio_mgr) {
-		status = DSP_EPOINTER;
+		status = -EFAULT;
 		goto func_end;
 	}
 	*phMsgMgr = NULL;
@@ -464,7 +464,7 @@ dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
 			status = -EPERM;
 		} else {
 			if (LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
-				status = DSP_EPOINTER;
+				status = -EFAULT;
 				goto func_cont;
 			}
 			/* Get msg from free list */
-- 
1.7.0.4

