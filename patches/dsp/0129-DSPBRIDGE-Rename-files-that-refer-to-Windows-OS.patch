From a579b5b89f64f5a627f5fd7b1b307cb71ee1e3ae Mon Sep 17 00:00:00 2001
From: Ivan Gomez Castellanos <ivan.gomez@ti.com>
Date: Fri, 30 Apr 2010 11:57:35 -0500
Subject: [PATCH 129/135] DSPBRIDGE: Rename files that refer to Windows OS

Since "wmd" (windows mini driver) and "wcd" (windows class driver)
refers to Windows OS, the following files are renamed:

wmd.h ==> dspdefs.h
wmdchnl.h ==> dspchnl.h
wmddeh.h ==> dspdeh.h
wmdio.h ==> dspio.h
wmdioctl.h ==> dspioctl.h
wmdmsg.h ==> dspmsg.h
wcd.h ==> dspapi.h
wcdioctl.h ==> dspapi-ioctl.h
wcd.c ==> dspapi.c

Signed-off-by: Ivan Gomez Castellanos <ivan.gomez@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/_chnl_sm.h    |    4 +-
 arch/arm/plat-omap/include/dspbridge/_dcd.h        |    2 +-
 arch/arm/plat-omap/include/dspbridge/dev.h         |    2 +-
 arch/arm/plat-omap/include/dspbridge/devdefs.h     |    2 +-
 arch/arm/plat-omap/include/dspbridge/drvdefs.h     |    2 +-
 .../arm/plat-omap/include/dspbridge/dspapi-ioctl.h |  466 ++++++
 arch/arm/plat-omap/include/dspbridge/dspapi.h      |   36 +
 arch/arm/plat-omap/include/dspbridge/dspchnl.h     |   72 +
 arch/arm/plat-omap/include/dspbridge/dspdefs.h     | 1134 ++++++++++++++
 arch/arm/plat-omap/include/dspbridge/dspdeh.h      |   47 +
 arch/arm/plat-omap/include/dspbridge/dspio.h       |   41 +
 arch/arm/plat-omap/include/dspbridge/dspioctl.h    |   73 +
 arch/arm/plat-omap/include/dspbridge/dspmsg.h      |   56 +
 arch/arm/plat-omap/include/dspbridge/wcd.h         |   36 -
 arch/arm/plat-omap/include/dspbridge/wcdioctl.h    |  466 ------
 arch/arm/plat-omap/include/dspbridge/wmd.h         | 1134 --------------
 arch/arm/plat-omap/include/dspbridge/wmdchnl.h     |   72 -
 arch/arm/plat-omap/include/dspbridge/wmddeh.h      |   47 -
 arch/arm/plat-omap/include/dspbridge/wmdio.h       |   41 -
 arch/arm/plat-omap/include/dspbridge/wmdioctl.h    |   73 -
 arch/arm/plat-omap/include/dspbridge/wmdmsg.h      |   56 -
 drivers/dsp/bridge/Makefile                        |    2 +-
 drivers/dsp/bridge/core/_deh.h                     |    2 +-
 drivers/dsp/bridge/core/_tiomap.h                  |    2 +-
 drivers/dsp/bridge/core/chnl_sm.c                  |    4 +-
 drivers/dsp/bridge/core/io_sm.c                    |    6 +-
 drivers/dsp/bridge/core/mmu_fault.c                |    2 +-
 drivers/dsp/bridge/core/msg_sm.c                   |    2 +-
 drivers/dsp/bridge/core/tiomap3430.c               |   12 +-
 drivers/dsp/bridge/core/tiomap3430_pwr.c           |    2 +-
 drivers/dsp/bridge/core/ue_deh.c                   |    4 +-
 drivers/dsp/bridge/core/wdt.c                      |    2 +-
 drivers/dsp/bridge/pmgr/chnlobj.h                  |    2 +-
 drivers/dsp/bridge/pmgr/dev.c                      |    2 +-
 drivers/dsp/bridge/pmgr/dspapi.c                   | 1656 ++++++++++++++++++++
 drivers/dsp/bridge/pmgr/ioobj.h                    |    2 +-
 drivers/dsp/bridge/pmgr/msg.c                      |    2 +-
 drivers/dsp/bridge/pmgr/msgobj.h                   |    2 +-
 drivers/dsp/bridge/pmgr/wcd.c                      | 1656 --------------------
 drivers/dsp/bridge/rmgr/disp.c                     |    2 +-
 drivers/dsp/bridge/rmgr/drv.c                      |    2 +-
 drivers/dsp/bridge/rmgr/drv_interface.c            |    2 +-
 drivers/dsp/bridge/rmgr/node.c                     |    4 +-
 drivers/dsp/bridge/rmgr/proc.c                     |    6 +-
 drivers/dsp/bridge/rmgr/pwr.c                      |    2 +-
 drivers/dsp/bridge/rmgr/strm.c                     |    2 +-
 46 files changed, 3622 insertions(+), 3622 deletions(-)
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspapi-ioctl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspapi.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspchnl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspdeh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspio.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspioctl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspmsg.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wcd.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wcdioctl.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmd.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmdchnl.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmddeh.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmdio.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmdioctl.h
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/wmdmsg.h
 create mode 100644 drivers/dsp/bridge/pmgr/dspapi.c
 delete mode 100644 drivers/dsp/bridge/pmgr/wcd.c

diff --git a/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
index b473744..7a728b1 100644
--- a/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
+++ b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
@@ -23,8 +23,8 @@
 #ifndef _CHNL_SM_
 #define _CHNL_SM_
 
-#include <dspbridge/wcd.h>
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspapi.h>
+#include <dspbridge/dspdefs.h>
 
 #include <dspbridge/list.h>
 #include <dspbridge/ntfy.h>
diff --git a/arch/arm/plat-omap/include/dspbridge/_dcd.h b/arch/arm/plat-omap/include/dspbridge/_dcd.h
index 7a0938a..27691c6 100644
--- a/arch/arm/plat-omap/include/dspbridge/_dcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/_dcd.h
@@ -20,7 +20,7 @@
 #ifndef _WCD_
 #define _WCD_
 
-#include <dspbridge/wcdioctl.h>
+#include <dspbridge/dspapi-ioctl.h>
 
 /*
  *  ======== api_call_dev_ioctl ========
diff --git a/arch/arm/plat-omap/include/dspbridge/dev.h b/arch/arm/plat-omap/include/dspbridge/dev.h
index 9f6e5ba..5e753ae 100644
--- a/arch/arm/plat-omap/include/dspbridge/dev.h
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -26,7 +26,7 @@
 #include <dspbridge/dehdefs.h>
 #include <dspbridge/nodedefs.h>
 #include <dspbridge/dispdefs.h>
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 #include <dspbridge/dmm.h>
 #include <dspbridge/host_os.h>
 
diff --git a/arch/arm/plat-omap/include/dspbridge/devdefs.h b/arch/arm/plat-omap/include/dspbridge/devdefs.h
index 8c0adc1..600be0e 100644
--- a/arch/arm/plat-omap/include/dspbridge/devdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/devdefs.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * Definition of common include typedef between wmd.h and dev.h. Required
+ * Definition of common include typedef between dspdefs.h and dev.h. Required
  * to break circular dependency between WMD and DEV include files.
  *
  * Copyright (C) 2008 Texas Instruments, Inc.
diff --git a/arch/arm/plat-omap/include/dspbridge/drvdefs.h b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
index f084207..c0dea57 100644
--- a/arch/arm/plat-omap/include/dspbridge/drvdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
@@ -3,7 +3,7 @@
  *
  * DSP-BIOS Bridge driver support functions for TI OMAP processors.
  *
- * Definition of common struct between wmd.h and drv.h.
+ * Definition of common struct between dspdefs.h and drv.h.
  *
  * Copyright (C) 2005-2006 Texas Instruments, Inc.
  *
diff --git a/arch/arm/plat-omap/include/dspbridge/dspapi-ioctl.h b/arch/arm/plat-omap/include/dspbridge/dspapi-ioctl.h
new file mode 100644
index 0000000..d87db5c
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspapi-ioctl.h
@@ -0,0 +1,466 @@
+/*
+ * dspapi-ioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Contains structures and commands that are used for interaction
+ * between the DDSP API and class driver.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WCDIOCTL_
+#define WCDIOCTL_
+
+#include <dspbridge/cmm.h>
+#include <dspbridge/strmdefs.h>
+#include <dspbridge/dbdcd.h>
+
+union Trapped_Args {
+
+	/* MGR Module */
+	struct {
+		u32 node_id;
+		struct dsp_ndbprops __user *pndb_props;
+		u32 undb_props_size;
+		u32 __user *pu_num_nodes;
+	} args_mgr_enumnode_info;
+
+	struct {
+		u32 processor_id;
+		struct dsp_processorinfo __user *processor_info;
+		u32 processor_info_size;
+		u32 __user *pu_num_procs;
+	} args_mgr_enumproc_info;
+
+	struct {
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+		char *psz_path_name;
+	} args_mgr_registerobject;
+
+	struct {
+		struct dsp_uuid *uuid_obj;
+		enum dsp_dcdobjtype obj_type;
+	} args_mgr_unregisterobject;
+
+	struct {
+		struct dsp_notification __user *__user *anotifications;
+		u32 count;
+		u32 __user *pu_index;
+		u32 utimeout;
+	} args_mgr_wait;
+
+	/* PROC Module */
+	struct {
+		u32 processor_id;
+		struct dsp_processorattrin __user *attr_in;
+		void *__user *ph_processor;
+	} args_proc_attach;
+
+	struct {
+		void *hprocessor;
+		u32 dw_cmd;
+		struct dsp_cbdata __user *pargs;
+	} args_proc_ctrl;
+
+	struct {
+		void *hprocessor;
+	} args_proc_detach;
+
+	struct {
+		void *hprocessor;
+		void *__user *node_tab;
+		u32 node_tab_size;
+		u32 __user *pu_num_nodes;
+		u32 __user *pu_allocated;
+	} args_proc_enumnode_info;
+
+	struct {
+		void *hprocessor;
+		u32 resource_type;
+		struct dsp_resourceinfo *resource_info;
+		u32 resource_info_size;
+	} args_proc_enumresources;
+
+	struct {
+		void *hprocessor;
+		struct dsp_processorstate __user *proc_state_obj;
+		u32 state_info_size;
+	} args_proc_getstate;
+
+	struct {
+		void *hprocessor;
+		u8 __user *pbuf;
+		u8 __user *psize;
+		u32 max_size;
+	} args_proc_gettrace;
+
+	struct {
+		void *hprocessor;
+		s32 argc_index;
+		char __user *__user *user_args;
+		char *__user *user_envp;
+	} args_proc_load;
+
+	struct {
+		void *hprocessor;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_proc_register_notify;
+
+	struct {
+		void *hprocessor;
+	} args_proc_start;
+
+	struct {
+		void *hprocessor;
+		u32 ul_size;
+		void *__user *pp_rsv_addr;
+	} args_proc_rsvmem;
+
+	struct {
+		void *hprocessor;
+		u32 ul_size;
+		void *prsv_addr;
+	} args_proc_unrsvmem;
+
+	struct {
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		void *req_addr;
+		void *__user *pp_map_addr;
+		u32 ul_map_attr;
+	} args_proc_mapmem;
+
+	struct {
+		void *hprocessor;
+		u32 ul_size;
+		void *map_addr;
+	} args_proc_unmapmem;
+
+	struct {
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+		u32 ul_flags;
+	} args_proc_flushmemory;
+
+	struct {
+		void *hprocessor;
+	} args_proc_stop;
+
+	struct {
+		void *hprocessor;
+		void *pmpu_addr;
+		u32 ul_size;
+	} args_proc_invalidatememory;
+
+	/* NODE Module */
+	struct {
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_cbdata __user *pargs;
+		struct dsp_nodeattrin __user *attr_in;
+		void *__user *ph_node;
+	} args_node_allocate;
+
+	struct {
+		void *hnode;
+		u32 usize;
+		struct dsp_bufferattr __user *pattr;
+		u8 *__user *pbuffer;
+	} args_node_allocmsgbuf;
+
+	struct {
+		void *hnode;
+		s32 prio;
+	} args_node_changepriority;
+
+	struct {
+		void *hnode;
+		u32 stream_id;
+		void *other_node;
+		u32 other_stream;
+		struct dsp_strmattr __user *pattrs;
+		struct dsp_cbdata __user *conn_param;
+	} args_node_connect;
+
+	struct {
+		void *hnode;
+	} args_node_create;
+
+	struct {
+		void *hnode;
+	} args_node_delete;
+
+	struct {
+		void *hnode;
+		struct dsp_bufferattr __user *pattr;
+		u8 *pbuffer;
+	} args_node_freemsgbuf;
+
+	struct {
+		void *hnode;
+		struct dsp_nodeattr __user *pattr;
+		u32 attr_size;
+	} args_node_getattr;
+
+	struct {
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_getmessage;
+
+	struct {
+		void *hnode;
+	} args_node_pause;
+
+	struct {
+		void *hnode;
+		struct dsp_msg __user *message;
+		u32 utimeout;
+	} args_node_putmessage;
+
+	struct {
+		void *hnode;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_node_registernotify;
+
+	struct {
+		void *hnode;
+	} args_node_run;
+
+	struct {
+		void *hnode;
+		dsp_status __user *pstatus;
+	} args_node_terminate;
+
+	struct {
+		void *hprocessor;
+		struct dsp_uuid __user *node_id_ptr;
+		struct dsp_ndbprops __user *node_props;
+	} args_node_getuuidprops;
+
+	/* STRM module */
+
+	struct {
+		void *hstream;
+		u32 usize;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_allocatebuffer;
+
+	struct {
+		void *hstream;
+	} args_strm_close;
+
+	struct {
+		void *hstream;
+		u8 *__user *ap_buffer;
+		u32 num_bufs;
+	} args_strm_freebuffer;
+
+	struct {
+		void *hstream;
+		void **ph_event;
+	} args_strm_geteventhandle;
+
+	struct {
+		void *hstream;
+		struct stream_info __user *stream_info;
+		u32 stream_info_size;
+	} args_strm_getinfo;
+
+	struct {
+		void *hstream;
+		bool flush_flag;
+	} args_strm_idle;
+
+	struct {
+		void *hstream;
+		u8 *pbuffer;
+		u32 dw_bytes;
+		u32 dw_buf_size;
+		u32 dw_arg;
+	} args_strm_issue;
+
+	struct {
+		void *hnode;
+		u32 direction;
+		u32 index;
+		struct strm_attr __user *attr_in;
+		void *__user *ph_stream;
+	} args_strm_open;
+
+	struct {
+		void *hstream;
+		u8 *__user *buf_ptr;
+		u32 __user *bytes;
+		u32 __user *buf_size_ptr;
+		u32 __user *pdw_arg;
+	} args_strm_reclaim;
+
+	struct {
+		void *hstream;
+		u32 event_mask;
+		u32 notify_type;
+		struct dsp_notification __user *hnotification;
+	} args_strm_registernotify;
+
+	struct {
+		void *__user *stream_tab;
+		u32 strm_num;
+		u32 __user *pmask;
+		u32 utimeout;
+	} args_strm_select;
+
+	/* CMM Module */
+	struct {
+		struct cmm_object *hcmm_mgr;
+		u32 usize;
+		struct cmm_attrs *pattrs;
+		OUT void **pp_buf_va;
+	} args_cmm_allocbuf;
+
+	struct {
+		struct cmm_object *hcmm_mgr;
+		void *buf_pa;
+		u32 ul_seg_id;
+	} args_cmm_freebuf;
+
+	struct {
+		void *hprocessor;
+		struct cmm_object *__user *ph_cmm_mgr;
+	} args_cmm_gethandle;
+
+	struct {
+		struct cmm_object *hcmm_mgr;
+		struct cmm_info __user *cmm_info_obj;
+	} args_cmm_getinfo;
+
+	/* UTIL module */
+	struct {
+		s32 util_argc;
+		char **pp_argv;
+	} args_util_testdll;
+};
+
+/*
+ * Dspbridge Ioctl numbering scheme
+ *
+ *    7                           0
+ *  ---------------------------------
+ *  |  Module   |   Ioctl Number    |
+ *  ---------------------------------
+ *  | x | x | x | 0 | 0 | 0 | 0 | 0 |
+ *  ---------------------------------
+ */
+
+/* Ioctl driver identifier */
+#define DB		0xDB
+
+/*
+ * Following are used to distinguish between module ioctls, this is needed
+ * in case new ioctls are introduced.
+ */
+#define DB_MODULE_MASK		0xE0
+#define DB_IOC_MASK		0x1F
+
+/* Ioctl module masks */
+#define DB_MGR		0x0
+#define DB_PROC		0x20
+#define DB_NODE		0x40
+#define DB_STRM		0x60
+#define DB_CMM		0x80
+
+#define DB_MODULE_SHIFT		5
+
+/* Used to calculate the ioctl per dspbridge module */
+#define DB_IOC(module, num) \
+			(((module) & DB_MODULE_MASK) | ((num) & DB_IOC_MASK))
+/* Used to get dspbridge ioctl module */
+#define DB_GET_MODULE(cmd)	((cmd) & DB_MODULE_MASK)
+/* Used to get dspbridge ioctl number */
+#define DB_GET_IOC(cmd)		((cmd) & DB_IOC_MASK)
+
+/* TODO: Remove deprecated and not implemented */
+
+/* MGR Module */
+#define MGR_ENUMNODE_INFO	_IOWR(DB, DB_IOC(DB_MGR, 0), unsigned long)
+#define MGR_ENUMPROC_INFO	_IOWR(DB, DB_IOC(DB_MGR, 1), unsigned long)
+#define MGR_REGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 2), unsigned long)
+#define MGR_UNREGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 3), unsigned long)
+#define MGR_WAIT		_IOWR(DB, DB_IOC(DB_MGR, 4), unsigned long)
+/* MGR_GET_PROC_RES Deprecated */
+#define MGR_GET_PROC_RES	_IOR(DB, DB_IOC(DB_MGR, 5), unsigned long)
+
+/* PROC Module */
+#define PROC_ATTACH		_IOWR(DB, DB_IOC(DB_PROC, 0), unsigned long)
+#define PROC_CTRL		_IOR(DB, DB_IOC(DB_PROC, 1), unsigned long)
+/* PROC_DETACH Deprecated */
+#define PROC_DETACH		_IOR(DB, DB_IOC(DB_PROC, 2), unsigned long)
+#define PROC_ENUMNODE		_IOWR(DB, DB_IOC(DB_PROC, 3), unsigned long)
+#define PROC_ENUMRESOURCES	_IOWR(DB, DB_IOC(DB_PROC, 4), unsigned long)
+#define PROC_GET_STATE		_IOWR(DB, DB_IOC(DB_PROC, 5), unsigned long)
+#define PROC_GET_TRACE		_IOWR(DB, DB_IOC(DB_PROC, 6), unsigned long)
+#define PROC_LOAD		_IOW(DB, DB_IOC(DB_PROC, 7), unsigned long)
+#define PROC_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_PROC, 8), unsigned long)
+#define PROC_START		_IOW(DB, DB_IOC(DB_PROC, 9), unsigned long)
+#define PROC_RSVMEM		_IOWR(DB, DB_IOC(DB_PROC, 10), unsigned long)
+#define PROC_UNRSVMEM		_IOW(DB, DB_IOC(DB_PROC, 11), unsigned long)
+#define PROC_MAPMEM		_IOWR(DB, DB_IOC(DB_PROC, 12), unsigned long)
+#define PROC_UNMAPMEM		_IOR(DB, DB_IOC(DB_PROC, 13), unsigned long)
+#define PROC_FLUSHMEMORY	_IOW(DB, DB_IOC(DB_PROC, 14), unsigned long)
+#define PROC_STOP		_IOWR(DB, DB_IOC(DB_PROC, 15), unsigned long)
+#define PROC_INVALIDATEMEMORY	_IOW(DB, DB_IOC(DB_PROC, 16), unsigned long)
+
+/* NODE Module */
+#define NODE_ALLOCATE		_IOWR(DB, DB_IOC(DB_NODE, 0), unsigned long)
+#define NODE_ALLOCMSGBUF	_IOWR(DB, DB_IOC(DB_NODE, 1), unsigned long)
+#define NODE_CHANGEPRIORITY	_IOW(DB, DB_IOC(DB_NODE, 2), unsigned long)
+#define NODE_CONNECT		_IOW(DB, DB_IOC(DB_NODE, 3), unsigned long)
+#define NODE_CREATE		_IOW(DB, DB_IOC(DB_NODE, 4), unsigned long)
+#define NODE_DELETE		_IOW(DB, DB_IOC(DB_NODE, 5), unsigned long)
+#define NODE_FREEMSGBUF		_IOW(DB, DB_IOC(DB_NODE, 6), unsigned long)
+#define NODE_GETATTR		_IOWR(DB, DB_IOC(DB_NODE, 7), unsigned long)
+#define NODE_GETMESSAGE		_IOWR(DB, DB_IOC(DB_NODE, 8), unsigned long)
+#define NODE_PAUSE		_IOW(DB, DB_IOC(DB_NODE, 9), unsigned long)
+#define NODE_PUTMESSAGE		_IOW(DB, DB_IOC(DB_NODE, 10), unsigned long)
+#define NODE_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_NODE, 11), unsigned long)
+#define NODE_RUN		_IOW(DB, DB_IOC(DB_NODE, 12), unsigned long)
+#define NODE_TERMINATE		_IOWR(DB, DB_IOC(DB_NODE, 13), unsigned long)
+#define NODE_GETUUIDPROPS	_IOWR(DB, DB_IOC(DB_NODE, 14), unsigned long)
+
+/* STRM Module */
+#define STRM_ALLOCATEBUFFER	_IOWR(DB, DB_IOC(DB_STRM, 0), unsigned long)
+#define STRM_CLOSE		_IOW(DB, DB_IOC(DB_STRM, 1), unsigned long)
+#define STRM_FREEBUFFER		_IOWR(DB, DB_IOC(DB_STRM, 2), unsigned long)
+#define STRM_GETEVENTHANDLE	_IO(DB, DB_IOC(DB_STRM, 3))	/* Not Impl'd */
+#define STRM_GETINFO		_IOWR(DB, DB_IOC(DB_STRM, 4), unsigned long)
+#define STRM_IDLE		_IOW(DB, DB_IOC(DB_STRM, 5), unsigned long)
+#define STRM_ISSUE		_IOW(DB, DB_IOC(DB_STRM, 6), unsigned long)
+#define STRM_OPEN		_IOWR(DB, DB_IOC(DB_STRM, 7), unsigned long)
+#define STRM_RECLAIM		_IOWR(DB, DB_IOC(DB_STRM, 8), unsigned long)
+#define STRM_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_STRM, 9), unsigned long)
+#define STRM_SELECT		_IOWR(DB, DB_IOC(DB_STRM, 10), unsigned long)
+
+/* CMM Module */
+#define CMM_ALLOCBUF		_IO(DB, DB_IOC(DB_CMM, 0))	/* Not Impl'd */
+#define CMM_FREEBUF		_IO(DB, DB_IOC(DB_CMM, 1))	/* Not Impl'd */
+#define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
+#define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
+
+#endif /* WCDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspapi.h b/arch/arm/plat-omap/include/dspbridge/dspapi.h
new file mode 100644
index 0000000..232aab0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspapi.h
@@ -0,0 +1,36 @@
+/*
+ * dspapi.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Bridge class driver library functions, object definitions, and
+ * return error/status codes.  To be included by Bridge mini drivers.
+ *
+ * Notes:
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.  WMD's must not call module Init/Exit
+ *   functions.
+ *
+ *   To ensure WMD binary compatibility across different platforms,
+ *   for the same processor, a WMD must restrict its usage of system
+ *   services to those exported by the 'Bridge class library.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WCD_
+#define WCD_
+
+/* This BRD API Library Version: */
+#define BRD_API_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
+#define BRD_API_MINOR_VERSION   (u32)0
+
+#endif /* WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspchnl.h b/arch/arm/plat-omap/include/dspbridge/dspchnl.h
new file mode 100644
index 0000000..3f3907d
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspchnl.h
@@ -0,0 +1,72 @@
+/*
+ * dspchnl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge channel class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are implemented
+ * by every class of WMD channel library.
+ *
+ * Notes:
+ *   The function comment headers reside in dspdefs.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDCHNL_
+#define WMDCHNL_
+
+extern dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+				     struct dev_object *hdev_obj,
+				     IN CONST struct chnl_mgrattrs
+				     *pMgrAttrs);
+
+extern dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr);
+
+extern dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
+				   struct chnl_mgr *hchnl_mgr,
+				   s8 chnl_mode,
+				   u32 uChnlId,
+				   CONST IN OPTIONAL struct chnl_attr
+				   *pattrs);
+
+extern dsp_status bridge_chnl_close(struct chnl_object *chnl_obj);
+
+extern dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj,
+				      void *pHostBuf,
+				      u32 byte_size, u32 buf_size,
+				      OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
+
+extern dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, OUT struct chnl_ioc *pIOC);
+
+extern dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj);
+
+extern dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj,
+				    u32 dwTimeOut);
+
+extern dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
+				    OUT struct chnl_info *pInfo);
+
+extern dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr,
+					u32 uChnlID, OUT struct chnl_mgrinfo
+					*pMgrInfo);
+
+extern dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj,
+				   u32 dwTimeOut, bool fFlush);
+
+extern dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
+					   u32 event_mask,
+					   u32 notify_type,
+					   struct dsp_notification
+					   *hnotification);
+
+#endif /* WMDCHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspdefs.h b/arch/arm/plat-omap/include/dspbridge/dspdefs.h
new file mode 100644
index 0000000..804fe98
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspdefs.h
@@ -0,0 +1,1134 @@
+/*
+ * dspdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Bridge mini driver entry point and interface function declarations.
+ *
+ * Notes:
+ *   The Bridge class driver obtains it's function interface to
+ *   the Bridge mini driver via a call to bridge_drv_entry().
+ *
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.
+ *
+ *   WMD function DBC Requires and Ensures are also made by the WCD on
+ *   behalf of the WMD, to simplify the WMD code.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMD_
+#define WMD_
+
+#include <dspbridge/brddefs.h>
+#include <dspbridge/cfgdefs.h>
+#include <dspbridge/chnlpriv.h>
+#include <dspbridge/dehdefs.h>
+#include <dspbridge/devdefs.h>
+#include <dspbridge/iodefs.h>
+#include <dspbridge/msgdefs.h>
+
+/*
+ *  Any IOCTLS at or above this value are reserved for standard WMD
+ *  interfaces.
+ */
+#define BRD_RESERVEDIOCTLBASE   0x8000
+
+/* Handle to mini-driver's private device context. */
+struct bridge_dev_context;
+
+/*--------------------------------------------------------------------------- */
+/* 'Bridge MINI DRIVER FUNCTION TYPES */
+/*--------------------------------------------------------------------------- */
+
+/*
+ *  ======== bridge_brd_monitor ========
+ *  Purpose:
+ *      Bring the board to the BRD_IDLE (monitor) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_IDLE state;
+ *      else:           Board state is indeterminate.
+ */
+typedef dsp_status(*fxn_brd_monitor) (struct bridge_dev_context *hDevContext);
+
+/*
+ *  ======== fxn_brd_setstate ========
+ *  Purpose:
+ *      Sets the Mini driver state
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulBrdState:     Board state
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Ensures:
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Update the Board state to the specified state.
+ */
+typedef dsp_status(*fxn_brd_setstate) (struct bridge_dev_context
+				       * hDevContext, u32 ulBrdState);
+
+/*
+ *  ======== bridge_brd_start ========
+ *  Purpose:
+ *      Bring board to the BRD_RUNNING (start) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      dwDSPAddr:      DSP address at which to start execution.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *      Board is in monitor (BRD_IDLE) state.
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+typedef dsp_status(*fxn_brd_start) (struct bridge_dev_context
+				    * hDevContext, u32 dwDSPAddr);
+
+/*
+ *  ======== bridge_brd_mem_copy ========
+ *  Purpose:
+ *  Copy memory from one DSP address to another
+ *  Parameters:
+ *      dev_context:    Pointer to context handle
+ *  ulDspDestAddr:  DSP address to copy to
+ *  ulDspSrcAddr:   DSP address to copy from
+ *  ul_num_bytes: Number of bytes to copy
+ *  ulMemType:  What section of memory to copy to
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      dev_context != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+typedef dsp_status(*fxn_brd_memcopy) (struct bridge_dev_context
+				      * hDevContext,
+				      u32 ulDspDestAddr,
+				      u32 ulDspSrcAddr,
+				      u32 ul_num_bytes, u32 ulMemType);
+/*
+ *  ======== bridge_brd_mem_write ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.  Unlike bridge_brd_write, this API does reset the DSP
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ul_num_bytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_brd_memwrite) (struct bridge_dev_context
+				       * hDevContext,
+				       IN u8 *pHostBuf,
+				       u32 dwDSPAddr, u32 ul_num_bytes,
+				       u32 ulMemType);
+
+/*
+ *  ======== bridge_brd_mem_map ========
+ *  Purpose:
+ *      Map a MPU memory region to a DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ul_mpu_addr:      MPU memory region start address.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ul_num_bytes:     Number of bytes to map.
+ *      map_attrs:       Mapping attributes (e.g. endianness).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_brd_memmap) (struct bridge_dev_context
+				     * hDevContext, u32 ul_mpu_addr,
+				     u32 ulVirtAddr, u32 ul_num_bytes,
+				     u32 ulMapAttrs);
+
+/*
+ *  ======== bridge_brd_mem_un_map ========
+ *  Purpose:
+ *      UnMap an MPU memory region from DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ul_num_bytes:     Number of bytes to unmap.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_brd_memunmap) (struct bridge_dev_context
+				       * hDevContext,
+				       u32 ulVirtAddr, u32 ul_num_bytes);
+
+/*
+ *  ======== bridge_brd_stop ========
+ *  Purpose:
+ *      Bring board to the BRD_STOPPED state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_STOPPED (stop) state;
+ *                      Interrupts to the PC are disabled.
+ *      else:           Board state is indeterminate.
+ */
+typedef dsp_status(*fxn_brd_stop) (struct bridge_dev_context *hDevContext);
+
+/*
+ *  ======== bridge_brd_status ========
+ *  Purpose:
+ *      Report the current state of the board.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      pdwState:       Ptr to BRD status variable.
+ *  Returns:
+ *      DSP_SOK:
+ *  Requires:
+ *      pdwState != NULL;
+ *      hDevContext != NULL
+ *  Ensures:
+ *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
+ */
+typedef dsp_status(*fxn_brd_status) (struct bridge_dev_context *hDevContext,
+				     int *pdwState);
+
+/*
+ *  ======== bridge_brd_read ========
+ *  Purpose:
+ *      Read a block of DSP memory, from a given memory space, into a host
+ *      buffer.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Destination).
+ *      dwDSPAddr:      Address on DSP board (Source).
+ *      ul_num_bytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP from which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ *  Will not write more than ul_num_bytes bytes into pHostBuf.
+ */
+typedef dsp_status(*fxn_brd_read) (struct bridge_dev_context *hDevContext,
+				   OUT u8 *pHostBuf,
+				   u32 dwDSPAddr,
+				   u32 ul_num_bytes, u32 ulMemType);
+
+/*
+ *  ======== bridge_brd_write ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ul_num_bytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
+ *      -EPERM:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_brd_write) (struct bridge_dev_context *hDevContext,
+				    IN u8 *pHostBuf,
+				    u32 dwDSPAddr,
+				    u32 ul_num_bytes, u32 ulMemType);
+
+/*
+ *  ======== bridge_chnl_create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given 'Bridge board.
+ *  Parameters:
+ *      phChnlMgr:      Location to store a channel manager object on output.
+ *      hdev_obj:     Handle to a device object.
+ *      pMgrAttrs:      Channel manager attributes.
+ *      pMgrAttrs->max_channels: Max channels
+ *      pMgrAttrs->birq:      Channel's I/O IRQ number.
+ *      pMgrAttrs->irq_shared:   TRUE if the IRQ is shareable.
+ *      pMgrAttrs->word_size: DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->shm_base:  Base physical address of shared memory, if any.
+ *      pMgrAttrs->usm_length: Bytes of shared memory block.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      -ENOMEM:        Insufficient memory for requested resources.
+ *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
+ *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
+ *  Requires:
+ *      phChnlMgr != NULL.
+ *      pMgrAttrs != NULL
+ *      pMgrAttrs field are all valid:
+ *          0 < max_channels <= CHNL_MAXCHANNELS.
+ *          birq <= 15.
+ *          word_size > 0.
+ *      hdev_obj != NULL
+ *      No channel manager exists for this board.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_chnl_create) (OUT struct chnl_mgr
+				      **phChnlMgr,
+				      struct dev_object
+				      * hdev_obj,
+				      IN CONST struct
+				      chnl_mgrattrs * pMgrAttrs);
+
+/*
+ *  ======== bridge_chnl_destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ *  Parameters:
+ *      hchnl_mgr:       Channel manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EFAULT:    hchnl_mgr was invalid.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
+ *          chnl_create may subsequently be called for the same device.
+ */
+typedef dsp_status(*fxn_chnl_destroy) (struct chnl_mgr *hchnl_mgr);
+/*
+ *  ======== bridge_deh_notify ========
+ *  Purpose:
+ *      When notified of DSP error, take appropriate action.
+ *  Parameters:
+ *      hdeh_mgr:        Handle to DEH manager object.
+ *      ulEventMask:  Indicate the type of exception
+ *      dwErrInfo:     Error information
+ *  Returns:
+ *
+ *  Requires:
+ *      hdeh_mgr != NULL;
+ *     ulEventMask with a valid exception
+ *  Ensures:
+ */
+typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
+				u32 ulEventMask, u32 dwErrInfo);
+
+/*
+ *  ======== bridge_chnl_open ========
+ *  Purpose:
+ *      Open a new half-duplex channel to the DSP board.
+ *  Parameters:
+ *      phChnl:         Location to store a channel object handle.
+ *      hchnl_mgr:	Handle to channel manager, as returned by
+ *      		CHNL_GetMgr().
+ *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *                      direction of data transfer.
+ *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
+ *                      select a free channel id (default);
+ *                      otherwise this field specifies the id of the channel.
+ *      pattrs:         Channel attributes.  Attribute fields are as follows:
+ *      pattrs->uio_reqs: Specifies the maximum number of I/O requests which can
+ *                      be pending at any given time. All request packets are
+ *                      preallocated when the channel is opened.
+ *      pattrs->event_obj: This field allows the user to supply an auto reset
+ *                      event object for channel I/O completion notifications.
+ *                      It is the responsibility of the user to destroy this
+ *                      object AFTER closing the channel.
+ *                      This channel event object can be retrieved using
+ *                      CHNL_GetEventHandle().
+ *      pattrs->hReserved: The kernel mode handle of this event object.
+ *
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      -EFAULT:            hchnl_mgr is invalid.
+ *      -ENOMEM:            Insufficient memory for requested resources.
+ *      -EINVAL:        Invalid number of IOReqs.
+ *      CHNL_E_OUTOFSTREAMS:    No free channels available.
+ *      CHNL_E_BADCHANID:       Channel ID is out of range.
+ *      -EALREADY:        Channel is in use.
+ *      CHNL_E_NOIORPS:         No free IO request packets available for
+ *                              queuing.
+ *  Requires:
+ *      phChnl != NULL.
+ *      pattrs != NULL.
+ *      pattrs->event_obj is a valid event handle.
+ *      pattrs->hReserved is the kernel mode handle for pattrs->event_obj.
+ *  Ensures:
+ *      DSP_SOK:                *phChnl is a valid channel.
+ *      else:                   *phChnl is set to NULL if (phChnl != NULL);
+ */
+typedef dsp_status(*fxn_chnl_open) (OUT struct chnl_object
+				    **phChnl,
+				    struct chnl_mgr *hchnl_mgr,
+				    s8 chnl_mode,
+				    u32 uChnlId,
+				    CONST IN OPTIONAL struct
+				    chnl_attr * pattrs);
+
+/*
+ *  ======== bridge_chnl_close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ *  Parameters:
+ *      chnl_obj:          Handle to a channel object.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      -EFAULT:    Invalid chnl_obj.
+ *  Requires:
+ *      No thread must be blocked on this channel's I/O completion event.
+ *  Ensures:
+ *      DSP_SOK:        chnl_obj is no longer valid.
+ */
+typedef dsp_status(*fxn_chnl_close) (struct chnl_object *chnl_obj);
+
+/*
+ *  ======== bridge_chnl_add_io_req ========
+ *  Purpose:
+ *      Enqueue an I/O request for data transfer on a channel to the DSP.
+ *      The direction (mode) is specified in the channel object. Note the DSP
+ *      address is specified for channels opened in direct I/O mode.
+ *  Parameters:
+ *      chnl_obj:          Channel object handle.
+ *      pHostBuf:       Host buffer address source.
+ *      byte_size:	Number of PC bytes to transfer. A zero value indicates
+ *                      that this buffer is the last in the output channel.
+ *                      A zero value is invalid for an input channel.
+ *!     buf_size:       Actual buffer size in host bytes.
+ *      dw_dsp_addr:      DSP address for transfer.  (Currently ignored).
+ *      dw_arg:          A user argument that travels with the buffer.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      -EFAULT:    Invalid chnl_obj.
+ *      -EFAULT:   pHostBuf is invalid.
+ *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
+ *      -ECANCELED: I/O has been cancelled on this channel.  No further
+ *                      I/O is allowed.
+ *      CHNL_E_EOS:     End of stream was already marked on a previous
+ *                      IORequest on this channel.  No further I/O is expected.
+ *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
+ *                      the size of the physical shared memory output window.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: The buffer will be transferred if the channel is ready;
+ *          otherwise, will be queued for transfer when the channel becomes
+ *          ready.  In any case, notifications of I/O completion are
+ *          asynchronous.
+ *          If byte_size is 0 for an output channel, subsequent CHNL_AddIOReq's
+ *          on this channel will fail with error code CHNL_E_EOS.  The
+ *          corresponding IOC for this I/O request will have its status flag
+ *          set to CHNL_IOCSTATEOS.
+ */
+typedef dsp_status(*fxn_chnl_addioreq) (struct chnl_object
+					* chnl_obj,
+					void *pHostBuf,
+					u32 byte_size,
+					u32 buf_size,
+					OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
+
+/*
+ *  ======== bridge_chnl_get_ioc ========
+ *  Purpose:
+ *      Dequeue an I/O completion record, which contains information about the
+ *      completed I/O request.
+ *  Parameters:
+ *      chnl_obj:          Channel object handle.
+ *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
+ *                      first available IOC.
+ *      pIOC:           On output, contains host buffer address, bytes
+ *                      transferred, and status of I/O completion.
+ *      pIOC->status:   See chnldefs.h.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EFAULT:    Invalid chnl_obj.
+ *      -EFAULT:   pIOC is invalid.
+ *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
+ *                      yet no I/O completions were queued.
+ *  Requires:
+ *      dwTimeOut == CHNL_IOCNOWAIT.
+ *  Ensures:
+ *      DSP_SOK: if there are any remaining IOC's queued before this call
+ *          returns, the channel event object will be left in a signalled
+ *          state.
+ */
+typedef dsp_status(*fxn_chnl_getioc) (struct chnl_object *chnl_obj,
+				      u32 dwTimeOut,
+				      OUT struct chnl_ioc *pIOC);
+
+/*
+ *  ======== bridge_chnl_cancel_io ========
+ *  Purpose:
+ *      Return all I/O requests to the client which have not yet been
+ *      transferred.  The channel's I/O completion object is
+ *      signalled, and all the I/O requests are queued as IOC's, with the
+ *      status field set to CHNL_IOCSTATCANCEL.
+ *      This call is typically used in abort situations, and is a prelude to
+ *      chnl_close();
+ *  Parameters:
+ *      chnl_obj:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      -EFAULT:    Invalid chnl_obj.
+ *  Requires:
+ *  Ensures:
+ *      Subsequent I/O requests to this channel will not be accepted.
+ */
+typedef dsp_status(*fxn_chnl_cancelio) (struct chnl_object *chnl_obj);
+
+/*
+ *  ======== bridge_chnl_flush_io ========
+ *  Purpose:
+ *      For an output stream (to the DSP), indicates if any IO requests are in
+ *      the output request queue.  For input streams (from the DSP), will
+ *      cancel all pending IO requests.
+ *  Parameters:
+ *      chnl_obj:              Channel object handle.
+ *      dwTimeOut:          Timeout value for flush operation.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
+ *      -EFAULT:        Invalid chnl_obj.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            No I/O requests will be pending on this channel.
+ */
+typedef dsp_status(*fxn_chnl_flushio) (struct chnl_object *chnl_obj,
+				       u32 dwTimeOut);
+
+/*
+ *  ======== bridge_chnl_get_info ========
+ *  Purpose:
+ *      Retrieve information related to a channel.
+ *  Parameters:
+ *      chnl_obj:          Handle to a valid channel object, or NULL.
+ *      pInfo:          Location to store channel info.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      -EFAULT:    Invalid chnl_obj.
+ *      -EFAULT:   pInfo == NULL.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:        pInfo points to a filled in chnl_info struct,
+ *                      if (pInfo != NULL).
+ */
+typedef dsp_status(*fxn_chnl_getinfo) (struct chnl_object *chnl_obj,
+				       OUT struct chnl_info *pChnlInfo);
+
+/*
+ *  ======== bridge_chnl_get_mgr_info ========
+ *  Purpose:
+ *      Retrieve information related to the channel manager.
+ *  Parameters:
+ *      hchnl_mgr:           Handle to a valid channel manager, or NULL.
+ *      uChnlID:            Channel ID.
+ *      pMgrInfo:           Location to store channel manager info.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      -EFAULT:        Invalid hchnl_mgr.
+ *      -EFAULT:       pMgrInfo == NULL.
+ *      CHNL_E_BADCHANID:   Invalid channel ID.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            pMgrInfo points to a filled in chnl_mgrinfo
+ *                          struct, if (pMgrInfo != NULL).
+ */
+typedef dsp_status(*fxn_chnl_getmgrinfo) (struct chnl_mgr
+					  * hchnl_mgr,
+					  u32 uChnlID,
+					  OUT struct chnl_mgrinfo *pMgrInfo);
+
+/*
+ *  ======== bridge_chnl_idle ========
+ *  Purpose:
+ *      Idle a channel. If this is an input channel, or if this is an output
+ *      channel and fFlush is TRUE, all currently enqueued buffers will be
+ *      dequeued (data discarded for output channel).
+ *      If this is an output channel and fFlush is FALSE, this function
+ *      will block until all currently buffered data is output, or the timeout
+ *      specified has been reached.
+ *
+ *  Parameters:
+ *      chnl_obj:          Channel object handle.
+ *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
+ *                      to wait for buffers to be output. (Not used for
+ *                      input channel).
+ *      fFlush:         If output channel and fFlush is TRUE, discard any
+ *                      currently buffered data. If FALSE, wait for currently
+ *                      buffered data to be output, or timeout, whichever
+ *                      occurs first. fFlush is ignored for input channel.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      -EFAULT:        Invalid chnl_obj.
+ *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
+ *  Requires:
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_chnl_idle) (struct chnl_object *chnl_obj,
+				    u32 dwTimeOut, bool fFlush);
+
+/*
+ *  ======== bridge_chnl_register_notify ========
+ *  Purpose:
+ *      Register for notification of events on a channel.
+ *  Parameters:
+ *      chnl_obj:          Channel object handle.
+ *      event_mask:     Type of events to be notified about: IO completion
+ *                      (DSP_STREAMIOCOMPLETION) or end of stream
+ *                      (DSP_STREAMDONE).
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of a dsp_notification object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ENOMEM:    Insufficient memory.
+ *      -EINVAL:     event_mask is 0 and hnotification was not
+ *                      previously registered.
+ *      -EFAULT:    NULL hnotification, hnotification event name
+ *                      too long, or hnotification event name NULL.
+ *  Requires:
+ *      Valid chnl_obj.
+ *      hnotification != NULL.
+ *      (event_mask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
+ *      notify_type == DSP_SIGNALEVENT.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_chnl_registernotify)
+ (struct chnl_object *chnl_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
+
+/*
+ *  ======== bridge_dev_create ========
+ *  Purpose:
+ *      Complete creation of the device object for this board.
+ *  Parameters:
+ *      phDevContext:   Ptr to location to store a WMD device context.
+ *      hdev_obj:     Handle to a Device Object, created and managed by WCD.
+ *      pConfig:        Ptr to configuration parameters provided by the Windows
+ *                      Configuration Manager during device loading.
+ *      pDspConfig:     DSP resources, as specified in the registry key for this
+ *                      device.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      -ENOMEM:        Unable to allocate memory for device context.
+ *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
+ *                          parameters did not satisfy hardware assumptions
+ *                          made by this WMD.
+ *  Requires:
+ *      phDevContext != NULL;
+ *      hdev_obj != NULL;
+ *      pConfig != NULL;
+ *      pDspConfig != NULL;
+ *      Fields in pConfig and pDspConfig contain valid values.
+ *  Ensures:
+ *      DSP_SOK:        All mini-driver specific DSP resource and other
+ *                      board context has been allocated.
+ *      -ENOMEM:    WMD failed to allocate resources.
+ *                      Any acquired resources have been freed.  The WCD will
+ *                      not call bridge_dev_destroy() if bridge_dev_create()
+ *                      fails.
+ *  Details:
+ *      Called during the CONFIGMG's Device_Init phase. Based on host and
+ *      DSP configuration information, create a board context, a handle to
+ *      which is passed into other WMD BRD and CHNL functions.  The
+ *      board context contains state information for the device. Since the
+ *      addresses of all IN pointer parameters may be invalid when this
+ *      function returns, they must not be stored into the device context
+ *      structure.
+ */
+typedef dsp_status(*fxn_dev_create) (OUT struct bridge_dev_context
+				     **phDevContext,
+				     struct dev_object
+				     * hdev_obj,
+				     IN struct cfg_hostres
+				     * pConfig);
+
+/*
+ *  ======== bridge_dev_ctrl ========
+ *  Purpose:
+ *      Mini-driver specific interface.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dw_cmd:          WMD defined command code.
+ *      pargs:          Pointer to an arbitrary argument structure.
+ *  Returns:
+ *      DSP_SOK or -EPERM. Actual command error codes should be passed back
+ *      in the pargs structure, and are defined by the WMD implementor.
+ *  Requires:
+ *      All calls are currently assumed to be synchronous.  There are no
+ *      IOCTL completion routines provided.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_dev_ctrl) (struct bridge_dev_context *hDevContext,
+				   u32 dw_cmd, IN OUT void *pargs);
+
+/*
+ *  ======== bridge_dev_destroy ========
+ *  Purpose:
+ *      Deallocate WMD device extension structures and all other resources
+ *      acquired by the mini-driver.
+ *      No calls to other mini driver functions may subsequently
+ *      occur, except for bridge_dev_create().
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device information.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Failed to release a resource previously acquired.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ *      DSP_SOK: Device context is freed.
+ */
+typedef dsp_status(*fxn_dev_destroy) (struct bridge_dev_context *hDevContext);
+
+/*
+ *  ======== bridge_deh_create ========
+ *  Purpose:
+ *      Create an object that manages DSP exceptions from the GPP.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      hdev_obj:     Handle to DEV object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ENOMEM:    Memory allocation failure.
+ *      -EPERM:      Creation failed.
+ *  Requires:
+ *      hdev_obj != NULL;
+ *      phDehMgr != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_deh_create) (OUT struct deh_mgr
+				     **phDehMgr, struct dev_object *hdev_obj);
+
+/*
+ *  ======== bridge_deh_destroy ========
+ *  Purpose:
+ *      Destroy the DEH object.
+ *  Parameters:
+ *      hdeh_mgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Destroy failed.
+ *  Requires:
+ *      hdeh_mgr != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_deh_destroy) (struct deh_mgr *hdeh_mgr);
+
+/*
+ *  ======== bridge_deh_register_notify ========
+ *  Purpose:
+ *      Register for DEH event notification.
+ *  Parameters:
+ *      hdeh_mgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Destroy failed.
+ *  Requires:
+ *      hdeh_mgr != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_deh_registernotify)
+ (struct deh_mgr *hdeh_mgr,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
+
+/*
+ *  ======== bridge_deh_get_info ========
+ *  Purpose:
+ *      Get DSP exception info.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      pErrInfo:       Ptr to error info structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -EPERM:      Creation failed.
+ *  Requires:
+ *      phDehMgr != NULL;
+ *      pErrorInfo != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
+				      struct dsp_errorinfo *pErrInfo);
+
+/*
+ *  ======== bridge_io_create ========
+ *  Purpose:
+ *      Create an object that manages I/O between CHNL and msg_ctrl.
+ *  Parameters:
+ *      phIOMgr:        Location to store IO manager on output.
+ *      hchnl_mgr:       Handle to channel manager.
+ *      hmsg_mgr:        Handle to message manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ENOMEM:    Memory allocation failure.
+ *      -EPERM:      Creation failed.
+ *  Requires:
+ *      hdev_obj != NULL;
+ *      Channel manager already created;
+ *      Message manager already created;
+ *      pMgrAttrs != NULL;
+ *      phIOMgr != NULL;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
+				    struct dev_object *hdev_obj,
+				    IN CONST struct io_attrs *pMgrAttrs);
+
+/*
+ *  ======== bridge_io_destroy ========
+ *  Purpose:
+ *      Destroy object created in bridge_io_create.
+ *  Parameters:
+ *      hio_mgr:         IO Manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ENOMEM:    Memory allocation failure.
+ *      -EPERM:      Creation failed.
+ *  Requires:
+ *      Valid hio_mgr;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_io_destroy) (struct io_mgr *hio_mgr);
+
+/*
+ *  ======== bridge_io_on_loaded ========
+ *  Purpose:
+ *      Called whenever a program is loaded to update internal data. For
+ *      example, if shared memory is used, this function would update the
+ *      shared memory location and address.
+ *  Parameters:
+ *      hio_mgr:     IO Manager.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      -EPERM:  Internal failure occurred.
+ *  Requires:
+ *      Valid hio_mgr;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_io_onloaded) (struct io_mgr *hio_mgr);
+
+/*
+ *  ======== fxn_io_getprocload ========
+ *  Purpose:
+ *      Called to get the Processor's current and predicted load
+ *  Parameters:
+ *      hio_mgr:     IO Manager.
+ *      pProcLoadStat   Processor Load statistics
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      -EPERM:  Internal failure occurred.
+ *  Requires:
+ *      Valid hio_mgr;
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
+					 struct dsp_procloadstat *
+					 pProcLoadStat);
+
+/*
+ *  ======== bridge_msg_create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object.
+ *  Parameters:
+ *      phMsgMgr:           Location to store msg_ctrl manager on output.
+ *      hdev_obj:         Handle to a device object.
+ *      msgCallback:        Called whenever an RMS_EXIT message is received.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      -ENOMEM:        Insufficient memory.
+ *  Requires:
+ *      phMsgMgr != NULL.
+ *      msgCallback != NULL.
+ *      hdev_obj != NULL.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_msg_create)
+ (OUT struct msg_mgr **phMsgMgr,
+  struct dev_object *hdev_obj, msg_onexit msgCallback);
+
+/*
+ *  ======== bridge_msg_create_queue ========
+ *  Purpose:
+ *      Create a msg_ctrl queue for sending or receiving messages from a Message
+ *      node on the DSP.
+ *  Parameters:
+ *      hmsg_mgr:            msg_ctrl queue manager handle returned from
+ *                          bridge_msg_create.
+ *      phMsgQueue:         Location to store msg_ctrl queue on output.
+ *      msgq_id:	    Identifier for messages (node environment pointer).
+ *      max_msgs:           Max number of simultaneous messages for the node.
+ *      h:                  Handle passed to hmsg_mgr->msgCallback().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      -ENOMEM:        Insufficient memory.
+ *  Requires:
+ *      phMsgQueue != NULL.
+ *      h != NULL.
+ *      max_msgs > 0.
+ *  Ensures:
+ *      phMsgQueue !=NULL <==> DSP_SOK.
+ */
+typedef dsp_status(*fxn_msg_createqueue)
+ (struct msg_mgr *hmsg_mgr,
+  OUT struct msg_queue **phMsgQueue, u32 msgq_id, u32 max_msgs, void *h);
+
+/*
+ *  ======== bridge_msg_delete ========
+ *  Purpose:
+ *      Delete a msg_ctrl manager allocated in bridge_msg_create().
+ *  Parameters:
+ *      hmsg_mgr:    Handle returned from bridge_msg_create().
+ *  Returns:
+ *  Requires:
+ *      Valid hmsg_mgr.
+ *  Ensures:
+ */
+typedef void (*fxn_msg_delete) (struct msg_mgr *hmsg_mgr);
+
+/*
+ *  ======== bridge_msg_delete_queue ========
+ *  Purpose:
+ *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
+ *  Parameters:
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
+ *  Returns:
+ *  Requires:
+ *      Valid msg_queue_obj.
+ *  Ensures:
+ */
+typedef void (*fxn_msg_deletequeue) (struct msg_queue *msg_queue_obj);
+
+/*
+ *  ======== bridge_msg_get ========
+ *  Purpose:
+ *      Get a message from a msg_ctrl queue.
+ *  Parameters:
+ *      msg_queue_obj:     Handle to msg_ctrl queue returned from
+ *                     bridge_msg_create_queue.
+ *      pmsg:          Location to copy message into.
+ *      utimeout:      Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *      -ETIME:  Timeout occurred.
+ *      -EPERM:     No frames available for message (max_msgs too
+ *                     small).
+ *  Requires:
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_msg_get) (struct msg_queue *msg_queue_obj,
+				  struct dsp_msg *pmsg, u32 utimeout);
+
+/*
+ *  ======== bridge_msg_put ========
+ *  Purpose:
+ *      Put a message onto a msg_ctrl queue.
+ *  Parameters:
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      pmsg:           Pointer to message.
+ *      utimeout:       Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ETIME:   Timeout occurred.
+ *      -EPERM:      No frames available for message (max_msgs too
+ *                      small).
+ *  Requires:
+ *      Valid msg_queue_obj.
+ *      pmsg != NULL.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_msg_put) (struct msg_queue *msg_queue_obj,
+				  IN CONST struct dsp_msg *pmsg, u32 utimeout);
+
+/*
+ *  ======== bridge_msg_register_notify ========
+ *  Purpose:
+ *      Register notification for when a message is ready.
+ *  Parameters:
+ *      msg_queue_obj:      Handle to msg_ctrl queue returned from
+ *                      bridge_msg_create_queue.
+ *      event_mask:     Type of events to be notified about: Must be
+ *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
+ *      notify_type:    DSP_SIGNALEVENT.
+ *      hnotification:  Handle of notification object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      -ENOMEM:    Insufficient memory.
+ *  Requires:
+ *      Valid msg_queue_obj.
+ *      hnotification != NULL.
+ *      notify_type == DSP_SIGNALEVENT.
+ *      event_mask == DSP_NODEMESSAGEREADY || event_mask == 0.
+ *  Ensures:
+ */
+typedef dsp_status(*fxn_msg_registernotify)
+ (struct msg_queue *msg_queue_obj,
+  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
+
+/*
+ *  ======== bridge_msg_set_queue_id ========
+ *  Purpose:
+ *      Set message queue id to node environment. Allows bridge_msg_create_queue
+ *      to be called in node_allocate, before the node environment is known.
+ *  Parameters:
+ *      msg_queue_obj:  Handle to msg_ctrl queue returned from
+ *                  bridge_msg_create_queue.
+ *      msgq_id:       Node environment pointer.
+ *  Returns:
+ *  Requires:
+ *      Valid msg_queue_obj.
+ *      msgq_id != 0.
+ *  Ensures:
+ */
+typedef void (*fxn_msg_setqueueid) (struct msg_queue *msg_queue_obj,
+				    u32 msgq_id);
+
+/*
+ *  'Bridge Mini Driver (WMD) interface function table.
+ *
+ *  The information in this table is filled in by the specific mini-driver,
+ *  and copied into the 'Bridge class driver's own space.  If any interface
+ *  function field is set to a value of NULL, then the class driver will
+ *  consider that function not implemented, and return the error code
+ *  -ENOSYS when a WMD client attempts to call that function.
+ *
+ *  This function table contains WCD version numbers, which are used by the
+ *  WMD loader to help ensure backwards compatility between older WMD's and a
+ *  newer 'Bridge Class Driver.  These must be set to WCD_MAJOR_VERSION
+ *  and WCD_MINOR_VERSION, respectively.
+ *
+ *  A mini-driver need not export a CHNL interface.  In this case, *all* of
+ *  the WMD_CHNL_* entries must be set to NULL.
+ */
+struct bridge_drv_interface {
+	u32 brd_api_major_version;	/* Set to BRD_API_MAJOR_VERSION. */
+	u32 brd_api_minor_version;	/* Set to BRD_API_MINOR_VERSION. */
+	fxn_dev_create pfn_dev_create;	/* Create device context */
+	fxn_dev_destroy pfn_dev_destroy;	/* Destroy device context */
+	fxn_dev_ctrl pfn_dev_cntrl;	/* Optional vendor interface */
+	fxn_brd_monitor pfn_brd_monitor;	/* Load and/or start monitor */
+	fxn_brd_start pfn_brd_start;	/* Start DSP program. */
+	fxn_brd_stop pfn_brd_stop;	/* Stop/reset board. */
+	fxn_brd_status pfn_brd_status;	/* Get current board status. */
+	fxn_brd_read pfn_brd_read;	/* Read board memory */
+	fxn_brd_write pfn_brd_write;	/* Write board memory. */
+	fxn_brd_setstate pfn_brd_set_state;	/* Sets the Board State */
+	fxn_brd_memcopy pfn_brd_mem_copy;	/* Copies DSP Memory */
+	fxn_brd_memwrite pfn_brd_mem_write;	/* Write DSP Memory w/o halt */
+	fxn_brd_memmap pfn_brd_mem_map;	/* Maps MPU mem to DSP mem */
+	fxn_brd_memunmap pfn_brd_mem_un_map;	/* Unmaps MPU mem to DSP mem */
+	fxn_chnl_create pfn_chnl_create;	/* Create channel manager. */
+	fxn_chnl_destroy pfn_chnl_destroy;	/* Destroy channel manager. */
+	fxn_chnl_open pfn_chnl_open;	/* Create a new channel. */
+	fxn_chnl_close pfn_chnl_close;	/* Close a channel. */
+	fxn_chnl_addioreq pfn_chnl_add_io_req;	/* Req I/O on a channel. */
+	fxn_chnl_getioc pfn_chnl_get_ioc;	/* Wait for I/O completion. */
+	fxn_chnl_cancelio pfn_chnl_cancel_io;	/* Cancl I/O on a channel. */
+	fxn_chnl_flushio pfn_chnl_flush_io;	/* Flush I/O. */
+	fxn_chnl_getinfo pfn_chnl_get_info;	/* Get channel specific info */
+	/* Get channel manager info. */
+	fxn_chnl_getmgrinfo pfn_chnl_get_mgr_info;
+	fxn_chnl_idle pfn_chnl_idle;	/* Idle the channel */
+	/* Register for notif. */
+	fxn_chnl_registernotify pfn_chnl_register_notify;
+	fxn_deh_create pfn_deh_create;	/* Create DEH manager */
+	fxn_deh_destroy pfn_deh_destroy;	/* Destroy DEH manager */
+	fxn_deh_notify pfn_deh_notify;	/* Notify of DSP error */
+	/* register for deh notif. */
+	fxn_deh_registernotify pfn_deh_register_notify;
+	fxn_deh_getinfo pfn_deh_get_info;	/* register for deh notif. */
+	fxn_io_create pfn_io_create;	/* Create IO manager */
+	fxn_io_destroy pfn_io_destroy;	/* Destroy IO manager */
+	fxn_io_onloaded pfn_io_on_loaded;	/* Notify of program loaded */
+	/* Get Processor's current and predicted load */
+	fxn_io_getprocload pfn_io_get_proc_load;
+	fxn_msg_create pfn_msg_create;	/* Create message manager */
+	/* Create message queue */
+	fxn_msg_createqueue pfn_msg_create_queue;
+	fxn_msg_delete pfn_msg_delete;	/* Delete message manager */
+	/* Delete message queue */
+	fxn_msg_deletequeue pfn_msg_delete_queue;
+	fxn_msg_get pfn_msg_get;	/* Get a message */
+	fxn_msg_put pfn_msg_put;	/* Send a message */
+	/* Register for notif. */
+	fxn_msg_registernotify pfn_msg_register_notify;
+	/* Set message queue id */
+	fxn_msg_setqueueid pfn_msg_set_queue_id;
+};
+
+/*
+ *  ======== bridge_drv_entry ========
+ *  Purpose:
+ *      Registers WMD functions with the class driver. Called only once
+ *      by the WCD.  The caller will first check WCD version compatibility, and
+ *      then copy the interface functions into its own memory space.
+ *  Parameters:
+ *      ppDrvInterface  Pointer to a location to receive a pointer to the
+ *                      mini driver interface.
+ *  Returns:
+ *  Requires:
+ *      The code segment this function resides in must expect to be discarded
+ *      after completion.
+ *  Ensures:
+ *      ppDrvInterface pointer initialized to WMD's function interface.
+ *      No system resources are acquired by this function.
+ *  Details:
+ *      Win95: Called during the Device_Init phase.
+ */
+void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
+		   IN CONST char *driver_file_name);
+
+#endif /* WMD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspdeh.h b/arch/arm/plat-omap/include/dspbridge/dspdeh.h
new file mode 100644
index 0000000..512ef64
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspdeh.h
@@ -0,0 +1,47 @@
+/*
+ * dspdeh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Defines upper edge DEH functions required by all WMD/WCD driver
+ * interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside with the function typedefs in dspdefs.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDDEH_
+#define WMDDEH_
+
+#include <dspbridge/devdefs.h>
+
+#include <dspbridge/dehdefs.h>
+
+extern dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
+		struct dev_object *hdev_obj);
+
+extern dsp_status bridge_deh_destroy(struct deh_mgr *deh_mgr);
+
+extern dsp_status bridge_deh_get_info(struct deh_mgr *deh_mgr,
+		struct dsp_errorinfo *pErrInfo);
+
+extern dsp_status bridge_deh_register_notify(struct deh_mgr *deh_mgr,
+		u32 event_mask,
+		u32 notify_type,
+		struct dsp_notification *hnotification);
+
+extern void bridge_deh_notify(struct deh_mgr *deh_mgr,
+		u32 ulEventMask, u32 dwErrInfo);
+
+extern void bridge_deh_release_dummy_mem(void);
+#endif /* WMDDEH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspio.h b/arch/arm/plat-omap/include/dspbridge/dspio.h
new file mode 100644
index 0000000..b010d2a
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspio.h
@@ -0,0 +1,41 @@
+/*
+ * dspio.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge IO functions required by all WMD / WCD
+ * driver interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside in dspdefs.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDIO_
+#define WMDIO_
+
+#include <dspbridge/devdefs.h>
+#include <dspbridge/iodefs.h>
+
+extern dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
+				   struct dev_object *hdev_obj,
+				   IN CONST struct io_attrs *pMgrAttrs);
+
+extern dsp_status bridge_io_destroy(struct io_mgr *hio_mgr);
+
+extern dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr);
+
+extern dsp_status iva_io_on_loaded(struct io_mgr *hio_mgr);
+extern dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
+				       OUT struct dsp_procloadstat *pProcStat);
+
+#endif /* WMDIO_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspioctl.h b/arch/arm/plat-omap/include/dspbridge/dspioctl.h
new file mode 100644
index 0000000..3f7a787
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspioctl.h
@@ -0,0 +1,73 @@
+/*
+ * dspioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * BRIDGE Minidriver BRD_IOCtl reserved command definitions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDIOCTL_
+#define WMDIOCTL_
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/*
+ * Any IOCTLS at or above this value are reserved for standard WMD
+ * interfaces.
+ */
+#define BRDIOCTL_RESERVEDBASE       0x8000
+
+#define BRDIOCTL_CHNLREAD           (BRDIOCTL_RESERVEDBASE + 0x10)
+#define BRDIOCTL_CHNLWRITE          (BRDIOCTL_RESERVEDBASE + 0x20)
+#define BRDIOCTL_GETINTRCOUNT       (BRDIOCTL_RESERVEDBASE + 0x30)
+#define BRDIOCTL_RESETINTRCOUNT     (BRDIOCTL_RESERVEDBASE + 0x40)
+#define BRDIOCTL_INTERRUPTDSP       (BRDIOCTL_RESERVEDBASE + 0x50)
+/* DMMU */
+#define BRDIOCTL_SETMMUCONFIG       (BRDIOCTL_RESERVEDBASE + 0x60)
+/* PWR */
+#define BRDIOCTL_PWRCONTROL         (BRDIOCTL_RESERVEDBASE + 0x70)
+
+/* attention, modifiers:
+ * Some of these control enumerations are made visible to user for power
+ * control, so any changes to this list, should also be updated in the user
+ * header file 'dbdefs.h' ***/
+/* These ioctls are reserved for PWR power commands for the DSP */
+#define BRDIOCTL_DEEPSLEEP          (BRDIOCTL_PWRCONTROL + 0x0)
+#define BRDIOCTL_EMERGENCYSLEEP     (BRDIOCTL_PWRCONTROL + 0x1)
+#define BRDIOCTL_WAKEUP             (BRDIOCTL_PWRCONTROL + 0x2)
+#define BRDIOCTL_PWRENABLE          (BRDIOCTL_PWRCONTROL + 0x3)
+#define BRDIOCTL_PWRDISABLE         (BRDIOCTL_PWRCONTROL + 0x4)
+#define BRDIOCTL_CLK_CTRL		    (BRDIOCTL_PWRCONTROL + 0x7)
+/* DSP Initiated Hibernate */
+#define BRDIOCTL_PWR_HIBERNATE	(BRDIOCTL_PWRCONTROL + 0x8)
+#define BRDIOCTL_PRESCALE_NOTIFY (BRDIOCTL_PWRCONTROL + 0x9)
+#define BRDIOCTL_POSTSCALE_NOTIFY (BRDIOCTL_PWRCONTROL + 0xA)
+#define BRDIOCTL_CONSTRAINT_REQUEST (BRDIOCTL_PWRCONTROL + 0xB)
+
+/* Number of actual DSP-MMU TLB entrries */
+#define BRDIOCTL_NUMOFMMUTLB        32
+
+struct bridge_ioctl_extproc {
+	u32 ul_dsp_va;		/* DSP virtual address */
+	u32 ul_gpp_pa;		/* GPP physical address */
+	/* GPP virtual address. __va does not work for ioremapped addresses */
+	u32 ul_gpp_va;
+	u32 ul_size;		/* Size of the mapped memory in bytes */
+	enum hw_endianism_t endianism;
+	enum hw_mmu_mixed_size_t mixed_mode;
+	enum hw_element_size_t elem_size;
+};
+
+#endif /* WMDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspmsg.h b/arch/arm/plat-omap/include/dspbridge/dspmsg.h
new file mode 100644
index 0000000..c1fabc2
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspmsg.h
@@ -0,0 +1,56 @@
+/*
+ * dspmsg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge message class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are
+ * implemented by every class of WMD channel library.
+ *
+ * Notes:
+ *   Function comment headers reside in dspdefs.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDMSG_
+#define WMDMSG_
+
+#include <dspbridge/msgdefs.h>
+
+extern dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+				    struct dev_object *hdev_obj,
+				    msg_onexit msgCallback);
+
+extern dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
+				       OUT struct msg_queue **phMsgQueue,
+				       u32 msgq_id, u32 max_msgs, void *h);
+
+extern void bridge_msg_delete(struct msg_mgr *hmsg_mgr);
+
+extern void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj);
+
+extern dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
+				 struct dsp_msg *pmsg, u32 utimeout);
+
+extern dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
+				 IN CONST struct dsp_msg *pmsg, u32 utimeout);
+
+extern dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
+					  u32 event_mask,
+					  u32 notify_type,
+					  struct dsp_notification
+					  *hnotification);
+
+extern void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj,
+					u32 msgq_id);
+
+#endif /* WMDMSG_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcd.h b/arch/arm/plat-omap/include/dspbridge/wcd.h
deleted file mode 100644
index 1a68baa..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wcd.h
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * wcd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Bridge class driver library functions, object definitions, and
- * return error/status codes.  To be included by Bridge mini drivers.
- *
- * Notes:
- *   Bridge Class Driver services exported to WMD's are initialized by the
- *   WCD on behalf of the WMD.  WMD's must not call module Init/Exit
- *   functions.
- *
- *   To ensure WMD binary compatibility across different platforms,
- *   for the same processor, a WMD must restrict its usage of system
- *   services to those exported by the 'Bridge class library.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WCD_
-#define WCD_
-
-/* This BRD API Library Version: */
-#define BRD_API_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
-#define BRD_API_MINOR_VERSION   (u32)0
-
-#endif /* WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcdioctl.h b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
deleted file mode 100644
index 7ebb9f0..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
+++ /dev/null
@@ -1,466 +0,0 @@
-/*
- * wcdioctl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Contains structures and commands that are used for interaction
- * between the DDSP API and class driver.
- *
- * Copyright (C) 2008 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WCDIOCTL_
-#define WCDIOCTL_
-
-#include <dspbridge/cmm.h>
-#include <dspbridge/strmdefs.h>
-#include <dspbridge/dbdcd.h>
-
-union Trapped_Args {
-
-	/* MGR Module */
-	struct {
-		u32 node_id;
-		struct dsp_ndbprops __user *pndb_props;
-		u32 undb_props_size;
-		u32 __user *pu_num_nodes;
-	} args_mgr_enumnode_info;
-
-	struct {
-		u32 processor_id;
-		struct dsp_processorinfo __user *processor_info;
-		u32 processor_info_size;
-		u32 __user *pu_num_procs;
-	} args_mgr_enumproc_info;
-
-	struct {
-		struct dsp_uuid *uuid_obj;
-		enum dsp_dcdobjtype obj_type;
-		char *psz_path_name;
-	} args_mgr_registerobject;
-
-	struct {
-		struct dsp_uuid *uuid_obj;
-		enum dsp_dcdobjtype obj_type;
-	} args_mgr_unregisterobject;
-
-	struct {
-		struct dsp_notification __user *__user *anotifications;
-		u32 count;
-		u32 __user *pu_index;
-		u32 utimeout;
-	} args_mgr_wait;
-
-	/* PROC Module */
-	struct {
-		u32 processor_id;
-		struct dsp_processorattrin __user *attr_in;
-		void *__user *ph_processor;
-	} args_proc_attach;
-
-	struct {
-		void *hprocessor;
-		u32 dw_cmd;
-		struct dsp_cbdata __user *pargs;
-	} args_proc_ctrl;
-
-	struct {
-		void *hprocessor;
-	} args_proc_detach;
-
-	struct {
-		void *hprocessor;
-		void *__user *node_tab;
-		u32 node_tab_size;
-		u32 __user *pu_num_nodes;
-		u32 __user *pu_allocated;
-	} args_proc_enumnode_info;
-
-	struct {
-		void *hprocessor;
-		u32 resource_type;
-		struct dsp_resourceinfo *resource_info;
-		u32 resource_info_size;
-	} args_proc_enumresources;
-
-	struct {
-		void *hprocessor;
-		struct dsp_processorstate __user *proc_state_obj;
-		u32 state_info_size;
-	} args_proc_getstate;
-
-	struct {
-		void *hprocessor;
-		u8 __user *pbuf;
-		u8 __user *psize;
-		u32 max_size;
-	} args_proc_gettrace;
-
-	struct {
-		void *hprocessor;
-		s32 argc_index;
-		char __user *__user *user_args;
-		char *__user *user_envp;
-	} args_proc_load;
-
-	struct {
-		void *hprocessor;
-		u32 event_mask;
-		u32 notify_type;
-		struct dsp_notification __user *hnotification;
-	} args_proc_register_notify;
-
-	struct {
-		void *hprocessor;
-	} args_proc_start;
-
-	struct {
-		void *hprocessor;
-		u32 ul_size;
-		void *__user *pp_rsv_addr;
-	} args_proc_rsvmem;
-
-	struct {
-		void *hprocessor;
-		u32 ul_size;
-		void *prsv_addr;
-	} args_proc_unrsvmem;
-
-	struct {
-		void *hprocessor;
-		void *pmpu_addr;
-		u32 ul_size;
-		void *req_addr;
-		void *__user *pp_map_addr;
-		u32 ul_map_attr;
-	} args_proc_mapmem;
-
-	struct {
-		void *hprocessor;
-		u32 ul_size;
-		void *map_addr;
-	} args_proc_unmapmem;
-
-	struct {
-		void *hprocessor;
-		void *pmpu_addr;
-		u32 ul_size;
-		u32 ul_flags;
-	} args_proc_flushmemory;
-
-	struct {
-		void *hprocessor;
-	} args_proc_stop;
-
-	struct {
-		void *hprocessor;
-		void *pmpu_addr;
-		u32 ul_size;
-	} args_proc_invalidatememory;
-
-	/* NODE Module */
-	struct {
-		void *hprocessor;
-		struct dsp_uuid __user *node_id_ptr;
-		struct dsp_cbdata __user *pargs;
-		struct dsp_nodeattrin __user *attr_in;
-		void *__user *ph_node;
-	} args_node_allocate;
-
-	struct {
-		void *hnode;
-		u32 usize;
-		struct dsp_bufferattr __user *pattr;
-		u8 *__user *pbuffer;
-	} args_node_allocmsgbuf;
-
-	struct {
-		void *hnode;
-		s32 prio;
-	} args_node_changepriority;
-
-	struct {
-		void *hnode;
-		u32 stream_id;
-		void *other_node;
-		u32 other_stream;
-		struct dsp_strmattr __user *pattrs;
-		struct dsp_cbdata __user *conn_param;
-	} args_node_connect;
-
-	struct {
-		void *hnode;
-	} args_node_create;
-
-	struct {
-		void *hnode;
-	} args_node_delete;
-
-	struct {
-		void *hnode;
-		struct dsp_bufferattr __user *pattr;
-		u8 *pbuffer;
-	} args_node_freemsgbuf;
-
-	struct {
-		void *hnode;
-		struct dsp_nodeattr __user *pattr;
-		u32 attr_size;
-	} args_node_getattr;
-
-	struct {
-		void *hnode;
-		struct dsp_msg __user *message;
-		u32 utimeout;
-	} args_node_getmessage;
-
-	struct {
-		void *hnode;
-	} args_node_pause;
-
-	struct {
-		void *hnode;
-		struct dsp_msg __user *message;
-		u32 utimeout;
-	} args_node_putmessage;
-
-	struct {
-		void *hnode;
-		u32 event_mask;
-		u32 notify_type;
-		struct dsp_notification __user *hnotification;
-	} args_node_registernotify;
-
-	struct {
-		void *hnode;
-	} args_node_run;
-
-	struct {
-		void *hnode;
-		dsp_status __user *pstatus;
-	} args_node_terminate;
-
-	struct {
-		void *hprocessor;
-		struct dsp_uuid __user *node_id_ptr;
-		struct dsp_ndbprops __user *node_props;
-	} args_node_getuuidprops;
-
-	/* STRM module */
-
-	struct {
-		void *hstream;
-		u32 usize;
-		u8 *__user *ap_buffer;
-		u32 num_bufs;
-	} args_strm_allocatebuffer;
-
-	struct {
-		void *hstream;
-	} args_strm_close;
-
-	struct {
-		void *hstream;
-		u8 *__user *ap_buffer;
-		u32 num_bufs;
-	} args_strm_freebuffer;
-
-	struct {
-		void *hstream;
-		void **ph_event;
-	} args_strm_geteventhandle;
-
-	struct {
-		void *hstream;
-		struct stream_info __user *stream_info;
-		u32 stream_info_size;
-	} args_strm_getinfo;
-
-	struct {
-		void *hstream;
-		bool flush_flag;
-	} args_strm_idle;
-
-	struct {
-		void *hstream;
-		u8 *pbuffer;
-		u32 dw_bytes;
-		u32 dw_buf_size;
-		u32 dw_arg;
-	} args_strm_issue;
-
-	struct {
-		void *hnode;
-		u32 direction;
-		u32 index;
-		struct strm_attr __user *attr_in;
-		void *__user *ph_stream;
-	} args_strm_open;
-
-	struct {
-		void *hstream;
-		u8 *__user *buf_ptr;
-		u32 __user *bytes;
-		u32 __user *buf_size_ptr;
-		u32 __user *pdw_arg;
-	} args_strm_reclaim;
-
-	struct {
-		void *hstream;
-		u32 event_mask;
-		u32 notify_type;
-		struct dsp_notification __user *hnotification;
-	} args_strm_registernotify;
-
-	struct {
-		void *__user *stream_tab;
-		u32 strm_num;
-		u32 __user *pmask;
-		u32 utimeout;
-	} args_strm_select;
-
-	/* CMM Module */
-	struct {
-		struct cmm_object *hcmm_mgr;
-		u32 usize;
-		struct cmm_attrs *pattrs;
-		OUT void **pp_buf_va;
-	} args_cmm_allocbuf;
-
-	struct {
-		struct cmm_object *hcmm_mgr;
-		void *buf_pa;
-		u32 ul_seg_id;
-	} args_cmm_freebuf;
-
-	struct {
-		void *hprocessor;
-		struct cmm_object *__user *ph_cmm_mgr;
-	} args_cmm_gethandle;
-
-	struct {
-		struct cmm_object *hcmm_mgr;
-		struct cmm_info __user *cmm_info_obj;
-	} args_cmm_getinfo;
-
-	/* UTIL module */
-	struct {
-		s32 util_argc;
-		char **pp_argv;
-	} args_util_testdll;
-};
-
-/*
- * Dspbridge Ioctl numbering scheme
- *
- *    7                           0
- *  ---------------------------------
- *  |  Module   |   Ioctl Number    |
- *  ---------------------------------
- *  | x | x | x | 0 | 0 | 0 | 0 | 0 |
- *  ---------------------------------
- */
-
-/* Ioctl driver identifier */
-#define DB		0xDB
-
-/*
- * Following are used to distinguish between module ioctls, this is needed
- * in case new ioctls are introduced.
- */
-#define DB_MODULE_MASK		0xE0
-#define DB_IOC_MASK		0x1F
-
-/* Ioctl module masks */
-#define DB_MGR		0x0
-#define DB_PROC		0x20
-#define DB_NODE		0x40
-#define DB_STRM		0x60
-#define DB_CMM		0x80
-
-#define DB_MODULE_SHIFT		5
-
-/* Used to calculate the ioctl per dspbridge module */
-#define DB_IOC(module, num) \
-			(((module) & DB_MODULE_MASK) | ((num) & DB_IOC_MASK))
-/* Used to get dspbridge ioctl module */
-#define DB_GET_MODULE(cmd)	((cmd) & DB_MODULE_MASK)
-/* Used to get dspbridge ioctl number */
-#define DB_GET_IOC(cmd)		((cmd) & DB_IOC_MASK)
-
-/* TODO: Remove deprecated and not implemented */
-
-/* MGR Module */
-#define MGR_ENUMNODE_INFO	_IOWR(DB, DB_IOC(DB_MGR, 0), unsigned long)
-#define MGR_ENUMPROC_INFO	_IOWR(DB, DB_IOC(DB_MGR, 1), unsigned long)
-#define MGR_REGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 2), unsigned long)
-#define MGR_UNREGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 3), unsigned long)
-#define MGR_WAIT		_IOWR(DB, DB_IOC(DB_MGR, 4), unsigned long)
-/* MGR_GET_PROC_RES Deprecated */
-#define MGR_GET_PROC_RES	_IOR(DB, DB_IOC(DB_MGR, 5), unsigned long)
-
-/* PROC Module */
-#define PROC_ATTACH		_IOWR(DB, DB_IOC(DB_PROC, 0), unsigned long)
-#define PROC_CTRL		_IOR(DB, DB_IOC(DB_PROC, 1), unsigned long)
-/* PROC_DETACH Deprecated */
-#define PROC_DETACH		_IOR(DB, DB_IOC(DB_PROC, 2), unsigned long)
-#define PROC_ENUMNODE		_IOWR(DB, DB_IOC(DB_PROC, 3), unsigned long)
-#define PROC_ENUMRESOURCES	_IOWR(DB, DB_IOC(DB_PROC, 4), unsigned long)
-#define PROC_GET_STATE		_IOWR(DB, DB_IOC(DB_PROC, 5), unsigned long)
-#define PROC_GET_TRACE		_IOWR(DB, DB_IOC(DB_PROC, 6), unsigned long)
-#define PROC_LOAD		_IOW(DB, DB_IOC(DB_PROC, 7), unsigned long)
-#define PROC_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_PROC, 8), unsigned long)
-#define PROC_START		_IOW(DB, DB_IOC(DB_PROC, 9), unsigned long)
-#define PROC_RSVMEM		_IOWR(DB, DB_IOC(DB_PROC, 10), unsigned long)
-#define PROC_UNRSVMEM		_IOW(DB, DB_IOC(DB_PROC, 11), unsigned long)
-#define PROC_MAPMEM		_IOWR(DB, DB_IOC(DB_PROC, 12), unsigned long)
-#define PROC_UNMAPMEM		_IOR(DB, DB_IOC(DB_PROC, 13), unsigned long)
-#define PROC_FLUSHMEMORY	_IOW(DB, DB_IOC(DB_PROC, 14), unsigned long)
-#define PROC_STOP		_IOWR(DB, DB_IOC(DB_PROC, 15), unsigned long)
-#define PROC_INVALIDATEMEMORY	_IOW(DB, DB_IOC(DB_PROC, 16), unsigned long)
-
-/* NODE Module */
-#define NODE_ALLOCATE		_IOWR(DB, DB_IOC(DB_NODE, 0), unsigned long)
-#define NODE_ALLOCMSGBUF	_IOWR(DB, DB_IOC(DB_NODE, 1), unsigned long)
-#define NODE_CHANGEPRIORITY	_IOW(DB, DB_IOC(DB_NODE, 2), unsigned long)
-#define NODE_CONNECT		_IOW(DB, DB_IOC(DB_NODE, 3), unsigned long)
-#define NODE_CREATE		_IOW(DB, DB_IOC(DB_NODE, 4), unsigned long)
-#define NODE_DELETE		_IOW(DB, DB_IOC(DB_NODE, 5), unsigned long)
-#define NODE_FREEMSGBUF		_IOW(DB, DB_IOC(DB_NODE, 6), unsigned long)
-#define NODE_GETATTR		_IOWR(DB, DB_IOC(DB_NODE, 7), unsigned long)
-#define NODE_GETMESSAGE		_IOWR(DB, DB_IOC(DB_NODE, 8), unsigned long)
-#define NODE_PAUSE		_IOW(DB, DB_IOC(DB_NODE, 9), unsigned long)
-#define NODE_PUTMESSAGE		_IOW(DB, DB_IOC(DB_NODE, 10), unsigned long)
-#define NODE_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_NODE, 11), unsigned long)
-#define NODE_RUN		_IOW(DB, DB_IOC(DB_NODE, 12), unsigned long)
-#define NODE_TERMINATE		_IOWR(DB, DB_IOC(DB_NODE, 13), unsigned long)
-#define NODE_GETUUIDPROPS	_IOWR(DB, DB_IOC(DB_NODE, 14), unsigned long)
-
-/* STRM Module */
-#define STRM_ALLOCATEBUFFER	_IOWR(DB, DB_IOC(DB_STRM, 0), unsigned long)
-#define STRM_CLOSE		_IOW(DB, DB_IOC(DB_STRM, 1), unsigned long)
-#define STRM_FREEBUFFER		_IOWR(DB, DB_IOC(DB_STRM, 2), unsigned long)
-#define STRM_GETEVENTHANDLE	_IO(DB, DB_IOC(DB_STRM, 3))	/* Not Impl'd */
-#define STRM_GETINFO		_IOWR(DB, DB_IOC(DB_STRM, 4), unsigned long)
-#define STRM_IDLE		_IOW(DB, DB_IOC(DB_STRM, 5), unsigned long)
-#define STRM_ISSUE		_IOW(DB, DB_IOC(DB_STRM, 6), unsigned long)
-#define STRM_OPEN		_IOWR(DB, DB_IOC(DB_STRM, 7), unsigned long)
-#define STRM_RECLAIM		_IOWR(DB, DB_IOC(DB_STRM, 8), unsigned long)
-#define STRM_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_STRM, 9), unsigned long)
-#define STRM_SELECT		_IOWR(DB, DB_IOC(DB_STRM, 10), unsigned long)
-
-/* CMM Module */
-#define CMM_ALLOCBUF		_IO(DB, DB_IOC(DB_CMM, 0))	/* Not Impl'd */
-#define CMM_FREEBUF		_IO(DB, DB_IOC(DB_CMM, 1))	/* Not Impl'd */
-#define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
-#define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
-
-#endif /* WCDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
deleted file mode 100644
index 1541f5e..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmd.h
+++ /dev/null
@@ -1,1134 +0,0 @@
-/*
- * wmd.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Bridge mini driver entry point and interface function declarations.
- *
- * Notes:
- *   The Bridge class driver obtains it's function interface to
- *   the Bridge mini driver via a call to bridge_drv_entry().
- *
- *   Bridge Class Driver services exported to WMD's are initialized by the
- *   WCD on behalf of the WMD.
- *
- *   WMD function DBC Requires and Ensures are also made by the WCD on
- *   behalf of the WMD, to simplify the WMD code.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMD_
-#define WMD_
-
-#include <dspbridge/brddefs.h>
-#include <dspbridge/cfgdefs.h>
-#include <dspbridge/chnlpriv.h>
-#include <dspbridge/dehdefs.h>
-#include <dspbridge/devdefs.h>
-#include <dspbridge/iodefs.h>
-#include <dspbridge/msgdefs.h>
-
-/*
- *  Any IOCTLS at or above this value are reserved for standard WMD
- *  interfaces.
- */
-#define BRD_RESERVEDIOCTLBASE   0x8000
-
-/* Handle to mini-driver's private device context. */
-struct bridge_dev_context;
-
-/*--------------------------------------------------------------------------- */
-/* 'Bridge MINI DRIVER FUNCTION TYPES */
-/*--------------------------------------------------------------------------- */
-
-/*
- *  ======== bridge_brd_monitor ========
- *  Purpose:
- *      Bring the board to the BRD_IDLE (monitor) state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *  Returns:
- *      DSP_SOK:        Success.
- *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_IDLE state;
- *      else:           Board state is indeterminate.
- */
-typedef dsp_status(*fxn_brd_monitor) (struct bridge_dev_context *hDevContext);
-
-/*
- *  ======== fxn_brd_setstate ========
- *  Purpose:
- *      Sets the Mini driver state
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ulBrdState:     Board state
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      ulBrdState  <= BRD_LASTSTATE.
- *  Ensures:
- *      ulBrdState  <= BRD_LASTSTATE.
- *  Update the Board state to the specified state.
- */
-typedef dsp_status(*fxn_brd_setstate) (struct bridge_dev_context
-				       * hDevContext, u32 ulBrdState);
-
-/*
- *  ======== bridge_brd_start ========
- *  Purpose:
- *      Bring board to the BRD_RUNNING (start) state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *      dwDSPAddr:      DSP address at which to start execution.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *      Board is in monitor (BRD_IDLE) state.
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_RUNNING state.
- *                      Interrupts to the PC are enabled.
- *      else:           Board state is indeterminate.
- */
-typedef dsp_status(*fxn_brd_start) (struct bridge_dev_context
-				    * hDevContext, u32 dwDSPAddr);
-
-/*
- *  ======== bridge_brd_mem_copy ========
- *  Purpose:
- *  Copy memory from one DSP address to another
- *  Parameters:
- *      dev_context:    Pointer to context handle
- *  ulDspDestAddr:  DSP address to copy to
- *  ulDspSrcAddr:   DSP address to copy from
- *  ul_num_bytes: Number of bytes to copy
- *  ulMemType:  What section of memory to copy to
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      dev_context != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_RUNNING state.
- *                      Interrupts to the PC are enabled.
- *      else:           Board state is indeterminate.
- */
-typedef dsp_status(*fxn_brd_memcopy) (struct bridge_dev_context
-				      * hDevContext,
-				      u32 ulDspDestAddr,
-				      u32 ulDspSrcAddr,
-				      u32 ul_num_bytes, u32 ulMemType);
-/*
- *  ======== bridge_brd_mem_write ========
- *  Purpose:
- *      Write a block of host memory into a DSP address, into a given memory
- *      space.  Unlike bridge_brd_write, this API does reset the DSP
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      pHostBuf:       Pointer to host buffer (Source).
- *      ul_num_bytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP to which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- */
-typedef dsp_status(*fxn_brd_memwrite) (struct bridge_dev_context
-				       * hDevContext,
-				       IN u8 *pHostBuf,
-				       u32 dwDSPAddr, u32 ul_num_bytes,
-				       u32 ulMemType);
-
-/*
- *  ======== bridge_brd_mem_map ========
- *  Purpose:
- *      Map a MPU memory region to a DSP/IVA memory space
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ul_mpu_addr:      MPU memory region start address.
- *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ul_num_bytes:     Number of bytes to map.
- *      map_attrs:       Mapping attributes (e.g. endianness).
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_brd_memmap) (struct bridge_dev_context
-				     * hDevContext, u32 ul_mpu_addr,
-				     u32 ulVirtAddr, u32 ul_num_bytes,
-				     u32 ulMapAttrs);
-
-/*
- *  ======== bridge_brd_mem_un_map ========
- *  Purpose:
- *      UnMap an MPU memory region from DSP/IVA memory space
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      ulVirtAddr:     DSP/IVA memory region u8 address.
- *      ul_num_bytes:     Number of bytes to unmap.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_brd_memunmap) (struct bridge_dev_context
-				       * hDevContext,
-				       u32 ulVirtAddr, u32 ul_num_bytes);
-
-/*
- *  ======== bridge_brd_stop ========
- *  Purpose:
- *      Bring board to the BRD_STOPPED state.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL
- *  Ensures:
- *      DSP_SOK:        Board is in BRD_STOPPED (stop) state;
- *                      Interrupts to the PC are disabled.
- *      else:           Board state is indeterminate.
- */
-typedef dsp_status(*fxn_brd_stop) (struct bridge_dev_context *hDevContext);
-
-/*
- *  ======== bridge_brd_status ========
- *  Purpose:
- *      Report the current state of the board.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device context.
- *      pdwState:       Ptr to BRD status variable.
- *  Returns:
- *      DSP_SOK:
- *  Requires:
- *      pdwState != NULL;
- *      hDevContext != NULL
- *  Ensures:
- *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
- */
-typedef dsp_status(*fxn_brd_status) (struct bridge_dev_context *hDevContext,
-				     int *pdwState);
-
-/*
- *  ======== bridge_brd_read ========
- *  Purpose:
- *      Read a block of DSP memory, from a given memory space, into a host
- *      buffer.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Destination).
- *      dwDSPAddr:      Address on DSP board (Source).
- *      ul_num_bytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP from which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- *  Will not write more than ul_num_bytes bytes into pHostBuf.
- */
-typedef dsp_status(*fxn_brd_read) (struct bridge_dev_context *hDevContext,
-				   OUT u8 *pHostBuf,
-				   u32 dwDSPAddr,
-				   u32 ul_num_bytes, u32 ulMemType);
-
-/*
- *  ======== bridge_brd_write ========
- *  Purpose:
- *      Write a block of host memory into a DSP address, into a given memory
- *      space.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      pHostBuf:       Pointer to host buffer (Source).
- *      ul_num_bytes:     Number of bytes to transfer.
- *      ulMemType:      Memory space on DSP to which to transfer.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
- *      -EPERM:      Other, unspecified error.
- *  Requires:
- *      hDevContext != NULL;
- *      pHostBuf != NULL.
- *  Ensures:
- */
-typedef dsp_status(*fxn_brd_write) (struct bridge_dev_context *hDevContext,
-				    IN u8 *pHostBuf,
-				    u32 dwDSPAddr,
-				    u32 ul_num_bytes, u32 ulMemType);
-
-/*
- *  ======== bridge_chnl_create ========
- *  Purpose:
- *      Create a channel manager object, responsible for opening new channels
- *      and closing old ones for a given 'Bridge board.
- *  Parameters:
- *      phChnlMgr:      Location to store a channel manager object on output.
- *      hdev_obj:     Handle to a device object.
- *      pMgrAttrs:      Channel manager attributes.
- *      pMgrAttrs->max_channels: Max channels
- *      pMgrAttrs->birq:      Channel's I/O IRQ number.
- *      pMgrAttrs->irq_shared:   TRUE if the IRQ is shareable.
- *      pMgrAttrs->word_size: DSP Word size in equivalent PC bytes..
- *      pMgrAttrs->shm_base:  Base physical address of shared memory, if any.
- *      pMgrAttrs->usm_length: Bytes of shared memory block.
- *  Returns:
- *      DSP_SOK:            Success;
- *      -ENOMEM:        Insufficient memory for requested resources.
- *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
- *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
- *  Requires:
- *      phChnlMgr != NULL.
- *      pMgrAttrs != NULL
- *      pMgrAttrs field are all valid:
- *          0 < max_channels <= CHNL_MAXCHANNELS.
- *          birq <= 15.
- *          word_size > 0.
- *      hdev_obj != NULL
- *      No channel manager exists for this board.
- *  Ensures:
- */
-typedef dsp_status(*fxn_chnl_create) (OUT struct chnl_mgr
-				      **phChnlMgr,
-				      struct dev_object
-				      * hdev_obj,
-				      IN CONST struct
-				      chnl_mgrattrs * pMgrAttrs);
-
-/*
- *  ======== bridge_chnl_destroy ========
- *  Purpose:
- *      Close all open channels, and destroy the channel manager.
- *  Parameters:
- *      hchnl_mgr:       Channel manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EFAULT:    hchnl_mgr was invalid.
- *  Requires:
- *  Ensures:
- *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
- *          chnl_create may subsequently be called for the same device.
- */
-typedef dsp_status(*fxn_chnl_destroy) (struct chnl_mgr *hchnl_mgr);
-/*
- *  ======== bridge_deh_notify ========
- *  Purpose:
- *      When notified of DSP error, take appropriate action.
- *  Parameters:
- *      hdeh_mgr:        Handle to DEH manager object.
- *      ulEventMask:  Indicate the type of exception
- *      dwErrInfo:     Error information
- *  Returns:
- *
- *  Requires:
- *      hdeh_mgr != NULL;
- *     ulEventMask with a valid exception
- *  Ensures:
- */
-typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
-				u32 ulEventMask, u32 dwErrInfo);
-
-/*
- *  ======== bridge_chnl_open ========
- *  Purpose:
- *      Open a new half-duplex channel to the DSP board.
- *  Parameters:
- *      phChnl:         Location to store a channel object handle.
- *      hchnl_mgr:	Handle to channel manager, as returned by
- *      		CHNL_GetMgr().
- *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
- *                      direction of data transfer.
- *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
- *                      select a free channel id (default);
- *                      otherwise this field specifies the id of the channel.
- *      pattrs:         Channel attributes.  Attribute fields are as follows:
- *      pattrs->uio_reqs: Specifies the maximum number of I/O requests which can
- *                      be pending at any given time. All request packets are
- *                      preallocated when the channel is opened.
- *      pattrs->event_obj: This field allows the user to supply an auto reset
- *                      event object for channel I/O completion notifications.
- *                      It is the responsibility of the user to destroy this
- *                      object AFTER closing the channel.
- *                      This channel event object can be retrieved using
- *                      CHNL_GetEventHandle().
- *      pattrs->hReserved: The kernel mode handle of this event object.
- *
- *  Returns:
- *      DSP_SOK:                Success.
- *      -EFAULT:            hchnl_mgr is invalid.
- *      -ENOMEM:            Insufficient memory for requested resources.
- *      -EINVAL:        Invalid number of IOReqs.
- *      CHNL_E_OUTOFSTREAMS:    No free channels available.
- *      CHNL_E_BADCHANID:       Channel ID is out of range.
- *      -EALREADY:        Channel is in use.
- *      CHNL_E_NOIORPS:         No free IO request packets available for
- *                              queuing.
- *  Requires:
- *      phChnl != NULL.
- *      pattrs != NULL.
- *      pattrs->event_obj is a valid event handle.
- *      pattrs->hReserved is the kernel mode handle for pattrs->event_obj.
- *  Ensures:
- *      DSP_SOK:                *phChnl is a valid channel.
- *      else:                   *phChnl is set to NULL if (phChnl != NULL);
- */
-typedef dsp_status(*fxn_chnl_open) (OUT struct chnl_object
-				    **phChnl,
-				    struct chnl_mgr *hchnl_mgr,
-				    s8 chnl_mode,
-				    u32 uChnlId,
-				    CONST IN OPTIONAL struct
-				    chnl_attr * pattrs);
-
-/*
- *  ======== bridge_chnl_close ========
- *  Purpose:
- *      Ensures all pending I/O on this channel is cancelled, discards all
- *      queued I/O completion notifications, then frees the resources allocated
- *      for this channel, and makes the corresponding logical channel id
- *      available for subsequent use.
- *  Parameters:
- *      chnl_obj:          Handle to a channel object.
- *  Returns:
- *      DSP_SOK:        Success;
- *      -EFAULT:    Invalid chnl_obj.
- *  Requires:
- *      No thread must be blocked on this channel's I/O completion event.
- *  Ensures:
- *      DSP_SOK:        chnl_obj is no longer valid.
- */
-typedef dsp_status(*fxn_chnl_close) (struct chnl_object *chnl_obj);
-
-/*
- *  ======== bridge_chnl_add_io_req ========
- *  Purpose:
- *      Enqueue an I/O request for data transfer on a channel to the DSP.
- *      The direction (mode) is specified in the channel object. Note the DSP
- *      address is specified for channels opened in direct I/O mode.
- *  Parameters:
- *      chnl_obj:          Channel object handle.
- *      pHostBuf:       Host buffer address source.
- *      byte_size:	Number of PC bytes to transfer. A zero value indicates
- *                      that this buffer is the last in the output channel.
- *                      A zero value is invalid for an input channel.
- *!     buf_size:       Actual buffer size in host bytes.
- *      dw_dsp_addr:      DSP address for transfer.  (Currently ignored).
- *      dw_arg:          A user argument that travels with the buffer.
- *  Returns:
- *      DSP_SOK:        Success;
- *      -EFAULT:    Invalid chnl_obj.
- *      -EFAULT:   pHostBuf is invalid.
- *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
- *      -ECANCELED: I/O has been cancelled on this channel.  No further
- *                      I/O is allowed.
- *      CHNL_E_EOS:     End of stream was already marked on a previous
- *                      IORequest on this channel.  No further I/O is expected.
- *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
- *                      the size of the physical shared memory output window.
- *  Requires:
- *  Ensures:
- *      DSP_SOK: The buffer will be transferred if the channel is ready;
- *          otherwise, will be queued for transfer when the channel becomes
- *          ready.  In any case, notifications of I/O completion are
- *          asynchronous.
- *          If byte_size is 0 for an output channel, subsequent CHNL_AddIOReq's
- *          on this channel will fail with error code CHNL_E_EOS.  The
- *          corresponding IOC for this I/O request will have its status flag
- *          set to CHNL_IOCSTATEOS.
- */
-typedef dsp_status(*fxn_chnl_addioreq) (struct chnl_object
-					* chnl_obj,
-					void *pHostBuf,
-					u32 byte_size,
-					u32 buf_size,
-					OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
-
-/*
- *  ======== bridge_chnl_get_ioc ========
- *  Purpose:
- *      Dequeue an I/O completion record, which contains information about the
- *      completed I/O request.
- *  Parameters:
- *      chnl_obj:          Channel object handle.
- *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
- *                      first available IOC.
- *      pIOC:           On output, contains host buffer address, bytes
- *                      transferred, and status of I/O completion.
- *      pIOC->status:   See chnldefs.h.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EFAULT:    Invalid chnl_obj.
- *      -EFAULT:   pIOC is invalid.
- *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
- *                      yet no I/O completions were queued.
- *  Requires:
- *      dwTimeOut == CHNL_IOCNOWAIT.
- *  Ensures:
- *      DSP_SOK: if there are any remaining IOC's queued before this call
- *          returns, the channel event object will be left in a signalled
- *          state.
- */
-typedef dsp_status(*fxn_chnl_getioc) (struct chnl_object *chnl_obj,
-				      u32 dwTimeOut,
-				      OUT struct chnl_ioc *pIOC);
-
-/*
- *  ======== bridge_chnl_cancel_io ========
- *  Purpose:
- *      Return all I/O requests to the client which have not yet been
- *      transferred.  The channel's I/O completion object is
- *      signalled, and all the I/O requests are queued as IOC's, with the
- *      status field set to CHNL_IOCSTATCANCEL.
- *      This call is typically used in abort situations, and is a prelude to
- *      chnl_close();
- *  Parameters:
- *      chnl_obj:          Channel object handle.
- *  Returns:
- *      DSP_SOK:        Success;
- *      -EFAULT:    Invalid chnl_obj.
- *  Requires:
- *  Ensures:
- *      Subsequent I/O requests to this channel will not be accepted.
- */
-typedef dsp_status(*fxn_chnl_cancelio) (struct chnl_object *chnl_obj);
-
-/*
- *  ======== bridge_chnl_flush_io ========
- *  Purpose:
- *      For an output stream (to the DSP), indicates if any IO requests are in
- *      the output request queue.  For input streams (from the DSP), will
- *      cancel all pending IO requests.
- *  Parameters:
- *      chnl_obj:              Channel object handle.
- *      dwTimeOut:          Timeout value for flush operation.
- *  Returns:
- *      DSP_SOK:            Success;
- *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
- *      -EFAULT:        Invalid chnl_obj.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:            No I/O requests will be pending on this channel.
- */
-typedef dsp_status(*fxn_chnl_flushio) (struct chnl_object *chnl_obj,
-				       u32 dwTimeOut);
-
-/*
- *  ======== bridge_chnl_get_info ========
- *  Purpose:
- *      Retrieve information related to a channel.
- *  Parameters:
- *      chnl_obj:          Handle to a valid channel object, or NULL.
- *      pInfo:          Location to store channel info.
- *  Returns:
- *      DSP_SOK:        Success;
- *      -EFAULT:    Invalid chnl_obj.
- *      -EFAULT:   pInfo == NULL.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:        pInfo points to a filled in chnl_info struct,
- *                      if (pInfo != NULL).
- */
-typedef dsp_status(*fxn_chnl_getinfo) (struct chnl_object *chnl_obj,
-				       OUT struct chnl_info *pChnlInfo);
-
-/*
- *  ======== bridge_chnl_get_mgr_info ========
- *  Purpose:
- *      Retrieve information related to the channel manager.
- *  Parameters:
- *      hchnl_mgr:           Handle to a valid channel manager, or NULL.
- *      uChnlID:            Channel ID.
- *      pMgrInfo:           Location to store channel manager info.
- *  Returns:
- *      DSP_SOK:            Success;
- *      -EFAULT:        Invalid hchnl_mgr.
- *      -EFAULT:       pMgrInfo == NULL.
- *      CHNL_E_BADCHANID:   Invalid channel ID.
- *  Requires:
- *  Ensures:
- *      DSP_SOK:            pMgrInfo points to a filled in chnl_mgrinfo
- *                          struct, if (pMgrInfo != NULL).
- */
-typedef dsp_status(*fxn_chnl_getmgrinfo) (struct chnl_mgr
-					  * hchnl_mgr,
-					  u32 uChnlID,
-					  OUT struct chnl_mgrinfo *pMgrInfo);
-
-/*
- *  ======== bridge_chnl_idle ========
- *  Purpose:
- *      Idle a channel. If this is an input channel, or if this is an output
- *      channel and fFlush is TRUE, all currently enqueued buffers will be
- *      dequeued (data discarded for output channel).
- *      If this is an output channel and fFlush is FALSE, this function
- *      will block until all currently buffered data is output, or the timeout
- *      specified has been reached.
- *
- *  Parameters:
- *      chnl_obj:          Channel object handle.
- *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
- *                      to wait for buffers to be output. (Not used for
- *                      input channel).
- *      fFlush:         If output channel and fFlush is TRUE, discard any
- *                      currently buffered data. If FALSE, wait for currently
- *                      buffered data to be output, or timeout, whichever
- *                      occurs first. fFlush is ignored for input channel.
- *  Returns:
- *      DSP_SOK:            Success;
- *      -EFAULT:        Invalid chnl_obj.
- *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
- *  Requires:
- *  Ensures:
- */
-typedef dsp_status(*fxn_chnl_idle) (struct chnl_object *chnl_obj,
-				    u32 dwTimeOut, bool fFlush);
-
-/*
- *  ======== bridge_chnl_register_notify ========
- *  Purpose:
- *      Register for notification of events on a channel.
- *  Parameters:
- *      chnl_obj:          Channel object handle.
- *      event_mask:     Type of events to be notified about: IO completion
- *                      (DSP_STREAMIOCOMPLETION) or end of stream
- *                      (DSP_STREAMDONE).
- *      notify_type:    DSP_SIGNALEVENT.
- *      hnotification:  Handle of a dsp_notification object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ENOMEM:    Insufficient memory.
- *      -EINVAL:     event_mask is 0 and hnotification was not
- *                      previously registered.
- *      -EFAULT:    NULL hnotification, hnotification event name
- *                      too long, or hnotification event name NULL.
- *  Requires:
- *      Valid chnl_obj.
- *      hnotification != NULL.
- *      (event_mask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
- *      notify_type == DSP_SIGNALEVENT.
- *  Ensures:
- */
-typedef dsp_status(*fxn_chnl_registernotify)
- (struct chnl_object *chnl_obj,
-  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
-
-/*
- *  ======== bridge_dev_create ========
- *  Purpose:
- *      Complete creation of the device object for this board.
- *  Parameters:
- *      phDevContext:   Ptr to location to store a WMD device context.
- *      hdev_obj:     Handle to a Device Object, created and managed by WCD.
- *      pConfig:        Ptr to configuration parameters provided by the Windows
- *                      Configuration Manager during device loading.
- *      pDspConfig:     DSP resources, as specified in the registry key for this
- *                      device.
- *  Returns:
- *      DSP_SOK:            Success.
- *      -ENOMEM:        Unable to allocate memory for device context.
- *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
- *                          parameters did not satisfy hardware assumptions
- *                          made by this WMD.
- *  Requires:
- *      phDevContext != NULL;
- *      hdev_obj != NULL;
- *      pConfig != NULL;
- *      pDspConfig != NULL;
- *      Fields in pConfig and pDspConfig contain valid values.
- *  Ensures:
- *      DSP_SOK:        All mini-driver specific DSP resource and other
- *                      board context has been allocated.
- *      -ENOMEM:    WMD failed to allocate resources.
- *                      Any acquired resources have been freed.  The WCD will
- *                      not call bridge_dev_destroy() if bridge_dev_create()
- *                      fails.
- *  Details:
- *      Called during the CONFIGMG's Device_Init phase. Based on host and
- *      DSP configuration information, create a board context, a handle to
- *      which is passed into other WMD BRD and CHNL functions.  The
- *      board context contains state information for the device. Since the
- *      addresses of all IN pointer parameters may be invalid when this
- *      function returns, they must not be stored into the device context
- *      structure.
- */
-typedef dsp_status(*fxn_dev_create) (OUT struct bridge_dev_context
-				     **phDevContext,
-				     struct dev_object
-				     * hdev_obj,
-				     IN struct cfg_hostres
-				     * pConfig);
-
-/*
- *  ======== bridge_dev_ctrl ========
- *  Purpose:
- *      Mini-driver specific interface.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      dw_cmd:          WMD defined command code.
- *      pargs:          Pointer to an arbitrary argument structure.
- *  Returns:
- *      DSP_SOK or -EPERM. Actual command error codes should be passed back
- *      in the pargs structure, and are defined by the WMD implementor.
- *  Requires:
- *      All calls are currently assumed to be synchronous.  There are no
- *      IOCTL completion routines provided.
- *  Ensures:
- */
-typedef dsp_status(*fxn_dev_ctrl) (struct bridge_dev_context *hDevContext,
-				   u32 dw_cmd, IN OUT void *pargs);
-
-/*
- *  ======== bridge_dev_destroy ========
- *  Purpose:
- *      Deallocate WMD device extension structures and all other resources
- *      acquired by the mini-driver.
- *      No calls to other mini driver functions may subsequently
- *      occur, except for bridge_dev_create().
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device information.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Failed to release a resource previously acquired.
- *  Requires:
- *      hDevContext != NULL;
- *  Ensures:
- *      DSP_SOK: Device context is freed.
- */
-typedef dsp_status(*fxn_dev_destroy) (struct bridge_dev_context *hDevContext);
-
-/*
- *  ======== bridge_deh_create ========
- *  Purpose:
- *      Create an object that manages DSP exceptions from the GPP.
- *  Parameters:
- *      phDehMgr:       Location to store DEH manager on output.
- *      hdev_obj:     Handle to DEV object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ENOMEM:    Memory allocation failure.
- *      -EPERM:      Creation failed.
- *  Requires:
- *      hdev_obj != NULL;
- *      phDehMgr != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_deh_create) (OUT struct deh_mgr
-				     **phDehMgr, struct dev_object *hdev_obj);
-
-/*
- *  ======== bridge_deh_destroy ========
- *  Purpose:
- *      Destroy the DEH object.
- *  Parameters:
- *      hdeh_mgr:        Handle to DEH manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Destroy failed.
- *  Requires:
- *      hdeh_mgr != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_deh_destroy) (struct deh_mgr *hdeh_mgr);
-
-/*
- *  ======== bridge_deh_register_notify ========
- *  Purpose:
- *      Register for DEH event notification.
- *  Parameters:
- *      hdeh_mgr:        Handle to DEH manager object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Destroy failed.
- *  Requires:
- *      hdeh_mgr != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_deh_registernotify)
- (struct deh_mgr *hdeh_mgr,
-  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
-
-/*
- *  ======== bridge_deh_get_info ========
- *  Purpose:
- *      Get DSP exception info.
- *  Parameters:
- *      phDehMgr:       Location to store DEH manager on output.
- *      pErrInfo:       Ptr to error info structure.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -EPERM:      Creation failed.
- *  Requires:
- *      phDehMgr != NULL;
- *      pErrorInfo != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
-				      struct dsp_errorinfo *pErrInfo);
-
-/*
- *  ======== bridge_io_create ========
- *  Purpose:
- *      Create an object that manages I/O between CHNL and msg_ctrl.
- *  Parameters:
- *      phIOMgr:        Location to store IO manager on output.
- *      hchnl_mgr:       Handle to channel manager.
- *      hmsg_mgr:        Handle to message manager.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ENOMEM:    Memory allocation failure.
- *      -EPERM:      Creation failed.
- *  Requires:
- *      hdev_obj != NULL;
- *      Channel manager already created;
- *      Message manager already created;
- *      pMgrAttrs != NULL;
- *      phIOMgr != NULL;
- *  Ensures:
- */
-typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
-				    struct dev_object *hdev_obj,
-				    IN CONST struct io_attrs *pMgrAttrs);
-
-/*
- *  ======== bridge_io_destroy ========
- *  Purpose:
- *      Destroy object created in bridge_io_create.
- *  Parameters:
- *      hio_mgr:         IO Manager.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ENOMEM:    Memory allocation failure.
- *      -EPERM:      Creation failed.
- *  Requires:
- *      Valid hio_mgr;
- *  Ensures:
- */
-typedef dsp_status(*fxn_io_destroy) (struct io_mgr *hio_mgr);
-
-/*
- *  ======== bridge_io_on_loaded ========
- *  Purpose:
- *      Called whenever a program is loaded to update internal data. For
- *      example, if shared memory is used, this function would update the
- *      shared memory location and address.
- *  Parameters:
- *      hio_mgr:     IO Manager.
- *  Returns:
- *      DSP_SOK:    Success.
- *      -EPERM:  Internal failure occurred.
- *  Requires:
- *      Valid hio_mgr;
- *  Ensures:
- */
-typedef dsp_status(*fxn_io_onloaded) (struct io_mgr *hio_mgr);
-
-/*
- *  ======== fxn_io_getprocload ========
- *  Purpose:
- *      Called to get the Processor's current and predicted load
- *  Parameters:
- *      hio_mgr:     IO Manager.
- *      pProcLoadStat   Processor Load statistics
- *  Returns:
- *      DSP_SOK:    Success.
- *      -EPERM:  Internal failure occurred.
- *  Requires:
- *      Valid hio_mgr;
- *  Ensures:
- */
-typedef dsp_status(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
-					 struct dsp_procloadstat *
-					 pProcLoadStat);
-
-/*
- *  ======== bridge_msg_create ========
- *  Purpose:
- *      Create an object to manage message queues. Only one of these objects
- *      can exist per device object.
- *  Parameters:
- *      phMsgMgr:           Location to store msg_ctrl manager on output.
- *      hdev_obj:         Handle to a device object.
- *      msgCallback:        Called whenever an RMS_EXIT message is received.
- *  Returns:
- *      DSP_SOK:            Success.
- *      -ENOMEM:        Insufficient memory.
- *  Requires:
- *      phMsgMgr != NULL.
- *      msgCallback != NULL.
- *      hdev_obj != NULL.
- *  Ensures:
- */
-typedef dsp_status(*fxn_msg_create)
- (OUT struct msg_mgr **phMsgMgr,
-  struct dev_object *hdev_obj, msg_onexit msgCallback);
-
-/*
- *  ======== bridge_msg_create_queue ========
- *  Purpose:
- *      Create a msg_ctrl queue for sending or receiving messages from a Message
- *      node on the DSP.
- *  Parameters:
- *      hmsg_mgr:            msg_ctrl queue manager handle returned from
- *                          bridge_msg_create.
- *      phMsgQueue:         Location to store msg_ctrl queue on output.
- *      msgq_id:	    Identifier for messages (node environment pointer).
- *      max_msgs:           Max number of simultaneous messages for the node.
- *      h:                  Handle passed to hmsg_mgr->msgCallback().
- *  Returns:
- *      DSP_SOK:            Success.
- *      -ENOMEM:        Insufficient memory.
- *  Requires:
- *      phMsgQueue != NULL.
- *      h != NULL.
- *      max_msgs > 0.
- *  Ensures:
- *      phMsgQueue !=NULL <==> DSP_SOK.
- */
-typedef dsp_status(*fxn_msg_createqueue)
- (struct msg_mgr *hmsg_mgr,
-  OUT struct msg_queue **phMsgQueue, u32 msgq_id, u32 max_msgs, void *h);
-
-/*
- *  ======== bridge_msg_delete ========
- *  Purpose:
- *      Delete a msg_ctrl manager allocated in bridge_msg_create().
- *  Parameters:
- *      hmsg_mgr:    Handle returned from bridge_msg_create().
- *  Returns:
- *  Requires:
- *      Valid hmsg_mgr.
- *  Ensures:
- */
-typedef void (*fxn_msg_delete) (struct msg_mgr *hmsg_mgr);
-
-/*
- *  ======== bridge_msg_delete_queue ========
- *  Purpose:
- *      Delete a msg_ctrl queue allocated in bridge_msg_create_queue.
- *  Parameters:
- *      msg_queue_obj:  Handle to msg_ctrl queue returned from
- *                  bridge_msg_create_queue.
- *  Returns:
- *  Requires:
- *      Valid msg_queue_obj.
- *  Ensures:
- */
-typedef void (*fxn_msg_deletequeue) (struct msg_queue *msg_queue_obj);
-
-/*
- *  ======== bridge_msg_get ========
- *  Purpose:
- *      Get a message from a msg_ctrl queue.
- *  Parameters:
- *      msg_queue_obj:     Handle to msg_ctrl queue returned from
- *                     bridge_msg_create_queue.
- *      pmsg:          Location to copy message into.
- *      utimeout:      Timeout to wait for a message.
- *  Returns:
- *      DSP_SOK:       Success.
- *      -ETIME:  Timeout occurred.
- *      -EPERM:     No frames available for message (max_msgs too
- *                     small).
- *  Requires:
- *      Valid msg_queue_obj.
- *      pmsg != NULL.
- *  Ensures:
- */
-typedef dsp_status(*fxn_msg_get) (struct msg_queue *msg_queue_obj,
-				  struct dsp_msg *pmsg, u32 utimeout);
-
-/*
- *  ======== bridge_msg_put ========
- *  Purpose:
- *      Put a message onto a msg_ctrl queue.
- *  Parameters:
- *      msg_queue_obj:      Handle to msg_ctrl queue returned from
- *                      bridge_msg_create_queue.
- *      pmsg:           Pointer to message.
- *      utimeout:       Timeout to wait for a message.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ETIME:   Timeout occurred.
- *      -EPERM:      No frames available for message (max_msgs too
- *                      small).
- *  Requires:
- *      Valid msg_queue_obj.
- *      pmsg != NULL.
- *  Ensures:
- */
-typedef dsp_status(*fxn_msg_put) (struct msg_queue *msg_queue_obj,
-				  IN CONST struct dsp_msg *pmsg, u32 utimeout);
-
-/*
- *  ======== bridge_msg_register_notify ========
- *  Purpose:
- *      Register notification for when a message is ready.
- *  Parameters:
- *      msg_queue_obj:      Handle to msg_ctrl queue returned from
- *                      bridge_msg_create_queue.
- *      event_mask:     Type of events to be notified about: Must be
- *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
- *      notify_type:    DSP_SIGNALEVENT.
- *      hnotification:  Handle of notification object.
- *  Returns:
- *      DSP_SOK:        Success.
- *      -ENOMEM:    Insufficient memory.
- *  Requires:
- *      Valid msg_queue_obj.
- *      hnotification != NULL.
- *      notify_type == DSP_SIGNALEVENT.
- *      event_mask == DSP_NODEMESSAGEREADY || event_mask == 0.
- *  Ensures:
- */
-typedef dsp_status(*fxn_msg_registernotify)
- (struct msg_queue *msg_queue_obj,
-  u32 event_mask, u32 notify_type, struct dsp_notification *hnotification);
-
-/*
- *  ======== bridge_msg_set_queue_id ========
- *  Purpose:
- *      Set message queue id to node environment. Allows bridge_msg_create_queue
- *      to be called in node_allocate, before the node environment is known.
- *  Parameters:
- *      msg_queue_obj:  Handle to msg_ctrl queue returned from
- *                  bridge_msg_create_queue.
- *      msgq_id:       Node environment pointer.
- *  Returns:
- *  Requires:
- *      Valid msg_queue_obj.
- *      msgq_id != 0.
- *  Ensures:
- */
-typedef void (*fxn_msg_setqueueid) (struct msg_queue *msg_queue_obj,
-				    u32 msgq_id);
-
-/*
- *  'Bridge Mini Driver (WMD) interface function table.
- *
- *  The information in this table is filled in by the specific mini-driver,
- *  and copied into the 'Bridge class driver's own space.  If any interface
- *  function field is set to a value of NULL, then the class driver will
- *  consider that function not implemented, and return the error code
- *  -ENOSYS when a WMD client attempts to call that function.
- *
- *  This function table contains WCD version numbers, which are used by the
- *  WMD loader to help ensure backwards compatility between older WMD's and a
- *  newer 'Bridge Class Driver.  These must be set to WCD_MAJOR_VERSION
- *  and WCD_MINOR_VERSION, respectively.
- *
- *  A mini-driver need not export a CHNL interface.  In this case, *all* of
- *  the WMD_CHNL_* entries must be set to NULL.
- */
-struct bridge_drv_interface {
-	u32 brd_api_major_version;	/* Set to BRD_API_MAJOR_VERSION. */
-	u32 brd_api_minor_version;	/* Set to BRD_API_MINOR_VERSION. */
-	fxn_dev_create pfn_dev_create;	/* Create device context */
-	fxn_dev_destroy pfn_dev_destroy;	/* Destroy device context */
-	fxn_dev_ctrl pfn_dev_cntrl;	/* Optional vendor interface */
-	fxn_brd_monitor pfn_brd_monitor;	/* Load and/or start monitor */
-	fxn_brd_start pfn_brd_start;	/* Start DSP program. */
-	fxn_brd_stop pfn_brd_stop;	/* Stop/reset board. */
-	fxn_brd_status pfn_brd_status;	/* Get current board status. */
-	fxn_brd_read pfn_brd_read;	/* Read board memory */
-	fxn_brd_write pfn_brd_write;	/* Write board memory. */
-	fxn_brd_setstate pfn_brd_set_state;	/* Sets the Board State */
-	fxn_brd_memcopy pfn_brd_mem_copy;	/* Copies DSP Memory */
-	fxn_brd_memwrite pfn_brd_mem_write;	/* Write DSP Memory w/o halt */
-	fxn_brd_memmap pfn_brd_mem_map;	/* Maps MPU mem to DSP mem */
-	fxn_brd_memunmap pfn_brd_mem_un_map;	/* Unmaps MPU mem to DSP mem */
-	fxn_chnl_create pfn_chnl_create;	/* Create channel manager. */
-	fxn_chnl_destroy pfn_chnl_destroy;	/* Destroy channel manager. */
-	fxn_chnl_open pfn_chnl_open;	/* Create a new channel. */
-	fxn_chnl_close pfn_chnl_close;	/* Close a channel. */
-	fxn_chnl_addioreq pfn_chnl_add_io_req;	/* Req I/O on a channel. */
-	fxn_chnl_getioc pfn_chnl_get_ioc;	/* Wait for I/O completion. */
-	fxn_chnl_cancelio pfn_chnl_cancel_io;	/* Cancl I/O on a channel. */
-	fxn_chnl_flushio pfn_chnl_flush_io;	/* Flush I/O. */
-	fxn_chnl_getinfo pfn_chnl_get_info;	/* Get channel specific info */
-	/* Get channel manager info. */
-	fxn_chnl_getmgrinfo pfn_chnl_get_mgr_info;
-	fxn_chnl_idle pfn_chnl_idle;	/* Idle the channel */
-	/* Register for notif. */
-	fxn_chnl_registernotify pfn_chnl_register_notify;
-	fxn_deh_create pfn_deh_create;	/* Create DEH manager */
-	fxn_deh_destroy pfn_deh_destroy;	/* Destroy DEH manager */
-	fxn_deh_notify pfn_deh_notify;	/* Notify of DSP error */
-	/* register for deh notif. */
-	fxn_deh_registernotify pfn_deh_register_notify;
-	fxn_deh_getinfo pfn_deh_get_info;	/* register for deh notif. */
-	fxn_io_create pfn_io_create;	/* Create IO manager */
-	fxn_io_destroy pfn_io_destroy;	/* Destroy IO manager */
-	fxn_io_onloaded pfn_io_on_loaded;	/* Notify of program loaded */
-	/* Get Processor's current and predicted load */
-	fxn_io_getprocload pfn_io_get_proc_load;
-	fxn_msg_create pfn_msg_create;	/* Create message manager */
-	/* Create message queue */
-	fxn_msg_createqueue pfn_msg_create_queue;
-	fxn_msg_delete pfn_msg_delete;	/* Delete message manager */
-	/* Delete message queue */
-	fxn_msg_deletequeue pfn_msg_delete_queue;
-	fxn_msg_get pfn_msg_get;	/* Get a message */
-	fxn_msg_put pfn_msg_put;	/* Send a message */
-	/* Register for notif. */
-	fxn_msg_registernotify pfn_msg_register_notify;
-	/* Set message queue id */
-	fxn_msg_setqueueid pfn_msg_set_queue_id;
-};
-
-/*
- *  ======== bridge_drv_entry ========
- *  Purpose:
- *      Registers WMD functions with the class driver. Called only once
- *      by the WCD.  The caller will first check WCD version compatibility, and
- *      then copy the interface functions into its own memory space.
- *  Parameters:
- *      ppDrvInterface  Pointer to a location to receive a pointer to the
- *                      mini driver interface.
- *  Returns:
- *  Requires:
- *      The code segment this function resides in must expect to be discarded
- *      after completion.
- *  Ensures:
- *      ppDrvInterface pointer initialized to WMD's function interface.
- *      No system resources are acquired by this function.
- *  Details:
- *      Win95: Called during the Device_Init phase.
- */
-void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
-		   IN CONST char *driver_file_name);
-
-#endif /* WMD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdchnl.h b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
deleted file mode 100644
index 57ca2af..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * wmdchnl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Declares the upper edge channel class library functions required by
- * all WMD / WCD driver interface tables.  These functions are implemented
- * by every class of WMD channel library.
- *
- * Notes:
- *   The function comment headers reside in wmd.h.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMDCHNL_
-#define WMDCHNL_
-
-extern dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
-				     struct dev_object *hdev_obj,
-				     IN CONST struct chnl_mgrattrs
-				     *pMgrAttrs);
-
-extern dsp_status bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr);
-
-extern dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
-				   struct chnl_mgr *hchnl_mgr,
-				   s8 chnl_mode,
-				   u32 uChnlId,
-				   CONST IN OPTIONAL struct chnl_attr
-				   *pattrs);
-
-extern dsp_status bridge_chnl_close(struct chnl_object *chnl_obj);
-
-extern dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj,
-				      void *pHostBuf,
-				      u32 byte_size, u32 buf_size,
-				      OPTIONAL u32 dw_dsp_addr, u32 dw_arg);
-
-extern dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj,
-				   u32 dwTimeOut, OUT struct chnl_ioc *pIOC);
-
-extern dsp_status bridge_chnl_cancel_io(struct chnl_object *chnl_obj);
-
-extern dsp_status bridge_chnl_flush_io(struct chnl_object *chnl_obj,
-				    u32 dwTimeOut);
-
-extern dsp_status bridge_chnl_get_info(struct chnl_object *chnl_obj,
-				    OUT struct chnl_info *pInfo);
-
-extern dsp_status bridge_chnl_get_mgr_info(struct chnl_mgr *hchnl_mgr,
-					u32 uChnlID, OUT struct chnl_mgrinfo
-					*pMgrInfo);
-
-extern dsp_status bridge_chnl_idle(struct chnl_object *chnl_obj,
-				   u32 dwTimeOut, bool fFlush);
-
-extern dsp_status bridge_chnl_register_notify(struct chnl_object *chnl_obj,
-					   u32 event_mask,
-					   u32 notify_type,
-					   struct dsp_notification
-					   *hnotification);
-
-#endif /* WMDCHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmddeh.h b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
deleted file mode 100644
index 6f9a788..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmddeh.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * wmddeh.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Defines upper edge DEH functions required by all WMD/WCD driver
- * interface tables.
- *
- * Notes:
- *   Function comment headers reside with the function typedefs in wmd.h.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMDDEH_
-#define WMDDEH_
-
-#include <dspbridge/devdefs.h>
-
-#include <dspbridge/dehdefs.h>
-
-extern dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
-		struct dev_object *hdev_obj);
-
-extern dsp_status bridge_deh_destroy(struct deh_mgr *deh_mgr);
-
-extern dsp_status bridge_deh_get_info(struct deh_mgr *deh_mgr,
-		struct dsp_errorinfo *pErrInfo);
-
-extern dsp_status bridge_deh_register_notify(struct deh_mgr *deh_mgr,
-		u32 event_mask,
-		u32 notify_type,
-		struct dsp_notification *hnotification);
-
-extern void bridge_deh_notify(struct deh_mgr *deh_mgr,
-		u32 ulEventMask, u32 dwErrInfo);
-
-extern void bridge_deh_release_dummy_mem(void);
-#endif /* WMDDEH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdio.h b/arch/arm/plat-omap/include/dspbridge/wmdio.h
deleted file mode 100644
index c566350..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmdio.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * wmdio.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Declares the upper edge IO functions required by all WMD / WCD
- * driver interface tables.
- *
- * Notes:
- *   Function comment headers reside in wmd.h.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMDIO_
-#define WMDIO_
-
-#include <dspbridge/devdefs.h>
-#include <dspbridge/iodefs.h>
-
-extern dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
-				   struct dev_object *hdev_obj,
-				   IN CONST struct io_attrs *pMgrAttrs);
-
-extern dsp_status bridge_io_destroy(struct io_mgr *hio_mgr);
-
-extern dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr);
-
-extern dsp_status iva_io_on_loaded(struct io_mgr *hio_mgr);
-extern dsp_status bridge_io_get_proc_load(IN struct io_mgr *hio_mgr,
-				       OUT struct dsp_procloadstat *pProcStat);
-
-#endif /* WMDIO_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdioctl.h b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
deleted file mode 100644
index 9fe5543..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * wmdioctl.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * BRIDGE Minidriver BRD_IOCtl reserved command definitions.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMDIOCTL_
-#define WMDIOCTL_
-
-/* ------------------------------------ Hardware Abstraction Layer */
-#include <hw_defs.h>
-#include <hw_mmu.h>
-
-/*
- * Any IOCTLS at or above this value are reserved for standard WMD
- * interfaces.
- */
-#define BRDIOCTL_RESERVEDBASE       0x8000
-
-#define BRDIOCTL_CHNLREAD           (BRDIOCTL_RESERVEDBASE + 0x10)
-#define BRDIOCTL_CHNLWRITE          (BRDIOCTL_RESERVEDBASE + 0x20)
-#define BRDIOCTL_GETINTRCOUNT       (BRDIOCTL_RESERVEDBASE + 0x30)
-#define BRDIOCTL_RESETINTRCOUNT     (BRDIOCTL_RESERVEDBASE + 0x40)
-#define BRDIOCTL_INTERRUPTDSP       (BRDIOCTL_RESERVEDBASE + 0x50)
-/* DMMU */
-#define BRDIOCTL_SETMMUCONFIG       (BRDIOCTL_RESERVEDBASE + 0x60)
-/* PWR */
-#define BRDIOCTL_PWRCONTROL         (BRDIOCTL_RESERVEDBASE + 0x70)
-
-/* attention, modifiers:
- * Some of these control enumerations are made visible to user for power
- * control, so any changes to this list, should also be updated in the user
- * header file 'dbdefs.h' ***/
-/* These ioctls are reserved for PWR power commands for the DSP */
-#define BRDIOCTL_DEEPSLEEP          (BRDIOCTL_PWRCONTROL + 0x0)
-#define BRDIOCTL_EMERGENCYSLEEP     (BRDIOCTL_PWRCONTROL + 0x1)
-#define BRDIOCTL_WAKEUP             (BRDIOCTL_PWRCONTROL + 0x2)
-#define BRDIOCTL_PWRENABLE          (BRDIOCTL_PWRCONTROL + 0x3)
-#define BRDIOCTL_PWRDISABLE         (BRDIOCTL_PWRCONTROL + 0x4)
-#define BRDIOCTL_CLK_CTRL		    (BRDIOCTL_PWRCONTROL + 0x7)
-/* DSP Initiated Hibernate */
-#define BRDIOCTL_PWR_HIBERNATE	(BRDIOCTL_PWRCONTROL + 0x8)
-#define BRDIOCTL_PRESCALE_NOTIFY (BRDIOCTL_PWRCONTROL + 0x9)
-#define BRDIOCTL_POSTSCALE_NOTIFY (BRDIOCTL_PWRCONTROL + 0xA)
-#define BRDIOCTL_CONSTRAINT_REQUEST (BRDIOCTL_PWRCONTROL + 0xB)
-
-/* Number of actual DSP-MMU TLB entrries */
-#define BRDIOCTL_NUMOFMMUTLB        32
-
-struct bridge_ioctl_extproc {
-	u32 ul_dsp_va;		/* DSP virtual address */
-	u32 ul_gpp_pa;		/* GPP physical address */
-	/* GPP virtual address. __va does not work for ioremapped addresses */
-	u32 ul_gpp_va;
-	u32 ul_size;		/* Size of the mapped memory in bytes */
-	enum hw_endianism_t endianism;
-	enum hw_mmu_mixed_size_t mixed_mode;
-	enum hw_element_size_t elem_size;
-};
-
-#endif /* WMDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdmsg.h b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
deleted file mode 100644
index 7935b6e..0000000
--- a/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * wmdmsg.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Declares the upper edge message class library functions required by
- * all WMD / WCD driver interface tables.  These functions are
- * implemented by every class of WMD channel library.
- *
- * Notes:
- *   Function comment headers reside in wmd.h.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef WMDMSG_
-#define WMDMSG_
-
-#include <dspbridge/msgdefs.h>
-
-extern dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
-				    struct dev_object *hdev_obj,
-				    msg_onexit msgCallback);
-
-extern dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
-				       OUT struct msg_queue **phMsgQueue,
-				       u32 msgq_id, u32 max_msgs, void *h);
-
-extern void bridge_msg_delete(struct msg_mgr *hmsg_mgr);
-
-extern void bridge_msg_delete_queue(struct msg_queue *msg_queue_obj);
-
-extern dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
-				 struct dsp_msg *pmsg, u32 utimeout);
-
-extern dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
-				 IN CONST struct dsp_msg *pmsg, u32 utimeout);
-
-extern dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
-					  u32 event_mask,
-					  u32 notify_type,
-					  struct dsp_notification
-					  *hnotification);
-
-extern void bridge_msg_set_queue_id(struct msg_queue *msg_queue_obj,
-					u32 msgq_id);
-
-#endif /* WMDMSG_ */
diff --git a/drivers/dsp/bridge/Makefile b/drivers/dsp/bridge/Makefile
index e2cb9f6..4c2f923 100644
--- a/drivers/dsp/bridge/Makefile
+++ b/drivers/dsp/bridge/Makefile
@@ -6,7 +6,7 @@ libservices = services/sync.o services/cfg.o \
 libcore = core/chnl_sm.o core/msg_sm.o core/io_sm.o core/tiomap3430.o \
 		core/tiomap3430_pwr.o core/tiomap_io.o \
 		core/mmu_fault.o core/ue_deh.o core/wdt.o core/dsp-clock.o
-libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
+libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/dspapi.o \
 		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
 librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
 		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
diff --git a/drivers/dsp/bridge/core/_deh.h b/drivers/dsp/bridge/core/_deh.h
index e06e50d..8da2212 100644
--- a/drivers/dsp/bridge/core/_deh.h
+++ b/drivers/dsp/bridge/core/_deh.h
@@ -20,7 +20,7 @@
 #define _DEH_
 
 #include <dspbridge/ntfy.h>
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /* DEH Manager: only one created per board: */
 struct deh_mgr {
diff --git a/drivers/dsp/bridge/core/_tiomap.h b/drivers/dsp/bridge/core/_tiomap.h
index 296f18a..df73964 100644
--- a/drivers/dsp/bridge/core/_tiomap.h
+++ b/drivers/dsp/bridge/core/_tiomap.h
@@ -25,7 +25,7 @@
 #include <mach-omap2/cm-regbits-34xx.h>
 #include <dspbridge/devdefs.h>
 #include <hw_defs.h>
-#include <dspbridge/wmdioctl.h>	/* for bridge_ioctl_extproc defn */
+#include <dspbridge/dspioctl.h>	/* for bridge_ioctl_extproc defn */
 #include <dspbridge/sync.h>
 #include <dspbridge/clk.h>
 
diff --git a/drivers/dsp/bridge/core/chnl_sm.c b/drivers/dsp/bridge/core/chnl_sm.c
index c4857a8..bb2dd7b 100644
--- a/drivers/dsp/bridge/core/chnl_sm.c
+++ b/drivers/dsp/bridge/core/chnl_sm.c
@@ -58,8 +58,8 @@
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Mini-Driver */
-#include <dspbridge/wmd.h>
-#include <dspbridge/wmdchnl.h>
+#include <dspbridge/dspdefs.h>
+#include <dspbridge/dspchnl.h>
 #include "_tiomap.h"
 
 /*  ----------------------------------- Platform Manager */
diff --git a/drivers/dsp/bridge/core/io_sm.c b/drivers/dsp/bridge/core/io_sm.c
index ac92bef..d6c1a98 100644
--- a/drivers/dsp/bridge/core/io_sm.c
+++ b/drivers/dsp/bridge/core/io_sm.c
@@ -46,9 +46,9 @@
 #include <hw_mmu.h>
 
 /* Mini Driver */
-#include <dspbridge/wmddeh.h>
-#include <dspbridge/wmdio.h>
-#include <dspbridge/wmdioctl.h>
+#include <dspbridge/dspdeh.h>
+#include <dspbridge/dspio.h>
+#include <dspbridge/dspioctl.h>
 #include <dspbridge/wdt.h>
 #include <_tiomap.h>
 #include <tiomap_io.h>
diff --git a/drivers/dsp/bridge/core/mmu_fault.c b/drivers/dsp/bridge/core/mmu_fault.c
index 0015d06..883f45d 100644
--- a/drivers/dsp/bridge/core/mmu_fault.c
+++ b/drivers/dsp/bridge/core/mmu_fault.c
@@ -29,7 +29,7 @@
 #include <dspbridge/drv.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmddeh.h>
+#include <dspbridge/dspdeh.h>
 
 /* ------------------------------------ Hardware Abstraction Layer */
 #include <hw_defs.h>
diff --git a/drivers/dsp/bridge/core/msg_sm.c b/drivers/dsp/bridge/core/msg_sm.c
index 4f08a83..d418ecf 100644
--- a/drivers/dsp/bridge/core/msg_sm.c
+++ b/drivers/dsp/bridge/core/msg_sm.c
@@ -36,7 +36,7 @@
 
 /*  ----------------------------------- This */
 #include <_msg_sm.h>
-#include <dspbridge/wmdmsg.h>
+#include <dspbridge/dspmsg.h>
 
 /*  ----------------------------------- Function Prototypes */
 static dsp_status add_new_msg(struct lst_list *msgList);
diff --git a/drivers/dsp/bridge/core/tiomap3430.c b/drivers/dsp/bridge/core/tiomap3430.c
index a016079..97a28ca 100644
--- a/drivers/dsp/bridge/core/tiomap3430.c
+++ b/drivers/dsp/bridge/core/tiomap3430.c
@@ -40,17 +40,17 @@
 #include <hw_mmu.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmd.h>
-#include <dspbridge/wmdchnl.h>
-#include <dspbridge/wmddeh.h>
-#include <dspbridge/wmdio.h>
-#include <dspbridge/wmdmsg.h>
+#include <dspbridge/dspdefs.h>
+#include <dspbridge/dspchnl.h>
+#include <dspbridge/dspdeh.h>
+#include <dspbridge/dspio.h>
+#include <dspbridge/dspmsg.h>
 #include <dspbridge/pwr.h>
 #include <dspbridge/io_sm.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
-#include <dspbridge/wcd.h>
+#include <dspbridge/dspapi.h>
 #include <dspbridge/dmm.h>
 #include <dspbridge/wdt.h>
 
diff --git a/drivers/dsp/bridge/core/tiomap3430_pwr.c b/drivers/dsp/bridge/core/tiomap3430_pwr.c
index 918466a..1897c50 100644
--- a/drivers/dsp/bridge/core/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/core/tiomap3430_pwr.c
@@ -35,7 +35,7 @@
 #include <dspbridge/pwr_sh.h>
 
 /*  ----------------------------------- Mini Driver */
-#include <dspbridge/wmddeh.h>
+#include <dspbridge/dspdeh.h>
 #include <dspbridge/wdt.h>
 
 /*  ----------------------------------- specific to this file */
diff --git a/drivers/dsp/bridge/core/ue_deh.c b/drivers/dsp/bridge/core/ue_deh.c
index a82f699..605f312 100644
--- a/drivers/dsp/bridge/core/ue_deh.c
+++ b/drivers/dsp/bridge/core/ue_deh.c
@@ -34,11 +34,11 @@
 #include <dspbridge/drv.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmddeh.h>
+#include <dspbridge/dspdeh.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
-#include <dspbridge/wcd.h>
+#include <dspbridge/dspapi.h>
 #include <dspbridge/wdt.h>
 
 /* ------------------------------------ Hardware Abstraction Layer */
diff --git a/drivers/dsp/bridge/core/wdt.c b/drivers/dsp/bridge/core/wdt.c
index 7a007f2..4637afb 100644
--- a/drivers/dsp/bridge/core/wdt.c
+++ b/drivers/dsp/bridge/core/wdt.c
@@ -19,7 +19,7 @@
 #include <dspbridge/std.h>
 #include <dspbridge/dbdefs.h>
 #include <dspbridge/errbase.h>
-#include <dspbridge/wmddeh.h>
+#include <dspbridge/dspdeh.h>
 #include <dspbridge/dev.h>
 #include <dspbridge/_chnl_sm.h>
 #include <dspbridge/wdt.h>
diff --git a/drivers/dsp/bridge/pmgr/chnlobj.h b/drivers/dsp/bridge/pmgr/chnlobj.h
index 2cc7c22..39ce007 100644
--- a/drivers/dsp/bridge/pmgr/chnlobj.h
+++ b/drivers/dsp/bridge/pmgr/chnlobj.h
@@ -21,7 +21,7 @@
 #define CHNLOBJ_
 
 #include <dspbridge/chnldefs.h>
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /*
  *  This struct is the first field in a chnl_mgr struct, as implemented in
diff --git a/drivers/dsp/bridge/pmgr/dev.c b/drivers/dsp/bridge/pmgr/dev.c
index 75100c4..c85a4fa 100644
--- a/drivers/dsp/bridge/pmgr/dev.c
+++ b/drivers/dsp/bridge/pmgr/dev.c
@@ -43,7 +43,7 @@
 #include <dspbridge/node.h>
 
 /*  ----------------------------------- Others */
-#include <dspbridge/wcd.h>	/* WCD version info. */
+#include <dspbridge/dspapi.h>	/* WCD version info. */
 
 #include <dspbridge/chnl.h>
 #include <dspbridge/io.h>
diff --git a/drivers/dsp/bridge/pmgr/dspapi.c b/drivers/dsp/bridge/pmgr/dspapi.c
new file mode 100644
index 0000000..9fb1192
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/dspapi.c
@@ -0,0 +1,1656 @@
+/*
+ * dspapi.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Common WCD functions, also includes the wrapper
+ * functions called directly by the DeviceIOControl interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/services.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/chnl.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/drv.h>
+
+#include <dspbridge/proc.h>
+#include <dspbridge/strm.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/disp.h>
+#include <dspbridge/mgr.h>
+#include <dspbridge/node.h>
+#include <dspbridge/rmm.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/msg.h>
+#include <dspbridge/cmm.h>
+#include <dspbridge/io.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/_dcd.h>
+#include <dspbridge/dbdcd.h>
+
+#include <dspbridge/resourcecleanup.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define MAX_TRACEBUFLEN 255
+#define MAX_LOADARGS    16
+#define MAX_NODES       64
+#define MAX_STREAMS     16
+#define MAX_BUFS	64
+
+/* Used to get dspbridge ioctl table */
+#define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
+
+/* Device IOCtl function pointer */
+struct api_cmd {
+	u32(*fxn) (union Trapped_Args *args, void *pr_ctxt);
+	u32 dw_index;
+};
+
+/*  ----------------------------------- Globals */
+static u32 api_c_refs;
+
+/*
+ *  Function tables.
+ *  The order of these functions MUST be the same as the order of the command
+ *  numbers defined in dspapi-ioctl.h  This is how an IOCTL number in user mode
+ *  turns into a function call in kernel mode.
+ */
+
+/* MGR wrapper functions */
+static struct api_cmd mgr_cmd[] = {
+	{mgrwrap_enum_node_info},	/* MGR_ENUMNODE_INFO */
+	{mgrwrap_enum_proc_info},	/* MGR_ENUMPROC_INFO */
+	{mgrwrap_register_object},	/* MGR_REGISTEROBJECT */
+	{mgrwrap_unregister_object},	/* MGR_UNREGISTEROBJECT */
+	{mgrwrap_wait_for_bridge_events},	/* MGR_WAIT */
+	{mgrwrap_get_process_resources_info},	/* MGR_GET_PROC_RES */
+};
+
+/* PROC wrapper functions */
+static struct api_cmd proc_cmd[] = {
+	{procwrap_attach},	/* PROC_ATTACH */
+	{procwrap_ctrl},	/* PROC_CTRL */
+	{procwrap_detach},	/* PROC_DETACH */
+	{procwrap_enum_node_info},	/* PROC_ENUMNODE */
+	{procwrap_enum_resources},	/* PROC_ENUMRESOURCES */
+	{procwrap_get_state},	/* PROC_GET_STATE */
+	{procwrap_get_trace},	/* PROC_GET_TRACE */
+	{procwrap_load},	/* PROC_LOAD */
+	{procwrap_register_notify},	/* PROC_REGISTERNOTIFY */
+	{procwrap_start},	/* PROC_START */
+	{procwrap_reserve_memory},	/* PROC_RSVMEM */
+	{procwrap_un_reserve_memory},	/* PROC_UNRSVMEM */
+	{procwrap_map},		/* PROC_MAPMEM */
+	{procwrap_un_map},	/* PROC_UNMAPMEM */
+	{procwrap_flush_memory},	/* PROC_FLUSHMEMORY */
+	{procwrap_stop},	/* PROC_STOP */
+	{procwrap_invalidate_memory},	/* PROC_INVALIDATEMEMORY */
+};
+
+/* NODE wrapper functions */
+static struct api_cmd node_cmd[] = {
+	{nodewrap_allocate},	/* NODE_ALLOCATE */
+	{nodewrap_alloc_msg_buf},	/* NODE_ALLOCMSGBUF */
+	{nodewrap_change_priority},	/* NODE_CHANGEPRIORITY */
+	{nodewrap_connect},	/* NODE_CONNECT */
+	{nodewrap_create},	/* NODE_CREATE */
+	{nodewrap_delete},	/* NODE_DELETE */
+	{nodewrap_free_msg_buf},	/* NODE_FREEMSGBUF */
+	{nodewrap_get_attr},	/* NODE_GETATTR */
+	{nodewrap_get_message},	/* NODE_GETMESSAGE */
+	{nodewrap_pause},	/* NODE_PAUSE */
+	{nodewrap_put_message},	/* NODE_PUTMESSAGE */
+	{nodewrap_register_notify},	/* NODE_REGISTERNOTIFY */
+	{nodewrap_run},		/* NODE_RUN */
+	{nodewrap_terminate},	/* NODE_TERMINATE */
+	{nodewrap_get_uuid_props},	/* NODE_GETUUIDPROPS */
+};
+
+/* STRM wrapper functions */
+static struct api_cmd strm_cmd[] = {
+	{strmwrap_allocate_buffer},	/* STRM_ALLOCATEBUFFER */
+	{strmwrap_close},	/* STRM_CLOSE */
+	{strmwrap_free_buffer},	/* STRM_FREEBUFFER */
+	{strmwrap_get_event_handle},	/* STRM_GETEVENTHANDLE */
+	{strmwrap_get_info},	/* STRM_GETINFO */
+	{strmwrap_idle},	/* STRM_IDLE */
+	{strmwrap_issue},	/* STRM_ISSUE */
+	{strmwrap_open},	/* STRM_OPEN */
+	{strmwrap_reclaim},	/* STRM_RECLAIM */
+	{strmwrap_register_notify},	/* STRM_REGISTERNOTIFY */
+	{strmwrap_select},	/* STRM_SELECT */
+};
+
+/* CMM wrapper functions */
+static struct api_cmd cmm_cmd[] = {
+	{cmmwrap_calloc_buf},	/* CMM_ALLOCBUF */
+	{cmmwrap_free_buf},	/* CMM_FREEBUF */
+	{cmmwrap_get_handle},	/* CMM_GETHANDLE */
+	{cmmwrap_get_info},	/* CMM_GETINFO */
+};
+
+/* Array used to store ioctl table sizes. It can hold up to 8 entries */
+static u8 size_cmd[] = {
+	ARRAY_SIZE(mgr_cmd),
+	ARRAY_SIZE(proc_cmd),
+	ARRAY_SIZE(node_cmd),
+	ARRAY_SIZE(strm_cmd),
+	ARRAY_SIZE(cmm_cmd),
+};
+
+static inline void _cp_fm_usr(void *to, const void __user * from,
+			      dsp_status *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!from)) {
+		*err = -EFAULT;
+		return;
+	}
+
+	if (unlikely(copy_from_user(to, from, bytes)))
+		*err = -EFAULT;
+}
+
+#define CP_FM_USR(to, from, err, n)				\
+	_cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
+
+static inline void _cp_to_usr(void __user *to, const void *from,
+			      dsp_status *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!to)) {
+		*err = -EFAULT;
+		return;
+	}
+
+	if (unlikely(copy_to_user(to, from, bytes)))
+		*err = -EFAULT;
+}
+
+#define CP_TO_USR(to, from, err, n)				\
+	_cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
+
+/*
+ *  ======== api_call_dev_ioctl ========
+ *  Purpose:
+ *      Call the (wrapper) function for the corresponding API IOCTL.
+ */
+inline dsp_status api_call_dev_ioctl(u32 cmd, union Trapped_Args *args,
+				      u32 *result, void *pr_ctxt)
+{
+	u32(*ioctl_cmd) (union Trapped_Args *args, void *pr_ctxt) = NULL;
+	int i;
+
+	if (_IOC_TYPE(cmd) != DB) {
+		pr_err("%s: Incompatible dspbridge ioctl number\n", __func__);
+		goto err;
+	}
+
+	if (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {
+		pr_err("%s: undefined ioctl module\n", __func__);
+		goto err;
+	}
+
+	/* Check the size of the required cmd table */
+	i = DB_GET_IOC(cmd);
+	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
+		pr_err("%s: requested ioctl %d out of bounds for table %d\n",
+		       __func__, i, DB_GET_IOC_TABLE(cmd));
+		goto err;
+	}
+
+	switch (DB_GET_MODULE(cmd)) {
+	case DB_MGR:
+		ioctl_cmd = mgr_cmd[i].fxn;
+		break;
+	case DB_PROC:
+		ioctl_cmd = proc_cmd[i].fxn;
+		break;
+	case DB_NODE:
+		ioctl_cmd = node_cmd[i].fxn;
+		break;
+	case DB_STRM:
+		ioctl_cmd = strm_cmd[i].fxn;
+		break;
+	case DB_CMM:
+		ioctl_cmd = cmm_cmd[i].fxn;
+		break;
+	}
+
+	if (!ioctl_cmd) {
+		pr_err("%s: requested ioctl not defined\n", __func__);
+		goto err;
+	} else {
+		*result = (*ioctl_cmd) (args, pr_ctxt);
+	}
+
+	return DSP_SOK;
+
+err:
+	return -EINVAL;
+}
+
+/*
+ *  ======== api_exit ========
+ */
+void api_exit(void)
+{
+	DBC_REQUIRE(api_c_refs > 0);
+	api_c_refs--;
+
+	if (api_c_refs == 0) {
+		/* Release all modules initialized in api_init(). */
+		cod_exit();
+		dev_exit();
+		chnl_exit();
+		msg_exit();
+		io_exit();
+		strm_exit();
+		disp_exit();
+		node_exit();
+		proc_exit();
+		mgr_exit();
+		rmm_exit();
+		drv_exit();
+	}
+	DBC_ENSURE(api_c_refs >= 0);
+}
+
+/*
+ *  ======== api_init ========
+ *  Purpose:
+ *      Module initialization used by Bridge API.
+ */
+bool api_init(void)
+{
+	bool ret = true;
+	bool fdrv, fdev, fcod, fchnl, fmsg, fio;
+	bool fmgr, fproc, fnode, fdisp, fstrm, frmm;
+
+	if (api_c_refs == 0) {
+		/* initialize driver and other modules */
+		fdrv = drv_init();
+		fmgr = mgr_init();
+		fproc = proc_init();
+		fnode = node_init();
+		fdisp = disp_init();
+		fstrm = strm_init();
+		frmm = rmm_init();
+		fchnl = chnl_init();
+		fmsg = msg_mod_init();
+		fio = io_init();
+		fdev = dev_init();
+		fcod = cod_init();
+		ret = fdrv && fdev && fchnl && fcod && fmsg && fio;
+		ret = ret && fmgr && fproc && frmm;
+		if (!ret) {
+			if (fdrv)
+				drv_exit();
+
+			if (fmgr)
+				mgr_exit();
+
+			if (fstrm)
+				strm_exit();
+
+			if (fproc)
+				proc_exit();
+
+			if (fnode)
+				node_exit();
+
+			if (fdisp)
+				disp_exit();
+
+			if (fchnl)
+				chnl_exit();
+
+			if (fmsg)
+				msg_exit();
+
+			if (fio)
+				io_exit();
+
+			if (fdev)
+				dev_exit();
+
+			if (fcod)
+				cod_exit();
+
+			if (frmm)
+				rmm_exit();
+
+		}
+	}
+	if (ret)
+		api_c_refs++;
+
+	return ret;
+}
+
+/*
+ *  ======== api_init_complete2 ========
+ *  Purpose:
+ *      Perform any required bridge initialization which cannot
+ *      be performed in api_init() or dev_start_device() due
+ *      to the fact that some services are not yet
+ *      completely initialized.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:	Allow this device to load
+ *      -EPERM:      Failure.
+ *  Requires:
+ *      Bridge API initialized.
+ *  Ensures:
+ */
+dsp_status api_init_complete2(void)
+{
+	dsp_status status = DSP_SOK;
+	struct cfg_devnode *dev_node;
+	struct dev_object *hdev_obj;
+	u8 dev_type;
+	u32 tmp;
+
+	DBC_REQUIRE(api_c_refs > 0);
+
+	/*  Walk the list of DevObjects, get each devnode, and attempting to
+	 *  autostart the board. Note that this requires COF loading, which
+	 *  requires KFILE. */
+	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
+	     hdev_obj = dev_get_next(hdev_obj)) {
+		if (DSP_FAILED(dev_get_dev_node(hdev_obj, &dev_node)))
+			continue;
+
+		if (DSP_FAILED(dev_get_dev_type(hdev_obj, &dev_type)))
+			continue;
+
+		if ((dev_type == DSP_UNIT) || (dev_type == IVA_UNIT))
+			if (cfg_get_auto_start(dev_node, &tmp) == DSP_SOK
+									&& tmp)
+				proc_auto_start(dev_node, hdev_obj);
+	}
+
+	return status;
+}
+
+/* TODO: Remove deprecated and not implemented ioctl wrappers */
+
+/*
+ * ======== mgrwrap_enum_node_info ========
+ */
+u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	u8 *pndb_props;
+	u32 num_nodes;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumnode_info.undb_props_size;
+
+	if (size < sizeof(struct dsp_ndbprops))
+		return -EINVAL;
+
+	pndb_props = kmalloc(size, GFP_KERNEL);
+	if (pndb_props == NULL)
+		status = -ENOMEM;
+
+	if (DSP_SUCCEEDED(status)) {
+		status =
+		    mgr_enum_node_info(args->args_mgr_enumnode_info.node_id,
+				       (struct dsp_ndbprops *)pndb_props, size,
+				       &num_nodes);
+	}
+	CP_TO_USR(args->args_mgr_enumnode_info.pndb_props, pndb_props, status,
+		  size);
+	CP_TO_USR(args->args_mgr_enumnode_info.pu_num_nodes, &num_nodes, status,
+		  1);
+	kfree(pndb_props);
+
+	return status;
+}
+
+/*
+ * ======== mgrwrap_enum_proc_info ========
+ */
+u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	u8 *processor_info;
+	u8 num_procs;
+	dsp_status status = DSP_SOK;
+	u32 size = args->args_mgr_enumproc_info.processor_info_size;
+
+	if (size < sizeof(struct dsp_processorinfo))
+		return -EINVAL;
+
+	processor_info = kmalloc(size, GFP_KERNEL);
+	if (processor_info == NULL)
+		status = -ENOMEM;
+
+	if (DSP_SUCCEEDED(status)) {
+		status =
+		    mgr_enum_processor_info(args->args_mgr_enumproc_info.
+					    processor_id,
+					    (struct dsp_processorinfo *)
+					    processor_info, size, &num_procs);
+	}
+	CP_TO_USR(args->args_mgr_enumproc_info.processor_info, processor_info,
+		  status, size);
+	CP_TO_USR(args->args_mgr_enumproc_info.pu_num_procs, &num_procs,
+		  status, 1);
+	kfree(processor_info);
+
+	return status;
+}
+
+#define WRAP_MAP2CALLER(x) x
+/*
+ * ======== mgrwrap_register_object ========
+ */
+u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+	struct dsp_uuid uuid_obj;
+	u32 path_size = 0;
+	char *psz_path_name = NULL;
+	dsp_status status = DSP_SOK;
+
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* path_size is increased by 1 to accommodate NULL */
+	path_size = strlen_user((char *)
+				args->args_mgr_registerobject.psz_path_name) +
+	    1;
+	psz_path_name = kmalloc(path_size, GFP_KERNEL);
+	if (!psz_path_name)
+		goto func_end;
+	ret = strncpy_from_user(psz_path_name,
+				(char *)args->args_mgr_registerobject.
+				psz_path_name, path_size);
+	if (!ret) {
+		status = -EFAULT;
+		goto func_end;
+	}
+
+	if (args->args_mgr_registerobject.obj_type >= DSP_DCDMAXOBJTYPE)
+		return -EINVAL;
+
+	status = dcd_register_object(&uuid_obj,
+				     args->args_mgr_registerobject.obj_type,
+				     (char *)psz_path_name);
+func_end:
+	kfree(psz_path_name);
+	return status;
+}
+
+/*
+ * ======== mgrwrap_unregister_object ========
+ */
+u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid uuid_obj;
+
+	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = dcd_unregister_object(&uuid_obj,
+				       args->args_mgr_unregisterobject.
+				       obj_type);
+func_end:
+	return status;
+
+}
+
+/*
+ * ======== mgrwrap_wait_for_bridge_events ========
+ */
+u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK, real_status = DSP_SOK;
+	struct dsp_notification *anotifications[MAX_EVENTS];
+	struct dsp_notification notifications[MAX_EVENTS];
+	u32 index, i;
+	u32 count = args->args_mgr_wait.count;
+
+	if (count > MAX_EVENTS)
+		status = -EINVAL;
+
+	/* get the array of pointers to user structures */
+	CP_FM_USR(anotifications, args->args_mgr_wait.anotifications,
+		  status, count);
+	/* get the events */
+	for (i = 0; i < count; i++) {
+		CP_FM_USR(&notifications[i], anotifications[i], status, 1);
+		if (DSP_SUCCEEDED(status)) {
+			/* set the array of pointers to kernel structures */
+			anotifications[i] = &notifications[i];
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		real_status = mgr_wait_for_bridge_events(anotifications, count,
+							 &index,
+							 args->args_mgr_wait.
+							 utimeout);
+	}
+	CP_TO_USR(args->args_mgr_wait.pu_index, &index, status, 1);
+	return real_status;
+}
+
+/*
+ * ======== MGRWRAP_GetProcessResourceInfo ========
+ */
+u32 __deprecated mgrwrap_get_process_resources_info(union Trapped_Args * args,
+						    void *pr_ctxt)
+{
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
+}
+
+/*
+ * ======== procwrap_attach ========
+ */
+u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt)
+{
+	void *processor;
+	dsp_status status = DSP_SOK;
+	struct dsp_processorattrin proc_attr_in, *attr_in = NULL;
+
+	/* Optional argument */
+	if (args->args_proc_attach.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,
+			  1);
+		if (DSP_SUCCEEDED(status))
+			attr_in = &proc_attr_in;
+		else
+			goto func_end;
+
+	}
+	status = proc_attach(args->args_proc_attach.processor_id, attr_in,
+			     &processor, pr_ctxt);
+	CP_TO_USR(args->args_proc_attach.ph_processor, &processor, status, 1);
+func_end:
+	return status;
+}
+
+/*
+ * ======== procwrap_ctrl ========
+ */
+u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 cb_data_size, __user * psize = (u32 __user *)
+	    args->args_proc_ctrl.pargs;
+	u8 *pargs = NULL;
+	dsp_status status = DSP_SOK;
+
+	if (psize) {
+		if (get_user(cb_data_size, psize)) {
+			status = -EPERM;
+			goto func_end;
+		}
+		cb_data_size += sizeof(u32);
+		pargs = kmalloc(cb_data_size, GFP_KERNEL);
+		if (pargs == NULL) {
+			status = -ENOMEM;
+			goto func_end;
+		}
+
+		CP_FM_USR(pargs, args->args_proc_ctrl.pargs, status,
+			  cb_data_size);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
+				   args->args_proc_ctrl.dw_cmd,
+				   (struct dsp_cbdata *)pargs);
+	}
+
+	/* CP_TO_USR(args->args_proc_ctrl.pargs, pargs, status, 1); */
+	kfree(pargs);
+func_end:
+	return status;
+}
+
+/*
+ * ======== procwrap_detach ========
+ */
+u32 __deprecated procwrap_detach(union Trapped_Args * args, void *pr_ctxt)
+{
+	/* proc_detach called at bridge_release only */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
+}
+
+/*
+ * ======== procwrap_enum_node_info ========
+ */
+u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	void *node_tab[MAX_NODES];
+	u32 num_nodes;
+	u32 alloc_cnt;
+
+	if (!args->args_proc_enumnode_info.node_tab_size)
+		return -EINVAL;
+
+	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
+				 node_tab,
+				 args->args_proc_enumnode_info.node_tab_size,
+				 &num_nodes, &alloc_cnt);
+	CP_TO_USR(args->args_proc_enumnode_info.node_tab, node_tab, status,
+		  num_nodes);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_num_nodes, &num_nodes,
+		  status, 1);
+	CP_TO_USR(args->args_proc_enumnode_info.pu_allocated, &alloc_cnt,
+		  status, 1);
+	return status;
+}
+
+/*
+ * ======== procwrap_flush_memory ========
+ */
+u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+
+	if (args->args_proc_flushmemory.ul_flags >
+	    PROC_WRITEBACK_INVALIDATE_MEM)
+		return -EINVAL;
+
+	status = proc_flush_memory(args->args_proc_flushmemory.hprocessor,
+				   args->args_proc_flushmemory.pmpu_addr,
+				   args->args_proc_flushmemory.ul_size,
+				   args->args_proc_flushmemory.ul_flags);
+	return status;
+}
+
+/*
+ * ======== procwrap_invalidate_memory ========
+ */
+u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+
+	status =
+	    proc_invalidate_memory(args->args_proc_invalidatememory.hprocessor,
+				   args->args_proc_invalidatememory.pmpu_addr,
+				   args->args_proc_invalidatememory.ul_size);
+	return status;
+}
+
+/*
+ * ======== procwrap_enum_resources ========
+ */
+u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_resourceinfo resource_info;
+
+	if (args->args_proc_enumresources.resource_info_size <
+	    sizeof(struct dsp_resourceinfo))
+		return -EINVAL;
+
+	status =
+	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
+				   args->args_proc_enumresources.resource_type,
+				   &resource_info,
+				   args->args_proc_enumresources.
+				   resource_info_size);
+
+	CP_TO_USR(args->args_proc_enumresources.resource_info, &resource_info,
+		  status, 1);
+
+	return status;
+
+}
+
+/*
+ * ======== procwrap_get_state ========
+ */
+u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	struct dsp_processorstate proc_state;
+
+	if (args->args_proc_getstate.state_info_size <
+	    sizeof(struct dsp_processorstate))
+		return -EINVAL;
+
+	status =
+	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
+			   args->args_proc_getstate.state_info_size);
+	CP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,
+		  1);
+	return status;
+
+}
+
+/*
+ * ======== procwrap_get_trace ========
+ */
+u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	u8 *pbuf;
+
+	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
+		return -EINVAL;
+
+	pbuf = kzalloc(args->args_proc_gettrace.max_size, GFP_KERNEL);
+	if (pbuf != NULL) {
+		status = proc_get_trace(args->args_proc_gettrace.hprocessor,
+					pbuf,
+					args->args_proc_gettrace.max_size);
+	} else {
+		status = -ENOMEM;
+	}
+	CP_TO_USR(args->args_proc_gettrace.pbuf, pbuf, status,
+		  args->args_proc_gettrace.max_size);
+	kfree(pbuf);
+
+	return status;
+}
+
+/*
+ * ======== procwrap_load ========
+ */
+u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
+{
+	s32 i, len;
+	dsp_status status = DSP_SOK;
+	char *temp;
+	s32 count = args->args_proc_load.argc_index;
+	u8 **argv = NULL, **envp = NULL;
+
+	if (count <= 0 || count > MAX_LOADARGS) {
+		status = -EINVAL;
+		goto func_cont;
+	}
+
+	argv = kmalloc(count * sizeof(u8 *), GFP_KERNEL);
+	if (!argv) {
+		status = -ENOMEM;
+		goto func_cont;
+	}
+
+	CP_FM_USR(argv, args->args_proc_load.user_args, status, count);
+	if (DSP_FAILED(status)) {
+		kfree(argv);
+		argv = NULL;
+		goto func_cont;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (argv[i]) {
+			/* User space pointer to argument */
+			temp = (char *)argv[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
+			/* Kernel space pointer to argument */
+			argv[i] = kmalloc(len, GFP_KERNEL);
+			if (argv[i]) {
+				CP_FM_USR(argv[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					kfree(argv[i]);
+					argv[i] = NULL;
+					goto func_cont;
+				}
+			} else {
+				status = -ENOMEM;
+				goto func_cont;
+			}
+		}
+	}
+	/* TODO: validate this */
+	if (args->args_proc_load.user_envp) {
+		/* number of elements in the envp array including NULL */
+		count = 0;
+		do {
+			get_user(temp, args->args_proc_load.user_envp + count);
+			count++;
+		} while (temp);
+		envp = kmalloc(count * sizeof(u8 *), GFP_KERNEL);
+		if (!envp) {
+			status = -ENOMEM;
+			goto func_cont;
+		}
+
+		CP_FM_USR(envp, args->args_proc_load.user_envp, status, count);
+		if (DSP_FAILED(status)) {
+			kfree(envp);
+			envp = NULL;
+			goto func_cont;
+		}
+		for (i = 0; envp[i]; i++) {
+			/* User space pointer to argument */
+			temp = (char *)envp[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
+			/* Kernel space pointer to argument */
+			envp[i] = kmalloc(len, GFP_KERNEL);
+			if (envp[i]) {
+				CP_FM_USR(envp[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					kfree(envp[i]);
+					envp[i] = NULL;
+					goto func_cont;
+				}
+			} else {
+				status = -ENOMEM;
+				goto func_cont;
+			}
+		}
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		status = proc_load(args->args_proc_load.hprocessor,
+				   args->args_proc_load.argc_index,
+				   (CONST char **)argv, (CONST char **)envp);
+	}
+func_cont:
+	if (envp) {
+		i = 0;
+		while (envp[i])
+			kfree(envp[i++]);
+
+		kfree(envp);
+	}
+
+	if (argv) {
+		count = args->args_proc_load.argc_index;
+		for (i = 0; (i < count) && argv[i]; i++)
+			kfree(argv[i]);
+
+		kfree(argv);
+	}
+
+	return status;
+}
+
+/*
+ * ======== procwrap_map ========
+ */
+u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	void *map_addr;
+
+	if (!args->args_proc_mapmem.ul_size)
+		return -EINVAL;
+
+	status = proc_map(args->args_proc_mapmem.hprocessor,
+			  args->args_proc_mapmem.pmpu_addr,
+			  args->args_proc_mapmem.ul_size,
+			  args->args_proc_mapmem.req_addr, &map_addr,
+			  args->args_proc_mapmem.ul_map_attr, pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
+			status = -EINVAL;
+			proc_un_map(args->args_proc_mapmem.hprocessor,
+				    map_addr, pr_ctxt);
+		}
+
+	}
+	return status;
+}
+
+/*
+ * ======== procwrap_register_notify ========
+ */
+u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	struct dsp_notification notification;
+
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
+	notification.handle = NULL;
+
+	status =
+	    proc_register_notify(args->args_proc_register_notify.hprocessor,
+				 args->args_proc_register_notify.event_mask,
+				 args->args_proc_register_notify.notify_type,
+				 &notification);
+	CP_TO_USR(args->args_proc_register_notify.hnotification, &notification,
+		  status, 1);
+	return status;
+}
+
+/*
+ * ======== procwrap_reserve_memory ========
+ */
+u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	void *prsv_addr;
+
+	if ((args->args_proc_rsvmem.ul_size <= 0) ||
+	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
+		return -EINVAL;
+
+	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
+				     args->args_proc_rsvmem.ul_size, &prsv_addr,
+				     pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
+			status = -EINVAL;
+			proc_un_reserve_memory(args->args_proc_rsvmem.
+					       hprocessor, prsv_addr, pr_ctxt);
+		}
+	}
+	return status;
+}
+
+/*
+ * ======== procwrap_start ========
+ */
+u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = proc_start(args->args_proc_start.hprocessor);
+	return ret;
+}
+
+/*
+ * ======== procwrap_un_map ========
+ */
+u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+
+	status = proc_un_map(args->args_proc_unmapmem.hprocessor,
+			     args->args_proc_unmapmem.map_addr, pr_ctxt);
+	return status;
+}
+
+/*
+ * ======== procwrap_un_reserve_memory ========
+ */
+u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+
+	status = proc_un_reserve_memory(args->args_proc_unrsvmem.hprocessor,
+					args->args_proc_unrsvmem.prsv_addr,
+					pr_ctxt);
+	return status;
+}
+
+/*
+ * ======== procwrap_stop ========
+ */
+u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = proc_stop(args->args_proc_stop.hprocessor);
+
+	return ret;
+}
+
+/*
+ * ======== nodewrap_allocate ========
+ */
+u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	u32 cb_data_size = 0;
+	u32 __user *psize = (u32 __user *) args->args_node_allocate.pargs;
+	u8 *pargs = NULL;
+	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
+	struct node_object *hnode;
+
+	/* Optional argument */
+	if (psize) {
+		if (get_user(cb_data_size, psize))
+			status = -EPERM;
+
+		cb_data_size += sizeof(u32);
+		if (DSP_SUCCEEDED(status)) {
+			pargs = kmalloc(cb_data_size, GFP_KERNEL);
+			if (pargs == NULL)
+				status = -ENOMEM;
+
+		}
+		CP_FM_USR(pargs, args->args_node_allocate.pargs, status,
+			  cb_data_size);
+	}
+	CP_FM_USR(&node_uuid, args->args_node_allocate.node_id_ptr, status, 1);
+	if (DSP_FAILED(status))
+		goto func_cont;
+	/* Optional argument */
+	if (args->args_node_allocate.attr_in) {
+		CP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,
+			  status, 1);
+		if (DSP_SUCCEEDED(status))
+			attr_in = &proc_attr_in;
+		else
+			status = -ENOMEM;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = node_allocate(args->args_node_allocate.hprocessor,
+				       &node_uuid, (struct dsp_cbdata *)pargs,
+				       attr_in, &hnode, pr_ctxt);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
+		if (DSP_FAILED(status)) {
+			status = -EFAULT;
+			node_delete(hnode, pr_ctxt);
+		}
+	}
+func_cont:
+	kfree(pargs);
+
+	return status;
+}
+
+/*
+ *  ======== nodewrap_alloc_msg_buf ========
+ */
+u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	u8 *pbuffer = NULL;
+
+	if (!args->args_node_allocmsgbuf.usize)
+		return -EINVAL;
+
+	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pattr = &attr;
+
+	}
+	/* IN OUT argument */
+	CP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.pbuffer, status, 1);
+	if (DSP_SUCCEEDED(status)) {
+		status = node_alloc_msg_buf(args->args_node_allocmsgbuf.hnode,
+					    args->args_node_allocmsgbuf.usize,
+					    pattr, &pbuffer);
+	}
+	CP_TO_USR(args->args_node_allocmsgbuf.pbuffer, &pbuffer, status, 1);
+	return status;
+}
+
+/*
+ * ======== nodewrap_change_priority ========
+ */
+u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = node_change_priority(args->args_node_changepriority.hnode,
+				   args->args_node_changepriority.prio);
+
+	return ret;
+}
+
+/*
+ * ======== nodewrap_connect ========
+ */
+u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_strmattr attrs;
+	struct dsp_strmattr *pattrs = NULL;
+	u32 cb_data_size;
+	u32 __user *psize = (u32 __user *) args->args_node_connect.conn_param;
+	u8 *pargs = NULL;
+
+	/* Optional argument */
+	if (psize) {
+		if (get_user(cb_data_size, psize))
+			status = -EPERM;
+
+		cb_data_size += sizeof(u32);
+		if (DSP_SUCCEEDED(status)) {
+			pargs = kmalloc(cb_data_size, GFP_KERNEL);
+			if (pargs == NULL) {
+				status = -ENOMEM;
+				goto func_cont;
+			}
+
+		}
+		CP_FM_USR(pargs, args->args_node_connect.conn_param, status,
+			  cb_data_size);
+		if (DSP_FAILED(status))
+			goto func_cont;
+	}
+	if (args->args_node_connect.pattrs) {	/* Optional argument */
+		CP_FM_USR(&attrs, args->args_node_connect.pattrs, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pattrs = &attrs;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = node_connect(args->args_node_connect.hnode,
+				      args->args_node_connect.stream_id,
+				      args->args_node_connect.other_node,
+				      args->args_node_connect.other_stream,
+				      pattrs, (struct dsp_cbdata *)pargs);
+	}
+func_cont:
+	kfree(pargs);
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_create ========
+ */
+u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = node_create(args->args_node_create.hnode);
+
+	return ret;
+}
+
+/*
+ * ======== nodewrap_delete ========
+ */
+u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = node_delete(args->args_node_delete.hnode, pr_ctxt);
+
+	return ret;
+}
+
+/*
+ *  ======== nodewrap_free_msg_buf ========
+ */
+u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_bufferattr *pattr = NULL;
+	struct dsp_bufferattr attr;
+	if (args->args_node_freemsgbuf.pattr) {	/* Optional argument */
+		CP_FM_USR(&attr, args->args_node_freemsgbuf.pattr, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pattr = &attr;
+
+	}
+
+	if (!args->args_node_freemsgbuf.pbuffer)
+		return -EFAULT;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
+					   args->args_node_freemsgbuf.pbuffer,
+					   pattr);
+	}
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_get_attr ========
+ */
+u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_nodeattr attr;
+
+	status = node_get_attr(args->args_node_getattr.hnode, &attr,
+			       args->args_node_getattr.attr_size);
+	CP_TO_USR(args->args_node_getattr.pattr, &attr, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_get_message ========
+ */
+u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	struct dsp_msg msg;
+
+	status = node_get_message(args->args_node_getmessage.hnode, &msg,
+				  args->args_node_getmessage.utimeout);
+
+	CP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_pause ========
+ */
+u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = node_pause(args->args_node_pause.hnode);
+
+	return ret;
+}
+
+/*
+ * ======== nodewrap_put_message ========
+ */
+u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_msg msg;
+
+	CP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);
+
+	if (DSP_SUCCEEDED(status)) {
+		status =
+		    node_put_message(args->args_node_putmessage.hnode, &msg,
+				     args->args_node_putmessage.utimeout);
+	}
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_register_notify ========
+ */
+u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
+
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
+	notification.handle = NULL;
+
+	if (!args->args_proc_register_notify.event_mask)
+		CP_FM_USR(&notification,
+			  args->args_proc_register_notify.hnotification,
+			  status, 1);
+
+	status = node_register_notify(args->args_node_registernotify.hnode,
+				      args->args_node_registernotify.event_mask,
+				      args->args_node_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_node_registernotify.hnotification, &notification,
+		  status, 1);
+	return status;
+}
+
+/*
+ * ======== nodewrap_run ========
+ */
+u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = node_run(args->args_node_run.hnode);
+
+	return ret;
+}
+
+/*
+ * ======== nodewrap_terminate ========
+ */
+u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	dsp_status tempstatus;
+
+	status = node_terminate(args->args_node_terminate.hnode, &tempstatus);
+
+	CP_TO_USR(args->args_node_terminate.pstatus, &tempstatus, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== nodewrap_get_uuid_props ========
+ */
+u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_uuid node_uuid;
+	struct dsp_ndbprops *pnode_props = NULL;
+
+	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
+		  1);
+	if (DSP_FAILED(status))
+		goto func_cont;
+	pnode_props = kmalloc(sizeof(struct dsp_ndbprops), GFP_KERNEL);
+	if (pnode_props != NULL) {
+		status =
+		    node_get_uuid_props(args->args_node_getuuidprops.hprocessor,
+					&node_uuid, pnode_props);
+		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
+			  status, 1);
+	} else
+		status = -ENOMEM;
+func_cont:
+	kfree(pnode_props);
+	return status;
+}
+
+/*
+ * ======== strmwrap_allocate_buffer ========
+ */
+u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_allocatebuffer.num_bufs;
+
+	if (num_bufs > MAX_BUFS)
+		return -EINVAL;
+
+	ap_buffer = kmalloc((num_bufs * sizeof(u8 *)), GFP_KERNEL);
+
+	status = strm_allocate_buffer(args->args_strm_allocatebuffer.hstream,
+				      args->args_strm_allocatebuffer.usize,
+				      ap_buffer, num_bufs, pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
+			  status, num_bufs);
+		if (DSP_FAILED(status)) {
+			status = -EFAULT;
+			strm_free_buffer(args->args_strm_allocatebuffer.hstream,
+					 ap_buffer, num_bufs, pr_ctxt);
+		}
+	}
+	kfree(ap_buffer);
+
+	return status;
+}
+
+/*
+ * ======== strmwrap_close ========
+ */
+u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt)
+{
+	return strm_close(args->args_strm_close.hstream, pr_ctxt);
+}
+
+/*
+ * ======== strmwrap_free_buffer ========
+ */
+u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	u8 **ap_buffer = NULL;
+	u32 num_bufs = args->args_strm_freebuffer.num_bufs;
+
+	if (num_bufs > MAX_BUFS)
+		return -EINVAL;
+
+	ap_buffer = kmalloc((num_bufs * sizeof(u8 *)), GFP_KERNEL);
+
+	CP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,
+		  num_bufs);
+
+	if (DSP_SUCCEEDED(status)) {
+		status = strm_free_buffer(args->args_strm_freebuffer.hstream,
+					  ap_buffer, num_bufs, pr_ctxt);
+	}
+	CP_TO_USR(args->args_strm_freebuffer.ap_buffer, ap_buffer, status,
+		  num_bufs);
+	kfree(ap_buffer);
+
+	return status;
+}
+
+/*
+ * ======== strmwrap_get_event_handle ========
+ */
+u32 __deprecated strmwrap_get_event_handle(union Trapped_Args * args,
+					   void *pr_ctxt)
+{
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return -ENOSYS;
+}
+
+/*
+ * ======== strmwrap_get_info ========
+ */
+u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct stream_info strm_info;
+	struct dsp_streaminfo user;
+	struct dsp_streaminfo *temp;
+
+	CP_FM_USR(&strm_info, args->args_strm_getinfo.stream_info, status, 1);
+	temp = strm_info.user_strm;
+
+	strm_info.user_strm = &user;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = strm_get_info(args->args_strm_getinfo.hstream,
+				       &strm_info,
+				       args->args_strm_getinfo.
+				       stream_info_size);
+	}
+	CP_TO_USR(temp, strm_info.user_strm, status, 1);
+	strm_info.user_strm = temp;
+	CP_TO_USR(args->args_strm_getinfo.stream_info, &strm_info, status, 1);
+	return status;
+}
+
+/*
+ * ======== strmwrap_idle ========
+ */
+u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 ret;
+
+	ret = strm_idle(args->args_strm_idle.hstream,
+			args->args_strm_idle.flush_flag);
+
+	return ret;
+}
+
+/*
+ * ======== strmwrap_issue ========
+ */
+u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+
+	if (!args->args_strm_issue.pbuffer)
+		return -EFAULT;
+
+	/* No need of doing CP_FM_USR for the user buffer (pbuffer)
+	   as this is done in Bridge internal function bridge_chnl_add_io_req
+	   in chnl_sm.c */
+	status = strm_issue(args->args_strm_issue.hstream,
+			    args->args_strm_issue.pbuffer,
+			    args->args_strm_issue.dw_bytes,
+			    args->args_strm_issue.dw_buf_size,
+			    args->args_strm_issue.dw_arg);
+
+	return status;
+}
+
+/*
+ * ======== strmwrap_open ========
+ */
+u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct strm_attr attr;
+	struct strm_object *strm_obj;
+	struct dsp_streamattrin strm_attr_in;
+
+	CP_FM_USR(&attr, args->args_strm_open.attr_in, status, 1);
+
+	if (attr.stream_attr_in != NULL) {	/* Optional argument */
+		CP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);
+		if (DSP_SUCCEEDED(status)) {
+			attr.stream_attr_in = &strm_attr_in;
+			if (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)
+				return -ENOSYS;
+		}
+
+	}
+	status = strm_open(args->args_strm_open.hnode,
+			   args->args_strm_open.direction,
+			   args->args_strm_open.index, &attr, &strm_obj,
+			   pr_ctxt);
+	CP_TO_USR(args->args_strm_open.ph_stream, &strm_obj, status, 1);
+	return status;
+}
+
+/*
+ * ======== strmwrap_reclaim ========
+ */
+u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	u8 *buf_ptr;
+	u32 ul_bytes;
+	u32 dw_arg;
+	u32 ul_buf_size;
+
+	status = strm_reclaim(args->args_strm_reclaim.hstream, &buf_ptr,
+			      &ul_bytes, &ul_buf_size, &dw_arg);
+	CP_TO_USR(args->args_strm_reclaim.buf_ptr, &buf_ptr, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.bytes, &ul_bytes, status, 1);
+	CP_TO_USR(args->args_strm_reclaim.pdw_arg, &dw_arg, status, 1);
+
+	if (args->args_strm_reclaim.buf_size_ptr != NULL) {
+		CP_TO_USR(args->args_strm_reclaim.buf_size_ptr, &ul_buf_size,
+			  status, 1);
+	}
+
+	return status;
+}
+
+/*
+ * ======== strmwrap_register_notify ========
+ */
+u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct dsp_notification notification;
+
+	/* Initialize the notification data structure */
+	notification.ps_name = NULL;
+	notification.handle = NULL;
+
+	status = strm_register_notify(args->args_strm_registernotify.hstream,
+				      args->args_strm_registernotify.event_mask,
+				      args->args_strm_registernotify.
+				      notify_type, &notification);
+	CP_TO_USR(args->args_strm_registernotify.hnotification, &notification,
+		  status, 1);
+
+	return status;
+}
+
+/*
+ * ======== strmwrap_select ========
+ */
+u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 mask;
+	struct strm_object *strm_tab[MAX_STREAMS];
+	dsp_status status = DSP_SOK;
+
+	if (args->args_strm_select.strm_num > MAX_STREAMS)
+		return -EINVAL;
+
+	CP_FM_USR(strm_tab, args->args_strm_select.stream_tab, status,
+		  args->args_strm_select.strm_num);
+	if (DSP_SUCCEEDED(status)) {
+		status = strm_select(strm_tab, args->args_strm_select.strm_num,
+				     &mask, args->args_strm_select.utimeout);
+	}
+	CP_TO_USR(args->args_strm_select.pmask, &mask, status, 1);
+	return status;
+}
+
+/* CMM */
+
+/*
+ * ======== cmmwrap_calloc_buf ========
+ */
+u32 __deprecated cmmwrap_calloc_buf(union Trapped_Args * args, void *pr_ctxt)
+{
+	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return -ENOSYS;
+}
+
+/*
+ * ======== cmmwrap_free_buf ========
+ */
+u32 __deprecated cmmwrap_free_buf(union Trapped_Args * args, void *pr_ctxt)
+{
+	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return -ENOSYS;
+}
+
+/*
+ * ======== cmmwrap_get_handle ========
+ */
+u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct cmm_object *hcmm_mgr;
+
+	status = cmm_get_handle(args->args_cmm_gethandle.hprocessor, &hcmm_mgr);
+
+	CP_TO_USR(args->args_cmm_gethandle.ph_cmm_mgr, &hcmm_mgr, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== cmmwrap_get_info ========
+ */
+u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
+{
+	dsp_status status = DSP_SOK;
+	struct cmm_info cmm_info_obj;
+
+	status = cmm_get_info(args->args_cmm_getinfo.hcmm_mgr, &cmm_info_obj);
+
+	CP_TO_USR(args->args_cmm_getinfo.cmm_info_obj, &cmm_info_obj, status,
+		  1);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/pmgr/ioobj.h b/drivers/dsp/bridge/pmgr/ioobj.h
index 2986b91..010ddcf 100644
--- a/drivers/dsp/bridge/pmgr/ioobj.h
+++ b/drivers/dsp/bridge/pmgr/ioobj.h
@@ -21,7 +21,7 @@
 #define IOOBJ_
 
 #include <dspbridge/devdefs.h>
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /*
  *  This struct is the first field in a io_mgr struct, as implemented in
diff --git a/drivers/dsp/bridge/pmgr/msg.c b/drivers/dsp/bridge/pmgr/msg.c
index 78bfb46..95848a6 100644
--- a/drivers/dsp/bridge/pmgr/msg.c
+++ b/drivers/dsp/bridge/pmgr/msg.c
@@ -28,7 +28,7 @@
 #include <dspbridge/dbc.h>
 
 /*  ----------------------------------- Mini Driver */
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
diff --git a/drivers/dsp/bridge/pmgr/msgobj.h b/drivers/dsp/bridge/pmgr/msgobj.h
index 3eb1098..d19e26b 100644
--- a/drivers/dsp/bridge/pmgr/msgobj.h
+++ b/drivers/dsp/bridge/pmgr/msgobj.h
@@ -20,7 +20,7 @@
 #ifndef MSGOBJ_
 #define MSGOBJ_
 
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 #include <dspbridge/msgdefs.h>
 
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
deleted file mode 100644
index 7685eb5..0000000
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ /dev/null
@@ -1,1656 +0,0 @@
-/*
- * wcd.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Common WCD functions, also includes the wrapper
- * functions called directly by the DeviceIOControl interface.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-/*  ----------------------------------- Host OS */
-#include <dspbridge/host_os.h>
-
-/*  ----------------------------------- DSP/BIOS Bridge */
-#include <dspbridge/std.h>
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-/*  ----------------------------------- Trace & Debug */
-#include <dspbridge/dbc.h>
-
-/*  ----------------------------------- OS Adaptation Layer */
-#include <dspbridge/cfg.h>
-#include <dspbridge/ntfy.h>
-#include <dspbridge/services.h>
-
-/*  ----------------------------------- Platform Manager */
-#include <dspbridge/chnl.h>
-#include <dspbridge/dev.h>
-#include <dspbridge/drv.h>
-
-#include <dspbridge/proc.h>
-#include <dspbridge/strm.h>
-
-/*  ----------------------------------- Resource Manager */
-#include <dspbridge/disp.h>
-#include <dspbridge/mgr.h>
-#include <dspbridge/node.h>
-#include <dspbridge/rmm.h>
-
-/*  ----------------------------------- Others */
-#include <dspbridge/msg.h>
-#include <dspbridge/cmm.h>
-#include <dspbridge/io.h>
-
-/*  ----------------------------------- This */
-#include <dspbridge/_dcd.h>
-#include <dspbridge/dbdcd.h>
-
-#include <dspbridge/resourcecleanup.h>
-
-/*  ----------------------------------- Defines, Data Structures, Typedefs */
-#define MAX_TRACEBUFLEN 255
-#define MAX_LOADARGS    16
-#define MAX_NODES       64
-#define MAX_STREAMS     16
-#define MAX_BUFS	64
-
-/* Used to get dspbridge ioctl table */
-#define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
-
-/* Device IOCtl function pointer */
-struct api_cmd {
-	u32(*fxn) (union Trapped_Args *args, void *pr_ctxt);
-	u32 dw_index;
-};
-
-/*  ----------------------------------- Globals */
-static u32 api_c_refs;
-
-/*
- *  Function tables.
- *  The order of these functions MUST be the same as the order of the command
- *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
- *  turns into a function call in kernel mode.
- */
-
-/* MGR wrapper functions */
-static struct api_cmd mgr_cmd[] = {
-	{mgrwrap_enum_node_info},	/* MGR_ENUMNODE_INFO */
-	{mgrwrap_enum_proc_info},	/* MGR_ENUMPROC_INFO */
-	{mgrwrap_register_object},	/* MGR_REGISTEROBJECT */
-	{mgrwrap_unregister_object},	/* MGR_UNREGISTEROBJECT */
-	{mgrwrap_wait_for_bridge_events},	/* MGR_WAIT */
-	{mgrwrap_get_process_resources_info},	/* MGR_GET_PROC_RES */
-};
-
-/* PROC wrapper functions */
-static struct api_cmd proc_cmd[] = {
-	{procwrap_attach},	/* PROC_ATTACH */
-	{procwrap_ctrl},	/* PROC_CTRL */
-	{procwrap_detach},	/* PROC_DETACH */
-	{procwrap_enum_node_info},	/* PROC_ENUMNODE */
-	{procwrap_enum_resources},	/* PROC_ENUMRESOURCES */
-	{procwrap_get_state},	/* PROC_GET_STATE */
-	{procwrap_get_trace},	/* PROC_GET_TRACE */
-	{procwrap_load},	/* PROC_LOAD */
-	{procwrap_register_notify},	/* PROC_REGISTERNOTIFY */
-	{procwrap_start},	/* PROC_START */
-	{procwrap_reserve_memory},	/* PROC_RSVMEM */
-	{procwrap_un_reserve_memory},	/* PROC_UNRSVMEM */
-	{procwrap_map},		/* PROC_MAPMEM */
-	{procwrap_un_map},	/* PROC_UNMAPMEM */
-	{procwrap_flush_memory},	/* PROC_FLUSHMEMORY */
-	{procwrap_stop},	/* PROC_STOP */
-	{procwrap_invalidate_memory},	/* PROC_INVALIDATEMEMORY */
-};
-
-/* NODE wrapper functions */
-static struct api_cmd node_cmd[] = {
-	{nodewrap_allocate},	/* NODE_ALLOCATE */
-	{nodewrap_alloc_msg_buf},	/* NODE_ALLOCMSGBUF */
-	{nodewrap_change_priority},	/* NODE_CHANGEPRIORITY */
-	{nodewrap_connect},	/* NODE_CONNECT */
-	{nodewrap_create},	/* NODE_CREATE */
-	{nodewrap_delete},	/* NODE_DELETE */
-	{nodewrap_free_msg_buf},	/* NODE_FREEMSGBUF */
-	{nodewrap_get_attr},	/* NODE_GETATTR */
-	{nodewrap_get_message},	/* NODE_GETMESSAGE */
-	{nodewrap_pause},	/* NODE_PAUSE */
-	{nodewrap_put_message},	/* NODE_PUTMESSAGE */
-	{nodewrap_register_notify},	/* NODE_REGISTERNOTIFY */
-	{nodewrap_run},		/* NODE_RUN */
-	{nodewrap_terminate},	/* NODE_TERMINATE */
-	{nodewrap_get_uuid_props},	/* NODE_GETUUIDPROPS */
-};
-
-/* STRM wrapper functions */
-static struct api_cmd strm_cmd[] = {
-	{strmwrap_allocate_buffer},	/* STRM_ALLOCATEBUFFER */
-	{strmwrap_close},	/* STRM_CLOSE */
-	{strmwrap_free_buffer},	/* STRM_FREEBUFFER */
-	{strmwrap_get_event_handle},	/* STRM_GETEVENTHANDLE */
-	{strmwrap_get_info},	/* STRM_GETINFO */
-	{strmwrap_idle},	/* STRM_IDLE */
-	{strmwrap_issue},	/* STRM_ISSUE */
-	{strmwrap_open},	/* STRM_OPEN */
-	{strmwrap_reclaim},	/* STRM_RECLAIM */
-	{strmwrap_register_notify},	/* STRM_REGISTERNOTIFY */
-	{strmwrap_select},	/* STRM_SELECT */
-};
-
-/* CMM wrapper functions */
-static struct api_cmd cmm_cmd[] = {
-	{cmmwrap_calloc_buf},	/* CMM_ALLOCBUF */
-	{cmmwrap_free_buf},	/* CMM_FREEBUF */
-	{cmmwrap_get_handle},	/* CMM_GETHANDLE */
-	{cmmwrap_get_info},	/* CMM_GETINFO */
-};
-
-/* Array used to store ioctl table sizes. It can hold up to 8 entries */
-static u8 size_cmd[] = {
-	ARRAY_SIZE(mgr_cmd),
-	ARRAY_SIZE(proc_cmd),
-	ARRAY_SIZE(node_cmd),
-	ARRAY_SIZE(strm_cmd),
-	ARRAY_SIZE(cmm_cmd),
-};
-
-static inline void _cp_fm_usr(void *to, const void __user * from,
-			      dsp_status *err, unsigned long bytes)
-{
-	if (DSP_FAILED(*err))
-		return;
-
-	if (unlikely(!from)) {
-		*err = -EFAULT;
-		return;
-	}
-
-	if (unlikely(copy_from_user(to, from, bytes)))
-		*err = -EFAULT;
-}
-
-#define CP_FM_USR(to, from, err, n)				\
-	_cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
-
-static inline void _cp_to_usr(void __user *to, const void *from,
-			      dsp_status *err, unsigned long bytes)
-{
-	if (DSP_FAILED(*err))
-		return;
-
-	if (unlikely(!to)) {
-		*err = -EFAULT;
-		return;
-	}
-
-	if (unlikely(copy_to_user(to, from, bytes)))
-		*err = -EFAULT;
-}
-
-#define CP_TO_USR(to, from, err, n)				\
-	_cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
-
-/*
- *  ======== api_call_dev_ioctl ========
- *  Purpose:
- *      Call the (wrapper) function for the corresponding API IOCTL.
- */
-inline dsp_status api_call_dev_ioctl(u32 cmd, union Trapped_Args *args,
-				      u32 *result, void *pr_ctxt)
-{
-	u32(*ioctl_cmd) (union Trapped_Args *args, void *pr_ctxt) = NULL;
-	int i;
-
-	if (_IOC_TYPE(cmd) != DB) {
-		pr_err("%s: Incompatible dspbridge ioctl number\n", __func__);
-		goto err;
-	}
-
-	if (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {
-		pr_err("%s: undefined ioctl module\n", __func__);
-		goto err;
-	}
-
-	/* Check the size of the required cmd table */
-	i = DB_GET_IOC(cmd);
-	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
-		pr_err("%s: requested ioctl %d out of bounds for table %d\n",
-		       __func__, i, DB_GET_IOC_TABLE(cmd));
-		goto err;
-	}
-
-	switch (DB_GET_MODULE(cmd)) {
-	case DB_MGR:
-		ioctl_cmd = mgr_cmd[i].fxn;
-		break;
-	case DB_PROC:
-		ioctl_cmd = proc_cmd[i].fxn;
-		break;
-	case DB_NODE:
-		ioctl_cmd = node_cmd[i].fxn;
-		break;
-	case DB_STRM:
-		ioctl_cmd = strm_cmd[i].fxn;
-		break;
-	case DB_CMM:
-		ioctl_cmd = cmm_cmd[i].fxn;
-		break;
-	}
-
-	if (!ioctl_cmd) {
-		pr_err("%s: requested ioctl not defined\n", __func__);
-		goto err;
-	} else {
-		*result = (*ioctl_cmd) (args, pr_ctxt);
-	}
-
-	return DSP_SOK;
-
-err:
-	return -EINVAL;
-}
-
-/*
- *  ======== api_exit ========
- */
-void api_exit(void)
-{
-	DBC_REQUIRE(api_c_refs > 0);
-	api_c_refs--;
-
-	if (api_c_refs == 0) {
-		/* Release all modules initialized in api_init(). */
-		cod_exit();
-		dev_exit();
-		chnl_exit();
-		msg_exit();
-		io_exit();
-		strm_exit();
-		disp_exit();
-		node_exit();
-		proc_exit();
-		mgr_exit();
-		rmm_exit();
-		drv_exit();
-	}
-	DBC_ENSURE(api_c_refs >= 0);
-}
-
-/*
- *  ======== api_init ========
- *  Purpose:
- *      Module initialization used by Bridge API.
- */
-bool api_init(void)
-{
-	bool ret = true;
-	bool fdrv, fdev, fcod, fchnl, fmsg, fio;
-	bool fmgr, fproc, fnode, fdisp, fstrm, frmm;
-
-	if (api_c_refs == 0) {
-		/* initialize driver and other modules */
-		fdrv = drv_init();
-		fmgr = mgr_init();
-		fproc = proc_init();
-		fnode = node_init();
-		fdisp = disp_init();
-		fstrm = strm_init();
-		frmm = rmm_init();
-		fchnl = chnl_init();
-		fmsg = msg_mod_init();
-		fio = io_init();
-		fdev = dev_init();
-		fcod = cod_init();
-		ret = fdrv && fdev && fchnl && fcod && fmsg && fio;
-		ret = ret && fmgr && fproc && frmm;
-		if (!ret) {
-			if (fdrv)
-				drv_exit();
-
-			if (fmgr)
-				mgr_exit();
-
-			if (fstrm)
-				strm_exit();
-
-			if (fproc)
-				proc_exit();
-
-			if (fnode)
-				node_exit();
-
-			if (fdisp)
-				disp_exit();
-
-			if (fchnl)
-				chnl_exit();
-
-			if (fmsg)
-				msg_exit();
-
-			if (fio)
-				io_exit();
-
-			if (fdev)
-				dev_exit();
-
-			if (fcod)
-				cod_exit();
-
-			if (frmm)
-				rmm_exit();
-
-		}
-	}
-	if (ret)
-		api_c_refs++;
-
-	return ret;
-}
-
-/*
- *  ======== api_init_complete2 ========
- *  Purpose:
- *      Perform any required bridge initialization which cannot
- *      be performed in api_init() or dev_start_device() due
- *      to the fact that some services are not yet
- *      completely initialized.
- *  Parameters:
- *  Returns:
- *      DSP_SOK:	Allow this device to load
- *      -EPERM:      Failure.
- *  Requires:
- *      Bridge API initialized.
- *  Ensures:
- */
-dsp_status api_init_complete2(void)
-{
-	dsp_status status = DSP_SOK;
-	struct cfg_devnode *dev_node;
-	struct dev_object *hdev_obj;
-	u8 dev_type;
-	u32 tmp;
-
-	DBC_REQUIRE(api_c_refs > 0);
-
-	/*  Walk the list of DevObjects, get each devnode, and attempting to
-	 *  autostart the board. Note that this requires COF loading, which
-	 *  requires KFILE. */
-	for (hdev_obj = dev_get_first(); hdev_obj != NULL;
-	     hdev_obj = dev_get_next(hdev_obj)) {
-		if (DSP_FAILED(dev_get_dev_node(hdev_obj, &dev_node)))
-			continue;
-
-		if (DSP_FAILED(dev_get_dev_type(hdev_obj, &dev_type)))
-			continue;
-
-		if ((dev_type == DSP_UNIT) || (dev_type == IVA_UNIT))
-			if (cfg_get_auto_start(dev_node, &tmp) == DSP_SOK
-									&& tmp)
-				proc_auto_start(dev_node, hdev_obj);
-	}
-
-	return status;
-}
-
-/* TODO: Remove deprecated and not implemented ioctl wrappers */
-
-/*
- * ======== mgrwrap_enum_node_info ========
- */
-u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
-{
-	u8 *pndb_props;
-	u32 num_nodes;
-	dsp_status status = DSP_SOK;
-	u32 size = args->args_mgr_enumnode_info.undb_props_size;
-
-	if (size < sizeof(struct dsp_ndbprops))
-		return -EINVAL;
-
-	pndb_props = kmalloc(size, GFP_KERNEL);
-	if (pndb_props == NULL)
-		status = -ENOMEM;
-
-	if (DSP_SUCCEEDED(status)) {
-		status =
-		    mgr_enum_node_info(args->args_mgr_enumnode_info.node_id,
-				       (struct dsp_ndbprops *)pndb_props, size,
-				       &num_nodes);
-	}
-	CP_TO_USR(args->args_mgr_enumnode_info.pndb_props, pndb_props, status,
-		  size);
-	CP_TO_USR(args->args_mgr_enumnode_info.pu_num_nodes, &num_nodes, status,
-		  1);
-	kfree(pndb_props);
-
-	return status;
-}
-
-/*
- * ======== mgrwrap_enum_proc_info ========
- */
-u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
-{
-	u8 *processor_info;
-	u8 num_procs;
-	dsp_status status = DSP_SOK;
-	u32 size = args->args_mgr_enumproc_info.processor_info_size;
-
-	if (size < sizeof(struct dsp_processorinfo))
-		return -EINVAL;
-
-	processor_info = kmalloc(size, GFP_KERNEL);
-	if (processor_info == NULL)
-		status = -ENOMEM;
-
-	if (DSP_SUCCEEDED(status)) {
-		status =
-		    mgr_enum_processor_info(args->args_mgr_enumproc_info.
-					    processor_id,
-					    (struct dsp_processorinfo *)
-					    processor_info, size, &num_procs);
-	}
-	CP_TO_USR(args->args_mgr_enumproc_info.processor_info, processor_info,
-		  status, size);
-	CP_TO_USR(args->args_mgr_enumproc_info.pu_num_procs, &num_procs,
-		  status, 1);
-	kfree(processor_info);
-
-	return status;
-}
-
-#define WRAP_MAP2CALLER(x) x
-/*
- * ======== mgrwrap_register_object ========
- */
-u32 mgrwrap_register_object(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-	struct dsp_uuid uuid_obj;
-	u32 path_size = 0;
-	char *psz_path_name = NULL;
-	dsp_status status = DSP_SOK;
-
-	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
-	if (DSP_FAILED(status))
-		goto func_end;
-	/* path_size is increased by 1 to accommodate NULL */
-	path_size = strlen_user((char *)
-				args->args_mgr_registerobject.psz_path_name) +
-	    1;
-	psz_path_name = kmalloc(path_size, GFP_KERNEL);
-	if (!psz_path_name)
-		goto func_end;
-	ret = strncpy_from_user(psz_path_name,
-				(char *)args->args_mgr_registerobject.
-				psz_path_name, path_size);
-	if (!ret) {
-		status = -EFAULT;
-		goto func_end;
-	}
-
-	if (args->args_mgr_registerobject.obj_type >= DSP_DCDMAXOBJTYPE)
-		return -EINVAL;
-
-	status = dcd_register_object(&uuid_obj,
-				     args->args_mgr_registerobject.obj_type,
-				     (char *)psz_path_name);
-func_end:
-	kfree(psz_path_name);
-	return status;
-}
-
-/*
- * ======== mgrwrap_unregister_object ========
- */
-u32 mgrwrap_unregister_object(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_uuid uuid_obj;
-
-	CP_FM_USR(&uuid_obj, args->args_mgr_registerobject.uuid_obj, status, 1);
-	if (DSP_FAILED(status))
-		goto func_end;
-
-	status = dcd_unregister_object(&uuid_obj,
-				       args->args_mgr_unregisterobject.
-				       obj_type);
-func_end:
-	return status;
-
-}
-
-/*
- * ======== mgrwrap_wait_for_bridge_events ========
- */
-u32 mgrwrap_wait_for_bridge_events(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK, real_status = DSP_SOK;
-	struct dsp_notification *anotifications[MAX_EVENTS];
-	struct dsp_notification notifications[MAX_EVENTS];
-	u32 index, i;
-	u32 count = args->args_mgr_wait.count;
-
-	if (count > MAX_EVENTS)
-		status = -EINVAL;
-
-	/* get the array of pointers to user structures */
-	CP_FM_USR(anotifications, args->args_mgr_wait.anotifications,
-		  status, count);
-	/* get the events */
-	for (i = 0; i < count; i++) {
-		CP_FM_USR(&notifications[i], anotifications[i], status, 1);
-		if (DSP_SUCCEEDED(status)) {
-			/* set the array of pointers to kernel structures */
-			anotifications[i] = &notifications[i];
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		real_status = mgr_wait_for_bridge_events(anotifications, count,
-							 &index,
-							 args->args_mgr_wait.
-							 utimeout);
-	}
-	CP_TO_USR(args->args_mgr_wait.pu_index, &index, status, 1);
-	return real_status;
-}
-
-/*
- * ======== MGRWRAP_GetProcessResourceInfo ========
- */
-u32 __deprecated mgrwrap_get_process_resources_info(union Trapped_Args * args,
-						    void *pr_ctxt)
-{
-	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
-	return DSP_SOK;
-}
-
-/*
- * ======== procwrap_attach ========
- */
-u32 procwrap_attach(union Trapped_Args *args, void *pr_ctxt)
-{
-	void *processor;
-	dsp_status status = DSP_SOK;
-	struct dsp_processorattrin proc_attr_in, *attr_in = NULL;
-
-	/* Optional argument */
-	if (args->args_proc_attach.attr_in) {
-		CP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,
-			  1);
-		if (DSP_SUCCEEDED(status))
-			attr_in = &proc_attr_in;
-		else
-			goto func_end;
-
-	}
-	status = proc_attach(args->args_proc_attach.processor_id, attr_in,
-			     &processor, pr_ctxt);
-	CP_TO_USR(args->args_proc_attach.ph_processor, &processor, status, 1);
-func_end:
-	return status;
-}
-
-/*
- * ======== procwrap_ctrl ========
- */
-u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 cb_data_size, __user * psize = (u32 __user *)
-	    args->args_proc_ctrl.pargs;
-	u8 *pargs = NULL;
-	dsp_status status = DSP_SOK;
-
-	if (psize) {
-		if (get_user(cb_data_size, psize)) {
-			status = -EPERM;
-			goto func_end;
-		}
-		cb_data_size += sizeof(u32);
-		pargs = kmalloc(cb_data_size, GFP_KERNEL);
-		if (pargs == NULL) {
-			status = -ENOMEM;
-			goto func_end;
-		}
-
-		CP_FM_USR(pargs, args->args_proc_ctrl.pargs, status,
-			  cb_data_size);
-	}
-	if (DSP_SUCCEEDED(status)) {
-		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
-				   args->args_proc_ctrl.dw_cmd,
-				   (struct dsp_cbdata *)pargs);
-	}
-
-	/* CP_TO_USR(args->args_proc_ctrl.pargs, pargs, status, 1); */
-	kfree(pargs);
-func_end:
-	return status;
-}
-
-/*
- * ======== procwrap_detach ========
- */
-u32 __deprecated procwrap_detach(union Trapped_Args * args, void *pr_ctxt)
-{
-	/* proc_detach called at bridge_release only */
-	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
-	return DSP_SOK;
-}
-
-/*
- * ======== procwrap_enum_node_info ========
- */
-u32 procwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	void *node_tab[MAX_NODES];
-	u32 num_nodes;
-	u32 alloc_cnt;
-
-	if (!args->args_proc_enumnode_info.node_tab_size)
-		return -EINVAL;
-
-	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
-				 node_tab,
-				 args->args_proc_enumnode_info.node_tab_size,
-				 &num_nodes, &alloc_cnt);
-	CP_TO_USR(args->args_proc_enumnode_info.node_tab, node_tab, status,
-		  num_nodes);
-	CP_TO_USR(args->args_proc_enumnode_info.pu_num_nodes, &num_nodes,
-		  status, 1);
-	CP_TO_USR(args->args_proc_enumnode_info.pu_allocated, &alloc_cnt,
-		  status, 1);
-	return status;
-}
-
-/*
- * ======== procwrap_flush_memory ========
- */
-u32 procwrap_flush_memory(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-
-	if (args->args_proc_flushmemory.ul_flags >
-	    PROC_WRITEBACK_INVALIDATE_MEM)
-		return -EINVAL;
-
-	status = proc_flush_memory(args->args_proc_flushmemory.hprocessor,
-				   args->args_proc_flushmemory.pmpu_addr,
-				   args->args_proc_flushmemory.ul_size,
-				   args->args_proc_flushmemory.ul_flags);
-	return status;
-}
-
-/*
- * ======== procwrap_invalidate_memory ========
- */
-u32 procwrap_invalidate_memory(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-
-	status =
-	    proc_invalidate_memory(args->args_proc_invalidatememory.hprocessor,
-				   args->args_proc_invalidatememory.pmpu_addr,
-				   args->args_proc_invalidatememory.ul_size);
-	return status;
-}
-
-/*
- * ======== procwrap_enum_resources ========
- */
-u32 procwrap_enum_resources(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_resourceinfo resource_info;
-
-	if (args->args_proc_enumresources.resource_info_size <
-	    sizeof(struct dsp_resourceinfo))
-		return -EINVAL;
-
-	status =
-	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
-				   args->args_proc_enumresources.resource_type,
-				   &resource_info,
-				   args->args_proc_enumresources.
-				   resource_info_size);
-
-	CP_TO_USR(args->args_proc_enumresources.resource_info, &resource_info,
-		  status, 1);
-
-	return status;
-
-}
-
-/*
- * ======== procwrap_get_state ========
- */
-u32 procwrap_get_state(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	struct dsp_processorstate proc_state;
-
-	if (args->args_proc_getstate.state_info_size <
-	    sizeof(struct dsp_processorstate))
-		return -EINVAL;
-
-	status =
-	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
-			   args->args_proc_getstate.state_info_size);
-	CP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,
-		  1);
-	return status;
-
-}
-
-/*
- * ======== procwrap_get_trace ========
- */
-u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	u8 *pbuf;
-
-	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
-		return -EINVAL;
-
-	pbuf = kzalloc(args->args_proc_gettrace.max_size, GFP_KERNEL);
-	if (pbuf != NULL) {
-		status = proc_get_trace(args->args_proc_gettrace.hprocessor,
-					pbuf,
-					args->args_proc_gettrace.max_size);
-	} else {
-		status = -ENOMEM;
-	}
-	CP_TO_USR(args->args_proc_gettrace.pbuf, pbuf, status,
-		  args->args_proc_gettrace.max_size);
-	kfree(pbuf);
-
-	return status;
-}
-
-/*
- * ======== procwrap_load ========
- */
-u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
-{
-	s32 i, len;
-	dsp_status status = DSP_SOK;
-	char *temp;
-	s32 count = args->args_proc_load.argc_index;
-	u8 **argv = NULL, **envp = NULL;
-
-	if (count <= 0 || count > MAX_LOADARGS) {
-		status = -EINVAL;
-		goto func_cont;
-	}
-
-	argv = kmalloc(count * sizeof(u8 *), GFP_KERNEL);
-	if (!argv) {
-		status = -ENOMEM;
-		goto func_cont;
-	}
-
-	CP_FM_USR(argv, args->args_proc_load.user_args, status, count);
-	if (DSP_FAILED(status)) {
-		kfree(argv);
-		argv = NULL;
-		goto func_cont;
-	}
-
-	for (i = 0; i < count; i++) {
-		if (argv[i]) {
-			/* User space pointer to argument */
-			temp = (char *)argv[i];
-			/* len is increased by 1 to accommodate NULL */
-			len = strlen_user((char *)temp) + 1;
-			/* Kernel space pointer to argument */
-			argv[i] = kmalloc(len, GFP_KERNEL);
-			if (argv[i]) {
-				CP_FM_USR(argv[i], temp, status, len);
-				if (DSP_FAILED(status)) {
-					kfree(argv[i]);
-					argv[i] = NULL;
-					goto func_cont;
-				}
-			} else {
-				status = -ENOMEM;
-				goto func_cont;
-			}
-		}
-	}
-	/* TODO: validate this */
-	if (args->args_proc_load.user_envp) {
-		/* number of elements in the envp array including NULL */
-		count = 0;
-		do {
-			get_user(temp, args->args_proc_load.user_envp + count);
-			count++;
-		} while (temp);
-		envp = kmalloc(count * sizeof(u8 *), GFP_KERNEL);
-		if (!envp) {
-			status = -ENOMEM;
-			goto func_cont;
-		}
-
-		CP_FM_USR(envp, args->args_proc_load.user_envp, status, count);
-		if (DSP_FAILED(status)) {
-			kfree(envp);
-			envp = NULL;
-			goto func_cont;
-		}
-		for (i = 0; envp[i]; i++) {
-			/* User space pointer to argument */
-			temp = (char *)envp[i];
-			/* len is increased by 1 to accommodate NULL */
-			len = strlen_user((char *)temp) + 1;
-			/* Kernel space pointer to argument */
-			envp[i] = kmalloc(len, GFP_KERNEL);
-			if (envp[i]) {
-				CP_FM_USR(envp[i], temp, status, len);
-				if (DSP_FAILED(status)) {
-					kfree(envp[i]);
-					envp[i] = NULL;
-					goto func_cont;
-				}
-			} else {
-				status = -ENOMEM;
-				goto func_cont;
-			}
-		}
-	}
-
-	if (DSP_SUCCEEDED(status)) {
-		status = proc_load(args->args_proc_load.hprocessor,
-				   args->args_proc_load.argc_index,
-				   (CONST char **)argv, (CONST char **)envp);
-	}
-func_cont:
-	if (envp) {
-		i = 0;
-		while (envp[i])
-			kfree(envp[i++]);
-
-		kfree(envp);
-	}
-
-	if (argv) {
-		count = args->args_proc_load.argc_index;
-		for (i = 0; (i < count) && argv[i]; i++)
-			kfree(argv[i]);
-
-		kfree(argv);
-	}
-
-	return status;
-}
-
-/*
- * ======== procwrap_map ========
- */
-u32 procwrap_map(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	void *map_addr;
-
-	if (!args->args_proc_mapmem.ul_size)
-		return -EINVAL;
-
-	status = proc_map(args->args_proc_mapmem.hprocessor,
-			  args->args_proc_mapmem.pmpu_addr,
-			  args->args_proc_mapmem.ul_size,
-			  args->args_proc_mapmem.req_addr, &map_addr,
-			  args->args_proc_mapmem.ul_map_attr, pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
-		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
-			status = -EINVAL;
-			proc_un_map(args->args_proc_mapmem.hprocessor,
-				    map_addr, pr_ctxt);
-		}
-
-	}
-	return status;
-}
-
-/*
- * ======== procwrap_register_notify ========
- */
-u32 procwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	struct dsp_notification notification;
-
-	/* Initialize the notification data structure */
-	notification.ps_name = NULL;
-	notification.handle = NULL;
-
-	status =
-	    proc_register_notify(args->args_proc_register_notify.hprocessor,
-				 args->args_proc_register_notify.event_mask,
-				 args->args_proc_register_notify.notify_type,
-				 &notification);
-	CP_TO_USR(args->args_proc_register_notify.hnotification, &notification,
-		  status, 1);
-	return status;
-}
-
-/*
- * ======== procwrap_reserve_memory ========
- */
-u32 procwrap_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	void *prsv_addr;
-
-	if ((args->args_proc_rsvmem.ul_size <= 0) ||
-	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
-		return -EINVAL;
-
-	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
-				     args->args_proc_rsvmem.ul_size, &prsv_addr,
-				     pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
-		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
-			status = -EINVAL;
-			proc_un_reserve_memory(args->args_proc_rsvmem.
-					       hprocessor, prsv_addr, pr_ctxt);
-		}
-	}
-	return status;
-}
-
-/*
- * ======== procwrap_start ========
- */
-u32 procwrap_start(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = proc_start(args->args_proc_start.hprocessor);
-	return ret;
-}
-
-/*
- * ======== procwrap_un_map ========
- */
-u32 procwrap_un_map(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-
-	status = proc_un_map(args->args_proc_unmapmem.hprocessor,
-			     args->args_proc_unmapmem.map_addr, pr_ctxt);
-	return status;
-}
-
-/*
- * ======== procwrap_un_reserve_memory ========
- */
-u32 procwrap_un_reserve_memory(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-
-	status = proc_un_reserve_memory(args->args_proc_unrsvmem.hprocessor,
-					args->args_proc_unrsvmem.prsv_addr,
-					pr_ctxt);
-	return status;
-}
-
-/*
- * ======== procwrap_stop ========
- */
-u32 procwrap_stop(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = proc_stop(args->args_proc_stop.hprocessor);
-
-	return ret;
-}
-
-/*
- * ======== nodewrap_allocate ========
- */
-u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_uuid node_uuid;
-	u32 cb_data_size = 0;
-	u32 __user *psize = (u32 __user *) args->args_node_allocate.pargs;
-	u8 *pargs = NULL;
-	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
-	struct node_object *hnode;
-
-	/* Optional argument */
-	if (psize) {
-		if (get_user(cb_data_size, psize))
-			status = -EPERM;
-
-		cb_data_size += sizeof(u32);
-		if (DSP_SUCCEEDED(status)) {
-			pargs = kmalloc(cb_data_size, GFP_KERNEL);
-			if (pargs == NULL)
-				status = -ENOMEM;
-
-		}
-		CP_FM_USR(pargs, args->args_node_allocate.pargs, status,
-			  cb_data_size);
-	}
-	CP_FM_USR(&node_uuid, args->args_node_allocate.node_id_ptr, status, 1);
-	if (DSP_FAILED(status))
-		goto func_cont;
-	/* Optional argument */
-	if (args->args_node_allocate.attr_in) {
-		CP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,
-			  status, 1);
-		if (DSP_SUCCEEDED(status))
-			attr_in = &proc_attr_in;
-		else
-			status = -ENOMEM;
-
-	}
-	if (DSP_SUCCEEDED(status)) {
-		status = node_allocate(args->args_node_allocate.hprocessor,
-				       &node_uuid, (struct dsp_cbdata *)pargs,
-				       attr_in, &hnode, pr_ctxt);
-	}
-	if (DSP_SUCCEEDED(status)) {
-		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
-		if (DSP_FAILED(status)) {
-			status = -EFAULT;
-			node_delete(hnode, pr_ctxt);
-		}
-	}
-func_cont:
-	kfree(pargs);
-
-	return status;
-}
-
-/*
- *  ======== nodewrap_alloc_msg_buf ========
- */
-u32 nodewrap_alloc_msg_buf(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_bufferattr *pattr = NULL;
-	struct dsp_bufferattr attr;
-	u8 *pbuffer = NULL;
-
-	if (!args->args_node_allocmsgbuf.usize)
-		return -EINVAL;
-
-	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
-		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
-		if (DSP_SUCCEEDED(status))
-			pattr = &attr;
-
-	}
-	/* IN OUT argument */
-	CP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.pbuffer, status, 1);
-	if (DSP_SUCCEEDED(status)) {
-		status = node_alloc_msg_buf(args->args_node_allocmsgbuf.hnode,
-					    args->args_node_allocmsgbuf.usize,
-					    pattr, &pbuffer);
-	}
-	CP_TO_USR(args->args_node_allocmsgbuf.pbuffer, &pbuffer, status, 1);
-	return status;
-}
-
-/*
- * ======== nodewrap_change_priority ========
- */
-u32 nodewrap_change_priority(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = node_change_priority(args->args_node_changepriority.hnode,
-				   args->args_node_changepriority.prio);
-
-	return ret;
-}
-
-/*
- * ======== nodewrap_connect ========
- */
-u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_strmattr attrs;
-	struct dsp_strmattr *pattrs = NULL;
-	u32 cb_data_size;
-	u32 __user *psize = (u32 __user *) args->args_node_connect.conn_param;
-	u8 *pargs = NULL;
-
-	/* Optional argument */
-	if (psize) {
-		if (get_user(cb_data_size, psize))
-			status = -EPERM;
-
-		cb_data_size += sizeof(u32);
-		if (DSP_SUCCEEDED(status)) {
-			pargs = kmalloc(cb_data_size, GFP_KERNEL);
-			if (pargs == NULL) {
-				status = -ENOMEM;
-				goto func_cont;
-			}
-
-		}
-		CP_FM_USR(pargs, args->args_node_connect.conn_param, status,
-			  cb_data_size);
-		if (DSP_FAILED(status))
-			goto func_cont;
-	}
-	if (args->args_node_connect.pattrs) {	/* Optional argument */
-		CP_FM_USR(&attrs, args->args_node_connect.pattrs, status, 1);
-		if (DSP_SUCCEEDED(status))
-			pattrs = &attrs;
-
-	}
-	if (DSP_SUCCEEDED(status)) {
-		status = node_connect(args->args_node_connect.hnode,
-				      args->args_node_connect.stream_id,
-				      args->args_node_connect.other_node,
-				      args->args_node_connect.other_stream,
-				      pattrs, (struct dsp_cbdata *)pargs);
-	}
-func_cont:
-	kfree(pargs);
-
-	return status;
-}
-
-/*
- * ======== nodewrap_create ========
- */
-u32 nodewrap_create(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = node_create(args->args_node_create.hnode);
-
-	return ret;
-}
-
-/*
- * ======== nodewrap_delete ========
- */
-u32 nodewrap_delete(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = node_delete(args->args_node_delete.hnode, pr_ctxt);
-
-	return ret;
-}
-
-/*
- *  ======== nodewrap_free_msg_buf ========
- */
-u32 nodewrap_free_msg_buf(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_bufferattr *pattr = NULL;
-	struct dsp_bufferattr attr;
-	if (args->args_node_freemsgbuf.pattr) {	/* Optional argument */
-		CP_FM_USR(&attr, args->args_node_freemsgbuf.pattr, status, 1);
-		if (DSP_SUCCEEDED(status))
-			pattr = &attr;
-
-	}
-
-	if (!args->args_node_freemsgbuf.pbuffer)
-		return -EFAULT;
-
-	if (DSP_SUCCEEDED(status)) {
-		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
-					   args->args_node_freemsgbuf.pbuffer,
-					   pattr);
-	}
-
-	return status;
-}
-
-/*
- * ======== nodewrap_get_attr ========
- */
-u32 nodewrap_get_attr(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_nodeattr attr;
-
-	status = node_get_attr(args->args_node_getattr.hnode, &attr,
-			       args->args_node_getattr.attr_size);
-	CP_TO_USR(args->args_node_getattr.pattr, &attr, status, 1);
-
-	return status;
-}
-
-/*
- * ======== nodewrap_get_message ========
- */
-u32 nodewrap_get_message(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	struct dsp_msg msg;
-
-	status = node_get_message(args->args_node_getmessage.hnode, &msg,
-				  args->args_node_getmessage.utimeout);
-
-	CP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);
-
-	return status;
-}
-
-/*
- * ======== nodewrap_pause ========
- */
-u32 nodewrap_pause(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = node_pause(args->args_node_pause.hnode);
-
-	return ret;
-}
-
-/*
- * ======== nodewrap_put_message ========
- */
-u32 nodewrap_put_message(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_msg msg;
-
-	CP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);
-
-	if (DSP_SUCCEEDED(status)) {
-		status =
-		    node_put_message(args->args_node_putmessage.hnode, &msg,
-				     args->args_node_putmessage.utimeout);
-	}
-
-	return status;
-}
-
-/*
- * ======== nodewrap_register_notify ========
- */
-u32 nodewrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_notification notification;
-
-	/* Initialize the notification data structure */
-	notification.ps_name = NULL;
-	notification.handle = NULL;
-
-	if (!args->args_proc_register_notify.event_mask)
-		CP_FM_USR(&notification,
-			  args->args_proc_register_notify.hnotification,
-			  status, 1);
-
-	status = node_register_notify(args->args_node_registernotify.hnode,
-				      args->args_node_registernotify.event_mask,
-				      args->args_node_registernotify.
-				      notify_type, &notification);
-	CP_TO_USR(args->args_node_registernotify.hnotification, &notification,
-		  status, 1);
-	return status;
-}
-
-/*
- * ======== nodewrap_run ========
- */
-u32 nodewrap_run(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = node_run(args->args_node_run.hnode);
-
-	return ret;
-}
-
-/*
- * ======== nodewrap_terminate ========
- */
-u32 nodewrap_terminate(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	dsp_status tempstatus;
-
-	status = node_terminate(args->args_node_terminate.hnode, &tempstatus);
-
-	CP_TO_USR(args->args_node_terminate.pstatus, &tempstatus, status, 1);
-
-	return status;
-}
-
-/*
- * ======== nodewrap_get_uuid_props ========
- */
-u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_uuid node_uuid;
-	struct dsp_ndbprops *pnode_props = NULL;
-
-	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
-		  1);
-	if (DSP_FAILED(status))
-		goto func_cont;
-	pnode_props = kmalloc(sizeof(struct dsp_ndbprops), GFP_KERNEL);
-	if (pnode_props != NULL) {
-		status =
-		    node_get_uuid_props(args->args_node_getuuidprops.hprocessor,
-					&node_uuid, pnode_props);
-		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
-			  status, 1);
-	} else
-		status = -ENOMEM;
-func_cont:
-	kfree(pnode_props);
-	return status;
-}
-
-/*
- * ======== strmwrap_allocate_buffer ========
- */
-u32 strmwrap_allocate_buffer(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status;
-	u8 **ap_buffer = NULL;
-	u32 num_bufs = args->args_strm_allocatebuffer.num_bufs;
-
-	if (num_bufs > MAX_BUFS)
-		return -EINVAL;
-
-	ap_buffer = kmalloc((num_bufs * sizeof(u8 *)), GFP_KERNEL);
-
-	status = strm_allocate_buffer(args->args_strm_allocatebuffer.hstream,
-				      args->args_strm_allocatebuffer.usize,
-				      ap_buffer, num_bufs, pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
-		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
-			  status, num_bufs);
-		if (DSP_FAILED(status)) {
-			status = -EFAULT;
-			strm_free_buffer(args->args_strm_allocatebuffer.hstream,
-					 ap_buffer, num_bufs, pr_ctxt);
-		}
-	}
-	kfree(ap_buffer);
-
-	return status;
-}
-
-/*
- * ======== strmwrap_close ========
- */
-u32 strmwrap_close(union Trapped_Args *args, void *pr_ctxt)
-{
-	return strm_close(args->args_strm_close.hstream, pr_ctxt);
-}
-
-/*
- * ======== strmwrap_free_buffer ========
- */
-u32 strmwrap_free_buffer(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	u8 **ap_buffer = NULL;
-	u32 num_bufs = args->args_strm_freebuffer.num_bufs;
-
-	if (num_bufs > MAX_BUFS)
-		return -EINVAL;
-
-	ap_buffer = kmalloc((num_bufs * sizeof(u8 *)), GFP_KERNEL);
-
-	CP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,
-		  num_bufs);
-
-	if (DSP_SUCCEEDED(status)) {
-		status = strm_free_buffer(args->args_strm_freebuffer.hstream,
-					  ap_buffer, num_bufs, pr_ctxt);
-	}
-	CP_TO_USR(args->args_strm_freebuffer.ap_buffer, ap_buffer, status,
-		  num_bufs);
-	kfree(ap_buffer);
-
-	return status;
-}
-
-/*
- * ======== strmwrap_get_event_handle ========
- */
-u32 __deprecated strmwrap_get_event_handle(union Trapped_Args * args,
-					   void *pr_ctxt)
-{
-	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
-	return -ENOSYS;
-}
-
-/*
- * ======== strmwrap_get_info ========
- */
-u32 strmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct stream_info strm_info;
-	struct dsp_streaminfo user;
-	struct dsp_streaminfo *temp;
-
-	CP_FM_USR(&strm_info, args->args_strm_getinfo.stream_info, status, 1);
-	temp = strm_info.user_strm;
-
-	strm_info.user_strm = &user;
-
-	if (DSP_SUCCEEDED(status)) {
-		status = strm_get_info(args->args_strm_getinfo.hstream,
-				       &strm_info,
-				       args->args_strm_getinfo.
-				       stream_info_size);
-	}
-	CP_TO_USR(temp, strm_info.user_strm, status, 1);
-	strm_info.user_strm = temp;
-	CP_TO_USR(args->args_strm_getinfo.stream_info, &strm_info, status, 1);
-	return status;
-}
-
-/*
- * ======== strmwrap_idle ========
- */
-u32 strmwrap_idle(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 ret;
-
-	ret = strm_idle(args->args_strm_idle.hstream,
-			args->args_strm_idle.flush_flag);
-
-	return ret;
-}
-
-/*
- * ======== strmwrap_issue ========
- */
-u32 strmwrap_issue(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-
-	if (!args->args_strm_issue.pbuffer)
-		return -EFAULT;
-
-	/* No need of doing CP_FM_USR for the user buffer (pbuffer)
-	   as this is done in Bridge internal function bridge_chnl_add_io_req
-	   in chnl_sm.c */
-	status = strm_issue(args->args_strm_issue.hstream,
-			    args->args_strm_issue.pbuffer,
-			    args->args_strm_issue.dw_bytes,
-			    args->args_strm_issue.dw_buf_size,
-			    args->args_strm_issue.dw_arg);
-
-	return status;
-}
-
-/*
- * ======== strmwrap_open ========
- */
-u32 strmwrap_open(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct strm_attr attr;
-	struct strm_object *strm_obj;
-	struct dsp_streamattrin strm_attr_in;
-
-	CP_FM_USR(&attr, args->args_strm_open.attr_in, status, 1);
-
-	if (attr.stream_attr_in != NULL) {	/* Optional argument */
-		CP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);
-		if (DSP_SUCCEEDED(status)) {
-			attr.stream_attr_in = &strm_attr_in;
-			if (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)
-				return -ENOSYS;
-		}
-
-	}
-	status = strm_open(args->args_strm_open.hnode,
-			   args->args_strm_open.direction,
-			   args->args_strm_open.index, &attr, &strm_obj,
-			   pr_ctxt);
-	CP_TO_USR(args->args_strm_open.ph_stream, &strm_obj, status, 1);
-	return status;
-}
-
-/*
- * ======== strmwrap_reclaim ========
- */
-u32 strmwrap_reclaim(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	u8 *buf_ptr;
-	u32 ul_bytes;
-	u32 dw_arg;
-	u32 ul_buf_size;
-
-	status = strm_reclaim(args->args_strm_reclaim.hstream, &buf_ptr,
-			      &ul_bytes, &ul_buf_size, &dw_arg);
-	CP_TO_USR(args->args_strm_reclaim.buf_ptr, &buf_ptr, status, 1);
-	CP_TO_USR(args->args_strm_reclaim.bytes, &ul_bytes, status, 1);
-	CP_TO_USR(args->args_strm_reclaim.pdw_arg, &dw_arg, status, 1);
-
-	if (args->args_strm_reclaim.buf_size_ptr != NULL) {
-		CP_TO_USR(args->args_strm_reclaim.buf_size_ptr, &ul_buf_size,
-			  status, 1);
-	}
-
-	return status;
-}
-
-/*
- * ======== strmwrap_register_notify ========
- */
-u32 strmwrap_register_notify(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct dsp_notification notification;
-
-	/* Initialize the notification data structure */
-	notification.ps_name = NULL;
-	notification.handle = NULL;
-
-	status = strm_register_notify(args->args_strm_registernotify.hstream,
-				      args->args_strm_registernotify.event_mask,
-				      args->args_strm_registernotify.
-				      notify_type, &notification);
-	CP_TO_USR(args->args_strm_registernotify.hnotification, &notification,
-		  status, 1);
-
-	return status;
-}
-
-/*
- * ======== strmwrap_select ========
- */
-u32 strmwrap_select(union Trapped_Args *args, void *pr_ctxt)
-{
-	u32 mask;
-	struct strm_object *strm_tab[MAX_STREAMS];
-	dsp_status status = DSP_SOK;
-
-	if (args->args_strm_select.strm_num > MAX_STREAMS)
-		return -EINVAL;
-
-	CP_FM_USR(strm_tab, args->args_strm_select.stream_tab, status,
-		  args->args_strm_select.strm_num);
-	if (DSP_SUCCEEDED(status)) {
-		status = strm_select(strm_tab, args->args_strm_select.strm_num,
-				     &mask, args->args_strm_select.utimeout);
-	}
-	CP_TO_USR(args->args_strm_select.pmask, &mask, status, 1);
-	return status;
-}
-
-/* CMM */
-
-/*
- * ======== cmmwrap_calloc_buf ========
- */
-u32 __deprecated cmmwrap_calloc_buf(union Trapped_Args * args, void *pr_ctxt)
-{
-	/* This operation is done in kernel */
-	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
-	return -ENOSYS;
-}
-
-/*
- * ======== cmmwrap_free_buf ========
- */
-u32 __deprecated cmmwrap_free_buf(union Trapped_Args * args, void *pr_ctxt)
-{
-	/* This operation is done in kernel */
-	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
-	return -ENOSYS;
-}
-
-/*
- * ======== cmmwrap_get_handle ========
- */
-u32 cmmwrap_get_handle(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct cmm_object *hcmm_mgr;
-
-	status = cmm_get_handle(args->args_cmm_gethandle.hprocessor, &hcmm_mgr);
-
-	CP_TO_USR(args->args_cmm_gethandle.ph_cmm_mgr, &hcmm_mgr, status, 1);
-
-	return status;
-}
-
-/*
- * ======== cmmwrap_get_info ========
- */
-u32 cmmwrap_get_info(union Trapped_Args *args, void *pr_ctxt)
-{
-	dsp_status status = DSP_SOK;
-	struct cmm_info cmm_info_obj;
-
-	status = cmm_get_info(args->args_cmm_getinfo.hcmm_mgr, &cmm_info_obj);
-
-	CP_TO_USR(args->args_cmm_getinfo.cmm_info_obj, &cmm_info_obj, status,
-		  1);
-
-	return status;
-}
diff --git a/drivers/dsp/bridge/rmgr/disp.c b/drivers/dsp/bridge/rmgr/disp.c
index c125395..2808868 100644
--- a/drivers/dsp/bridge/rmgr/disp.c
+++ b/drivers/dsp/bridge/rmgr/disp.c
@@ -32,7 +32,7 @@
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/dev.h>
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index f1fe604..931576f 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -39,7 +39,7 @@
 #include <dspbridge/proc.h>
 #include <dspbridge/strm.h>
 #include <dspbridge/nodepriv.h>
-#include <dspbridge/wmdchnl.h>
+#include <dspbridge/dspchnl.h>
 #include <dspbridge/resourcecleanup.h>
 
 /*  ----------------------------------- Defines, Data Structures, Typedefs */
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.c b/drivers/dsp/bridge/rmgr/drv_interface.c
index adb9380..37337ff 100644
--- a/drivers/dsp/bridge/rmgr/drv_interface.c
+++ b/drivers/dsp/bridge/rmgr/drv_interface.c
@@ -45,7 +45,7 @@
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Platform Manager */
-#include <dspbridge/wcdioctl.h>
+#include <dspbridge/dspapi-ioctl.h>
 #include <dspbridge/_dcd.h>
 #include <dspbridge/dspdrv.h>
 
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
index e1b7d7a..cdd60e6 100644
--- a/drivers/dsp/bridge/rmgr/node.c
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -48,8 +48,8 @@
 #include <dspbridge/rms_sh.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmd.h>
-#include <dspbridge/wmdioctl.h>
+#include <dspbridge/dspdefs.h>
+#include <dspbridge/dspioctl.h>
 
 /*  ----------------------------------- Others */
 #include <dspbridge/gb.h>
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index fe88256..7dc9b5c 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -33,8 +33,8 @@
 #include <dspbridge/ntfy.h>
 #include <dspbridge/sync.h>
 /*  ----------------------------------- Mini Driver */
-#include <dspbridge/wmd.h>
-#include <dspbridge/wmddeh.h>
+#include <dspbridge/dspdefs.h>
+#include <dspbridge/dspdeh.h>
 /*  ----------------------------------- Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
@@ -50,7 +50,7 @@
 /*  ----------------------------------- Others */
 #include <dspbridge/dbdcd.h>
 #include <dspbridge/msg.h>
-#include <dspbridge/wmdioctl.h>
+#include <dspbridge/dspioctl.h>
 #include <dspbridge/drv.h>
 
 /*  ----------------------------------- This */
diff --git a/drivers/dsp/bridge/rmgr/pwr.c b/drivers/dsp/bridge/rmgr/pwr.c
index f8accd1..fa50a1f 100644
--- a/drivers/dsp/bridge/rmgr/pwr.c
+++ b/drivers/dsp/bridge/rmgr/pwr.c
@@ -30,7 +30,7 @@
 #include <dspbridge/dev.h>
 
 /*  ----------------------------------- Link Driver */
-#include <dspbridge/wmdioctl.h>
+#include <dspbridge/dspioctl.h>
 
 /*
  *  ======== pwr_sleep_dsp ========
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
index dcdd406..b654b0a 100644
--- a/drivers/dsp/bridge/rmgr/strm.c
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -31,7 +31,7 @@
 #include <dspbridge/sync.h>
 
 /*  ----------------------------------- Mini Driver */
-#include <dspbridge/wmd.h>
+#include <dspbridge/dspdefs.h>
 
 /*  ----------------------------------- Resource Manager */
 #include <dspbridge/nodepriv.h>
-- 
1.7.0.4

