From 54741934c9d405b8ec6f54112e7c5cf1370da85c Mon Sep 17 00:00:00 2001
From: Ivan Gomez Castellanos <ivan.gomez@ti.com>
Date: Mon, 12 Apr 2010 22:41:24 -0500
Subject: [PATCH 087/135] DSPBRIDGE: Moving functions from mem.c to drv.c

Since the mem.c file is going to be deleted, and as the drv.c file
is used for DSP/BIOS Bridge resource allocation, then the following
functions can be placed here and their prototypes in drv.h:

mem_ext_phys_pool_init
mem_ext_phys_pool_release
mem_ext_phys_mem_alloc
mem_alloc_phys_mem
mem_flush_cache
mem_free_phys_mem

Also, as mem_alloc_phys_mem is never called in atomic context, then
the in_atomic function is removed.

Signed-off-by: Ivan Gomez Castellanos <ivan.gomez@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/drv.h |   78 ++++++++++++++
 arch/arm/plat-omap/include/dspbridge/mem.h |   78 --------------
 drivers/dsp/bridge/rmgr/drv.c              |  152 +++++++++++++++++++++++++++
 drivers/dsp/bridge/services/mem.c          |  154 ----------------------------
 4 files changed, 230 insertions(+), 232 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
index 59176d5..f5ea482 100644
--- a/arch/arm/plat-omap/include/dspbridge/drv.h
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -406,4 +406,82 @@ dsp_status drv_request_bridge_res_dsp(void **phost_resources);
 void bridge_recover_schedule(void);
 #endif
 
+/*
+ *  ======== mem_ext_phys_pool_init ========
+ *  Purpose:
+ *      Uses the physical memory chunk passed for internal consitent memory
+ *      allocations.
+ *      physical address based on the page frame address.
+ *  Parameters:
+ *      poolPhysBase  starting address of the physical memory pool.
+ *      poolSize      size of the physical memory pool.
+ *  Returns:
+ *      none.
+ *  Requires:
+ *      - MEM initialized.
+ *      - valid physical address for the base and size > 0
+ */
+extern void mem_ext_phys_pool_init(IN u32 poolPhysBase, IN u32 poolSize);
+
+/*
+ *  ======== mem_ext_phys_pool_release ========
+ */
+extern void mem_ext_phys_pool_release(void);
+
+/*  ======== mem_alloc_phys_mem ========
+ *  Purpose:
+ *      Allocate physically contiguous, uncached memory
+ *  Parameters:
+ *      byte_size:     Number of bytes to allocate.
+ *      ulAlign:    Alignment Mask.
+ *      pPhysicalAddress: Physical address of allocated memory.
+ *  Returns:
+ *      Pointer to a block of memory;
+ *      NULL if memory couldn't be allocated, or if byte_size == 0.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.  Returned physical address refers to physical
+ *      location of memory.
+ */
+extern void *mem_alloc_phys_mem(IN u32 byte_size,
+				IN u32 ulAlign, OUT u32 *pPhysicalAddress);
+
+/*
+ *  ======== mem_flush_cache ========
+ *  Purpose:
+ *      Performs system cache sync with discard
+ *  Parameters:
+ *      pMemBuf:    Pointer to memory region to be flushed.
+ *      pMemBuf:    Size of the memory region to be flushed.
+ *  Returns:
+ *  Requires:
+ *      MEM is initialized.
+ *  Ensures:
+ *      Cache is synchronized
+ */
+extern void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType);
+
+/*
+ *  ======== mem_free_phys_mem ========
+ *  Purpose:
+ *      Free the given block of physically contiguous memory.
+ *  Parameters:
+ *      pVirtualAddress:  Pointer to virtual memory region allocated
+ *      by mem_alloc_phys_mem().
+ *      pPhysicalAddress:  Pointer to physical memory region  allocated
+ *      by mem_alloc_phys_mem().
+ *      byte_size:  Size of the memory region allocated by mem_alloc_phys_mem().
+ *  Returns:
+ *  Requires:
+ *      MEM initialized.
+ *      pVirtualAddress is a valid memory address returned by
+ *          mem_alloc_phys_mem()
+ *  Ensures:
+ *      pVirtualAddress is no longer a valid pointer to memory.
+ */
+extern void mem_free_phys_mem(void *pVirtualAddress,
+			      u32 pPhysicalAddress, u32 byte_size);
+
 #endif /* DRV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
index 19a4be9..2e72de3 100644
--- a/arch/arm/plat-omap/include/dspbridge/mem.h
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -68,26 +68,6 @@ extern void *mem_alloc(IN u32 byte_size, IN enum mem_poolattrs type);
     }                                                   \
 }
 
-/*  ======== mem_alloc_phys_mem ========
- *  Purpose:
- *      Allocate physically contiguous, uncached memory
- *  Parameters:
- *      byte_size:     Number of bytes to allocate.
- *      ulAlign:    Alignment Mask.
- *      pPhysicalAddress: Physical address of allocated memory.
- *  Returns:
- *      Pointer to a block of memory;
- *      NULL if memory couldn't be allocated, or if byte_size == 0.
- *  Requires:
- *      MEM initialized.
- *  Ensures:
- *      The returned pointer, if not NULL, points to a valid memory block of
- *      the size requested.  Returned physical address refers to physical
- *      location of memory.
- */
-extern void *mem_alloc_phys_mem(IN u32 byte_size,
-				IN u32 ulAlign, OUT u32 *pPhysicalAddress);
-
 /*
  *  ======== mem_calloc ========
  *  Purpose:
@@ -124,42 +104,6 @@ extern void *mem_calloc(IN u32 byte_size, IN enum mem_poolattrs type);
 extern void mem_exit(void);
 
 /*
- *  ======== mem_flush_cache ========
- *  Purpose:
- *      Performs system cache sync with discard
- *  Parameters:
- *      pMemBuf:    Pointer to memory region to be flushed.
- *      pMemBuf:    Size of the memory region to be flushed.
- *  Returns:
- *  Requires:
- *      MEM is initialized.
- *  Ensures:
- *      Cache is synchronized
- */
-extern void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType);
-
-/*
- *  ======== mem_free_phys_mem ========
- *  Purpose:
- *      Free the given block of physically contiguous memory.
- *  Parameters:
- *      pVirtualAddress:  Pointer to virtual memory region allocated
- *      by mem_alloc_phys_mem().
- *      pPhysicalAddress:  Pointer to physical memory region  allocated
- *      by mem_alloc_phys_mem().
- *      byte_size:  Size of the memory region allocated by mem_alloc_phys_mem().
- *  Returns:
- *  Requires:
- *      MEM initialized.
- *      pVirtualAddress is a valid memory address returned by
- *          mem_alloc_phys_mem()
- *  Ensures:
- *      pVirtualAddress is no longer a valid pointer to memory.
- */
-extern void mem_free_phys_mem(void *pVirtualAddress,
-			      u32 pPhysicalAddress, u32 byte_size);
-
-/*
  *  ======== MEM_FREE_OBJECT ========
  *  Purpose:
  *      Utility macro to invalidate an object's signature, and deallocate it.
@@ -255,26 +199,4 @@ extern bool services_mem_init(void);
  */
 #define MEM_UNMAP_LINEAR_ADDRESS(pBaseAddr) {}
 
-/*
- *  ======== mem_ext_phys_pool_init ========
- *  Purpose:
- *      Uses the physical memory chunk passed for internal consitent memory
- *      allocations.
- *      physical address based on the page frame address.
- *  Parameters:
- *      poolPhysBase  starting address of the physical memory pool.
- *      poolSize      size of the physical memory pool.
- *  Returns:
- *      none.
- *  Requires:
- *      - MEM initialized.
- *      - valid physical address for the base and size > 0
- */
-extern void mem_ext_phys_pool_init(IN u32 poolPhysBase, IN u32 poolSize);
-
-/*
- *  ======== mem_ext_phys_pool_release ========
- */
-extern void mem_ext_phys_pool_release(void);
-
 #endif /* MEM_ */
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index 0b6a95a..571309f 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -63,6 +63,14 @@ struct drv_ext {
 
 /*  ----------------------------------- Globals */
 static s32 refs;
+static bool ext_phys_mem_pool_enabled;
+struct ext_phys_mem_pool {
+	u32 phys_mem_base;
+	u32 phys_mem_size;
+	u32 virt_mem_base;
+	u32 next_phys_alloc_ptr;
+};
+static struct ext_phys_mem_pool ext_mem_pool;
 
 /*  ----------------------------------- Function Prototypes */
 static dsp_status request_bridge_resources(struct cfg_hostres *res);
@@ -939,3 +947,147 @@ dsp_status drv_request_bridge_res_dsp(void **phost_resources)
 	/* End Mem alloc */
 	return status;
 }
+
+void mem_ext_phys_pool_init(u32 poolPhysBase, u32 poolSize)
+{
+	u32 pool_virt_base;
+
+	/* get the virtual address for the physical memory pool passed */
+	pool_virt_base = (u32) ioremap(poolPhysBase, poolSize);
+
+	if ((void **)pool_virt_base == NULL) {
+		pr_err("%s: external physical memory map failed\n", __func__);
+		ext_phys_mem_pool_enabled = false;
+	} else {
+		ext_mem_pool.phys_mem_base = poolPhysBase;
+		ext_mem_pool.phys_mem_size = poolSize;
+		ext_mem_pool.virt_mem_base = pool_virt_base;
+		ext_mem_pool.next_phys_alloc_ptr = poolPhysBase;
+		ext_phys_mem_pool_enabled = true;
+	}
+}
+
+void mem_ext_phys_pool_release(void)
+{
+	if (ext_phys_mem_pool_enabled) {
+		iounmap((void *)(ext_mem_pool.virt_mem_base));
+		ext_phys_mem_pool_enabled = false;
+	}
+}
+
+/*
+ *  ======== mem_ext_phys_mem_alloc ========
+ *  Purpose:
+ *     Allocate physically contiguous, uncached memory from external memory pool
+ */
+
+static void *mem_ext_phys_mem_alloc(u32 bytes, u32 align, OUT u32 * pPhysAddr)
+{
+	u32 new_alloc_ptr;
+	u32 offset;
+	u32 virt_addr;
+
+	if (align == 0)
+		align = 1;
+
+	if (bytes > ((ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)
+		     - ext_mem_pool.next_phys_alloc_ptr)) {
+		pPhysAddr = NULL;
+		return NULL;
+	} else {
+		offset = (ext_mem_pool.next_phys_alloc_ptr & (align - 1));
+		if (offset == 0)
+			new_alloc_ptr = ext_mem_pool.next_phys_alloc_ptr;
+		else
+			new_alloc_ptr = (ext_mem_pool.next_phys_alloc_ptr) +
+			    (align - offset);
+		if ((new_alloc_ptr + bytes) <=
+		    (ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)) {
+			/* we can allocate */
+			*pPhysAddr = new_alloc_ptr;
+			ext_mem_pool.next_phys_alloc_ptr =
+			    new_alloc_ptr + bytes;
+			virt_addr =
+			    ext_mem_pool.virt_mem_base + (new_alloc_ptr -
+							  ext_mem_pool.
+							  phys_mem_base);
+			return (void *)virt_addr;
+		} else {
+			*pPhysAddr = 0;
+			return NULL;
+		}
+	}
+}
+
+/*
+ *  ======== mem_alloc_phys_mem ========
+ *  Purpose:
+ *      Allocate physically contiguous, uncached memory
+ */
+void *mem_alloc_phys_mem(u32 byte_size, u32 ulAlign, OUT u32 * pPhysicalAddress)
+{
+	void *va_mem = NULL;
+	dma_addr_t pa_mem;
+
+	if (byte_size > 0) {
+		if (ext_phys_mem_pool_enabled) {
+			va_mem = mem_ext_phys_mem_alloc(byte_size, ulAlign,
+							(u32 *) &pa_mem);
+		} else
+			va_mem = dma_alloc_coherent(NULL, byte_size, &pa_mem,
+								GFP_KERNEL);
+		if (va_mem == NULL)
+			*pPhysicalAddress = 0;
+		else
+			*pPhysicalAddress = pa_mem;
+	}
+	return va_mem;
+}
+
+/*
+ *  ======== mem_flush_cache ========
+ *  Purpose:
+ *      Flush cache
+ */
+void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType)
+{
+	if (!pMemBuf)
+		return;
+
+	switch (FlushType) {
+		/* invalidate only */
+	case PROC_INVALIDATE_MEM:
+		dmac_inv_range(pMemBuf, pMemBuf + byte_size);
+		outer_inv_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							  byte_size));
+		break;
+		/* writeback only */
+	case PROC_WRITEBACK_MEM:
+		dmac_clean_range(pMemBuf, pMemBuf + byte_size);
+		outer_clean_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
+		/* writeback and invalidate */
+	case PROC_WRITEBACK_INVALIDATE_MEM:
+		dmac_flush_range(pMemBuf, pMemBuf + byte_size);
+		outer_flush_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
+							    byte_size));
+		break;
+	}
+
+}
+
+/*
+ *  ======== mem_free_phys_mem ========
+ *  Purpose:
+ *      Free the given block of physically contiguous memory.
+ */
+void mem_free_phys_mem(void *pVirtualAddress, u32 pPhysicalAddress,
+		       u32 byte_size)
+{
+	DBC_REQUIRE(pVirtualAddress != NULL);
+
+	if (!ext_phys_mem_pool_enabled)
+		dma_free_coherent(NULL, byte_size, pVirtualAddress,
+				  pPhysicalAddress);
+}
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
index 916a49f..caf4f9c 100644
--- a/drivers/dsp/bridge/services/mem.c
+++ b/drivers/dsp/bridge/services/mem.c
@@ -35,87 +35,7 @@
 #define MEM512MB   0x1fffffff
 
 /*  ----------------------------------- Globals */
-static bool ext_phys_mem_pool_enabled;
 
-struct ext_phys_mem_pool {
-	u32 phys_mem_base;
-	u32 phys_mem_size;
-	u32 virt_mem_base;
-	u32 next_phys_alloc_ptr;
-};
-
-static struct ext_phys_mem_pool ext_mem_pool;
-
-void mem_ext_phys_pool_init(u32 poolPhysBase, u32 poolSize)
-{
-	u32 pool_virt_base;
-
-	/* get the virtual address for the physical memory pool passed */
-	pool_virt_base = (u32) ioremap(poolPhysBase, poolSize);
-
-	if ((void **)pool_virt_base == NULL) {
-		pr_err("%s: external physical memory map failed\n", __func__);
-		ext_phys_mem_pool_enabled = false;
-	} else {
-		ext_mem_pool.phys_mem_base = poolPhysBase;
-		ext_mem_pool.phys_mem_size = poolSize;
-		ext_mem_pool.virt_mem_base = pool_virt_base;
-		ext_mem_pool.next_phys_alloc_ptr = poolPhysBase;
-		ext_phys_mem_pool_enabled = true;
-	}
-}
-
-void mem_ext_phys_pool_release(void)
-{
-	if (ext_phys_mem_pool_enabled) {
-		iounmap((void *)(ext_mem_pool.virt_mem_base));
-		ext_phys_mem_pool_enabled = false;
-	}
-}
-
-/*
- *  ======== mem_ext_phys_mem_alloc ========
- *  Purpose:
- *     Allocate physically contiguous, uncached memory from external memory pool
- */
-
-static void *mem_ext_phys_mem_alloc(u32 bytes, u32 align, OUT u32 * pPhysAddr)
-{
-	u32 new_alloc_ptr;
-	u32 offset;
-	u32 virt_addr;
-
-	if (align == 0)
-		align = 1;
-
-	if (bytes > ((ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)
-		     - ext_mem_pool.next_phys_alloc_ptr)) {
-		pPhysAddr = NULL;
-		return NULL;
-	} else {
-		offset = (ext_mem_pool.next_phys_alloc_ptr & (align - 1));
-		if (offset == 0)
-			new_alloc_ptr = ext_mem_pool.next_phys_alloc_ptr;
-		else
-			new_alloc_ptr = (ext_mem_pool.next_phys_alloc_ptr) +
-			    (align - offset);
-		if ((new_alloc_ptr + bytes) <=
-		    (ext_mem_pool.phys_mem_base + ext_mem_pool.phys_mem_size)) {
-			/* we can allocate */
-			*pPhysAddr = new_alloc_ptr;
-			ext_mem_pool.next_phys_alloc_ptr =
-			    new_alloc_ptr + bytes;
-			virt_addr =
-			    ext_mem_pool.virt_mem_base + (new_alloc_ptr -
-							  ext_mem_pool.
-							  phys_mem_base);
-			return (void *)virt_addr;
-		} else {
-			*pPhysAddr = 0;
-			return NULL;
-		}
-	}
-}
 
 /*
  *  ======== mem_alloc ========
@@ -147,32 +67,6 @@ void *mem_alloc(u32 byte_size, enum mem_poolattrs type)
 }
 
 /*
- *  ======== mem_alloc_phys_mem ========
- *  Purpose:
- *      Allocate physically contiguous, uncached memory
- */
-void *mem_alloc_phys_mem(u32 byte_size, u32 ulAlign, OUT u32 * pPhysicalAddress)
-{
-	void *va_mem = NULL;
-	dma_addr_t pa_mem;
-
-	if (byte_size > 0) {
-		if (ext_phys_mem_pool_enabled) {
-			va_mem = mem_ext_phys_mem_alloc(byte_size, ulAlign,
-							(u32 *) &pa_mem);
-		} else
-			va_mem = dma_alloc_coherent(NULL, byte_size, &pa_mem,
-						    (in_atomic()) ? GFP_ATOMIC :
-						    GFP_KERNEL);
-		if (va_mem == NULL)
-			*pPhysicalAddress = 0;
-		else
-			*pPhysicalAddress = pa_mem;
-	}
-	return va_mem;
-}
-
-/*
  *  ======== mem_calloc ========
  *  Purpose:
  *      Allocate zero-initialized memory from the paged or non-paged pools.
@@ -212,54 +106,6 @@ void mem_exit(void)
 }
 
 /*
- *  ======== mem_flush_cache ========
- *  Purpose:
- *      Flush cache
- */
-void mem_flush_cache(void *pMemBuf, u32 byte_size, s32 FlushType)
-{
-	if (!pMemBuf)
-		return;
-
-	switch (FlushType) {
-		/* invalidate only */
-	case PROC_INVALIDATE_MEM:
-		dmac_inv_range(pMemBuf, pMemBuf + byte_size);
-		outer_inv_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
-							  byte_size));
-		break;
-		/* writeback only */
-	case PROC_WRITEBACK_MEM:
-		dmac_clean_range(pMemBuf, pMemBuf + byte_size);
-		outer_clean_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
-							    byte_size));
-		break;
-		/* writeback and invalidate */
-	case PROC_WRITEBACK_INVALIDATE_MEM:
-		dmac_flush_range(pMemBuf, pMemBuf + byte_size);
-		outer_flush_range(__pa((u32) pMemBuf), __pa((u32) pMemBuf +
-							    byte_size));
-		break;
-	}
-
-}
-
-/*
- *  ======== mem_free_phys_mem ========
- *  Purpose:
- *      Free the given block of physically contiguous memory.
- */
-void mem_free_phys_mem(void *pVirtualAddress, u32 pPhysicalAddress,
-		       u32 byte_size)
-{
-	DBC_REQUIRE(pVirtualAddress != NULL);
-
-	if (!ext_phys_mem_pool_enabled)
-		dma_free_coherent(NULL, byte_size, pVirtualAddress,
-				  pPhysicalAddress);
-}
-
-/*
  *  ======== services_mem_init ========
  *  Purpose:
  *      Initialize MEM module private state.
-- 
1.7.0.4

