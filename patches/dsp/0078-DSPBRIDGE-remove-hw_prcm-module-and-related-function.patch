From 9d15666013b9437914aa83842f41a4c56e9f72c3 Mon Sep 17 00:00:00 2001
From: Fernando Guzman Lugo <x0095840@ti.com>
Date: Tue, 30 Mar 2010 21:37:21 -0600
Subject: [PATCH 078/135] DSPBRIDGE: remove hw_prcm module and related functions

This patches removes TI hw_prcm module and related functions
and replace them with kernel functions. As kernel functions
are exported, pointer function are used to build without
problem in case of building dspbridge as a module.

Signed-off-by: Fernando Guzman Lugo <x0095840@ti.com>
---
 arch/arm/mach-omap2/dspbridge.c                |    9 +-
 arch/arm/plat-omap/include/dspbridge/cfgdefs.h |    2 -
 arch/arm/plat-omap/include/dspbridge/host_os.h |    8 +
 drivers/dsp/bridge/Makefile                    |    2 +-
 drivers/dsp/bridge/hw/PRCMAccInt.h             |  303 ------------
 drivers/dsp/bridge/hw/PRCMRegAcM.h             |  615 ------------------------
 drivers/dsp/bridge/hw/hw_prcm.c                |  161 ------
 drivers/dsp/bridge/hw/hw_prcm.h                |  156 ------
 drivers/dsp/bridge/rmgr/drv.c                  |   14 -
 drivers/dsp/bridge/wmd/_tiomap.h               |    4 +
 drivers/dsp/bridge/wmd/tiomap3430.c            |  150 ++----
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c        |   57 +--
 drivers/dsp/bridge/wmd/tiomap_io.c             |   17 +-
 13 files changed, 102 insertions(+), 1396 deletions(-)
 delete mode 100644 drivers/dsp/bridge/hw/PRCMAccInt.h
 delete mode 100644 drivers/dsp/bridge/hw/PRCMRegAcM.h
 delete mode 100644 drivers/dsp/bridge/hw/hw_prcm.c
 delete mode 100644 drivers/dsp/bridge/hw/hw_prcm.h

diff --git a/arch/arm/mach-omap2/dspbridge.c b/arch/arm/mach-omap2/dspbridge.c
index 4150896..8d6c122 100644
--- a/arch/arm/mach-omap2/dspbridge.c
+++ b/arch/arm/mach-omap2/dspbridge.c
@@ -12,7 +12,8 @@
  */
 
 #include <linux/platform_device.h>
-
+#include "prm.h"
+#include "cm.h"
 #ifdef CONFIG_BRIDGE_DVFS
 #include <plat/omap-pm.h>
 #endif
@@ -28,6 +29,12 @@ static struct dspbridge_platform_data dspbridge_pdata __initdata = {
 	.cpu_set_freq	 = omap_pm_cpu_set_freq,
 	.cpu_get_freq	 = omap_pm_cpu_get_freq,
 #endif
+	.dsp_prm_read	= prm_read_mod_reg,
+	.dsp_prm_write	= prm_write_mod_reg,
+	.dsp_prm_rmw_bits = prm_rmw_mod_reg_bits,
+	.dsp_cm_read	= cm_read_mod_reg,
+	.dsp_cm_write	= cm_write_mod_reg,
+	.dsp_cm_rmw_bits = cm_rmw_mod_reg_bits,
 };
 
 static int __init dspbridge_init(void)
diff --git a/arch/arm/plat-omap/include/dspbridge/cfgdefs.h b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
index a71fc7b..8695fd3 100644
--- a/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
@@ -65,8 +65,6 @@ struct cfg_hostres {
 	u32 dw_chnl_offset;
 	u32 dw_chnl_buf_size;
 	u32 dw_num_chnls;
-	void __iomem *dw_prm_base;
-	void __iomem *dw_cm_base;
 	void __iomem *dw_per_base;
 	u32 dw_per_pm_base;
 	u32 dw_core_pm_base;
diff --git a/arch/arm/plat-omap/include/dspbridge/host_os.h b/arch/arm/plat-omap/include/dspbridge/host_os.h
index a5d8caf..2834304 100644
--- a/arch/arm/plat-omap/include/dspbridge/host_os.h
+++ b/arch/arm/plat-omap/include/dspbridge/host_os.h
@@ -60,6 +60,14 @@ struct dspbridge_platform_data {
 	unsigned long (*cpu_get_freq) (void);
 	unsigned long mpu_speed[6];
 
+	/* functions to write and read PRCM registers */
+	void (*dsp_prm_write)(u32, s16 , u16);
+	u32 (*dsp_prm_read)(s16 , u16);
+	u32 (*dsp_prm_rmw_bits)(u32, u32, s16, s16);
+	void (*dsp_cm_write)(u32, s16 , u16);
+	u32 (*dsp_cm_read)(s16 , u16);
+	u32 (*dsp_cm_rmw_bits)(u32, u32, s16, s16);
+
 	u32 phys_mempool_base;
 	u32 phys_mempool_size;
 };
diff --git a/drivers/dsp/bridge/Makefile b/drivers/dsp/bridge/Makefile
index 1350362..5a28374 100644
--- a/drivers/dsp/bridge/Makefile
+++ b/drivers/dsp/bridge/Makefile
@@ -15,7 +15,7 @@ librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
 		rmgr/nldr.o rmgr/drv_interface.o
 libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o \
 		 dynload/tramp.o
-libhw = hw/hw_prcm.o hw/hw_mmu.o
+libhw = hw/hw_mmu.o
 
 bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
 			$(libdload) $(libhw)
diff --git a/drivers/dsp/bridge/hw/PRCMAccInt.h b/drivers/dsp/bridge/hw/PRCMAccInt.h
deleted file mode 100644
index 7a513b0..0000000
--- a/drivers/dsp/bridge/hw/PRCMAccInt.h
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * PRCMAccInt.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef _PRCM_ACC_INT_H
-#define _PRCM_ACC_INT_H
-
-/* Mappings of level 1 EASI function numbers to function names */
-
-#define EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32  \
-						(PRCM_BASE_EASIL1 + 349)
-#define EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32	(PRCM_BASE_EASIL1 + 743)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32	(PRCM_BASE_EASIL1 + 951)
-#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32	(PRCM_BASE_EASIL1 + 961)
-#define EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 1087)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32	\
-						(PRCM_BASE_EASIL1 + 1105)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32	\
-						(PRCM_BASE_EASIL1 + 1305)
-#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32	\
-						(PRCM_BASE_EASIL1 + 1315)
-#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3_READ_ISSEL132	\
-						(PRCM_BASE_EASIL1 + 2261)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32	\
-						(PRCM_BASE_EASIL1 + 2364)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32	\
-						(PRCM_BASE_EASIL1 + 2365)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32	\
-						(PRCM_BASE_EASIL1 + 2366)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32	\
-						(PRCM_BASE_EASIL1 + 2380)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32	\
-						(PRCM_BASE_EASIL1 + 2381)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32	\
-						(PRCM_BASE_EASIL1 + 2382)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32	\
-						(PRCM_BASE_EASIL1 + 2397)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32	\
-						(PRCM_BASE_EASIL1 + 2398)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32	\
-						(PRCM_BASE_EASIL1 + 2413)
-#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32	\
-						(PRCM_BASE_EASIL1 + 2414)
-#define EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32	\
-						(PRCM_BASE_EASIL1 + 3747)
-#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32	(PRCM_BASE_EASIL1 + 3834)
-#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3846)
-#define EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 3850)
-#define EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32	(PRCM_BASE_EASIL1 + 3857)
-#define EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32	(PRCM_BASE_EASIL1 + 3863)
-#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3877)
-#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3927)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3941)
-#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3965)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32	\
-						(PRCM_BASE_EASIL1 + 3987)
-#define EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32	\
-						(PRCM_BASE_EASIL1 + 3993)
-#define EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 3997)
-#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32	\
-						(PRCM_BASE_EASIL1 + 4025)
-#define EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32	(PRCM_BASE_EASIL1 + 4029)
-#define EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4030)
-#define EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32	\
-						(PRCM_BASE_EASIL1 + 4165)
-#define EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32	\
-						(PRCM_BASE_EASIL1 + 4193)
-#define EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4197)
-#define EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32	\
-						(PRCM_BASE_EASIL1 + 4198)
-#define EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32	\
-						(PRCM_BASE_EASIL1 + 4235)
-#define EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4368)
-#define EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4370)
-#define EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32	(PRCM_BASE_EASIL1 + 4372)
-#define EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32	(PRCM_BASE_EASIL1 + 4373)
-#define EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4374)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32	\
-						(PRCM_BASE_EASIL1 + 4375)
-#define EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32	\
-						(PRCM_BASE_EASIL1 + 4376)
-#define EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32	\
-						(PRCM_BASE_EASIL1 + 4377)
-#define EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32	\
-						(PRCM_BASE_EASIL1 + 4378)
-#define EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32	\
-						(PRCM_BASE_EASIL1 + 4379)
-
-/* Register offset address definitions */
-
-#define PRCM_PRCM_CLKCFG_CTRL_OFFSET        (u32)(0x80)
-#define PRCM_CM_FCLKEN1_CORE_OFFSET          (u32)(0x200)
-#define PRCM_CM_ICLKEN1_CORE_OFFSET          (u32)(0x210)
-#define PRCM_CM_CLKSEL2_CORE_OFFSET          (u32)(0x244)
-#define PRCM_CM_CLKSEL1_PLL_OFFSET           (u32)(0x540)
-#define PRCM_CM_ICLKEN_DSP_OFFSET            (u32)(0x810)
-#define PRCM_CM_IDLEST_DSP_OFFSET            (u32)(0x820)
-#define PRCM_CM_AUTOIDLE_DSP_OFFSET          (u32)(0x830)
-#define PRCM_CM_CLKSEL_DSP_OFFSET            (u32)(0x840)
-#define PRCM_CM_CLKSTCTRL_DSP_OFFSET         (u32)(0x848)
-#define PRCM_RM_RSTCTRL_DSP_OFFSET           (u32)(0x050)
-#define PRCM_RM_RSTST_DSP_OFFSET             (u32)(0x058)
-#define PRCM_PM_PWSTCTRL_DSP_OFFSET          (u32)(0x8e0)
-#define PRCM_PM_PWSTST_DSP_OFFSET            (u32)(0x8e4)
-#define PRCM_PM_PWSTST_IVA2_OFFSET            (u32)(0xE4)
-#define PRCM_PM_PWSTCTRL_IVA2_OFFSET          (u32)(0xE0)
-#define PRCM_CM_CLKSTCTRL_IVA2_OFFSET         (u32)(0x48)
-#define CM_CLKSEL_PER_OFFSET                            (u32)(0x40)
-
-/* Bitfield mask and offset declarations */
-
-#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK         (u32)(0x1)
-#define PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET       (u32)(0)
-
-#define PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
-#define PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
-
-#define PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK               (u32)(0x200)
-#define PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET             (u32)(9)
-
-#define PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
-#define PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
-
-#define PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK               (u32)(0x200)
-#define PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET             (u32)(9)
-
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK           (u32)(0xc000)
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET         (u32)(14)
-
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK           (u32)(0x3000)
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET         (u32)(12)
-
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK           (u32)(0xc00)
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET         (u32)(10)
-
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK           (u32)(0x300)
-#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET         (u32)(8)
-
-#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK            (u32)(0x3800000)
-#define PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET          (u32)(23)
-
-#define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK              (u32)(0x2)
-#define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET            (u32)(1)
-
-#define PRCM_CM_IDLEST_DSP_ST_IPI_MASK                  (u32)(0x2)
-#define PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET                (u32)(1)
-
-#define PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK          (u32)(0x2)
-#define PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET        (u32)(1)
-
-#define PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK                (u32)(0x80)
-#define PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET              (u32)(7)
-
-#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK           (u32)(0x60)
-#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET         (u32)(5)
-
-#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK              (u32)(0x1f)
-#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET            (u32)(0)
-
-#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK        (u32)(0x1)
-#define PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET      (u32)(0)
-
-#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK            (u32)(0x40000)
-#define PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET          (u32)(18)
-
-#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET          (u32)(0)
-
-#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET          (u32)(0)
-
-#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET          (u32)(20)
-
-#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK            (u32)(0x100000)
-#define PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET          (u32)(20)
-
-#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET          (u32)(0)
-
-#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK            (u32)(0x3)
-#define PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET          (u32)(0)
-
-#define CM_FCLKEN_PER_OFFSET		(u32)(0x0)
-#define CM_FCLKEN_PER_GPT5_OFFSET         (u32)(6)
-#define CM_FCLKEN_PER_GPT5_MASK     (u32)(0x40)
-
-#define CM_FCLKEN_PER_GPT6_OFFSET   (u32)(7)
-#define CM_FCLKEN_PER_GPT6_MASK      (u32)(0x80)
-
-#define CM_ICLKEN_PER_OFFSET		(u32)(0x10)
-#define CM_ICLKEN_PER_GPT5_OFFSET  (u32)(6)
-#define CM_ICLKEN_PER_GPT5_MASK     (u32)(0x40)
-
-#define CM_ICLKEN_PER_GPT6_OFFSET  (u32)(7)
-#define CM_ICLKEN_PER_GPT6_MASK     (u32)(0x80)
-
-#define CM_CLKSEL_PER_GPT5_OFFSET   (u32)(3)
-#define CM_CLKSEL_PER_GPT5_MASK      (u32)(0x8)
-
-#define CM_CLKSEL_PER_GPT6_OFFSET   (u32)(4)
-#define CM_CLKSEL_PER_GPT6_MASK       (u32)(0x10)
-
-#define CM_FCLKEN_IVA2_OFFSET		(u32)(0x0)
-#define CM_FCLKEN_IVA2_EN_MASK	(u32)(0x1)
-#define CM_FCLKEN_IVA2_EN_OFFSET	(u32)(0x0)
-
-#define CM_IDLEST_IVA2_OFFSET 		(u32)(0x20)
-#define CM_IDLEST_IVA2_ST_IVA2_MASK (u32) (0x01)
-#define CM_IDLEST_IVA2_ST_IVA2_OFFSET (u32) (0x00)
-
-#define CM_FCLKEN1_CORE_OFFSET 	(u32)(0xA00)
-
-#define CM_ICLKEN1_CORE_OFFSET  	(u32)(0xA10)
-#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)	/* bit 7 */
-#define CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET	(u32)(7)
-
-#define CM_CLKSTCTRL_IVA2_OFFSET (u32)(0x0)
-#define CM_CLKSTCTRL_IVA2_MASK    (u32)(0x3)
-
-#define PRM_RSTCTRL_IVA2_OFFSET  	(u32)(0x50)
-#define PRM_RSTCTRL_IVA2_RST1_MASK	(u32)(0x1)
-#define PRM_RSTCTRL_IVA2_RST1_OFFSET	(u32)(0x0)
-#define PRM_RSTCTRL_IVA2_RST2_MASK	(u32)(0x2)
-#define PRM_RSTCTRL_IVA2_RST2_OFFSET	(u32)(0x1)
-#define PRM_RSTCTRL_IVA2_RST3_MASK	(u32)(0x4)
-#define PRM_RSTCTRL_IVA2_RST3_OFFSET	(u32)(0x2)
-
-/* The following represent the enumerated values for each bitfield */
-
-enum prcmprcm_clkcfg_ctrl_valid_config_e {
-	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_UPDATED = 0x0000,
-	PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID = 0x0001
-};
-
-enum prcmcm_clksel2_coreclksel_gpt8e {
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT832K = 0x0000,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS = 0x0001,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT = 0x0002,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT8_RESERVED = 0x0003
-};
-
-enum prcmcm_clksel2_coreclksel_gpt7e {
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT732K = 0x0000,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS = 0x0001,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT = 0x0002,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT7_RESERVED = 0x0003
-};
-
-enum prcmcm_clksel2_coreclksel_gpt6e {
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT632K = 0x0000,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS = 0x0001,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT = 0x0002,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT6_RESERVED = 0x0003
-};
-
-enum prcmcm_clksel2_coreclksel_gpt5e {
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT532K = 0x0000,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS = 0x0001,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT = 0x0002,
-	PRCMCM_CLKSEL2_CORECLKSEL_GPT5_RESERVED = 0x0003
-};
-
-enum prcmpm_pwstctrl_dsp_power_state_e {
-	PRCMPM_PWSTCTRL_DSP_POWER_STATE_ON = 0x0000,
-	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET = 0x0001,
-	PRCMPM_PWSTCTRL_DSP_POWER_STATE_RESERVED = 0x0002,
-	PRCMPM_PWSTCTRL_DSP_POWER_STATE_OFF = 0x0003
-};
-
-enum prcmpm_pwstctrl_iva2_power_state_e {
-	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON = 0x0003,
-	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RET = 0x0001,
-	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_RESERVED = 0x0002,
-	PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF = 0x0000
-};
-
-#endif /* _PRCM_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/PRCMRegAcM.h b/drivers/dsp/bridge/hw/PRCMRegAcM.h
deleted file mode 100644
index b941925..0000000
--- a/drivers/dsp/bridge/hw/PRCMRegAcM.h
+++ /dev/null
@@ -1,615 +0,0 @@
-/*
- * PRCMRegAcM.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef _PRCM_REG_ACM_H
-#define _PRCM_REG_ACM_H
-
-#include <GlobalTypes.h>
-#include <linux/io.h>
-
-#include <EasiGlobal.h>
-
-#include "PRCMAccInt.h"
-
-#if defined(USE_LEVEL_1_MACROS)
-
-#define PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32(baseAddress)\
-{\
-    const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;\
-    const u32 newValue = \
-	(u32)PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_CLK_VALID <<\
-      PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(\
-      EASIL1_PRCMPRCM_CLKCFG_CTRL_VALID_CONFIG_WRITE_CLK_VALID32);\
-    data &= ~(PRCM_PRCM_CLKCFG_CTRL_VALID_CONFIG_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define CM_FCLKEN_PER_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
-
-#define CM_ICLKEN_PER_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
-
-#define CM_FCLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = CM_FCLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);\
-   data &= ~(CM_FCLKEN_PER_GPT5_MASK);\
-   newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;\
-   newValue &= CM_FCLKEN_PER_GPT5_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-#define CM_FCLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = CM_FCLKEN_PER_OFFSET;\
-    register u32 data =\
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_FCLKEN_PER_GPT5_WRITE_REGISTER32);\
-   data &= ~(CM_FCLKEN_PER_GPT6_MASK);\
-   newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;\
-   newValue &= CM_FCLKEN_PER_GPT6_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-#define CM_ICLKEN_PER_GPT5_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = CM_ICLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);\
-   data &= ~(CM_ICLKEN_PER_GPT5_MASK);\
-   newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;\
-   newValue &= CM_ICLKEN_PER_GPT5_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-#define CM_ICLKEN_PER_GPT6_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = CM_ICLKEN_PER_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_ICLKEN_PER_GPT5_WRITE_REGISTER32);\
-   data &= ~(CM_ICLKEN_PER_GPT6_MASK);\
-   newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;\
-   newValue &= CM_ICLKEN_PER_GPT6_MASK;\
-   newValue |= data;\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-#define CM_FCLKEN1_CORE_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_CORE_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
-
-#define PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8_WRITE32);\
-    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);\
-    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;\
-    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7_WRITE32);\
-    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);\
-    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;\
-    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define CM_ICLKEN1_CORE_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_CORE_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
-
-#define  CM_ICLKEN1_COREEN_MAILBOXES_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXES_WRITE32);\
-    data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);\
-    newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;\
-    newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8_WRITE32);\
-    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);\
-    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
-    register u32 data =\
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7_WRITE32);\
-    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);\
-    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832K <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE32K32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_SYS <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_SYS32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8_EXT <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8_WRITE_EXT32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732K <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE32K32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_SYS <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_SYS32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7_EXT <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7_WRITE_EXT32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_SYS <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_SYS32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6_EXT <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6_WRITE_EXT32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define CM_CLKSEL_PER_GPT5_WRITE32K32(baseAddress)\
-{\
-    const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<\
-      CM_CLKSEL_PER_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT5_WRITE32K32);\
-    data &= ~(CM_CLKSEL_PER_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define CM_CLKSEL_PER_GPT6_WRITE32K32(baseAddress)\
-{\
-    const u32 offset = CM_CLKSEL_PER_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532K <<\
-      CM_CLKSEL_PER_GPT6_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_CM_CLKSEL_PER_GPT6_WRITE32K32);\
-    data &= ~(CM_CLKSEL_PER_GPT6_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_SYS <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_SYS32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32(baseAddress)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
-    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5_EXT <<\
-      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
-    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5_WRITE_EXT32);\
-    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPL_LS_CLKIN_READ32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &\
-      PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_MASK) >>\
-      PRCM_CM_CLKSEL1_PLL_APL_LS_CLKIN_OFFSET))
-
-#define CM_FCLKEN_IVA2EN_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = CM_FCLKEN_IVA2_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSP_WRITE32);\
-    data &= ~(CM_FCLKEN_IVA2_EN_MASK);\
-    newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;\
-    newValue &= CM_FCLKEN_IVA2_EN_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPI_WRITE32);\
-    data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);\
-    newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;\
-    newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_IDLEST_DSP_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSP_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
-
-#define PRCMCM_IDLEST_DSPST_IPI_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPI_READ32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_IDLEST_DSP_OFFSET)))) &\
-      PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>\
-      PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
-
-#define PRM_IDLEST_IVA2ST_IVA2_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSP_READ32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	  (CM_IDLEST_IVA2_OFFSET)))) &\
-      CM_IDLEST_IVA2_ST_IVA2_MASK) >>\
-      CM_IDLEST_IVA2_ST_IVA2_OFFSET))
-
-#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;\
-    register u32 data =\
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPI_WRITE32);\
-    data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);\
-    newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;\
-    newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSP_WRITE32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IF_WRITE32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
-    register u32 data = \
-      __raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_WRITE32);\
-    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;\
-    register u32 data = \
-      __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32);\
-    data &= ~(CM_CLKSTCTRL_IVA2_MASK);\
-    newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;\
-    newValue &= CM_CLKSTCTRL_IVA2_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_READ32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &\
-      PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK) >>\
-      PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET))
-
-#define PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSP_AUTOSTATE_DSP_WRITE32);\
-    data &= ~(PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK);\
-    newValue <<= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_OFFSET;\
-    newValue &= PRCM_CM_CLKSTCTRL_DSP_AUTOSTATE_DSP_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSP_READ_REGISTER32),\
-      __raw_readl(((baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
-
-#define PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-    __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-#define PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-	__raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-#define PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
-    register u32 data =\
-      __raw_readl(((baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSP_WRITE32);\
-    data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);\
-    newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;\
-    newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (baseAddress)+offset);\
-}
-
-#define PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_READ_REGISTER32),\
-      __raw_readl(((baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
-
-#define PRCMRM_RSTST_DSP_WRITE_REGISTER32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMRM_RSTST_DSP_WRITE_REGISTER32);\
-    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
-}
-
-#define PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32(baseAddress, value)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
-    register u32 data = \
-	__raw_readl(((u32)(baseAddress))+offset);\
-    register u32 newValue = ((u32)(value));\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_FORCE_STATE_WRITE32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK);\
-    newValue <<= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_OFFSET;\
-    newValue &= PRCM_PM_PWSTCTRL_DSP_FORCE_STATE_MASK;\
-    newValue |= data;\
-    __raw_writel(newValue, (u32)(baseAddress)+offset);\
-}
-
-#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_ON <<\
-      PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-#define PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2_POWER_STATE_OFF <<\
-      PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32);\
-    data &= ~(PRCM_PM_PWSTCTRL_IVA2_POWER_STATE_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-#define PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32(baseAddress)\
-{\
-    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
-    const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSP_POWER_STATE_RET <<\
-      PRCM_PM_PWSTCTRL_DSP_POWER_STATE_OFFSET;\
-    register u32 data = __raw_readl((baseAddress)+offset);\
-    _DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32);\
-    data &= ~(PRCM_PM_PWSTCTRL_DSP_POWER_STATE_MASK);\
-    data |= newValue;\
-    __raw_writel(data, (baseAddress)+offset);\
-}
-
-#define PRCMPM_PWSTST_DSP_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_READ_REGISTER32),\
-      __raw_readl(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
-
-#define PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_READ_REGISTER32),\
-      __raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
-
-#define PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_IN_TRANSITION_READ32),\
-      (((__raw_readl((((u32)(baseAddress))+\
-	(PRCM_PM_PWSTST_DSP_OFFSET)))) &\
-      PRCM_PM_PWSTST_DSP_IN_TRANSITION_MASK) >>\
-      PRCM_PM_PWSTST_DSP_IN_TRANSITION_OFFSET))
-
-#define PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32(baseAddress)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32),\
-      (((__raw_readl((((baseAddress))+\
-	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &\
-      PRCM_PM_PWSTST_IVA2_IN_TRANSITION_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_IN_TRANSITION_OFFSET))
-
-#define PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32(var)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_DSP_POWER_STATE_ST_GET32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_POWER_STATE_ST_MASK) >>\
-	PRCM_PM_PWSTST_DSP_POWER_STATE_ST_OFFSET))
-
-#define PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(var)\
-    (_DEBUG_LEVEL1_EASI(EASIL1_PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32),\
-      (u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_MASK) >>\
-      PRCM_PM_PWSTST_IVA2_POWER_STATE_ST_OFFSET))
-
-#endif /* USE_LEVEL_1_MACROS */
-
-#endif /* _PRCM_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/hw_prcm.c b/drivers/dsp/bridge/hw/hw_prcm.c
deleted file mode 100644
index 8c95dac..0000000
--- a/drivers/dsp/bridge/hw/hw_prcm.c
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * hw_prcm.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * API definitions to configure PRCM (Power, Reset & Clocks Manager)
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include <GlobalTypes.h>
-#include "PRCMRegAcM.h"
-#include <hw_defs.h>
-#include <hw_prcm.h>
-
-static hw_status hw_rst_write_val(const void __iomem *baseAddress,
-				  enum hw_rst_module_t r, s8 val);
-
-hw_status hw_rst_reset(const void __iomem *baseAddress, enum hw_rst_module_t r)
-{
-	return hw_rst_write_val(baseAddress, r, HW_SET);
-}
-
-hw_status hw_rst_un_reset(const void __iomem *baseAddress,
-			  enum hw_rst_module_t r)
-{
-	return hw_rst_write_val(baseAddress, r, HW_CLEAR);
-}
-
-static hw_status hw_rst_write_val(const void __iomem *baseAddress,
-				  enum hw_rst_module_t r, s8 val)
-{
-	hw_status status = RET_OK;
-
-	switch (r) {
-	case HW_RST1_IVA2:
-		PRM_RSTCTRL_IVA2RST1_DSP_WRITE32(baseAddress, val);
-		break;
-	case HW_RST2_IVA2:
-		PRM_RSTCTRL_IVA2RST2_DSP_WRITE32(baseAddress, val);
-		break;
-	case HW_RST3_IVA2:
-		PRM_RSTCTRL_IVA2RST3_DSP_WRITE32(baseAddress, val);
-		break;
-	default:
-		status = RET_FAIL;
-		break;
-	}
-	return status;
-}
-
-hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
-				enum hw_pwr_module_t p,
-				enum hw_pwr_state_t *value)
-{
-	hw_status status = RET_OK;
-	u32 temp;
-
-	switch (p) {
-	case HW_PWR_DOMAIN_DSP:
-		/* wait until Transition is complete */
-		do {
-			/* mdelay(1); */
-			temp = PRCMPM_PWSTST_IVA2_IN_TRANSITION_READ32
-			    (baseAddress);
-
-		} while (temp);
-
-		temp = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
-		*value = PRCMPM_PWSTST_IVA2_POWER_STATE_ST_GET32(temp);
-		break;
-
-	default:
-		status = RET_FAIL;
-		break;
-	}
-	return status;
-}
-
-hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress, u32 *value)
-{
-	hw_status status = RET_OK;
-
-	*value = PRCMPM_PWSTST_IVA2_READ_REGISTER32(baseAddress);
-
-	return status;
-}
-
-hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
-				      enum hw_pwr_module_t p,
-				      enum hw_pwr_state_t value)
-{
-	hw_status status = RET_OK;
-
-	switch (p) {
-	case HW_PWR_DOMAIN_DSP:
-		switch (value) {
-		case HW_PWR_STATE_ON:
-			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_ON32
-			    (baseAddress);
-			break;
-		case HW_PWR_STATE_RET:
-			PRCMPM_PWSTCTRL_DSP_POWER_STATE_WRITE_RET32
-			    (baseAddress);
-			break;
-		case HW_PWR_STATE_OFF:
-			PRCMPM_PWSTCTRL_IVA2_POWER_STATE_WRITE_OFF32
-			    (baseAddress);
-			break;
-		default:
-			status = RET_FAIL;
-			break;
-		}
-		break;
-
-	default:
-		status = RET_FAIL;
-		break;
-	}
-
-	return status;
-}
-
-hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
-				      enum hw_transition_state_t val)
-{
-	hw_status status = RET_OK;
-
-	PRCMCM_CLKSTCTRL_IVA2_WRITE_REGISTER32(baseAddress, val);
-
-	return status;
-
-}
-
-hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
-			   enum hw_rst_module_t m, u32 *value)
-{
-	hw_status status = RET_OK;
-
-	*value = PRCMRM_RSTST_DSP_READ_REGISTER32(baseAddress);
-
-	return status;
-}
-
-hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
-			     enum hw_rst_module_t m, u32 *value)
-{
-	hw_status status = RET_OK;
-
-	*value = PRCMRM_RSTCTRL_DSP_READ_REGISTER32(baseAddress);
-
-	return status;
-}
diff --git a/drivers/dsp/bridge/hw/hw_prcm.h b/drivers/dsp/bridge/hw/hw_prcm.h
deleted file mode 100644
index fd07f32..0000000
--- a/drivers/dsp/bridge/hw/hw_prcm.h
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * hw_prcm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * PRCM types and API declarations
- *
- * Copyright (C) 2007 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef _HW_PRCM_H
-#define _HW_PRCM_H
-
-/* HW_ClkModule:  Enumerated Type used to specify the clock domain */
-
-enum hw_clk_module_t {
-/* DSP Domain */
-	HW_CLK_DSP_CPU,
-	HW_CLK_DSP_IPI_MMU,
-	HW_CLK_IVA_ARM,
-	HW_CLK_IVA_COP,		/* IVA Coprocessor */
-
-/* Core Domain */
-	HW_CLK_FN_WDT4,		/* Functional Clock */
-	HW_CLK_FN_WDT3,
-	HW_CLK_FN_UART2,
-	HW_CLK_FN_UART1,
-	HW_CLK_GPT5,
-	HW_CLK_GPT6,
-	HW_CLK_GPT7,
-	HW_CLK_GPT8,
-
-	HW_CLK_IF_WDT4,		/* Interface Clock */
-	HW_CLK_IF_WDT3,
-	HW_CLK_IF_UART2,
-	HW_CLK_IF_UART1,
-	HW_CLK_IF_MBOX
-};
-
-enum hw_clk_subsys_t {
-	HW_CLK_DSPSS,
-	HW_CLK_IVASS
-};
-
-/* HW_GPtimers:  General purpose timers */
-enum hw_g_ptimer_t {
-	HW_GPT5 = 5,
-	HW_GPT6 = 6,
-	HW_GPT7 = 7,
-	HW_GPT8 = 8
-};
-
-/* GP timers Input clock type:  General purpose timers */
-enum hw_clocktype_t {
-	HW_CLK32K_HZ = 0,
-	HW_CLK_SYS = 1,
-	HW_CLK_EXT = 2
-};
-
-/* HW_ClkDiv:  Clock divisors */
-enum hw_clk_div_t {
-	HW_CLK_DIV1 = 0x1,
-	HW_CLK_DIV2 = 0x2,
-	HW_CLK_DIV3 = 0x3,
-	HW_CLK_DIV4 = 0x4,
-	HW_CLK_DIV6 = 0x6,
-	HW_CLK_DIV8 = 0x8,
-	HW_CLK_DIV12 = 0xC
-};
-
-/* HW_RstModule:  Enumerated Type used to specify the module to be reset */
-enum hw_rst_module_t {
-	HW_RST1_IVA2,		/* Reset the DSP */
-	HW_RST2_IVA2,		/* Reset MMU and LEON HWa */
-	HW_RST3_IVA2		/* Reset LEON sequencer */
-};
-
-/* HW_PwrModule:  Enumerated Type used to specify the power domain */
-enum hw_pwr_module_t {
-/* Domains */
-	HW_PWR_DOMAIN_CORE,
-	HW_PWR_DOMAIN_MPU,
-	HW_PWR_DOMAIN_WAKEUP,
-	HW_PWR_DOMAIN_DSP,
-
-/* Sub-domains */
-	HW_PWR_DSP_IPI,		/* IPI = Intrusive Port Interface */
-	HW_PWR_IVA_ISP		/* ISP = Intrusive Slave Port */
-};
-
-enum hw_pwr_state_t {
-	HW_PWR_STATE_OFF,
-	HW_PWR_STATE_RET,
-	HW_PWR_STATE_INACT,
-	HW_PWR_STATE_ON = 3
-};
-
-enum hw_force_state_t {
-	HW_FORCE_OFF,
-	HW_FORCE_ON
-};
-
-enum hw_idle_state_t {
-	HW_ACTIVE,
-	HW_STANDBY
-};
-
-enum hw_transition_state_t {
-	HW_AUTOTRANS_DIS,
-	HW_SW_SUP_SLEEP,
-	HW_SW_SUP_WAKEUP,
-	HW_AUTOTRANS_EN
-};
-
-extern hw_status hw_rst_reset(const void __iomem *baseAddress,
-			      enum hw_rst_module_t r);
-
-extern hw_status hw_rst_un_reset(const void __iomem *baseAddress,
-				 enum hw_rst_module_t r);
-
-extern hw_status hw_rstctrl_reg_get(const void __iomem *baseAddress,
-				    enum hw_rst_module_t p, u32 *value);
-extern hw_status hw_rstst_reg_get(const void __iomem *baseAddress,
-				  enum hw_rst_module_t p, u32 *value);
-
-extern hw_status hw_pwr_power_state_set(const u32 baseAddress,
-					enum hw_pwr_module_t p,
-					enum hw_pwr_state_t value);
-
-extern hw_status hw_clk_set_input_clock(const u32 baseAddress,
-					enum hw_g_ptimer_t gpt,
-					enum hw_clocktype_t c);
-
-extern hw_status hw_pwr_iva2_state_get(const void __iomem *baseAddress,
-				       enum hw_pwr_module_t p,
-				       enum hw_pwr_state_t *value);
-
-extern hw_status hw_pwrst_iva2_reg_get(const void __iomem *baseAddress,
-				       u32 *value);
-
-extern hw_status hw_pwr_iva2_power_state_set(const void __iomem *baseAddress,
-					     enum hw_pwr_module_t p,
-					     enum hw_pwr_state_t value);
-
-extern hw_status hw_pwr_clkctrl_iva2_reg_set(const void __iomem *baseAddress,
-					     enum hw_transition_state_t val);
-
-#endif /* _HW_PRCM_H */
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index fe53b5d..559a27b 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -892,10 +892,6 @@ static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 			host_res->dw_mem_base[1] = 0;
 			host_res->dw_mem_phys[1] = 0;
 
-			if (host_res->dw_prm_base)
-				iounmap(host_res->dw_prm_base);
-			if (host_res->dw_cm_base)
-				iounmap(host_res->dw_cm_base);
 			if (host_res->dw_mem_base[0])
 				iounmap((void *)host_res->dw_mem_base[0]);
 			if (host_res->dw_mem_base[2])
@@ -915,8 +911,6 @@ static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 			if (host_res->dw_sys_ctrl_base)
 				iounmap(host_res->dw_sys_ctrl_base);
 
-			host_res->dw_prm_base = NULL;
-			host_res->dw_cm_base = NULL;
 			host_res->dw_mem_base[0] = (u32) NULL;
 			host_res->dw_mem_base[2] = (u32) NULL;
 			host_res->dw_mem_base[3] = (u32) NULL;
@@ -941,18 +935,12 @@ static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 		host_res->num_mem_windows = 2;
 		/* First window is for DSP internal memory */
 
-		host_res->dw_prm_base = ioremap(OMAP_IVA2_PRM_BASE,
-						OMAP_IVA2_PRM_SIZE);
-		host_res->dw_cm_base = ioremap(OMAP_IVA2_CM_BASE,
-					       OMAP_IVA2_CM_SIZE);
 		host_res->dw_sys_ctrl_base = ioremap(OMAP_SYSC_BASE,
 						     OMAP_SYSC_SIZE);
 		dev_dbg(bridge, "dw_mem_base[0] 0x%x\n",
 			host_res->dw_mem_base[0]);
 		dev_dbg(bridge, "dw_mem_base[3] 0x%x\n",
 			host_res->dw_mem_base[3]);
-		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
-		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
 		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
 
 		/* for 24xx base port is not mapping the mamory for DSP
@@ -1038,8 +1026,6 @@ static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 bRequest)
 			host_res->dw_mem_base[3]);
 		dev_dbg(bridge, "dw_mem_base[4] 0x%x\n",
 			host_res->dw_mem_base[4]);
-		dev_dbg(bridge, "dw_prm_base %p\n", host_res->dw_prm_base);
-		dev_dbg(bridge, "dw_cm_base %p\n", host_res->dw_cm_base);
 		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
 		dw_buff_size = sizeof(shm_size);
 		status =
diff --git a/drivers/dsp/bridge/wmd/_tiomap.h b/drivers/dsp/bridge/wmd/_tiomap.h
index 71ef731..a23c373 100644
--- a/drivers/dsp/bridge/wmd/_tiomap.h
+++ b/drivers/dsp/bridge/wmd/_tiomap.h
@@ -19,6 +19,10 @@
 #ifndef _TIOMAP_
 #define _TIOMAP_
 
+#include <plat/powerdomain.h>
+#include <plat/clockdomain.h>
+#include <mach-omap2/prm-regbits-34xx.h>
+#include <mach-omap2/cm-regbits-34xx.h>
 #include <dspbridge/devdefs.h>
 #include <hw_defs.h>
 #include <dspbridge/wmdioctl.h>	/* for wmdioctl_extproc defn */
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 45684df..e4088b3 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -20,10 +20,6 @@
 #include <dspbridge/host_os.h>
 #include <linux/mm.h>
 #include <linux/mmzone.h>
-#include <mach-omap2/prm.h>
-#include <mach-omap2/cm.h>
-#include <mach-omap2/prm-regbits-34xx.h>
-#include <mach-omap2/cm-regbits-34xx.h>
 #include <plat/control.h>
 
 /*  ----------------------------------- DSP/BIOS Bridge */
@@ -43,7 +39,6 @@
 
 /* ------------------------------------ Hardware Abstraction Layer */
 #include <hw_defs.h>
-#include <hw_prcm.h>
 #include <hw_mmu.h>
 
 /*  ----------------------------------- Link Driver */
@@ -129,37 +124,6 @@ static dsp_status mem_map_vmalloc(struct wmd_dev_context *hDevContext,
 				  u32 ul_num_bytes,
 				  struct hw_mmu_map_attrs_t *hw_attrs);
 
-#ifdef CONFIG_BRIDGE_DEBUG
-static void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
-{
-	u32 temp;
-	temp = __raw_readl((cm_base) + 0x00);
-	dev_dbg(bridge, "CM_FCLKEN_IVA2 = 0x%x\n", temp);
-	temp = __raw_readl((cm_base) + 0x10);
-	dev_dbg(bridge, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((cm_base) + 0x20);
-	dev_dbg(bridge, "CM_IDLEST_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((cm_base) + 0x48);
-	dev_dbg(bridge, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((cm_base) + 0x4c);
-	dev_dbg(bridge, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((prm_base) + 0x50);
-	dev_dbg(bridge, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((prm_base) + 0x58);
-	dev_dbg(bridge, "RM_RSTST_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((prm_base) + 0xE0);
-	dev_dbg(bridge, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((prm_base) + 0xE4);
-	dev_dbg(bridge, "PM_PWSTST_IVA2 = 0x%x \n", temp);
-	temp = __raw_readl((cm_base) + 0xA10);
-	dev_dbg(bridge, "CM_ICLKEN1_CORE = 0x%x \n", temp);
-}
-#else
-static inline void get_hw_regs(void __iomem *prm_base, void __iomem *cm_base)
-{
-}
-#endif
-
 /*  ----------------------------------- Globals */
 
 /* Attributes of L2 page tables for DSP MMU */
@@ -319,44 +283,37 @@ static dsp_status bridge_brd_monitor(struct wmd_dev_context *hDevContext)
 {
 	dsp_status status = DSP_SOK;
 	struct wmd_dev_context *dev_context = hDevContext;
-	struct cfg_hostres resources;
 	u32 temp;
-	enum hw_pwr_state_t pwr_state;
+	struct dspbridge_platform_data *pdata =
+				    omap_dspbridge_dev->dev.platform_data;
 
-	status = cfg_get_host_resources((struct cfg_devnode *)
-					drv_get_first_dev_extension(),
-					&resources);
-	if (DSP_FAILED(status))
-		goto error_return;
-
-	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
-	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &temp);
-	if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
+	temp = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, PM_PWSTST) &
+					OMAP_POWERSTATEST_MASK;
+	if (!(temp & 0x02)) {
 		/* IVA2 is not in ON state */
 		/* Read and set PM_PWSTCTRL_IVA2  to ON */
-		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
-					    HW_PWR_DOMAIN_DSP, HW_PWR_STATE_ON);
+		(*pdata->dsp_prm_rmw_bits)(OMAP_POWERSTATEST_MASK,
+			PWRDM_POWER_ON, OMAP3430_IVA2_MOD, PM_PWSTCTRL);
 		/* Set the SW supervised state transition */
-		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
-					    HW_SW_SUP_WAKEUP);
+		(*pdata->dsp_cm_write)(OMAP34XX_CLKSTCTRL_FORCE_WAKEUP,
+					OMAP3430_IVA2_MOD, CM_CLKSTCTRL);
+
 		/* Wait until the state has moved to ON */
-		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
-				      &pwr_state);
+		while ((*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, PM_PWSTST) &
+						OMAP_INTRANSITION)
+			;
 		/* Disable Automatic transition */
-		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
-					    HW_AUTOTRANS_DIS);
+		(*pdata->dsp_cm_write)(OMAP34XX_CLKSTCTRL_DISABLE_AUTO,
+					OMAP3430_IVA2_MOD, CM_CLKSTCTRL);
 	}
-
-	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
-	hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
+	(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST2_IVA2, 0,
+					OMAP3430_IVA2_MOD, RM_RSTCTRL);
 	services_clk_enable(SERVICESCLK_IVA2_CK);
 
 	if (DSP_SUCCEEDED(status)) {
 		/* set the device state to IDLE */
 		dev_context->dw_brd_state = BRD_IDLE;
 	}
-error_return:
-	get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 	return status;
 }
 
@@ -441,6 +398,8 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 	u32 ext_clk_id = 0;
 	u32 tmp_index;
 	u32 clk_id_index = MBX_PM_MAX_RESOURCES;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
 
 	/* The device context contains all the mmu setup info from when the
 	 * last dsp base image was loaded. The first entry is always
@@ -474,9 +433,10 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 						drv_get_first_dev_extension(),
 						&resources);
 		/* Assert RST1 i.e only the RST only for DSP megacell */
-		/* hw_rst_reset(resources.dwPrcmBase, HW_RST1_IVA2); */
 		if (DSP_SUCCEEDED(status)) {
-			hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
+			(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST1_IVA2,
+					OMAP3430_RST1_IVA2, OMAP3430_IVA2_MOD,
+					RM_RSTCTRL);
 			/* Mask address with 1K for compatibility */
 			__raw_writel(dwDSPAddr & OMAP3_IVA2_BOOTADDR_MASK,
 					OMAP343X_CTRL_REGADDR(
@@ -492,12 +452,13 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 	if (DSP_SUCCEEDED(status)) {
 		/* Reset and Unreset the RST2, so that BOOTADDR is copied to
 		 * IVA2 SYSC register */
-		hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
+		(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST2_IVA2,
+			OMAP3430_RST1_IVA2, OMAP3430_IVA2_MOD, RM_RSTCTRL);
 		udelay(100);
-		hw_rst_un_reset(resources.dw_prm_base, HW_RST2_IVA2);
+		(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST2_IVA2, 0,
+					OMAP3430_IVA2_MOD, RM_RSTCTRL);
 		udelay(100);
 
-		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		/* Disbale the DSP MMU */
 		hw_mmu_disable(resources.dw_dmmu_base);
 		/* Disable TWL */
@@ -643,11 +604,9 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 		(void)dev_get_symbol(dev_context->hdev_obj,
 				     "_BRIDGEINIT_DSP_FREQ", &ul_dsp_clk_addr);
 		/*Set Autoidle Mode for IVA2 PLL */
-		temp = (u32) *((reg_uword32 *)
-				((u32) (resources.dw_cm_base) + 0x34));
-		temp = (temp & 0xFFFFFFFE) | 0x1;
-		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x34)) =
-		    (u32) temp;
+		(*pdata->dsp_cm_write)(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
+				OMAP3430_IVA2_MOD, OMAP3430_CM_AUTOIDLE_PLL);
+
 		if ((unsigned int *)ul_dsp_clk_addr != NULL) {
 			/* Get the clock rate */
 			status = services_clk_get_rate(SERVICESCLK_IVA2_CK,
@@ -695,11 +654,8 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 		    (u32) temp;
 
 /*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions */
-		temp = (u32) *((reg_uword32 *)
-				((u32) (resources.dw_cm_base) + 0x48));
-		temp = (temp & 0xFFFFFFFC) | 0x03;
-		*((reg_uword32 *) ((u32) (resources.dw_cm_base) + 0x48)) =
-		    (u32) temp;
+		(*pdata->dsp_cm_write)(OMAP34XX_CLKSTCTRL_ENABLE_AUTO,
+					OMAP3430_IVA2_MOD, CM_CLKSTCTRL);
 
 		/* Let DSP go */
 		dev_dbg(bridge, "%s Unreset\n", __func__);
@@ -707,7 +663,8 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 		hw_mmu_event_enable(resources.dw_dmmu_base,
 				    HW_MMU_ALL_INTERRUPTS);
 		/* release the RST1, DSP starts executing now .. */
-		hw_rst_un_reset(resources.dw_prm_base, HW_RST1_IVA2);
+		(*pdata->dsp_prm_rmw_bits)(OMAP3430_RST1_IVA2, 0,
+					OMAP3430_IVA2_MOD, RM_RSTCTRL);
 
 		dev_dbg(bridge, "Waiting for Sync @ 0x%x\n", dw_sync_addr);
 		dev_dbg(bridge, "DSP c_int00 Address =  0x%x\n", dwDSPAddr);
@@ -754,10 +711,11 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 {
 	dsp_status status = DSP_SOK;
 	struct wmd_dev_context *dev_context = hDevContext;
-	struct cfg_hostres resources;
 	struct pg_table_attrs *pt_attrs;
 	u32 dsp_pwr_state;
 	dsp_status clk_status;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
 
 	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
@@ -765,29 +723,21 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 	/* as per TRM, it is advised to first drive the IVA2 to 'Standby' mode,
 	 * before turning off the clocks.. This is to ensure that there are no
 	 * pending L3 or other transactons from IVA2 */
-	status = cfg_get_host_resources((struct cfg_devnode *)
-					drv_get_first_dev_extension(),
-					&resources);
-	if (DSP_FAILED(status))
-		return -EPERM;
-
-	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &dsp_pwr_state);
-	if (dsp_pwr_state != HW_PWR_STATE_OFF && dev_context->mbox) {
+	dsp_pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, PM_PWSTST) &
+					OMAP_POWERSTATEST_MASK;
+	if (dsp_pwr_state != PWRDM_POWER_OFF) {
 		sm_interrupt_dsp(dev_context, MBX_PM_DSPIDLE);
 		mdelay(10);
-		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
-		udelay(50);
 
 		clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 
 		/* IVA2 is not in OFF state */
 		/* Set PM_PWSTCTRL_IVA2  to OFF */
-		hw_pwr_iva2_power_state_set(resources.dw_prm_base,
-					    HW_PWR_DOMAIN_DSP,
-					    HW_PWR_STATE_OFF);
+		(*pdata->dsp_prm_rmw_bits)(OMAP_POWERSTATEST_MASK,
+			PWRDM_POWER_OFF, OMAP3430_IVA2_MOD, PM_PWSTCTRL);
 		/* Set the SW supervised state transition for Sleep */
-		hw_pwr_clkctrl_iva2_reg_set(resources.dw_cm_base,
-					    HW_SW_SUP_SLEEP);
+		(*pdata->dsp_cm_write)(OMAP34XX_CLKSTCTRL_FORCE_SLEEP,
+					OMAP3430_IVA2_MOD, CM_CLKSTCTRL);
 	} else {
 		clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
 	}
@@ -815,10 +765,9 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 		omap_mbox_put(dev_context->mbox);
 		dev_context->mbox = NULL;
 	}
-
-	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
-	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
-	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
+	/* Reset IVA2 clocks*/
+	(*pdata->dsp_prm_write)(OMAP3430_RST1_IVA2 | OMAP3430_RST2_IVA2 |
+			OMAP3430_RST3_IVA2, OMAP3430_IVA2_MOD, RM_RSTCTRL);
 
 	return status;
 }
@@ -838,6 +787,8 @@ static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 	struct cfg_hostres resources;
 	struct pg_table_attrs *pt_attrs;
 	dsp_status clk_status;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
 
 	if (dev_context->dw_brd_state == BRD_STOPPED)
 		return status;
@@ -876,10 +827,9 @@ static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 		omap_mbox_put(dev_context->mbox);
 		dev_context->mbox = NULL;
 	}
-
-	hw_rst_reset(resources.dw_prm_base, HW_RST1_IVA2);
-	hw_rst_reset(resources.dw_prm_base, HW_RST2_IVA2);
-	hw_rst_reset(resources.dw_prm_base, HW_RST3_IVA2);
+	/* Reset IVA2 clocks*/
+	(*pdata->dsp_prm_write)(OMAP3430_RST1_IVA2 | OMAP3430_RST2_IVA2 |
+			OMAP3430_RST3_IVA2, OMAP3430_IVA2_MOD, RM_RSTCTRL);
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index 4adfcf9..71b4ade 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -33,7 +33,6 @@
 
 /* ------------------------------------ Hardware Abstraction Layer */
 #include <hw_defs.h>
-#include <hw_prcm.h>
 #include <hw_mmu.h>
 
 #include <dspbridge/pwr_sh.h>
@@ -87,31 +86,24 @@ dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context)
 	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
 	u16 timeout = PWRSTST_TIMEOUT / 10;
-	struct cfg_hostres resources;
-	enum hw_pwr_state_t pwr_state;
+	u32 pwr_state;
 #ifdef CONFIG_BRIDGE_DVFS
 	u32 opplevel;
 	struct io_mgr *hio_mgr;
+#endif
 	struct dspbridge_platform_data *pdata =
 	    omap_dspbridge_dev->dev.platform_data;
-#endif
-
-	status = cfg_get_host_resources((struct cfg_devnode *)
-					drv_get_first_dev_extension(),
-					&resources);
-	if (DSP_FAILED(status))
-		return status;
 
-	hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
-			      &pwr_state);
+	pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, PM_PWSTST) &
+						OMAP_POWERSTATEST_MASK;
 	/* Wait for DSP to move into OFF state */
-	while ((pwr_state != HW_PWR_STATE_OFF) && --timeout) {
+	while ((pwr_state != PWRDM_POWER_OFF) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP OFF mode interrupted\n");
 			return -EPERM;
 		}
-		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
-				      &pwr_state);
+		pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,
+					PM_PWSTST) & OMAP_POWERSTATEST_MASK;
 	}
 	if (timeout == 0) {
 		pr_err("%s: Timed out waiting for DSP off mode\n", __func__);
@@ -161,41 +153,36 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 {
 	dsp_status status = DSP_SOK;
 #ifdef CONFIG_PM
-	struct cfg_hostres resources;
 #ifdef CONFIG_BRIDGE_NTFY_PWRERR
 	struct deh_mgr *hdeh_mgr;
 #endif /* CONFIG_BRIDGE_NTFY_PWRERR */
 	u16 timeout = PWRSTST_TIMEOUT / 10;
-	enum hw_pwr_state_t pwr_state, target_pwr_state;
+	u32 pwr_state, target_pwr_state;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
 
 	/* Check if sleep code is valid */
 	if ((dw_cmd != PWR_DEEPSLEEP) && (dw_cmd != PWR_EMERGENCYDEEPSLEEP))
 		return -EINVAL;
 
-	status = cfg_get_host_resources((struct cfg_devnode *)
-					drv_get_first_dev_extension(),
-					&resources);
-	if (DSP_FAILED(status))
-		return status;
-
 	switch (dev_context->dw_brd_state) {
 	case BRD_RUNNING:
 		omap_mbox_save_ctx(dev_context->mbox);
-		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+		if (dsp_test_sleepstate == PWRDM_POWER_OFF) {
 			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
 			dev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",
 				__func__);
-			target_pwr_state = HW_PWR_STATE_OFF;
+			target_pwr_state = PWRDM_POWER_OFF;
 		} else {
 			sm_interrupt_dsp(dev_context, MBX_PM_DSPRETENTION);
-			target_pwr_state = HW_PWR_STATE_RET;
+			target_pwr_state = PWRDM_POWER_RET;
 		}
 		break;
 	case BRD_RETENTION:
 		omap_mbox_save_ctx(dev_context->mbox);
-		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+		if (dsp_test_sleepstate == PWRDM_POWER_OFF) {
 			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
-			target_pwr_state = HW_PWR_STATE_OFF;
+			target_pwr_state = PWRDM_POWER_OFF;
 		} else
 			return DSP_SOK;
 		break;
@@ -214,8 +201,8 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 	}
 
 	/* Get the PRCM DSP power domain status */
-	hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
-			      &pwr_state);
+	pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD, PM_PWSTST) &
+						OMAP_POWERSTATEST_MASK;
 
 	/* Wait for DSP to move into target power state */
 	while ((pwr_state != target_pwr_state) && --timeout) {
@@ -223,8 +210,8 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 			pr_err("Waiting for DSP to Suspend interrupted\n");
 			return -EPERM;
 		}
-		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
-				      &pwr_state);
+		pwr_state = (*pdata->dsp_prm_read)(OMAP3430_IVA2_MOD,
+					PM_PWSTST) & OMAP_POWERSTATEST_MASK;
 	}
 
 	if (!timeout) {
@@ -237,7 +224,7 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 		return -ETIMEDOUT;
 	} else {
 		/* Update the Bridger Driver state */
-		if (dsp_test_sleepstate == HW_PWR_STATE_OFF)
+		if (dsp_test_sleepstate == PWRDM_POWER_OFF)
 			dev_context->dw_brd_state = BRD_HIBERNATION;
 		else
 			dev_context->dw_brd_state = BRD_RETENTION;
@@ -251,9 +238,7 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 			return status;
 		}
 #ifdef CONFIG_BRIDGE_DVFS
-		else if (target_pwr_state == HW_PWR_STATE_OFF) {
-			struct dspbridge_platform_data *pdata =
-			    omap_dspbridge_dev->dev.platform_data;
+		else if (target_pwr_state == PWRDM_POWER_OFF) {
 			/*
 			 * Set the OPP to low level before moving to OFF mode
 			 */
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.c b/drivers/dsp/bridge/wmd/tiomap_io.c
index 125023c..b1874a6 100644
--- a/drivers/dsp/bridge/wmd/tiomap_io.c
+++ b/drivers/dsp/bridge/wmd/tiomap_io.c
@@ -398,10 +398,10 @@ dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
 dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
 {
 #ifdef CONFIG_BRIDGE_DVFS
-	struct dspbridge_platform_data *pdata =
-		omap_dspbridge_dev->dev.platform_data;
 	u32 opplevel = 0;
 #endif
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
 	struct cfg_hostres resources;
 	dsp_status status = DSP_SOK;
 	u32 temp;
@@ -433,16 +433,19 @@ dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
 		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
 		 *     in CM_AUTOIDLE_PLL_IVA2 register
 		 */
-		*(reg_uword32 *) (resources.dw_cm_base + 0x34) = 0x1;
+		(*pdata->dsp_cm_write)(1 << OMAP3430_AUTO_IVA2_DPLL_SHIFT,
+				OMAP3430_IVA2_MOD, OMAP3430_CM_AUTOIDLE_PLL);
 
 		/*
 		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
 		 *     0.75 MHz - 1.0 MHz
 		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
 		 */
-		temp = *(reg_uword32 *) (resources.dw_cm_base + 0x4);
-		temp = (temp & 0xFFFFFF08) | 0x37;
-		*(reg_uword32 *) (resources.dw_cm_base + 0x4) = temp;
+		(*pdata->dsp_cm_rmw_bits)(OMAP3430_IVA2_DPLL_FREQSEL_MASK |
+				OMAP3430_EN_IVA2_DPLL_MASK,
+				0x3 << OMAP3430_IVA2_DPLL_FREQSEL_SHIFT |
+				0x7 << OMAP3430_EN_IVA2_DPLL_SHIFT,
+				OMAP3430_IVA2_MOD, OMAP3430_CM_CLKEN_PLL);
 
 		/* Restore mailbox settings */
 		omap_mbox_restore_ctx(dev_context->mbox);
@@ -464,4 +467,4 @@ dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
 	}
 
 	return DSP_SOK;
-}
\ No newline at end of file
+}
-- 
1.7.0.4

