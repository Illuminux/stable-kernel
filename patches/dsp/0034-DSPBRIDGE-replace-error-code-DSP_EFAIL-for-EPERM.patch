From ccba3f4d435a16cc1a68d21265c016f32f998972 Mon Sep 17 00:00:00 2001
From: Shivananda Hebbar <x0hebbar@ti.com>
Date: Mon, 19 Apr 2010 18:14:45 -0500
Subject: [PATCH 034/135] DSPBRIDGE: replace error code DSP_EFAIL for -EPERM

This patch replaces DSP_EFAIL with -EPERM.

Signed-off-by: Shivananda Hebbar <x0hebbar@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/_dcd.h  |    2 +-
 arch/arm/plat-omap/include/dspbridge/cfg.h   |    6 ++--
 arch/arm/plat-omap/include/dspbridge/clk.h   |   10 +++---
 arch/arm/plat-omap/include/dspbridge/cmm.h   |   14 ++++----
 arch/arm/plat-omap/include/dspbridge/cod.h   |    2 +-
 arch/arm/plat-omap/include/dspbridge/dbdcd.h |   16 ++++----
 arch/arm/plat-omap/include/dspbridge/dev.h   |   14 ++++----
 arch/arm/plat-omap/include/dspbridge/disp.h  |    4 +-
 arch/arm/plat-omap/include/dspbridge/drv.h   |   12 +++---
 arch/arm/plat-omap/include/dspbridge/mgr.h   |   12 +++---
 arch/arm/plat-omap/include/dspbridge/node.h  |   28 +++++++-------
 arch/arm/plat-omap/include/dspbridge/proc.h  |   48 +++++++++++++-------------
 arch/arm/plat-omap/include/dspbridge/pwr.h   |    8 ++--
 arch/arm/plat-omap/include/dspbridge/reg.h   |    8 ++--
 arch/arm/plat-omap/include/dspbridge/strm.h  |   24 ++++++------
 arch/arm/plat-omap/include/dspbridge/wmd.h   |   44 ++++++++++++------------
 drivers/dsp/bridge/pmgr/cmm.c                |   12 +++---
 drivers/dsp/bridge/pmgr/cod.c                |    6 ++--
 drivers/dsp/bridge/pmgr/dbll.c               |    2 +-
 drivers/dsp/bridge/pmgr/dev.c                |   10 +++---
 drivers/dsp/bridge/pmgr/msg.c                |    2 +-
 drivers/dsp/bridge/pmgr/wcd.c                |    8 ++--
 drivers/dsp/bridge/rmgr/dbdcd.c              |   42 +++++++++++-----------
 drivers/dsp/bridge/rmgr/disp.c               |   16 ++++----
 drivers/dsp/bridge/rmgr/drv.c                |   20 +++++-----
 drivers/dsp/bridge/rmgr/dspdrv.c             |    4 +-
 drivers/dsp/bridge/rmgr/mgr.c                |    6 ++--
 drivers/dsp/bridge/rmgr/nldr.c               |    4 +-
 drivers/dsp/bridge/rmgr/node.c               |   34 +++++++++---------
 drivers/dsp/bridge/rmgr/proc.c               |   26 +++++++-------
 drivers/dsp/bridge/rmgr/pwr.c                |    8 ++--
 drivers/dsp/bridge/rmgr/strm.c               |   16 ++++----
 drivers/dsp/bridge/services/clk.c            |   12 +++---
 drivers/dsp/bridge/services/reg.c            |    2 +-
 drivers/dsp/bridge/services/regsup.c         |    6 ++--
 drivers/dsp/bridge/services/regsup.h         |    4 +-
 drivers/dsp/bridge/services/sync.c           |    4 +-
 drivers/dsp/bridge/wmd/chnl_sm.c             |    2 +-
 drivers/dsp/bridge/wmd/io_sm.c               |   20 +++++-----
 drivers/dsp/bridge/wmd/msg_sm.c              |    8 ++--
 drivers/dsp/bridge/wmd/tiomap3430.c          |   44 ++++++++++++------------
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c      |   18 +++++-----
 drivers/dsp/bridge/wmd/tiomap_io.c           |   20 +++++-----
 drivers/dsp/bridge/wmd/ue_deh.c              |    2 +-
 44 files changed, 305 insertions(+), 305 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/_dcd.h b/arch/arm/plat-omap/include/dspbridge/_dcd.h
index 1350feb..9500594 100644
--- a/arch/arm/plat-omap/include/dspbridge/_dcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/_dcd.h
@@ -63,7 +63,7 @@ extern bool wcd_init(void);
  *  Parameters:
  *  Returns:
  *      DSP_SOK:        Allow this device to load
- *      DSP_EFAIL:      Failure.
+ *      -EPERM:      Failure.
  *  Requires:
  *      WCD initialized.
  *  Ensures:
diff --git a/arch/arm/plat-omap/include/dspbridge/cfg.h b/arch/arm/plat-omap/include/dspbridge/cfg.h
index 80c8fde..83a76e9 100644
--- a/arch/arm/plat-omap/include/dspbridge/cfg.h
+++ b/arch/arm/plat-omap/include/dspbridge/cfg.h
@@ -63,7 +63,7 @@ extern dsp_status cfg_get_auto_start(IN struct cfg_devnode *dev_node_obj,
  *      DSP_SOK:    Success.  pdwVersion contains Class Driver version in
  *                  the form: 0xAABBCCDD where AABB is Major version and
  *                  CCDD is Minor.
- *      DSP_EFAIL:  Failure.
+ *      -EPERM:  Failure.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
@@ -262,7 +262,7 @@ extern bool cfg_init(void);
  *  Returns:
  *      DSP_SOK:                Success.
  *      CFG_E_INVALIDHDEVNODE:  dev_node_obj is invalid.
- *      DSP_EFAIL:              Internal Error.
+ *      -EPERM:              Internal Error.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
@@ -280,7 +280,7 @@ extern dsp_status cfg_set_dev_object(IN struct cfg_devnode *dev_node_obj,
  *      dw_type          Type of Object to Store
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Internal Error.
+ *      -EPERM:      Internal Error.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
diff --git a/arch/arm/plat-omap/include/dspbridge/clk.h b/arch/arm/plat-omap/include/dspbridge/clk.h
index 89dd4d2..c36b634 100644
--- a/arch/arm/plat-omap/include/dspbridge/clk.h
+++ b/arch/arm/plat-omap/include/dspbridge/clk.h
@@ -84,7 +84,7 @@ extern bool services_clk_init(void);
  *  Parameters:
  *  Returns:
  *      DSP_SOK:	Success.
- *	DSP_EFAIL:	Error occured while enabling the clock.
+ *	-EPERM:	Error occured while enabling the clock.
  *  Requires:
  *  Ensures:
  */
@@ -97,7 +97,7 @@ extern dsp_status services_clk_enable(IN enum services_clk_id clk_id);
  *  Parameters:
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while disabling the clock.
+ *      -EPERM:      Error occured while disabling the clock.
  *  Requires:
  *  Ensures:
  */
@@ -110,7 +110,7 @@ extern dsp_status services_clk_disable(IN enum services_clk_id clk_id);
  *  Parameters:
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while Getting the clock rate.
+ *      -EPERM:      Error occured while Getting the clock rate.
  *  Requires:
  *  Ensures:
  */
@@ -123,7 +123,7 @@ extern dsp_status services_clk_get_rate(IN enum services_clk_id clk_id,
  *  Parameters:
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Error occured while setting the clock parent to 32KHz.
+ *      -EPERM:      Error occured while setting the clock parent to 32KHz.
  *  Requires:
  *  Ensures:
  */
@@ -137,7 +137,7 @@ extern void ssi_clk_prepare(bool FLAG);
  *  Parameters:
  *  Returns:
  *      s32:        Reference Count for the clock.
- *      DSP_EFAIL:  Error occured while getting the reference count of a clock.
+ *      -EPERM:  Error occured while getting the reference count of a clock.
  *  Requires:
  *  Ensures:
  */
diff --git a/arch/arm/plat-omap/include/dspbridge/cmm.h b/arch/arm/plat-omap/include/dspbridge/cmm.h
index 797323a..5d2dfe1 100644
--- a/arch/arm/plat-omap/include/dspbridge/cmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/cmm.h
@@ -76,7 +76,7 @@ extern void *cmm_calloc_buf(struct cmm_object *hcmm_mgr,
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      Failed to initialize critical sect sync object.
+ *      -EPERM:      Failed to initialize critical sect sync object.
  *
  *  Requires:
  *      cmm_init(void) called.
@@ -96,11 +96,11 @@ extern dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
  *  Parameters:
  *      hcmm_mgr:   Cmm Mgr handle.
  *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
- *                 If FALSE, and outstanding allocations will return DSP_EFAIL
+ *                 If FALSE, and outstanding allocations will return -EPERM
  *                 status.
  *  Returns:
  *      DSP_SOK:        CMM object & resources deleted.
- *      DSP_EFAIL:      Unable to free CMM object due to outstanding allocation.
+ *      -EPERM:      Unable to free CMM object due to outstanding allocation.
  *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
  *  Requires:
  *      CMM is initialized.
@@ -135,7 +135,7 @@ extern void cmm_exit(void);
  *                  Set to 0 to use default segment.
  *  Returns:
  *      DSP_SOK
- *      DSP_EFAIL
+ *      -EPERM
  *  Requires:
  *      CMM initialized.
  *      buf_pa != NULL
@@ -215,7 +215,7 @@ extern bool cmm_init(void);
  *      DSP_SOK:         Success.
  *      DSP_EHANDLE:     Invalid hcmm_mgr handle.
  *      DSP_EINVALIDARG: Invalid input argument.
- *      DSP_EFAIL:       Unable to register.
+ *      -EPERM:       Unable to register.
  *      - On success *pulSegId is a valid SM segment ID.
  *  Requires:
  *      ul_size > 0
@@ -246,7 +246,7 @@ extern dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
  *       DSP_SOK:         Success.
  *       DSP_EHANDLE:     Invalid handle.
  *       DSP_EINVALIDARG: Invalid ul_seg_id.
- *       DSP_EFAIL:       Unable to unregister for unknown reason.
+ *       -EPERM:       Unable to unregister for unknown reason.
  *  Requires:
  *  Ensures:
  *
@@ -309,7 +309,7 @@ extern dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Bad translator handle.
- *      DSP_EFAIL:      Unable to free translator resources.
+ *      -EPERM:      Unable to free translator resources.
  *  Requires:
  *      refs > 0
  *  Ensures:
diff --git a/arch/arm/plat-omap/include/dspbridge/cod.h b/arch/arm/plat-omap/include/dspbridge/cod.h
index 3d76a6b..66cb357 100644
--- a/arch/arm/plat-omap/include/dspbridge/cod.h
+++ b/arch/arm/plat-omap/include/dspbridge/cod.h
@@ -156,7 +156,7 @@ extern dsp_status cod_get_base_lib(struct cod_manager *cod_mgr_obj,
  *      usize:       size of name buffer.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Buffer too small.
+ *      -EPERM:  Buffer too small.
  *  Requires:
  *      COD module initialized.
  *      valid cod_mgr_obj.
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcd.h b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
index c782c8d..3960c69 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
@@ -85,7 +85,7 @@ extern dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Unable to allocate memory for DCD manager handle.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      DCD initialized.
  *      pszZlDllName is non-NULL.
@@ -122,7 +122,7 @@ extern dsp_status dcd_destroy_manager(IN struct dcd_manager *hdcd_mgr);
  *      uuid_obj:              Pointer to a dsp_uuid object.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EFAIL:          Unable to enumerate through the DCD database.
+ *      -EPERM:          Unable to enumerate through the DCD database.
  *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
  *  Requires:
  *      DCD initialized.
@@ -165,7 +165,7 @@ extern void dcd_exit(void);
  *      DSP_SOK: Success.
  *      DSP_EMEMORY: Memory allocation failure.
  *      DSP_EDCDREADSECT: Failure to read section containing library info.
- *      DSP_EFAIL: General failure.
+ *      -EPERM: General failure.
  *  Requires:
  *      DCD initialized.
  *      Valid hdcd_mgr.
@@ -195,7 +195,7 @@ extern dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
  *      DSP_SOK: Success.
  *      DSP_EMEMORY: Memory allocation failure.
  *      DSP_EDCDREADSECT: Failure to read section containing library info.
- *      DSP_EFAIL: General failure.
+ *      -EPERM: General failure.
  *  Requires:
  *      DCD initialized.
  *      Valid hdcd_mgr.
@@ -224,7 +224,7 @@ extern dsp_status dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
  *      phase_split:    Are phases in multiple libraries
  *  Returns:
  *      DSP_SOK: Success.
- *      DSP_EFAIL: General failure.
+ *      -EPERM: General failure.
  *  Requires:
  *      DCD initialized.
  *      Valid hdcd_mgr.
@@ -259,7 +259,7 @@ extern dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
  *      DSP_EDCDREADSECT:   Unable to read object code section.
  *      DSP_EDCDGETSECT:    Unable to access object code section.
  *      DSP_EDCDLOADBASE:   Unable to load code base.
- *      DSP_EFAIL:          General failure.
+ *      -EPERM:          General failure.
  *      DSP_EHANDLE:        Invalid DCD_HMANAGER handle.
  *  Requires:
  *      DCD initialized.
@@ -330,7 +330,7 @@ extern bool dcd_init(void);
  *      psz_path_name:    Path to the object's COFF file.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to register object.
+ *      -EPERM:      Failed to register object.
  *  Requires:
  *      DCD initialized.
  *      uuid_obj and szPathName are non-NULL values.
@@ -352,7 +352,7 @@ extern dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
  *      obj_type:    Type of object.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Unable to de-register the specified object.
+ *      -EPERM:  Unable to de-register the specified object.
  *  Requires:
  *      DCD initialized.
  *      uuid_obj is a non-NULL value.
diff --git a/arch/arm/plat-omap/include/dspbridge/dev.h b/arch/arm/plat-omap/include/dspbridge/dev.h
index 13b0cad..6bf3c48 100644
--- a/arch/arm/plat-omap/include/dspbridge/dev.h
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -82,7 +82,7 @@ extern u32 dev_brd_write_fxn(void *pArb,
  *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
- *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      -EPERM:              Unable to find WMD entry point function.
  *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
  *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
  *  Requires:
@@ -127,7 +127,7 @@ extern dsp_status dev_create_device(OUT struct dev_object
  *                          for this dev_node_obj.
  *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
  *      LDR_E_NOMEMORY:         PELDR is out of resources.
- *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      -EPERM:              Unable to find WMD entry point function.
  *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
  *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
  *  Requires:
@@ -159,7 +159,7 @@ extern dsp_status dev_create_iva_device(OUT struct dev_object
  *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
- *      DSP_EFAIL:  Some Error Occurred.
+ *      -EPERM:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
  *      Valid hdev_obj
@@ -177,13 +177,13 @@ extern dsp_status dev_create2(IN struct dev_object *hdev_obj);
  *      hdev_obj: Handle to device object created with dev_create_device().
  *  Returns:
  *      DSP_SOK:    Successful Creation of Node Manager
- *      DSP_EFAIL:  Some Error Occurred.
+ *      -EPERM:  Some Error Occurred.
  *  Requires:
  *      DEV Initialized
  *      Valid hdev_obj
  *  Ensures:
  *      DSP_SOK and hdev_obj->hnode_mgr == NULL
- *      else    DSP_EFAIL.
+ *      else    -EPERM.
  */
 extern dsp_status dev_destroy2(IN struct dev_object *hdev_obj);
 
@@ -198,7 +198,7 @@ extern dsp_status dev_destroy2(IN struct dev_object *hdev_obj);
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hdev_obj.
- *      DSP_EFAIL:      The WMD failed it's bridge_dev_destroy() function.
+ *      -EPERM:      The WMD failed it's bridge_dev_destroy() function.
  *  Requires:
  *      DEV Initialized.
  *  Ensures:
@@ -613,7 +613,7 @@ extern dsp_status dev_insert_proc_object(IN struct dev_object
  *      pbAlreadyAttached:  Ptr to return the bool
  *  Returns:
  *      DSP_SOK:            If successful.
- *      DSP_EFAIL           Failure to Remove the PROC Object from the list
+ *      -EPERM           Failure to Remove the PROC Object from the list
  *  Requires:
  *      DevObject is Valid
  *      proc_obj != 0
diff --git a/arch/arm/plat-omap/include/dspbridge/disp.h b/arch/arm/plat-omap/include/dspbridge/disp.h
index a6c8054..8e17536 100644
--- a/arch/arm/plat-omap/include/dspbridge/disp.h
+++ b/arch/arm/plat-omap/include/dspbridge/disp.h
@@ -38,7 +38,7 @@
  *  Returns:
  *      DSP_SOK:                Success;
  *      DSP_EMEMORY:            Insufficient memory for requested resources.
- *      DSP_EFAIL:              Unable to create dispatcher.
+ *      -EPERM:              Unable to create dispatcher.
  *  Requires:
  *      disp_init(void) called.
  *      pDispAttrs != NULL.
@@ -136,7 +136,7 @@ extern dsp_status disp_node_change_priority(struct disp_object
  *      DSP_ESTREAM:    Stream creation failure on the DSP.
  *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
  *      DSP_EUSER:      A user-defined failure occurred.
- *      DSP_EFAIL:      A failure occurred, unable to create node.
+ *      -EPERM:      A failure occurred, unable to create node.
  *  Requires:
  *      disp_init(void) called.
  *      Valid hDispObject.
diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
index 947cbdd..778b57d 100644
--- a/arch/arm/plat-omap/include/dspbridge/drv.h
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -160,7 +160,7 @@ struct process_context {
  *  Returns:
  *      DSP_SOK:        Sucess
  *      DSP_EMEMORY:    Failed in Memory allocation
- *      DSP_EFAIL:      General Failure
+ *      -EPERM:      General Failure
  *  Requires:
  *      DRV Initialized (refs > 0 )
  *      phDrvObject != NULL.
@@ -189,7 +189,7 @@ extern dsp_status drv_create(struct drv_object **phDrvObject);
  *      hdrv_obj:     Handle to Driver object .
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to destroy DRV Object
+ *      -EPERM:      Failed to destroy DRV Object
  *  Requires:
  *      DRV Initialized (cRegs > 0 )
  *      hdrv_obj is not NULL and a valid DRV handle .
@@ -256,10 +256,10 @@ extern u32 drv_get_first_dev_extension(void);
  *      Device Object List not Empty
  *  Returns:
  *      DSP_SOK:        Success
- *      DSP_EFAIL:      Failed to Get the Dev Object
+ *      -EPERM:      Failed to Get the Dev Object
  *  Ensures:
  *      DSP_SOK:        *phDevObject != NULL
- *      DSP_EFAIL:      *phDevObject = NULL
+ *      -EPERM:      *phDevObject = NULL
  */
 extern dsp_status drv_get_dev_object(u32 index,
 				     struct drv_object *hdrv_obj,
@@ -318,7 +318,7 @@ extern dsp_status drv_init(void);
  *      hdev_obj:     Handle to DeviceObject to insert.
  *  Returns:
  *      DSP_SOK:        If successful.
- *      DSP_EFAIL:      General Failure:
+ *      -EPERM:      General Failure:
  *  Requires:
  *      hdrv_obj != NULL and Valid DRV Handle.
  *      hdev_obj != NULL.
@@ -338,7 +338,7 @@ extern dsp_status drv_insert_dev_object(struct drv_object *hdrv_obj,
  *      hdev_obj:     Handle to DevObject to Remove
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to find dev_obj.
+ *      -EPERM:      Unable to find dev_obj.
  *  Requires:
  *      hdrv_obj != NULL and a Valid DRV Handle.
  *      hdev_obj != NULL.
diff --git a/arch/arm/plat-omap/include/dspbridge/mgr.h b/arch/arm/plat-omap/include/dspbridge/mgr.h
index feb1b61..79d23ff 100644
--- a/arch/arm/plat-omap/include/dspbridge/mgr.h
+++ b/arch/arm/plat-omap/include/dspbridge/mgr.h
@@ -54,7 +54,7 @@ dsp_status mgr_wait_for_bridge_events(struct dsp_notification
  *  Returns:
  *      DSP_SOK:        Success
  *      DSP_EMEMORY:    Failed to Create the Object
- *      DSP_EFAIL:      General Failure
+ *      -EPERM:      General Failure
  *  Requires:
  *      MGR Initialized (refs > 0 )
  *      phMgrObject != NULL.
@@ -79,7 +79,7 @@ extern dsp_status mgr_create(OUT struct mgr_object **hmgr_obj,
  *      DSP_SOK:        Success.
  *                      DCD Manager freed; MGR Object destroyed;
  *                      MGR Object deleted from the Registry.
- *      DSP_EFAIL:      Failed to destroy MGR Object
+ *      -EPERM:      Failed to destroy MGR Object
  *  Requires:
  *      MGR Initialized (refs > 0 )
  *      hmgr_obj is a valid MGR handle .
@@ -107,7 +107,7 @@ extern dsp_status mgr_destroy(struct mgr_object *hmgr_obj);
  *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
  *                              the number of nodes configured or in the
  *                              the properties of the enumerated nodes.
- *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *      -EPERM:          Failed to querry the Node Data Base
  *  Requires:
  *      pNDBPROPS is not null
  *      undb_props_size >= sizeof(dsp_ndbprops)
@@ -138,7 +138,7 @@ extern dsp_status mgr_enum_node_info(u32 node_id,
  *      DSP_SOK:            Success.
  *      DSP_EINVALIDARG:    Parameter processor_id is > than the number of
  *                          DSP Processors in the system.
- *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *      -EPERM:          Failed to querry the Node Data Base
  *  Requires:
  *      processor_info is not null
  *      pu_num_procs is not null
@@ -177,13 +177,13 @@ extern void mgr_exit(void);
  *      phDCDHandle:    Ptr to receive the DCD Handle.
  *  Returns:
  *      DSP_SOK:        Sucess
- *      DSP_EFAIL:      Failure to get the Handle
+ *      -EPERM:      Failure to get the Handle
  *  Requires:
  *      MGR is initialized.
  *      phDCDHandle != NULL
  *  Ensures:
  *      DSP_SOK and *phDCDHandle != NULL ||
- *      DSP_EFAIL and *phDCDHandle == NULL
+ *      -EPERM and *phDCDHandle == NULL
  */
 extern dsp_status mgr_get_dcd_handle(IN struct mgr_object
 				     *hMGRHandle, OUT u32 *phDCDHandle);
diff --git a/arch/arm/plat-omap/include/dspbridge/node.h b/arch/arm/plat-omap/include/dspbridge/node.h
index ec0dcf3..863efb0 100644
--- a/arch/arm/plat-omap/include/dspbridge/node.h
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -44,7 +44,7 @@
  *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
  *      DSP_ERANGE:         attr_in != NULL and attr_in->prio out of
  *                          range.
- *      DSP_EFAIL:          A failure occured, unable to allocate node.
+ *      -EPERM:          A failure occured, unable to allocate node.
  *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
  *  Requires:
  *      node_init(void) called.
@@ -78,7 +78,7 @@ extern dsp_status node_allocate(struct proc_object *hprocessor,
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid node handle.
  *      DSP_EMEMORY:    Insufficent memory.
- *      DSP_EFAIL:      General Failure.
+ *      -EPERM:      General Failure.
  *      DSP_ESIZE:      Invalid Size.
  *  Requires:
  *      node_init(void) called.
@@ -106,7 +106,7 @@ extern dsp_status node_alloc_msg_buf(struct node_object *hnode,
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_ERESTART:       A critical error has occurred and the DSP is
  *                          being restarted.
- *      DSP_EFAIL:          Unable to change node's runtime priority level.
+ *      -EPERM:          Unable to change node's runtime priority level.
  *  Requires:
  *      node_init(void) called.
  *  Ensures:
@@ -123,7 +123,7 @@ extern dsp_status node_change_priority(struct node_object *hnode, s32 prio);
  *      hProc:          Handle to processor object being destroyed.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
+ *      -EPERM:      Unable to delete all nodes belonging to hProc.
  *  Requires:
  *      Valid hnode_mgr.
  *      hProc != NULL.
@@ -173,7 +173,7 @@ extern dsp_status node_close_orphans(struct node_mgr *hnode_mgr,
  *      DSP_EWRONGSTATE:        Either hNode1 or hNode2 is not in the
  *                              NODE_ALLOCATED state.
  *      DSP_ENOMORECONNECTIONS: No more connections available.
- *      DSP_EFAIL:              Attempt to make an illegal connection (eg,
+ *      -EPERM:              Attempt to make an illegal connection (eg,
  *                              Device node to device node, or device node to
  *                              GPP), the two nodes are on different DSPs.
  *  Requires:
@@ -206,7 +206,7 @@ extern dsp_status node_connect(struct node_object *hNode1,
  *      DSP_ESTREAM:        Stream creation failure on the DSP.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
- *      DSP_EFAIL:          A failure occurred, unable to create node.
+ *      -EPERM:          A failure occurred, unable to create node.
  *  Requires:
  *      node_init(void) called.
  *  Ensures:
@@ -227,7 +227,7 @@ extern dsp_status node_create(struct node_object *hnode);
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      node_init(void) called.
  *      phNodeMgr != NULL.
@@ -254,7 +254,7 @@ extern dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EDELETE:        A deletion failure occurred.
  *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
- *      DSP_EFAIL:          A failure occurred in deleting the node.
+ *      -EPERM:          A failure occurred in deleting the node.
  *      DSP_ESYMBOL:        Delete function not found in the COFF file.
  *  Requires:
  *      node_init(void) called.
@@ -334,7 +334,7 @@ extern void node_exit(void);
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid node handle.
- *      DSP_EFAIL:      Failure to free the buffer.
+ *      -EPERM:      Failure to free the buffer.
  *  Requires:
  *      node_init(void) called.
  *      pbuffer != NULL.
@@ -384,7 +384,7 @@ extern dsp_status node_get_attr(struct node_object *hnode,
  *      DSP_EHANDLE:    Invalid hnode.
  *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
  *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
- *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
+ *      -EPERM:      Error occurred while trying to retrieve a message.
  *  Requires:
  *      node_init(void) called.
  *      message != NULL.
@@ -446,7 +446,7 @@ void node_on_exit(struct node_object *hnode, s32 nStatus);
  *      DSP_ENODETYPE:      Node is not a task or socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
- *      DSP_EFAIL:          Failed to pause node.
+ *      -EPERM:          Failed to pause node.
  *  Requires:
  *      node_init(void) called.
  *  Ensures:
@@ -470,7 +470,7 @@ extern dsp_status node_pause(struct node_object *hnode);
  *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
  *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
  *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
- *      DSP_EFAIL:          Unable to send message.
+ *      -EPERM:          Unable to send message.
  *  Requires:
  *      node_init(void) called.
  *      pmsg != NULL.
@@ -521,7 +521,7 @@ extern dsp_status node_register_notify(struct node_object *hnode,
  *                          socket node.
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
- *      DSP_EFAIL:          Unable to start or resume execution.
+ *      -EPERM:          Unable to start or resume execution.
  *      DSP_ESYMBOL:        Execute function not found in the COFF file.
  *  Requires:
  *      node_init(void) called.
@@ -545,7 +545,7 @@ extern dsp_status node_run(struct node_object *hnode);
  *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
  *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
  *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
- *      DSP_EFAIL:          Unable to terminate the node.
+ *      -EPERM:          Unable to terminate the node.
  *  Requires:
  *      node_init(void) called.
  *      pstatus != NULL.
diff --git a/arch/arm/plat-omap/include/dspbridge/proc.h b/arch/arm/plat-omap/include/dspbridge/proc.h
index 0707739..757dc86 100644
--- a/arch/arm/plat-omap/include/dspbridge/proc.h
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -36,14 +36,14 @@
  *      ph_processor :	   Ptr to location to store processor handle.
  *  Returns:
  *      DSP_SOK     :	   Success.
- *      DSP_EFAIL   :	   General failure.
+ *      -EPERM   :	   General failure.
  *      DSP_EHANDLE :	   Invalid processor handle.
  *      DSP_SALREADYATTACHED:   Success; Processor already attached.
  *  Requires:
  *      ph_processor != NULL.
  *      PROC Initialized.
  *  Ensures:
- *      DSP_EFAIL, and *ph_processor == NULL, OR
+ *      -EPERM, and *ph_processor == NULL, OR
  *      Success and *ph_processor is a Valid Processor handle OR
  *      DSP_SALREADYATTACHED and *ph_processor is a Valid Processor.
  *  Details:
@@ -64,7 +64,7 @@ extern dsp_status proc_attach(u32 processor_id,
  *  Returns:
  *      DSP_SOK     :   On Successful Loading
  *      DSP_EFILE   :   No DSP exec file found.
- *      DSP_EFAIL   :   General Failure
+ *      -EPERM   :   General Failure
  *  Requires:
  *      hdev_obj != NULL.
  *      dev_node_obj != NULL.
@@ -93,7 +93,7 @@ extern dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
  *			  to call this function.
  *      DSP_ERESTART:       A Critical error has occured and the DSP is being
  *			  restarted.
- *      DSP_EFAIL   :       General Failure.
+ *      -EPERM   :       General Failure.
  *  Requires:
  *      PROC Initialized.
  *  Ensures
@@ -113,7 +113,7 @@ extern dsp_status proc_ctrl(void *hprocessor,
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   InValid Handle.
- *      DSP_EFAIL   :   General failure.
+ *      -EPERM   :   General failure.
  *  Requires:
  *      PROC Initialized.
  *  Ensures:
@@ -142,7 +142,7 @@ extern dsp_status proc_detach(struct process_context *pr_ctxt);
  *		      insufficent. That is the number of nodes actually
  *		      allocated on the DSP is greater than the value
  *		      specified for node_tab_size.
- *      DSP_EFAIL   :   Unable to get Resource Information.
+ *      -EPERM   :   Unable to get Resource Information.
  *  Details:
  *  Requires
  *      pu_num_nodes is not NULL.
@@ -175,7 +175,7 @@ extern dsp_status proc_enum_nodes(void *hprocessor,
  *			  querry.
  *      DSP_ERESTART:       A Critical error has occured and the DSP is being
  *			  restarted.
- *      DSP_EFAIL   :       Unable to get Resource Information
+ *      -EPERM   :       Unable to get Resource Information
  *  Requires:
  *      resource_info is not NULL.
  *      Parameter resource_type is Valid.[TBD]
@@ -215,13 +215,13 @@ extern void proc_exit(void);
  *      phDevObject :   Location to store the DEV Handle.
  *  Returns:
  *      DSP_SOK     :   Success; *phDevObject has Dev handle
- *      DSP_EFAIL   :   Failure; *phDevObject is zero.
+ *      -EPERM   :   Failure; *phDevObject is zero.
  *  Requires:
  *      phDevObject is not NULL
  *      PROC Initialized.
  *  Ensures:
  *      DSP_SOK     :   *phDevObject is not NULL
- *      DSP_EFAIL   :   *phDevObject is NULL.
+ *      -EPERM   :   *phDevObject is NULL.
  */
 extern dsp_status proc_get_dev_object(void *hprocessor,
 				      struct dev_object **phDevObject);
@@ -252,7 +252,7 @@ extern bool proc_init(void);
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while querying processor state.
+ *      -EPERM   :   General failure while querying processor state.
  *  Requires:
  *      proc_state_obj is not NULL
  *      state_info_size is >= than the size of dsp_processorstate structure.
@@ -274,7 +274,7 @@ extern dsp_status proc_get_state(void *hprocessor, OUT struct dsp_processorstate
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while querying processor state.
+ *      -EPERM   :   General failure while querying processor state.
  *  Requires:
  *      proc_state_obj is not NULL
  *      state_info_size is >= than the size of dsp_processorstate structure.
@@ -295,7 +295,7 @@ extern dsp_status proc_get_processor_id(void *hprocessor, u32 * procID);
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   General failure while retireving processor trace
+ *      -EPERM   :   General failure while retireving processor trace
  *		      Buffer.
  *  Requires:
  *      pbuf is not NULL
@@ -325,7 +325,7 @@ extern dsp_status proc_get_trace(void *hprocessor, u8 * pbuf, u32 max_size);
  *			  specified Processor
  *      DSP_EACCESSDENIED:  Client does not have the required access rights
  *			  to reset and load the Processor
- *      DSP_EFAIL   :       Unable to Load the Processor
+ *      -EPERM   :       Unable to Load the Processor
  *  Requires:
  *      user_args is not NULL
  *      argc_index is > 0
@@ -356,7 +356,7 @@ extern dsp_status proc_load(void *hprocessor,
  *      DSP_EVALUE  :   Parameter event_mask is Invalid
  *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
  *		      is not supported.
- *      DSP_EFAIL   :   Unable to register for notification.
+ *      -EPERM   :   Unable to register for notification.
  *  Requires:
  *      hnotification is not NULL
  *      PROC Initialized.
@@ -378,7 +378,7 @@ extern dsp_status proc_register_notify(void *hprocessor,
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *      -EPERM   :   Failure to Set or Reset the Event
  *  Requires:
  *      uEvents is Supported or Valid type of Event
  *      hProc is a valid handle
@@ -397,7 +397,7 @@ extern dsp_status proc_notify_clients(void *hProc, u32 uEvents);
  *  Returns:
  *      DSP_SOK     :   Success.
  *      DSP_EHANDLE :   Invalid processor handle.
- *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *      -EPERM   :   Failure to Set or Reset the Event
  *  Requires:
  *      uEvents is Supported or Valid type of Event
  *      hProc is a valid handle
@@ -422,7 +422,7 @@ extern dsp_status proc_notify_all_clients(void *hProc, u32 uEvents);
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
  *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
- *      DSP_EFAIL   :       Unable to start the processor.
+ *      -EPERM   :       Unable to start the processor.
  *  Requires:
  *      PROC Initialized.
  *  Ensures:
@@ -444,7 +444,7 @@ extern dsp_status proc_start(void *hprocessor);
  *      DSP_SOK     :       Success.
  *      DSP_EHANDLE :       Invalid processor handle.
  *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
- *      DSP_EFAIL   :       Unable to start the processor.
+ *      -EPERM   :       Unable to start the processor.
  *  Requires:
  *      PROC Initialized.
  *  Ensures:
@@ -465,7 +465,7 @@ extern dsp_status proc_stop(void *hprocessor);
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *  Requires:
  *      PROC Initialized.
  *  Ensures:
@@ -486,7 +486,7 @@ extern dsp_status proc_flush_memory(void *hprocessor,
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *  Requires:
  *      PROC Initialized.
  *  Ensures:
@@ -511,7 +511,7 @@ extern dsp_status proc_invalidate_memory(void *hprocessor,
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *      DSP_EMEMORY     :   MPU side memory allocation error.
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
@@ -541,7 +541,7 @@ extern dsp_status proc_map(void *hprocessor,
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
  *  Requires:
  *      pp_rsv_addr is not NULL
@@ -563,7 +563,7 @@ extern dsp_status proc_reserve_memory(void *hprocessor,
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
  *		      :   address.
  *  Requires:
@@ -585,7 +585,7 @@ extern dsp_status proc_un_map(void *hprocessor, void *map_addr,
  *  Returns:
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
- *      DSP_EFAIL       :   General failure.
+ *      -EPERM       :   General failure.
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
diff --git a/arch/arm/plat-omap/include/dspbridge/pwr.h b/arch/arm/plat-omap/include/dspbridge/pwr.h
index 1ce54a1..922362a 100644
--- a/arch/arm/plat-omap/include/dspbridge/pwr.h
+++ b/arch/arm/plat-omap/include/dspbridge/pwr.h
@@ -43,7 +43,7 @@
  *      DSP_EINVALIDARG:    The specified sleepCode is not supported.
  *      DSP_ETIMEOUT:       A timeout occured while waiting for DSP sleep
  *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send sleep command to
+ *      -EPERM:          General failure, unable to send sleep command to
  *                          the DSP.
  */
 extern dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout);
@@ -64,7 +64,7 @@ extern dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout);
  *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
  *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
  *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
+ *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
  */
 extern dsp_status pwr_wake_dsp(IN CONST u32 timeout);
@@ -82,7 +82,7 @@ extern dsp_status pwr_wake_dsp(IN CONST u32 timeout);
  *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
  *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
  *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
+ *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
  */
 extern dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level);
@@ -100,7 +100,7 @@ extern dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level);
  *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
  *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
  *                          confirmation.
- *      DSP_EFAIL:          General failure, unable to send wake command to
+ *      -EPERM:          General failure, unable to send wake command to
  *                          the DSP.
  */
 extern dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level);
diff --git a/arch/arm/plat-omap/include/dspbridge/reg.h b/arch/arm/plat-omap/include/dspbridge/reg.h
index 8f32157..ed96d8a 100644
--- a/arch/arm/plat-omap/include/dspbridge/reg.h
+++ b/arch/arm/plat-omap/include/dspbridge/reg.h
@@ -32,7 +32,7 @@
  *      pstrValue:  Name of entry to delete.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EFAIL:  General failure.
+ *      -EPERM:  General failure.
  *  Requires:
  *      - REG initialized.
  *      - pstrValue is non-NULL value.
@@ -60,7 +60,7 @@ extern dsp_status reg_delete_value(IN CONST char *pstrValue);
  *                      If there is no data, pdwDataSize returns NULL.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      REG initialized.
  *      pstrKey is a non-NULL value.
@@ -101,7 +101,7 @@ extern void reg_exit(void);
  *                      the entry in pstrEntry.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      - REG initialized.
  *      - pstrEntry is non-NULL value.
@@ -135,7 +135,7 @@ extern bool reg_init(void);
  *      dw_value_size:    Specifies bytes of memory bValue points to.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      - REG initialized.
  *      - pstrEntry is non-NULL value.
diff --git a/arch/arm/plat-omap/include/dspbridge/strm.h b/arch/arm/plat-omap/include/dspbridge/strm.h
index 51a897f..7096457 100644
--- a/arch/arm/plat-omap/include/dspbridge/strm.h
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -37,7 +37,7 @@
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EMEMORY:    Insufficient memory.
- *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
+ *      -EPERM:      Failure occurred, unable to allocate buffers.
  *      DSP_ESIZE:      usize must be > 0 bytes.
  *  Requires:
  *      strm_init(void) called.
@@ -61,7 +61,7 @@ extern dsp_status strm_allocate_buffer(struct strm_object *hStrm,
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_EPENDING:   Some data buffers issued to the stream have not
  *                      been reclaimed.
- *      DSP_EFAIL:      Failure to close stream.
+ *      -EPERM:      Failure to close stream.
  *  Requires:
  *      strm_init(void) called.
  *  Ensures:
@@ -81,7 +81,7 @@ extern dsp_status strm_close(struct strm_object *hStrm,
  *  Returns:
  *      DSP_SOK:        Success;
  *      DSP_EMEMORY:    Insufficient memory for requested resources.
- *      DSP_EFAIL:      General failure.
+ *      -EPERM:      General failure.
  *  Requires:
  *      strm_init(void) called.
  *      phStrmMgr != NULL.
@@ -131,7 +131,7 @@ extern void strm_exit(void);
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid stream handle.
- *      DSP_EFAIL:      Failure occurred, unable to free buffers.
+ *      -EPERM:      Failure occurred, unable to free buffers.
  *  Requires:
  *      strm_init(void) called.
  *      ap_buffer != NULL.
@@ -173,7 +173,7 @@ extern dsp_status strm_get_event_handle(struct strm_object *hStrm,
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
  *      DSP_ESIZE:          stream_info_size < sizeof(dsp_streaminfo).
- *      DSP_EFAIL:          Unable to get stream info.
+ *      -EPERM:          Unable to get stream info.
  *  Requires:
  *      strm_init(void) called.
  *      stream_info != NULL.
@@ -202,7 +202,7 @@ extern dsp_status strm_get_info(struct strm_object *hStrm,
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_ETIMEOUT:   A timeout occurred before the stream could be idled.
  *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
- *      DSP_EFAIL:      Unable to idle stream.
+ *      -EPERM:      Unable to idle stream.
  *  Requires:
  *      strm_init(void) called.
  *  Ensures:
@@ -235,7 +235,7 @@ extern bool strm_init(void);
  *      DSP_SOK:            Success.
  *      DSP_EHANDLE:        Invalid hStrm.
  *      DSP_ESTREAMFULL:    The stream is full.
- *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
+ *      -EPERM:          Failure occurred, unable to issue buffer.
  *  Requires:
  *      strm_init(void) called.
  *      pbuf != NULL.
@@ -262,7 +262,7 @@ extern dsp_status strm_issue(struct strm_object *hStrm, IN u8 * pbuf,
  *      DSP_EDIRECTION: Invalid dir.
  *      DSP_EVALUE:     Invalid index.
  *      DSP_ENODETYPE:  hnode is not a task or DAIS socket node.
- *      DSP_EFAIL:      Unable to open stream.
+ *      -EPERM:      Unable to open stream.
  *  Requires:
  *      strm_init(void) called.
  *      phStrm != NULL.
@@ -288,7 +288,7 @@ extern dsp_status strm_open(struct node_object *hnode, u32 dir,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
+ *      -EPERM:      Failure occurred, unable to prepare buffer.
  *  Requires:
  *      strm_init(void) called.
  *      pbuffer != NULL.
@@ -314,7 +314,7 @@ extern dsp_status strm_prepare_buffer(struct strm_object *hStrm,
  *      DSP_EHANDLE:    Invalid hStrm.
  *      DSP_ETIMEOUT:   A timeout occurred before a buffer could be
  *                      retrieved.
- *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
+ *      -EPERM:      Failure occurred, unable to reclaim buffer.
  *  Requires:
  *      strm_init(void) called.
  *      buf_ptr != NULL.
@@ -367,7 +367,7 @@ extern dsp_status strm_register_notify(struct strm_object *hStrm,
 
  *      DSP_EHANDLE:    Invalid stream handle in array.
  *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
- *      DSP_EFAIL:      Failure occurred, unable to select a stream.
+ *      -EPERM:      Failure occurred, unable to select a stream.
  *  Requires:
  *      strm_init(void) called.
  *      strm_tab != NULL.
@@ -393,7 +393,7 @@ extern dsp_status strm_select(IN struct strm_object **strm_tab,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
+ *      -EPERM:      Failure occurred, unable to unprepare buffer.
  *  Requires:
  *      strm_init(void) called.
  *      pbuffer != NULL.
diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
index f9883db..744e6ab 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmd.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -60,7 +60,7 @@ struct wmd_dev_context;
  *      DSP_SOK:        Success.
  *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL
  *  Ensures:
@@ -78,7 +78,7 @@ typedef dsp_status(*fxn_brd_monitor) (struct wmd_dev_context *hDevContext);
  *      ulBrdState:     Board state
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *      ulBrdState  <= BRD_LASTSTATE.
@@ -99,7 +99,7 @@ typedef dsp_status(*fxn_brd_setstate) (struct wmd_dev_context
  *  Returns:
  *      DSP_SOK:        Success.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL
  *      Board is in monitor (BRD_IDLE) state.
@@ -123,7 +123,7 @@ typedef dsp_status(*fxn_brd_start) (struct wmd_dev_context
  *  ulMemType:  What section of memory to copy to
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      dev_context != NULL
  *  Ensures:
@@ -150,7 +150,7 @@ typedef dsp_status(*fxn_brd_memcopy) (struct wmd_dev_context
  *  Returns:
  *      DSP_SOK:        Success.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *      pHostBuf != NULL.
@@ -174,7 +174,7 @@ typedef dsp_status(*fxn_brd_memwrite) (struct wmd_dev_context
  *      map_attrs:       Mapping attributes (e.g. endianness).
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *  Ensures:
@@ -194,7 +194,7 @@ typedef dsp_status(*fxn_brd_memmap) (struct wmd_dev_context
  *      ul_num_bytes:     Number of bytes to unmap.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *  Ensures:
@@ -212,7 +212,7 @@ typedef dsp_status(*fxn_brd_memunmap) (struct wmd_dev_context
  *  Returns:
  *      DSP_SOK:        Success.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL
  *  Ensures:
@@ -254,7 +254,7 @@ typedef dsp_status(*fxn_brd_status) (struct wmd_dev_context *hDevContext,
  *  Returns:
  *      DSP_SOK:        Success.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *      pHostBuf != NULL.
@@ -280,7 +280,7 @@ typedef dsp_status(*fxn_brd_read) (struct wmd_dev_context *hDevContext,
  *  Returns:
  *      DSP_SOK:        Success.
  *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
- *      DSP_EFAIL:      Other, unspecified error.
+ *      -EPERM:      Other, unspecified error.
  *  Requires:
  *      hDevContext != NULL;
  *      pHostBuf != NULL.
@@ -702,7 +702,7 @@ typedef dsp_status(*fxn_dev_create) (OUT struct wmd_dev_context
  *      dw_cmd:          WMD defined command code.
  *      pargs:          Pointer to an arbitrary argument structure.
  *  Returns:
- *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
+ *      DSP_SOK or -EPERM. Actual command error codes should be passed back
  *      in the pargs structure, and are defined by the WMD implementor.
  *  Requires:
  *      All calls are currently assumed to be synchronous.  There are no
@@ -723,7 +723,7 @@ typedef dsp_status(*fxn_dev_ctrl) (struct wmd_dev_context *hDevContext,
  *      hDevContext:    Handle to mini-driver defined device information.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Failed to release a resource previously acquired.
+ *      -EPERM:      Failed to release a resource previously acquired.
  *  Requires:
  *      hDevContext != NULL;
  *  Ensures:
@@ -741,7 +741,7 @@ typedef dsp_status(*fxn_dev_destroy) (struct wmd_dev_context *hDevContext);
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
+ *      -EPERM:      Creation failed.
  *  Requires:
  *      hdev_obj != NULL;
  *      phDehMgr != NULL;
@@ -758,7 +758,7 @@ typedef dsp_status(*fxn_deh_create) (OUT struct deh_mgr
  *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Destroy failed.
+ *      -EPERM:      Destroy failed.
  *  Requires:
  *      hdeh_mgr != NULL;
  *  Ensures:
@@ -773,7 +773,7 @@ typedef dsp_status(*fxn_deh_destroy) (struct deh_mgr *hdeh_mgr);
  *      hdeh_mgr:        Handle to DEH manager object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Destroy failed.
+ *      -EPERM:      Destroy failed.
  *  Requires:
  *      hdeh_mgr != NULL;
  *  Ensures:
@@ -791,7 +791,7 @@ typedef dsp_status(*fxn_deh_registernotify)
  *      pErrInfo:       Ptr to error info structure.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EFAIL:      Creation failed.
+ *      -EPERM:      Creation failed.
  *  Requires:
  *      phDehMgr != NULL;
  *      pErrorInfo != NULL;
@@ -811,7 +811,7 @@ typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
+ *      -EPERM:      Creation failed.
  *  Requires:
  *      hdev_obj != NULL;
  *      Channel manager already created;
@@ -833,7 +833,7 @@ typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EMEMORY:    Memory allocation failure.
- *      DSP_EFAIL:      Creation failed.
+ *      -EPERM:      Creation failed.
  *  Requires:
  *      Valid hio_mgr;
  *  Ensures:
@@ -850,7 +850,7 @@ typedef dsp_status(*fxn_io_destroy) (struct io_mgr *hio_mgr);
  *      hio_mgr:     IO Manager.
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Internal failure occurred.
+ *      -EPERM:  Internal failure occurred.
  *  Requires:
  *      Valid hio_mgr;
  *  Ensures:
@@ -866,7 +866,7 @@ typedef dsp_status(*fxn_io_onloaded) (struct io_mgr *hio_mgr);
  *      pProcLoadStat   Processor Load statistics
  *  Returns:
  *      DSP_SOK:    Success.
- *      DSP_EFAIL:  Internal failure occurred.
+ *      -EPERM:  Internal failure occurred.
  *  Requires:
  *      Valid hio_mgr;
  *  Ensures:
@@ -962,7 +962,7 @@ typedef void (*fxn_msg_deletequeue) (struct msg_queue *msg_queue_obj);
  *  Returns:
  *      DSP_SOK:       Success.
  *      DSP_ETIMEOUT:  Timeout occurred.
- *      DSP_EFAIL:     No frames available for message (max_msgs too
+ *      -EPERM:     No frames available for message (max_msgs too
  *                     small).
  *  Requires:
  *      Valid msg_queue_obj.
@@ -984,7 +984,7 @@ typedef dsp_status(*fxn_msg_get) (struct msg_queue *msg_queue_obj,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_ETIMEOUT:   Timeout occurred.
- *      DSP_EFAIL:      No frames available for message (max_msgs too
+ *      -EPERM:      No frames available for message (max_msgs too
  *                      small).
  *  Requires:
  *      Valid msg_queue_obj.
diff --git a/drivers/dsp/bridge/pmgr/cmm.c b/drivers/dsp/bridge/pmgr/cmm.c
index 7523361..72cd311 100644
--- a/drivers/dsp/bridge/pmgr/cmm.c
+++ b/drivers/dsp/bridge/pmgr/cmm.c
@@ -280,7 +280,7 @@ dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
 			cmm_obj->dw_page_size = sys_info.dw_page_size;
 		} else {
 			cmm_obj->dw_page_size = 0;
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 		/* Note: DSP SM seg table(aDSPSMSegTab[]) zero'd by
 		 * MEM_ALLOC_OBJECT */
@@ -335,7 +335,7 @@ dsp_status cmm_destroy(struct cmm_object *hcmm_mgr, bool bForce)
 		if (DSP_SUCCEEDED(status)) {
 			if (temp_info.ul_total_in_use_cnt > 0) {
 				/* outstanding allocations */
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 		}
 	}
@@ -578,7 +578,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 	slot_seg = get_slot(cmm_mgr_obj);
 	if (slot_seg < 0) {
 		/* get a slot number */
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	/* Check if input ul_size is big enough to alloc at least one block */
@@ -602,7 +602,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 		psma->dw_dsp_base = dw_dsp_base;
 		psma->ul_dsp_size = ul_dsp_size;
 		if (psma->dw_vm_base == 0) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		if (DSP_SUCCEEDED(status)) {
@@ -689,7 +689,7 @@ dsp_status cmm_un_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 					cmm_mgr_obj->pa_gppsm_seg_tab[ul_id -
 								      1] = NULL;
 				} else if (ul_seg_id != CMM_ALLSEGMENTS) {
-					status = DSP_EFAIL;
+					status = -EPERM;
 				}
 				mutex_unlock(&cmm_mgr_obj->cmm_lock);
 				if (ul_seg_id != CMM_ALLSEGMENTS)
@@ -1062,7 +1062,7 @@ void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator, void *pVaBuf,
 dsp_status cmm_xlator_free_buf(struct cmm_xlatorobject *xlator, void *pBufVa)
 {
 	struct cmm_xlator *xlator_obj = (struct cmm_xlator *)xlator;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	void *buf_pa = NULL;
 
 	DBC_REQUIRE(refs > 0);
diff --git a/drivers/dsp/bridge/pmgr/cod.c b/drivers/dsp/bridge/pmgr/cod.c
index 548f1eb..edd08cd 100644
--- a/drivers/dsp/bridge/pmgr/cod.c
+++ b/drivers/dsp/bridge/pmgr/cod.c
@@ -169,7 +169,7 @@ static s32 cod_f_seek(struct file *filp, s32 lOffset, s32 cOrigin)
 	dw_cur_pos = filp->f_op->llseek(filp, lOffset, cOrigin);
 
 	if ((s32) dw_cur_pos < 0)
-		return DSP_EFAIL;
+		return -EPERM;
 
 	/* we can't use DSP_SOK here */
 	return 0;
@@ -186,7 +186,7 @@ static s32 cod_f_tell(struct file *filp)
 	dw_cur_pos = filp->f_op->llseek(filp, 0, SEEK_CUR);
 
 	if ((s32) dw_cur_pos < 0)
-		return DSP_EFAIL;
+		return -EPERM;
 
 	return dw_cur_pos;
 }
@@ -351,7 +351,7 @@ dsp_status cod_get_base_name(struct cod_manager *cod_mgr_obj, char *pszName,
 	if (usize <= COD_MAXPATHLENGTH)
 		strncpy(pszName, cod_mgr_obj->sz_zl_file, usize);
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/pmgr/dbll.c b/drivers/dsp/bridge/pmgr/dbll.c
index 0e7c4a4..24bfcd0 100644
--- a/drivers/dsp/bridge/pmgr/dbll.c
+++ b/drivers/dsp/bridge/pmgr/dbll.c
@@ -792,7 +792,7 @@ dsp_status dbll_read_sect(struct dbll_library_obj *lib, char *name,
 	/* Align size */
 	ul_sect_size = DOFF_ALIGN(ul_sect_size);
 	if (ul_sect_size > size) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else {
 		if (!dload_get_section(zl_lib->desc, sect, pContent))
 			status = DSP_EFREAD;
diff --git a/drivers/dsp/bridge/pmgr/dev.c b/drivers/dsp/bridge/pmgr/dev.c
index 5bc16e9..ae6f8aa 100644
--- a/drivers/dsp/bridge/pmgr/dev.c
+++ b/drivers/dsp/bridge/pmgr/dev.c
@@ -157,7 +157,7 @@ dsp_status dev_create_device(OUT struct dev_object **phDevObject,
 	bridge_drv_entry(&drv_fxns, pstrWMDFileName);
 	if (DSP_FAILED(cfg_get_object((u32 *) &hdrv_obj, REG_DRV_OBJECT))) {
 		/* don't propogate CFG errors from this PROC function */
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	/* Create the device object, and pass a handle to the WMD for
 	 * storage. */
@@ -250,7 +250,7 @@ dsp_status dev_create_device(OUT struct dev_object **phDevObject,
 		dev_obj->proc_list = mem_calloc(sizeof(struct lst_list),
 						MEM_NONPAGED);
 		if (!(dev_obj->proc_list))
-			status = DSP_EFAIL;
+			status = -EPERM;
 		else
 			INIT_LIST_HEAD(&dev_obj->proc_list->head);
 	}
@@ -319,7 +319,7 @@ dsp_status dev_destroy2(struct dev_object *hdev_obj)
 
 	if (dev_obj->hnode_mgr) {
 		if (DSP_FAILED(node_delete_mgr(dev_obj->hnode_mgr)))
-			status = DSP_EFAIL;
+			status = -EPERM;
 		else
 			dev_obj->hnode_mgr = NULL;
 
@@ -391,7 +391,7 @@ dsp_status dev_destroy_device(struct dev_object *hdev_obj)
 			    (dev_obj->hwmd_context);
 			dev_obj->hwmd_context = NULL;
 		} else
-			status = DSP_EFAIL;
+			status = -EPERM;
 		if (DSP_SUCCEEDED(status)) {
 			kfree(dev_obj->proc_list);
 			dev_obj->proc_list = NULL;
@@ -1049,7 +1049,7 @@ dsp_status dev_insert_proc_object(struct dev_object *hdev_obj,
  */
 dsp_status dev_remove_proc_object(struct dev_object *hdev_obj, u32 proc_obj)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct list_head *cur_elem;
 	struct dev_object *dev_obj = (struct dev_object *)hdev_obj;
 
diff --git a/drivers/dsp/bridge/pmgr/msg.c b/drivers/dsp/bridge/pmgr/msg.c
index 937b604..a025295 100644
--- a/drivers/dsp/bridge/pmgr/msg.c
+++ b/drivers/dsp/bridge/pmgr/msg.c
@@ -79,7 +79,7 @@ dsp_status msg_create(OUT struct msg_mgr **phMsgMgr,
 		/* Finally, return the new message manager handle: */
 		*phMsgMgr = hmsg_mgr;
 	} else {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	return status;
 }
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index 15a05a6..99f6218 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -371,7 +371,7 @@ bool wcd_init(void)
  *  Parameters:
  *  Returns:
  *      DSP_SOK:	Allow this device to load
- *      DSP_EFAIL:      Failure.
+ *      -EPERM:      Failure.
  *  Requires:
  *      WCD initialized.
  *  Ensures:
@@ -616,7 +616,7 @@ u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
 
 	if (psize) {
 		if (get_user(cb_data_size, psize)) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		cb_data_size += sizeof(u32);
@@ -1036,7 +1036,7 @@ u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 	/* Optional argument */
 	if (psize) {
 		if (get_user(cb_data_size, psize))
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
@@ -1137,7 +1137,7 @@ u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
 	/* Optional argument */
 	if (psize) {
 		if (get_user(cb_data_size, psize))
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		cb_data_size += sizeof(u32);
 		if (DSP_SUCCEEDED(status)) {
diff --git a/drivers/dsp/bridge/rmgr/dbdcd.c b/drivers/dsp/bridge/rmgr/dbdcd.c
index fd90c99..4604d5f 100644
--- a/drivers/dsp/bridge/rmgr/dbdcd.c
+++ b/drivers/dsp/bridge/rmgr/dbdcd.c
@@ -163,7 +163,7 @@ dsp_status dcd_create_manager(IN char *pszZlDllName,
 	}
 
 	DBC_ENSURE((DSP_SUCCEEDED(status)) || ((cod_mgr == NULL) &&
-					       (status == DSP_EFAIL))
+					       (status == -EPERM))
 		   || ((dcd_mgr_obj == NULL) && (status == DSP_EMEMORY)));
 
 func_end:
@@ -243,7 +243,7 @@ dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
 		    REG_MAXREGPATHLENGTH) {
 			strncat(sz_reg_key, "_\0", 2);
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 
 		/* This snprintf is guaranteed not to exceed max size of an
@@ -252,7 +252,7 @@ dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
 				  obj_type);
 
 		if (status == -1) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			status = DSP_SOK;
 			if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
@@ -260,7 +260,7 @@ dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
 				strncat(sz_reg_key, sz_obj_type,
 					strlen(sz_obj_type) + 1);
 			} else {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 		}
 
@@ -287,11 +287,11 @@ dsp_status dcd_enumerate_object(IN s32 cIndex, IN enum dsp_dcdobjtype obj_type,
 
 			status = DSP_SENUMCOMPLETE;
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	}
 
-	DBC_ENSURE(uuid_obj || (status == DSP_EFAIL));
+	DBC_ENSURE(uuid_obj || (status == -EPERM));
 
 	return status;
 }
@@ -409,11 +409,11 @@ dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
 	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
 		strncat(sz_reg_key, "_\0", 2);
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else {
 		status = DSP_SOK;
 
@@ -422,7 +422,7 @@ dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
 			strncat(sz_reg_key, sz_obj_type,
 				strlen(sz_obj_type) + 1);
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 
 		/* Create UUID value to set in registry. */
@@ -431,7 +431,7 @@ dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
 		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
 			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		/* Retrieve paths from the registry based on struct dsp_uuid */
 		dw_buf_size = REG_MAXREGPATHLENGTH;
@@ -656,7 +656,7 @@ dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
 		strncat(sz_reg_key, "_\0", 2);
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	switch (phase) {
 	case NLDR_CREATE:
@@ -685,14 +685,14 @@ dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 			strncat(sz_reg_key, sz_obj_type,
 				strlen(sz_obj_type) + 1);
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 		/* Create UUID value to find match in registry. */
 		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
 		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
 			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
-			status = DSP_EFAIL;
+			status = -EPERM;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Retrieve path from the registry based on dsp_uuid */
@@ -709,7 +709,7 @@ dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 		    REG_MAXREGPATHLENGTH) {
 			strncat(sz_reg_key, "_\0", 2);
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 		sprintf(sz_obj_type, "%d", DSP_DCDLIBRARYTYPE);
 		if ((strlen(sz_reg_key) + strlen(sz_obj_type))
@@ -717,13 +717,13 @@ dsp_status dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 			strncat(sz_reg_key, sz_obj_type,
 				strlen(sz_obj_type) + 1);
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
 		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
 			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		status = reg_get_value(sz_reg_key, (u8 *) pstrLibName, pdwSize);
 	}
@@ -804,13 +804,13 @@ dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
 	if ((strlen(sz_reg_key) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
 		strncat(sz_reg_key, "_\0", 2);
 	else {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 
 	status = snprintf(sz_obj_type, MAX_INT2CHAR_LENGTH, "%d", obj_type);
 	if (status == -1) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else {
 		status = DSP_SOK;
 		if ((strlen(sz_reg_key) + strlen(sz_obj_type)) <
@@ -818,14 +818,14 @@ dsp_status dcd_register_object(IN struct dsp_uuid *uuid_obj,
 			strncat(sz_reg_key, sz_obj_type,
 				strlen(sz_obj_type) + 1);
 		} else
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		/* Create UUID value to set in registry. */
 		uuid_uuid_to_string(uuid_obj, sz_uuid, MAXUUIDLEN);
 		if ((strlen(sz_reg_key) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
 			strncat(sz_reg_key, sz_uuid, MAXUUIDLEN);
 		else
-			status = DSP_EFAIL;
+			status = -EPERM;
 	}
 
 	if (DSP_FAILED(status))
@@ -1204,7 +1204,7 @@ static dsp_status get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		break;
 
 	default:
-		status = DSP_EFAIL;
+		status = -EPERM;
 		break;
 	}
 
diff --git a/drivers/dsp/bridge/rmgr/disp.c b/drivers/dsp/bridge/rmgr/disp.c
index 8a3b9d5..06611bd 100644
--- a/drivers/dsp/bridge/rmgr/disp.c
+++ b/drivers/dsp/bridge/rmgr/disp.c
@@ -136,7 +136,7 @@ dsp_status disp_create(OUT struct disp_object **phDispObject,
 		goto func_cont;
 
 	if (dev_type != DSP_UNIT) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_cont;
 	}
 
@@ -316,7 +316,7 @@ dsp_status disp_node_create(struct disp_object *disp_obj,
 	    sizeof(struct rms_msg_args)
 	    / sizeof(rms_word) - 1 + dw_length;
 	if (total >= max) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		dev_dbg(bridge, "%s: Message args too large for buffer! size "
 			"= %d, max = %d\n", __func__, total, max);
 	}
@@ -461,7 +461,7 @@ dsp_status disp_node_create(struct disp_object *disp_obj,
 			}
 		} else {
 			/* Args won't fit */
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -648,7 +648,7 @@ static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
 	dsp_status status = DSP_SOK;
 
 	if (total + sizeof(struct rms_strm_def) / sizeof(rms_word) >= max) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else {
 		strm_def_obj = (struct rms_strm_def *)(pdw_buf + total);
 		strm_def_obj->bufsize = strm_def.buf_size;
@@ -672,7 +672,7 @@ static dsp_status fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
 		    (dw_length + chars_in_rms_word - 1) / chars_in_rms_word;
 
 		if (total + name_len >= max) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			/*
 			 *  Zero out last word, since the device name may not
@@ -723,7 +723,7 @@ static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
 			if (CHNL_IS_TIMED_OUT(chnl_ioc_obj))
 				status = DSP_ETIMEOUT;
 			else
-				status = DSP_EFAIL;
+				status = -EPERM;
 		}
 	}
 	/* Get the reply */
@@ -744,7 +744,7 @@ static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
 			status = DSP_ETIMEOUT;
 		} else if (chnl_ioc_obj.byte_size < ul_bytes) {
 			/* Did not get all of the reply from the RMS */
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			if (CHNL_IS_IO_COMPLETE(chnl_ioc_obj)) {
 				DBC_ASSERT(chnl_ioc_obj.pbuf == pbuf);
@@ -752,7 +752,7 @@ static dsp_status send_message(struct disp_object *disp_obj, u32 dwTimeout,
 				*pdw_arg =
 				    (((rms_word *) (chnl_ioc_obj.pbuf))[1]);
 			} else {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 		}
 	}
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index 98f9b78..6751f5e 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -93,7 +93,7 @@ dsp_status drv_insert_node_res_element(bhandle hnode, bhandle hNodeRes,
 	if (DSP_SUCCEEDED(status)) {
 		if (mutex_lock_interruptible(&ctxt->node_mutex)) {
 			kfree(*node_res_obj);
-			return DSP_EFAIL;
+			return -EPERM;
 		}
 		(*node_res_obj)->hnode = hnode;
 		if (ctxt->node_list != NULL) {
@@ -122,7 +122,7 @@ dsp_status drv_remove_node_res_element(bhandle hNodeRes, bhandle hPCtxt)
 	dsp_status status = DSP_SOK;
 
 	if (mutex_lock_interruptible(&ctxt->node_mutex))
-		return DSP_EFAIL;
+		return -EPERM;
 	temp_node = ctxt->node_list;
 	if (temp_node == node_res_obj) {
 		ctxt->node_list = node_res_obj->next;
@@ -253,7 +253,7 @@ dsp_status drv_get_node_res_element(bhandle hnode, bhandle hNodeRes,
 	struct node_res_object *temp_node = NULL;
 
 	if (mutex_lock_interruptible(&ctxt->node_mutex))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	temp_node = ctxt->node_list;
 	while ((temp_node != NULL) && (temp_node->hnode != hnode)) {
@@ -291,7 +291,7 @@ dsp_status drv_proc_insert_strm_res_element(bhandle hStreamHandle,
 	if (DSP_SUCCEEDED(status)) {
 		if (mutex_lock_interruptible(&ctxt->strm_mutex)) {
 			kfree(*pstrm_res);
-			return DSP_EFAIL;
+			return -EPERM;
 		}
 		(*pstrm_res)->hstream = hStreamHandle;
 		if (ctxt->pstrm_list != NULL) {
@@ -319,7 +319,7 @@ dsp_status drv_proc_remove_strm_res_element(bhandle hstrm_res, bhandle hPCtxt)
 	dsp_status status = DSP_SOK;
 
 	if (mutex_lock_interruptible(&ctxt->strm_mutex))
-		return DSP_EFAIL;
+		return -EPERM;
 	temp_strm_res = ctxt->pstrm_list;
 
 	if (ctxt->pstrm_list == pstrm_res) {
@@ -392,7 +392,7 @@ dsp_status drv_get_strm_res_element(bhandle hStrm, bhandle hstrm_res,
 	struct strm_res_object *temp_strm;
 
 	if (mutex_lock_interruptible(&ctxt->strm_mutex))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	temp_strm = ctxt->pstrm_list;
 	while ((temp_strm != NULL) && (temp_strm->hstream != hStrm)) {
@@ -447,7 +447,7 @@ dsp_status drv_create(OUT struct drv_object **phDRVObject)
 					mem_calloc(sizeof(struct lst_list),
 						   MEM_NONPAGED);
 			if (!(pdrv_object->dev_node_string)) {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			} else {
 				INIT_LIST_HEAD(&pdrv_object->
 					       dev_node_string->head);
@@ -547,7 +547,7 @@ dsp_status drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
 		*phDevObject = (struct dev_object *)dev_obj;
 	} else {
 		*phDevObject = NULL;
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 
 	return status;
@@ -701,7 +701,7 @@ dsp_status drv_insert_dev_object(struct drv_object *hDRVObject,
 dsp_status drv_remove_dev_object(struct drv_object *hDRVObject,
 				 struct dev_object *hdev_obj)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
 	struct list_head *cur_elem;
 
@@ -779,7 +779,7 @@ dsp_status drv_request_resources(u32 dw_context, u32 *pDevNodeString)
 		dev_dbg(bridge, "%s: Allocating resources for UMA\n", __func__);
 		status = request_bridge_resources_dsp(dw_context, DRV_ASSIGN);
 	} else {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		dev_dbg(bridge, "%s: Unknown Device\n", __func__);
 	}
 
diff --git a/drivers/dsp/bridge/rmgr/dspdrv.c b/drivers/dsp/bridge/rmgr/dspdrv.c
index f8ceeba..5a57050 100644
--- a/drivers/dsp/bridge/rmgr/dspdrv.c
+++ b/drivers/dsp/bridge/rmgr/dspdrv.c
@@ -50,7 +50,7 @@
 u32 dsp_init(OUT u32 *init_status)
 {
 	char dev_node[MAXREGPATHLENGTH] = "TIOMAP1510";
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct drv_object *drv_obj = NULL;
 	u32 device_node;
 	u32 device_node_string;
@@ -76,7 +76,7 @@ u32 dsp_init(OUT u32 *init_status)
 			    ((u32) device_node_string, drv_obj);
 	} else {
 		dev_dbg(bridge, "%s: drv_request_resources Failed\n", __func__);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 
 	/* Unwind whatever was loaded */
diff --git a/drivers/dsp/bridge/rmgr/mgr.c b/drivers/dsp/bridge/rmgr/mgr.c
index cece9da..5fb177f 100644
--- a/drivers/dsp/bridge/rmgr/mgr.c
+++ b/drivers/dsp/bridge/rmgr/mgr.c
@@ -221,7 +221,7 @@ dsp_status mgr_enum_processor_info(u32 processor_id,
 				status = cfg_get_dsp_resources(dev_node,
 							       &chip_resources);
 			else
-				status = DSP_EFAIL;
+				status = -EPERM;
 
 			if (DSP_SUCCEEDED(status)) {
 				processor_info->processor_type =
@@ -286,7 +286,7 @@ dsp_status mgr_enum_processor_info(u32 processor_id,
 		} else {
 			dev_dbg(bridge, "%s: Failed to get DCD processor info "
 				"%x\n", __func__, status2);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	}
 	*pu_num_procs = proc_index;
@@ -321,7 +321,7 @@ void mgr_exit(void)
 dsp_status mgr_get_dcd_handle(struct mgr_object *hMGRHandle,
 			      OUT u32 *phDCDHandle)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct mgr_object *pmgr_obj = (struct mgr_object *)hMGRHandle;
 
 	DBC_REQUIRE(refs > 0);
diff --git a/drivers/dsp/bridge/rmgr/nldr.c b/drivers/dsp/bridge/rmgr/nldr.c
index c23deda..dc0006b 100644
--- a/drivers/dsp/bridge/rmgr/nldr.c
+++ b/drivers/dsp/bridge/rmgr/nldr.c
@@ -1589,7 +1589,7 @@ static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
 							   ovly_section->size,
 							   ovly_section->page);
 				if (bytes != ovly_section->size)
-					status = DSP_EFAIL;
+					status = -EPERM;
 
 				ovly_section = ovly_section->next_sect;
 			}
@@ -1610,7 +1610,7 @@ static dsp_status load_ovly(struct nldr_nodeobject *nldr_node_obj,
 							   ovly_section->size,
 							   ovly_section->page);
 				if (bytes != ovly_section->size)
-					status = DSP_EFAIL;
+					status = -EPERM;
 
 				ovly_section = ovly_section->next_sect;
 			}
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
index 32df890..aea60bb 100644
--- a/drivers/dsp/bridge/rmgr/node.c
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -345,7 +345,7 @@ dsp_status node_allocate(struct proc_object *hprocessor,
 	if (DSP_SUCCEEDED(status)) {
 		status = dev_get_node_manager(hdev_obj, &hnode_mgr);
 		if (hnode_mgr == NULL)
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 	}
 
@@ -359,7 +359,7 @@ dsp_status node_allocate(struct proc_object *hprocessor,
 	/* If processor is in error state then don't attempt
 	   to send the message */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 
@@ -367,7 +367,7 @@ dsp_status node_allocate(struct proc_object *hprocessor,
 	if (hnode_mgr->ul_fxn_addrs[0] == 0) {
 		/* No RMS on target - we currently can't handle this */
 		pr_err("%s: Failed, no RMS in base image\n", __func__);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else {
 		/* Validate attr_in fields, if non-NULL */
 		if (attr_in) {
@@ -865,10 +865,10 @@ dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
 		if (hNode1 != (struct node_object *)DSP_HGPPNODE &&
 		    hNode2 != (struct node_object *)DSP_HGPPNODE &&
 		    hNode1->hnode_mgr != hNode2->hnode_mgr)
-			status = DSP_EFAIL;
+			status = -EPERM;
 		/* Cannot connect a node to itself */
 		if (hNode1 == hNode2)
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -898,7 +898,7 @@ dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
 		if (node1_type == NODE_MESSAGE || node2_type == NODE_MESSAGE ||
 		    (node1_type != NODE_TASK && node1_type != NODE_DAISSOCKET &&
 		     node2_type != NODE_TASK && node2_type != NODE_DAISSOCKET))
-			status = DSP_EFAIL;
+			status = -EPERM;
 	}
 	/*
 	 * Check stream mode. Default is STRMMODE_PROCCOPY.
@@ -1176,7 +1176,7 @@ dsp_status node_create(struct node_object *hnode)
 	/* If processor is in error state then don't attempt to create
 	   new node */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	/* create struct dsp_cbdata struct for PWR calls */
@@ -1833,7 +1833,7 @@ dsp_status node_get_message(struct node_object *hnode,
 	/* If processor is in error state then don't attempt to get the
 	   message */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	hnode_mgr = hnode->hnode_mgr;
@@ -2065,7 +2065,7 @@ dsp_status node_pause(struct node_object *hnode)
 		/* If processor is in error state then don't attempt
 		   to send the message */
 		if (proc_state.proc_state == PROC_ERROR) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_cont;
 		}
 
@@ -2127,7 +2127,7 @@ dsp_status node_put_message(struct node_object *hnode,
 	/* If processor is in bad state then don't attempt sending the
 	   message */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	hnode_mgr = hnode->hnode_mgr;
@@ -2175,7 +2175,7 @@ dsp_status node_put_message(struct node_object *hnode,
 			} else {
 				pr_err("%s: udsp_word_size is zero!\n",
 				       __func__);
-				status = DSP_EFAIL;	/* bad DSPWordSize */
+				status = -EPERM;	/* bad DSPWordSize */
 			}
 		} else {	/* failed to translate buffer address */
 			status = DSP_ETRANSLATE;
@@ -2278,7 +2278,7 @@ dsp_status node_run(struct node_object *hnode)
 		goto func_end;
 	/* If processor is in error state then don't attempt to run the node */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	node_type = node_get_type(hnode);
@@ -2432,7 +2432,7 @@ dsp_status node_terminate(struct node_object *hnode, OUT dsp_status *pstatus)
 		/* If processor is in error state then don't attempt to send
 		 * A kill task command */
 		if (proc_state.proc_state == PROC_ERROR) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_cont;
 		}
 
@@ -2480,13 +2480,13 @@ dsp_status node_terminate(struct node_object *hnode, OUT dsp_status *pstatus)
 								  DSP_SYSERROR,
 								  DSP_EXCEPTIONABORT);
 								status =
-								    DSP_EFAIL;
+								    -EPERM;
 							}
 						} else
 							status = DSP_SOK;
 					}
 				} else
-					status = DSP_EFAIL;
+					status = -EPERM;
 			} else	/* Convert SYNC status to DSP status */
 				status = DSP_SOK;
 		}
@@ -2498,7 +2498,7 @@ func_cont:
 		mutex_lock(&hnode_mgr->node_mgr_lock);
 		/* Make sure node wasn't deleted while we blocked */
 		if (!MEM_IS_VALID_HANDLE(hnode, NODE_SIGNATURE)) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			*pstatus = hnode->exit_status;
 			dev_dbg(bridge, "%s: hnode: %p env 0x%x status 0x%x\n",
@@ -3039,7 +3039,7 @@ dsp_status node_get_uuid_props(void *hprocessor,
 	/* If processor is in error state then don't attempt
 	   to send the message */
 	if (proc_state.proc_state == PROC_ERROR) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 1f7dd09..1b8166e 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -230,7 +230,7 @@ proc_attach(u32 processor_id,
 		MEM_FREE_OBJECT(p_proc_object);
 	}
 func_end:
-	DBC_ENSURE((status == DSP_EFAIL && *ph_processor == NULL) ||
+	DBC_ENSURE((status == -EPERM && *ph_processor == NULL) ||
 		   (DSP_SUCCEEDED(status) &&
 		    MEM_IS_VALID_HANDLE(p_proc_object, PROC_SIGNATURE)) ||
 		   (status == DSP_SALREADYATTACHED &&
@@ -268,7 +268,7 @@ static dsp_status get_exec_file(struct cfg_devnode *dev_node_obj,
  *      hdev_obj:     Handle to the Device
  *  Returns:
  *      DSP_SOK:   On Successful Loading
- *      DSP_EFAIL  General Failure
+ *      -EPERM  General Failure
  *  Requires:
  *      hdev_obj != NULL
  *  Ensures:
@@ -276,7 +276,7 @@ static dsp_status get_exec_file(struct cfg_devnode *dev_node_obj,
 dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
 			   struct dev_object *hdev_obj)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct proc_object *p_proc_object;
 	char sz_exec_file[MAXCMDLINELEN];
 	char *argv[2];
@@ -379,7 +379,7 @@ dsp_status proc_ctrl(void *hprocessor, u32 dw_cmd, IN struct dsp_cbdata * arg)
 				       arg))) {
 			status = DSP_SOK;
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	} else {
 		status = DSP_EHANDLE;
@@ -437,7 +437,7 @@ dsp_status proc_enum_nodes(void *hprocessor, void **node_tab,
 			   IN u32 node_tab_size, OUT u32 *pu_num_nodes,
 			   OUT u32 *pu_allocated)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 	struct node_mgr *hnode_mgr = NULL;
 
@@ -601,7 +601,7 @@ dsp_status proc_get_resource_info(void *hprocessor, u32 resource_type,
 				  OUT struct dsp_resourceinfo *resource_info,
 				  u32 resource_info_size)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 	struct node_mgr *hnode_mgr = NULL;
 	struct nldr_object *nldr_obj = NULL;
@@ -651,7 +651,7 @@ dsp_status proc_get_resource_info(void *hprocessor, u32 resource_type,
 						   proc_load_stat));
 		break;
 	default:
-		status = DSP_EFAIL;
+		status = -EPERM;
 		break;
 	}
 func_end:
@@ -682,7 +682,7 @@ void proc_exit(void)
 dsp_status proc_get_dev_object(void *hprocessor,
 			       struct dev_object **phDevObject)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 
 	DBC_REQUIRE(refs > 0);
@@ -743,7 +743,7 @@ dsp_status proc_get_state(void *hprocessor,
 				break;
 			default:
 				proc_state_obj->proc_state = 0xFF;
-				status = DSP_EFAIL;
+				status = -EPERM;
 				break;
 			}
 		}
@@ -848,7 +848,7 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 		goto func_end;
 	}
 	if (DSP_FAILED(dev_get_cod_mgr(p_proc_object->hdev_obj, &cod_mgr))) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	status = proc_stop(hprocessor);
@@ -872,7 +872,7 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 		if (status == -1) {
 			dev_dbg(bridge, "%s: Proc ID string overflow\n",
 				__func__);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			new_envp =
 			    prepend_envp(new_envp, (char **)user_envp,
@@ -924,7 +924,7 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 				status = DSP_SOK;
 
 			if (DSP_FAILED(status)) {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			} else {
 				DBC_ASSERT(p_proc_object->psz_last_coff ==
 					   NULL);
@@ -1536,7 +1536,7 @@ func_end:
  */
 static dsp_status proc_monitor(struct proc_object *p_proc_object)
 {
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct msg_mgr *hmsg_mgr;
 	int brd_state;
 
diff --git a/drivers/dsp/bridge/rmgr/pwr.c b/drivers/dsp/bridge/rmgr/pwr.c
index 51d8f44..f17ea8d 100644
--- a/drivers/dsp/bridge/rmgr/pwr.c
+++ b/drivers/dsp/bridge/rmgr/pwr.c
@@ -40,7 +40,7 @@ dsp_status pwr_sleep_dsp(IN CONST u32 sleepCode, IN CONST u32 timeout)
 {
 	struct bridge_drv_interface *intf_fxns;
 	struct wmd_dev_context *dw_context;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct dev_object *hdev_obj = NULL;
 	u32 ioctlcode = 0;
 	u32 arg = timeout;
@@ -83,7 +83,7 @@ dsp_status pwr_wake_dsp(IN CONST u32 timeout)
 {
 	struct bridge_drv_interface *intf_fxns;
 	struct wmd_dev_context *dw_context;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct dev_object *hdev_obj = NULL;
 	u32 arg = timeout;
 
@@ -116,7 +116,7 @@ dsp_status pwr_pm_pre_scale(IN u16 voltage_domain, u32 level)
 {
 	struct bridge_drv_interface *intf_fxns;
 	struct wmd_dev_context *dw_context;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
@@ -152,7 +152,7 @@ dsp_status pwr_pm_post_scale(IN u16 voltage_domain, u32 level)
 {
 	struct bridge_drv_interface *intf_fxns;
 	struct wmd_dev_context *dw_context;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct dev_object *hdev_obj = NULL;
 	u32 arg[2];
 
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
index 699f2dc..370cf89 100644
--- a/drivers/dsp/bridge/rmgr/strm.c
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -193,7 +193,7 @@ dsp_status strm_close(struct strm_object *hStrm,
 		drv_proc_remove_strm_res_element(hstrm_res, pr_ctxt);
 func_end:
 	DBC_ENSURE(status == DSP_SOK || status == DSP_EHANDLE ||
-		   status == DSP_EPENDING || status == DSP_EFAIL);
+		   status == DSP_EPENDING || status == -EPERM);
 
 	dev_dbg(bridge, "%s: hStrm: %p, status 0x%x\n", __func__,
 		hStrm, status);
@@ -583,19 +583,19 @@ func_cont:
 			 * something documented
 			 */
 			if (status != DSP_EMEMORY && status !=
-			    DSP_EINVALIDARG && status != DSP_EFAIL) {
+			    DSP_EINVALIDARG && status != -EPERM) {
 				/*
 				 * We got a status that's not return-able.
 				 * Assert that we got something we were
 				 * expecting (DSP_EHANDLE isn't acceptable,
 				 * strm_mgr_obj->hchnl_mgr better be valid or we
-				 * assert here), and then return DSP_EFAIL.
+				 * assert here), and then return -EPERM.
 				 */
 				DBC_ASSERT(status == CHNL_E_OUTOFSTREAMS ||
 					   status == CHNL_E_BADCHANID ||
 					   status == CHNL_E_CHANBUSY ||
 					   status == CHNL_E_NOIORPS);
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 		}
 	}
@@ -612,7 +612,7 @@ func_cont:
 		   (*phStrm == NULL && (status == DSP_EHANDLE ||
 					status == DSP_EDIRECTION
 					|| status == DSP_EVALUE
-					|| status == DSP_EFAIL)));
+					|| status == -EPERM)));
 
 	dev_dbg(bridge, "%s: hnode: %p dir: 0x%x index: 0x%x pattr: %p "
 		"phStrm: %p status: 0x%x\n", __func__,
@@ -659,7 +659,7 @@ dsp_status strm_reclaim(struct strm_object *hStrm, OUT u8 ** buf_ptr,
 			} else {
 				/* Allow reclaims after idle to succeed */
 				if (!CHNL_IS_IO_CANCELLED(chnl_ioc_obj))
-					status = DSP_EFAIL;
+					status = -EPERM;
 
 			}
 		}
@@ -694,7 +694,7 @@ func_end:
 	/* ensure we return a documented return code */
 	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
 		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		   status == DSP_EFAIL);
+		   status == -EPERM);
 
 	dev_dbg(bridge, "%s: hStrm: %p buf_ptr: %p pulBytes: %p pdw_arg: %p "
 		"status 0x%x\n", __func__, hStrm,
@@ -739,7 +739,7 @@ dsp_status strm_register_notify(struct strm_object *hStrm, u32 event_mask,
 	/* ensure we return a documented return code */
 	DBC_ENSURE(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
 		   status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
-		   status == DSP_ENOTIMPL || status == DSP_EFAIL);
+		   status == DSP_ENOTIMPL || status == -EPERM);
 	return status;
 }
 
diff --git a/drivers/dsp/bridge/services/clk.c b/drivers/dsp/bridge/services/clk.c
index a398dc4..cb383ef 100644
--- a/drivers/dsp/bridge/services/clk.c
+++ b/drivers/dsp/bridge/services/clk.c
@@ -162,12 +162,12 @@ dsp_status services_clk_enable(IN enum services_clk_id clk_id)
 			       "CLK dev id = %d\n",
 			       services_clks[clk_id].clk_name,
 			       services_clks[clk_id].id);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	} else {
 		pr_err("%s: failed to get CLK %s, CLK dev id = %d\n", __func__,
 		     services_clks[clk_id].clk_name, services_clks[clk_id].id);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	/* The SSI module need to configured not to have the Forced idle for
 	 * master interface. If it is set to forced idle, the SSI module is
@@ -201,7 +201,7 @@ dsp_status clk_set32k_hz(IN enum services_clk_id clk_id)
 			pr_err("%s: failed for %s, dev id = %d\n", __func__,
 			       services_clks[clk_id].clk_name,
 			       services_clks[clk_id].id);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 	}
 	return status;
@@ -241,7 +241,7 @@ dsp_status services_clk_disable(IN enum services_clk_id clk_id)
 		       "CLK dev id = %d\n",
 		       services_clks[clk_id].clk_name,
 		       services_clks[clk_id].id);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	return status;
 }
@@ -272,7 +272,7 @@ dsp_status services_clk_get_rate(IN enum services_clk_id clk_id, u32 *speedKhz)
 		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
 		       services_clks[clk_id].clk_name,
 		       services_clks[clk_id].id);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	return status;
 }
@@ -293,7 +293,7 @@ s32 clk_get_use_cnt(IN enum services_clk_id clk_id)
 		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
 		       services_clks[clk_id].clk_name,
 		       services_clks[clk_id].id);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	return use_count;
 }
diff --git a/drivers/dsp/bridge/services/reg.c b/drivers/dsp/bridge/services/reg.c
index e7f15cf..410886e 100644
--- a/drivers/dsp/bridge/services/reg.c
+++ b/drivers/dsp/bridge/services/reg.c
@@ -100,7 +100,7 @@ dsp_status reg_get_value(IN CONST char *pstrValue, OUT u8 * pbData,
 	if (regsup_get_value((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
 		status = DSP_SOK;
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	return status;
 }
diff --git a/drivers/dsp/bridge/services/regsup.c b/drivers/dsp/bridge/services/regsup.c
index 275d91c..1bee0e2 100644
--- a/drivers/dsp/bridge/services/regsup.c
+++ b/drivers/dsp/bridge/services/regsup.c
@@ -79,7 +79,7 @@ void regsup_exit(void)
  */
 dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size)
 {
-	dsp_status ret = DSP_EFAIL;
+	dsp_status ret = -EPERM;
 	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
 	/*  Need to search through the entries looking for the right one. */
@@ -112,7 +112,7 @@ dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size)
  */
 dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size)
 {
-	dsp_status ret = DSP_EFAIL;
+	dsp_status ret = -EPERM;
 	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
 	/*  Need to search through the entries looking for the right one. */
@@ -214,7 +214,7 @@ dsp_status regsup_enum_value(IN u32 dw_index, IN CONST char *pstrKey,
  */
 dsp_status regsup_delete_value(IN CONST char *pstrValue)
 {
-	dsp_status ret = DSP_EFAIL;
+	dsp_status ret = -EPERM;
 	struct reg_value *rv = (struct reg_value *)lst_first(reg_key_list);
 
 	while (rv) {
diff --git a/drivers/dsp/bridge/services/regsup.h b/drivers/dsp/bridge/services/regsup.h
index 3577c0b..7e320c1 100644
--- a/drivers/dsp/bridge/services/regsup.h
+++ b/drivers/dsp/bridge/services/regsup.h
@@ -30,12 +30,12 @@ extern void regsup_exit(void);
 extern dsp_status regsup_delete_value(IN CONST char *pstrValue);
 
 /*  Get the value of the entry having the given name.  Returns DSP_SOK */
-/*  if an entry was found and the value retrieved.  Returns DSP_EFAIL
+/*  if an entry was found and the value retrieved.  Returns -EPERM
  *  otherwise. */
 extern dsp_status regsup_get_value(char *valName, void *pbuf, u32 * data_size);
 
 /*  Sets the value of the entry having the given name.  Returns DSP_SOK */
-/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise. */
+/*  if an entry was found and the value set.  Returns -EPERM otherwise. */
 extern dsp_status regsup_set_value(char *valName, void *pbuf, u32 data_size);
 
 /*  Returns registry "values" and their "data" under a (sub)key. */
diff --git a/drivers/dsp/bridge/services/sync.c b/drivers/dsp/bridge/services/sync.c
index e54b500..5ec35f2 100644
--- a/drivers/dsp/bridge/services/sync.c
+++ b/drivers/dsp/bridge/services/sync.c
@@ -52,7 +52,7 @@ void sync_set_event(struct sync_object *event)
  * timeout. In case of success the function will return DSP_SOK and
  * @pu_index will store the index of the array element set or in case
  * of timeout the function will return DSP_ETIMEOUT or in case of
- * interrupting by a signal it will return DSP_EFAIL.
+ * interrupting by a signal it will return -EPERM.
  */
 
 dsp_status sync_wait_on_multiple_events(struct sync_object **events,
@@ -60,7 +60,7 @@ dsp_status sync_wait_on_multiple_events(struct sync_object **events,
 				     unsigned *index)
 {
 	unsigned i;
-	dsp_status status = DSP_EFAIL;
+	dsp_status status = -EPERM;
 	struct completion m_comp;
 
 	init_completion(&m_comp);
diff --git a/drivers/dsp/bridge/wmd/chnl_sm.c b/drivers/dsp/bridge/wmd/chnl_sm.c
index a2f98e9..e7b1d1e 100644
--- a/drivers/dsp/bridge/wmd/chnl_sm.c
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -616,7 +616,7 @@ dsp_status bridge_chnl_get_ioc(struct chnl_object *chnl_obj, u32 dwTimeOut,
 			/* No response from DSP */
 			ioc.status |= CHNL_IOCSTATTIMEOUT;
 			dequeue_ioc = false;
-		} else if (stat_sync == DSP_EFAIL) {
+		} else if (stat_sync == -EPERM) {
 			/* This can occur when the user mode thread is
 			 * aborted (^C), or when _VWIN32_WaitSingleObject()
 			 * fails due to unkown causes. */
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
index 1b5d977..bc55992 100644
--- a/drivers/dsp/bridge/wmd/io_sm.c
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -617,7 +617,7 @@ dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 				hio_mgr->ext_proc_info.ty_tlb[i].ul_gpp_phys,
 				hio_mgr->ext_proc_info.ty_tlb[i].ul_dsp_virt,
 				ul_gpp_pa, ul_dsp_va, ul_seg_size);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			if (ndx < MAX_LOCK_TLB_ENTRIES) {
 				ae_proc[ndx].ul_dsp_va =
@@ -687,7 +687,7 @@ dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 		goto func_end;
 	} else {
 		if (ae_proc[0].ul_dsp_va > ul_shm_base) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		/* ul_shm_base may not be at ul_dsp_va address */
@@ -1587,7 +1587,7 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 	status =
 	    cod_get_sym_value(cod_man, SHM0_SHARED_BASE_SYM, &ul_shm0_base);
 	if (ul_shm0_base == 0) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		goto func_end;
 	}
 	/* Get end of 1st SM Heap region */
@@ -1596,7 +1596,7 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 		status = cod_get_sym_value(cod_man, SHM0_SHARED_END_SYM,
 					   &shm0_end);
 		if (shm0_end == 0) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 	}
@@ -1607,7 +1607,7 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 		    cod_get_sym_value(cod_man, SHM0_SHARED_RESERVED_BASE_SYM,
 				      &ul_shm0_rsrvd_start);
 		if (ul_shm0_rsrvd_start == 0) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 	}
@@ -1625,14 +1625,14 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 		ul_rsrvd_size =
 		    (shm0_end - ul_shm0_rsrvd_start + 1) * hio_mgr->word_size;
 		if (ul_rsrvd_size <= 0) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		/* Calc size of SM DSP can alloc from */
 		ul_dsp_size =
 		    (ul_shm0_rsrvd_start - ul_shm0_base) * hio_mgr->word_size;
 		if (ul_dsp_size <= 0) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		/* First TLB entry reserved for Bridge SM use. */
@@ -1651,7 +1651,7 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 			dw_offset = ul_dsp_virt - dw_gpp_base_pa;
 
 		if (ul_shm0_rsrvd_start * hio_mgr->word_size < ul_dsp_virt) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto func_end;
 		}
 		/*
@@ -1681,7 +1681,7 @@ static dsp_status register_shm_segs(struct io_mgr *hio_mgr,
 					   dw_gpp_base_va);
 		/* First SM region is seg_id = 1 */
 		if (ul_shm_seg_id0 != 1)
-			status = DSP_EFAIL;
+			status = -EPERM;
 	}
 func_end:
 	return status;
@@ -1733,7 +1733,7 @@ dsp_status io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs)
 			hio_mgr->shared_mem->opp_table_struct.curr_opp_pt =
 			    *(u32 *) pargs;
 		else
-			return DSP_EFAIL;
+			return -EPERM;
 		break;
 	case SHM_OPPINFO:
 		/*
diff --git a/drivers/dsp/bridge/wmd/msg_sm.c b/drivers/dsp/bridge/wmd/msg_sm.c
index 9e04a35..f0e3949 100644
--- a/drivers/dsp/bridge/wmd/msg_sm.c
+++ b/drivers/dsp/bridge/wmd/msg_sm.c
@@ -333,7 +333,7 @@ dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
 		}
 	} else {
 		if (msg_queue_obj->done)
-			status = DSP_EFAIL;
+			status = -EPERM;
 		else
 			msg_queue_obj->io_msg_pend++;
 
@@ -357,7 +357,7 @@ dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
 			/*  Signal that we're not going to access msg_queue_obj
 			 *  anymore, so it can be deleted. */
 			(void)sync_set_event(msg_queue_obj->sync_done_ack);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			if (DSP_SUCCEEDED(status)) {
 				DBC_ASSERT(!LST_IS_EMPTY
@@ -437,7 +437,7 @@ dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
 		iosm_schedule(hmsg_mgr->hio_mgr);
 	} else {
 		if (msg_queue_obj->done)
-			status = DSP_EFAIL;
+			status = -EPERM;
 		else
 			msg_queue_obj->io_msg_pend++;
 
@@ -461,7 +461,7 @@ dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
 			/*  Signal that we're not going to access msg_queue_obj
 			 *  anymore, so it can be deleted. */
 			(void)sync_set_event(msg_queue_obj->sync_done_ack);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		} else {
 			if (LST_IS_EMPTY(hmsg_mgr->msg_free_list)) {
 				status = DSP_EPOINTER;
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 0c6cf2f..8eea2a9 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -374,7 +374,7 @@ static dsp_status bridge_brd_read(struct wmd_dev_context *hDevContext,
 	u32 dsp_base_addr = hDevContext->dw_dsp_base_addr;
 
 	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		return status;
 	}
 	/* change here to account for the 3 bands of the DSP internal memory */
@@ -464,7 +464,7 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 	 * get cleared when the DSP program starts. */
 	if ((ul_shm_base_virt == 0) || (ul_shm_base == 0)) {
 		pr_err("%s: Illegal SM base\n", __func__);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	} else
 		*((volatile u32 *)dw_sync_addr) = 0xffffffff;
 
@@ -593,7 +593,7 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 				    clk_set32k_hz(bpwr_clks
 						  [clk_id_index].fun_clk);
 			} else {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
 			    ul_load_monitor_timer;
@@ -628,7 +628,7 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 				    clk_set32k_hz(bpwr_clks
 						  [clk_id_index].fun_clk);
 			} else {
-				status = DSP_EFAIL;
+				status = -EPERM;
 			}
 
 			clk_cmd = (BPWR_ENABLE_CLOCK << MBX_PM_CLK_CMDSHIFT) |
@@ -671,7 +671,7 @@ static dsp_status bridge_brd_start(struct wmd_dev_context *hDevContext,
 			dev_context->mbox = NULL;
 			pr_err("%s: Failed to get dsp mailbox handle\n",
 								__func__);
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 
 	}
@@ -769,7 +769,7 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 					drv_get_first_dev_extension(),
 					&resources);
 	if (DSP_FAILED(status))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &dsp_pwr_state);
 	if (dsp_pwr_state != HW_PWR_STATE_OFF && dev_context->mbox) {
@@ -848,7 +848,7 @@ static dsp_status wmd_brd_delete(struct wmd_dev_context *hDevContext)
 					drv_get_first_dev_extension(),
 					&resources);
 	if (DSP_FAILED(status))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	status = sleep_dsp(dev_context, PWR_EMERGENCYDEEPSLEEP, NULL);
 	clk_status = services_clk_disable(SERVICESCLK_IVA2_CK);
@@ -906,7 +906,7 @@ static dsp_status bridge_brd_write(struct wmd_dev_context *hDevContext,
 	struct wmd_dev_context *dev_context = hDevContext;
 
 	if (dwDSPAddr < dev_context->dw_dsp_start_add) {
-		status = DSP_EFAIL;
+		status = -EPERM;
 		return status;
 	}
 	if ((dwDSPAddr - dev_context->dw_dsp_start_add) <
@@ -975,7 +975,7 @@ static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
 								 dw_mem_length
 								 [3]);
 	if (!dev_context->dw_dsp_base_addr)
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	pt_attrs = mem_calloc(sizeof(struct pg_table_attrs), MEM_NONPAGED);
 	if (pt_attrs != NULL) {
@@ -1151,7 +1151,7 @@ static dsp_status bridge_dev_ctrl(struct wmd_dev_context *dev_context,
 		status = handle_constraints_set(dev_context, pargs);
 		break;
 	default:
-		status = DSP_EFAIL;
+		status = -EPERM;
 		break;
 	}
 	return status;
@@ -1400,7 +1400,7 @@ static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
 		for (pg_i = 0; pg_i < num_usr_pgs; pg_i++) {
 			pa = user_va2_pa(mm, mpu_addr);
 			if (!pa) {
-				status = DSP_EFAIL;
+				status = -EPERM;
 				pr_err("DSPBRIDGE: VM_IO mapping physical"
 				       "address is invalid\n");
 				break;
@@ -1454,7 +1454,7 @@ static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
 				       "Value = %d, Buffer"
 				       "size=0x%x\n", ul_mpu_addr,
 				       vma->vm_flags, pg_num, ul_num_bytes);
-				status = DSP_EFAIL;
+				status = -EPERM;
 				break;
 			}
 		}
@@ -1473,7 +1473,7 @@ func_cont:
 			bridge_brd_mem_un_map(dev_context, ulVirtAddr,
 					   (pg_i * PG_SIZE4K));
 		}
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 	/*
 	 * In any case, flush the TLB
@@ -1571,7 +1571,7 @@ static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
 			/* va_curr aligned to pte_size? */
 			if (pte_size == 0 || rem_bytes_l2 < pte_size ||
 			    va_curr & (pte_size - 1)) {
-				status = DSP_EFAIL;
+				status = -EPERM;
 				break;
 			}
 
@@ -1601,7 +1601,7 @@ static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
 			}
 			if (hw_mmu_pte_clear(pte_addr_l2, va_curr, pte_size)
 			    == RET_FAIL) {
-				status = DSP_EFAIL;
+				status = -EPERM;
 				goto EXIT_LOOP;
 			}
 
@@ -1622,14 +1622,14 @@ static dsp_status bridge_brd_mem_un_map(struct wmd_dev_context *hDevContext,
 				    RET_OK)
 					status = DSP_SOK;
 				else {
-					status = DSP_EFAIL;
+					status = -EPERM;
 					spin_unlock(&pt->pg_lock);
 					goto EXIT_LOOP;
 				}
 			}
 			rem_bytes -= pte_count * PG_SIZE4K;
 		} else
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		spin_unlock(&pt->pg_lock);
 		continue;
@@ -1638,7 +1638,7 @@ skip_coarse_page:
 		/* pte_size = 1 MB or 16 MB */
 		if (pte_size == 0 || rem_bytes < pte_size ||
 		    va_curr & (pte_size - 1)) {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			break;
 		}
 
@@ -1669,7 +1669,7 @@ skip_coarse_page:
 			rem_bytes -= pte_size;
 			va_curr += pte_size;
 		} else {
-			status = DSP_EFAIL;
+			status = -EPERM;
 			goto EXIT_LOOP;
 		}
 	}
@@ -1792,7 +1792,7 @@ static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
 			pte_val = *(u32 *) pte_addr_l1;
 			pte_size = hw_mmu_pte_size_l1(pte_val);
 		} else {
-			return DSP_EFAIL;
+			return -EPERM;
 		}
 		spin_lock(&pt->pg_lock);
 		if (pte_size == HW_MMU_COARSE_PAGE_SIZE) {
@@ -1829,7 +1829,7 @@ static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
 		} else {
 			/* Found valid L1 PTE of another size.
 			 * Should not overwrite it. */
-			status = DSP_EFAIL;
+			status = -EPERM;
 		}
 		if (DSP_SUCCEEDED(status)) {
 			pg_tbl_va = l2_base_va;
@@ -1926,7 +1926,7 @@ static dsp_status mem_map_vmalloc(struct wmd_dev_context *dev_context,
 	if (DSP_SUCCEEDED(status))
 		status = DSP_SOK;
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	/*
 	 * In any case, flush the TLB
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index 9174a80..0e36156 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -108,7 +108,7 @@ dsp_status handle_hibernation_from_dsp(struct wmd_dev_context *dev_context)
 	while ((pwr_state != HW_PWR_STATE_OFF) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP OFF mode interrupted\n");
-			return DSP_EFAIL;
+			return -EPERM;
 		}
 		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
 				      &pwr_state);
@@ -207,7 +207,7 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 		return DSP_SALREADYASLEEP;
 	default:
 		dev_dbg(bridge, "PM: %s - Bridge in Illegal state\n", __func__);
-		return DSP_EFAIL;
+		return -EPERM;
 	}
 
 	/* Get the PRCM DSP power domain status */
@@ -218,7 +218,7 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 	while ((pwr_state != target_pwr_state) && --timeout) {
 		if (msleep_interruptible(10)) {
 			pr_err("Waiting for DSP to Suspend interrupted\n");
-			return DSP_EFAIL;
+			return -EPERM;
 		}
 		hw_pwr_iva2_state_get(resources.dw_prm_base, HW_PWR_DOMAIN_DSP,
 				      &pwr_state);
@@ -313,7 +313,7 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 					&resources);
 
 	if (DSP_FAILED(status))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	ext_clk_id = ext_clk & MBX_PM_CLK_IDMASK;
 
@@ -329,7 +329,7 @@ dsp_status dsp_peripheral_clk_ctrl(struct wmd_dev_context *dev_context,
 	/* DBC_ASSERT(clk_id_index < MBX_PM_MAX_RESOURCES); */
 	if (clk_id_index == MBX_PM_MAX_RESOURCES) {
 		/* return with a more meaningfull error code */
-		return DSP_EFAIL;
+		return -EPERM;
 	}
 	ext_clk_cmd = (ext_clk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
 	switch (ext_clk_cmd) {
@@ -410,7 +410,7 @@ dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_PRENOTIFY);
 		return DSP_SOK;
 	} else {
-		return DSP_EFAIL;
+		return -EPERM;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return DSP_SOK;
@@ -452,7 +452,7 @@ dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 		dev_dbg(bridge, "OPP: %s wrote to shm. Sent post notification "
 			"to DSP\n", __func__);
 	} else {
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 #endif /* #ifdef CONFIG_BRIDGE_DVFS */
 	return status;
@@ -511,7 +511,7 @@ dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
 					IN void *pargs)
 {
 	u32 clk_idx;
-	dsp_status int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	dsp_status int_clk_status = -EPERM, fun_clk_status = -EPERM;
 	struct cfg_hostres resources;
 	u32 value;
 
@@ -544,7 +544,7 @@ dsp_status dsp_peripheral_clocks_enable(struct wmd_dev_context *dev_context,
 		}
 	}
 	if ((int_clk_status | fun_clk_status) != DSP_SOK)
-		return DSP_EFAIL;
+		return -EPERM;
 	return DSP_SOK;
 }
 
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.c b/drivers/dsp/bridge/wmd/tiomap_io.c
index b5504a9..205cf40 100644
--- a/drivers/dsp/bridge/wmd/tiomap_io.c
+++ b/drivers/dsp/bridge/wmd/tiomap_io.c
@@ -130,7 +130,7 @@ dsp_status read_ext_dsp_data(struct wmd_dev_context *hDevContext,
 		DBC_ASSERT(ul_ext_end > ul_ext_base);
 
 		if (ul_ext_end < ul_ext_base)
-			status = DSP_EFAIL;
+			status = -EPERM;
 
 		if (DSP_SUCCEEDED(status)) {
 			ul_tlb_base_virt =
@@ -156,7 +156,7 @@ dsp_status read_ext_dsp_data(struct wmd_dev_context *hDevContext,
 				 * only when the board is stopped.
 				*/
 				if (!dev_context->dw_dsp_ext_base_addr)
-					status = DSP_EFAIL;
+					status = -EPERM;
 			}
 
 			dw_base_addr = dw_ext_prog_virt_mem;
@@ -164,7 +164,7 @@ dsp_status read_ext_dsp_data(struct wmd_dev_context *hDevContext,
 	}
 
 	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 	offset = dwDSPAddr - ul_ext_base;
 
@@ -213,7 +213,7 @@ dsp_status write_dsp_data(struct wmd_dev_context *hDevContext,
 						  resources.dw_mem_length[4]);
 		offset = offset - base3;
 	} else {
-		return DSP_EFAIL;
+		return -EPERM;
 	}
 	if (ul_num_bytes)
 		memcpy((u8 *) (dw_base_addr + offset), pbHostBuf, ul_num_bytes);
@@ -319,7 +319,7 @@ dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
 		DBC_ASSERT(ul_ext_end != 0);
 		DBC_ASSERT(ul_ext_end > ul_ext_base);
 		if (ul_ext_end < ul_ext_base)
-			ret = DSP_EFAIL;
+			ret = -EPERM;
 
 		if (DSP_SUCCEEDED(ret)) {
 			ul_tlb_base_virt =
@@ -362,11 +362,11 @@ dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
 			/* This dw_dsp_ext_base_addr will get cleared only when
 			 * the board is stopped. */
 			if (!dev_context->dw_dsp_ext_base_addr)
-				ret = DSP_EFAIL;
+				ret = -EPERM;
 		}
 	}
 	if (!dw_base_addr || !ul_ext_base || !ul_ext_end)
-		ret = DSP_EFAIL;
+		ret = -EPERM;
 
 	if (DSP_SUCCEEDED(ret)) {
 		for (i = 0; i < 4; i++)
@@ -375,7 +375,7 @@ dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
 		dw_offset = dwDSPAddr - ul_ext_base;
 		/* Also make sure the dwDSPAddr is < ul_ext_end */
 		if (dwDSPAddr > ul_ext_end || dw_offset > dwDSPAddr)
-			ret = DSP_EFAIL;
+			ret = -EPERM;
 	}
 	if (DSP_SUCCEEDED(ret)) {
 		if (ul_num_bytes)
@@ -412,7 +412,7 @@ dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
 					drv_get_first_dev_extension(),
 					&resources);
 	if (DSP_FAILED(status))
-		return DSP_EFAIL;
+		return -EPERM;
 
 	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
 	    dev_context->dw_brd_state == BRD_HIBERNATION) {
@@ -458,7 +458,7 @@ dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
 
 	if (status) {
 		pr_err("omap_mbox_msg_send Fail and status = %d\n", status);
-		status = DSP_EFAIL;
+		status = -EPERM;
 	}
 
 	return DSP_SOK;
diff --git a/drivers/dsp/bridge/wmd/ue_deh.c b/drivers/dsp/bridge/wmd/ue_deh.c
index 9597f5d..5ddf5d9 100644
--- a/drivers/dsp/bridge/wmd/ue_deh.c
+++ b/drivers/dsp/bridge/wmd/ue_deh.c
@@ -119,7 +119,7 @@ dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
 					(void *)deh_mgr)) == 0)
 		status = DSP_SOK;
 	else
-		status = DSP_EFAIL;
+		status = -EPERM;
 
 err:
 	if (DSP_FAILED(status)) {
-- 
1.7.0.4

