From 4100affda5ac3df7392cb0e06f03ad09d709542b Mon Sep 17 00:00:00 2001
From: Fernando Guzman Lugo <x0095840@ti.com>
Date: Fri, 22 Jan 2010 21:46:42 -0600
Subject: [PATCH 007/135] DSPBRIDGE: Remove chnl_sm.h and tiomap_sm.c

Because of mailbox migration all the functions in tiomap_sm.c except
one and their prototypes in chnl_sm.h are not needed anymore,
so that function was changed to tiomap_io.c and changed the name
to remove camelcasing

Signed-off-by: Fernando Guzman Lugo <x0095840@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/chnl_sm.h |  151 ------------------------
 drivers/dsp/bridge/Makefile                    |    2 +-
 drivers/dsp/bridge/wmd/_tiomap.h               |   17 +++
 drivers/dsp/bridge/wmd/io_sm.c                 |   14 +--
 drivers/dsp/bridge/wmd/tiomap3430.c            |    3 +-
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c        |   13 +-
 drivers/dsp/bridge/wmd/tiomap_io.c             |   70 +++++++++++
 drivers/dsp/bridge/wmd/tiomap_sm.c             |   97 ---------------
 8 files changed, 101 insertions(+), 266 deletions(-)
 delete mode 100644 arch/arm/plat-omap/include/dspbridge/chnl_sm.h
 delete mode 100644 drivers/dsp/bridge/wmd/tiomap_sm.c

diff --git a/arch/arm/plat-omap/include/dspbridge/chnl_sm.h b/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
deleted file mode 100644
index fd17667..0000000
--- a/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * chnl_sm.h
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Prototypes for channel lower edge functions for a Bridge mini driver
- * implementing data transfer via shared memory.
- *
- * Notes:
- *   These lower edge functions must be implemented by the WMD writer.
- *   Currently, chnlsm_read() and chnlsm_write() are not called, but must
- *   be defined to link.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#ifndef CHNLSM_
-#define CHNLSM_
-
-#include <dspbridge/wmd.h>
-
-/*
- *  ======== chnlsm_disable_interrupt ========
- *  Purpose:
- *      Disable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-extern dsp_status chnlsm_disable_interrupt(struct wmd_dev_context *hDevContext);
-
-/*
- *  ======== chnlsm_enable_interrupt ========
- *  Purpose:
- *      Enable interrupts from the DSP board to the PC.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-extern dsp_status chnlsm_enable_interrupt(struct wmd_dev_context *hDevContext);
-
-/*
- *  ======== chnlsm_interrupt_dsp2 ========
- *  Purpose:
- *      Set interrupt value & send an interrupt to the DSP processor(s).
- *      This is typicaly used when mailbox interrupt mechanisms allow data
- *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      mb_val:         Value associated with interrupt(e.g. mailbox value).
- *  Returns:
- *      DSP_SOK:        Interrupt sent;
- *      else:           Unable to send interrupt.
- *  Requires:
- *  Ensures:
- */
-extern dsp_status chnlsm_interrupt_dsp2(struct wmd_dev_context *hDevContext,
-					u16 mb_val);
-
-/*
- *  ======== chnlsm_isr ========
- *  Purpose:
- *      Mini-driver's ISR, called by WCD when the board interrupts the host.
- *  Parameters:
- *      hDevContext:    Handle to the mini-driver defined device info.
- *      pfSchedDPC:     Set to TRUE to schedule a deferred procedure call
- *                      to advance the channel protocol.  The channel class
- *                      library will call the WMD's CHNLSM_DPC routine during
- *                      its own DPC, before dispatching I/O.
- *                      The channel class library should ignore *pfSchedDPC when
- *                      chnlsm_isr returns FALSE.
- *      pwMBRegVal:     Value of mailbox register.
- *  Returns:
- *      TRUE if this interrupt is was generated by the DSP board.
- *      FALSE otherwise.
- *  Requires:
- *      Interrupts to the host processor are disabled on entry.
- *      Must only call functions which are in page locked memory.
- *      Must only call asynchronous OS services.
- *      The EOI for this interrupt has already been sent to the PIC.
- *  Ensures:
- *      If the interrupt is *not* shared, this routine must return TRUE.
- */
-extern bool chnlsm_isr(struct wmd_dev_context *hDevContext,
-		       OUT bool *pfSchedDPC, OUT u16 *pwIntrVal);
-
-/*
- *  ======== chnlsm_read ========
- *  Purpose:
- *      Read data from DSP board memory into a Host buffer.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Destination).
- *      dwDSPAddr:      Address on DSP board (Source).
- *      ul_num_bytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-extern dsp_status chnlsm_read(struct wmd_dev_context *hDevContext,
-			      OUT u8 *pHostBuf,
-			      u32 dwDSPAddr, u32 ul_num_bytes);
-
-/*
- *  ======== chnlsm_update_shm_length ========
- *  Purpose:
- *      Allow the minidriver a chance to override the shm length as reported
- *      to the mini driver (chnl_sm.lib) by Windows Plug and Play.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pSHMLength:     Pointer to size of shm window (in DSP words).
- *  Returns:
- *      TRUE if pSHMLength updated; FALSE otherwise.
- *  Requires:
- *      pSHMLength != NULL.
- *  Ensures:
- *      No more than sizeof(u32) bytes written to *pSHMLength
- */
-extern bool chnlsm_update_shm_length(struct wmd_dev_context *hDevContext,
-				     IN OUT u32 *pSHMLength);
-
-/*
- *  ======== chnlsm_write ========
- *  Purpose:
- *      Write data from a Host buffer to DSP board memory.
- *  Parameters:
- *      hDevContext:    Handle to mini-driver defined device info.
- *      pHostBuf:       Pointer to host buffer (Source).
- *      dwDSPAddr:      Address on DSP board (Destination).
- *      ul_num_bytes:     Number of bytes to transfer.
- *  Returns:
- *  Requires:
- *  Ensures:
- */
-extern dsp_status chnlsm_write(struct wmd_dev_context *hDevContext,
-			       IN u8 *pHostBuf,
-			       u32 dwDSPAddr, u32 ul_num_bytes);
-
-#endif /* CHNLSM_ */
diff --git a/drivers/dsp/bridge/Makefile b/drivers/dsp/bridge/Makefile
index d700938..2b4f92c 100644
--- a/drivers/dsp/bridge/Makefile
+++ b/drivers/dsp/bridge/Makefile
@@ -6,7 +6,7 @@ libservices = services/mem.o services/sync.o \
                services/regsup.o services/ntfy.o \
 		services/services.o
 libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
-		wmd/tiomap3430_pwr.o wmd/tiomap_sm.o wmd/tiomap_io.o \
+		wmd/tiomap3430_pwr.o wmd/tiomap_io.o \
 		wmd/mmu_fault.o wmd/ue_deh.o
 libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
 		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
diff --git a/drivers/dsp/bridge/wmd/_tiomap.h b/drivers/dsp/bridge/wmd/_tiomap.h
index d563002..7a884f4 100644
--- a/drivers/dsp/bridge/wmd/_tiomap.h
+++ b/drivers/dsp/bridge/wmd/_tiomap.h
@@ -356,4 +356,21 @@ extern dsp_status wmd_tlb_dsp_va_to_mpu_pa(struct wmd_dev_context *dev_context,
 					   OUT u32 *ulPhysAddr,
 					   OUT u32 *sizeTlb);
 
+/*
+ *  ======== sm_interrupt_dsp ========
+ *  Purpose:
+ *      Set interrupt value & send an interrupt to the DSP processor(s).
+ *      This is typicaly used when mailbox interrupt mechanisms allow data
+ *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
+ *  Parameters:
+ *      dev_context:    Handle to mini-driver defined device info.
+ *      mb_val:         Value associated with interrupt(e.g. mailbox value).
+ *  Returns:
+ *      DSP_SOK:        Interrupt sent;
+ *      else:           Unable to send interrupt.
+ *  Requires:
+ *  Ensures:
+ */
+dsp_status sm_interrupt_dsp(struct wmd_dev_context* dev_context, u16 mb_val);
+
 #endif /* _TIOMAP_ */
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
index e68343d..7010f53 100644
--- a/drivers/dsp/bridge/wmd/io_sm.c
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -58,7 +58,6 @@
 /* Platform Manager */
 #include <dspbridge/cod.h>
 #include <dspbridge/dev.h>
-#include <dspbridge/chnl_sm.h>
 
 /* Others */
 #include <dspbridge/rms_sh.h>
@@ -831,7 +830,7 @@ void io_cancel_chnl(struct io_mgr *hio_mgr, u32 ulChnl)
 	IO_AND_VALUE(pio_mgr->hwmd_context, struct shm, sm, host_free_mask,
 		     (~(1 << ulChnl)));
 
-	chnlsm_interrupt_dsp2(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 func_end:
 	return;
 }
@@ -1223,7 +1222,7 @@ static void input_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 		/* Indicate to the DSP we have read the input */
 		IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, input_full,
 			     0);
-		chnlsm_interrupt_dsp2(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	}
 	if (notify_client) {
 		/* Notify client with IO completion record */
@@ -1350,7 +1349,7 @@ static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 			     msg_ctr_obj, buf_empty, true);
 		IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
 			     msg_ctr_obj, post_swi, true);
-		chnlsm_interrupt_dsp2(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+		sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	}
 func_end:
 	return;
@@ -1468,7 +1467,7 @@ static void output_chnl(struct io_mgr *pio_mgr, struct chnl_object *pchnl,
 #endif
 	IO_SET_VALUE(pio_mgr->hwmd_context, struct shm, sm, output_full, 1);
 	/* Indicate to the DSP we have written the output */
-	chnlsm_interrupt_dsp2(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 	/* Notify client with IO completion record (keep EOS) */
 	chnl_packet_obj->status &= CHNL_IOCSTATEOS;
 	notify_chnl_complete(pchnl, chnl_packet_obj);
@@ -1559,8 +1558,7 @@ static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr)
 			IO_SET_VALUE(pio_mgr->hwmd_context, struct msg_ctrl,
 				     msg_ctr_obj, post_swi, true);
 			/* Tell the DSP we have written the output. */
-			chnlsm_interrupt_dsp2(pio_mgr->hwmd_context,
-					      MBX_PCPY_CLASS);
+			sm_interrupt_dsp(pio_mgr->hwmd_context, MBX_PCPY_CLASS);
 		}
 	}
 func_end:
@@ -1718,7 +1716,7 @@ static u32 write_data(struct wmd_dev_context *hDevContext, void *dest,
 /* ZCPY IO routines. */
 void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val)
 {
-	chnlsm_interrupt_dsp2(pio_mgr->hwmd_context, mb_val);
+	sm_interrupt_dsp(pio_mgr->hwmd_context, mb_val);
 }
 
 /*
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 5f2ac70..d90518a 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -54,7 +54,6 @@
 #include <dspbridge/wmdio.h>
 #include <dspbridge/wmdmsg.h>
 #include <dspbridge/pwr.h>
-#include <dspbridge/chnl_sm.h>
 #include <dspbridge/io_sm.h>
 
 /*  ----------------------------------- Platform Manager */
@@ -774,7 +773,7 @@ static dsp_status bridge_brd_stop(struct wmd_dev_context *hDevContext)
 
 	hw_pwrst_iva2_reg_get(resources.dw_prm_base, &dsp_pwr_state);
 	if (dsp_pwr_state != HW_PWR_STATE_OFF && dev_context->mbox) {
-		chnlsm_interrupt_dsp2(dev_context, MBX_PM_DSPIDLE);
+		sm_interrupt_dsp(dev_context, MBX_PM_DSPIDLE);
 		mdelay(10);
 		get_hw_regs(resources.dw_prm_base, resources.dw_cm_base);
 		udelay(50);
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
index 2eb553b..9174a80 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -22,7 +22,6 @@
 #include <dspbridge/cfg.h>
 #include <dspbridge/drv.h>
 #include <dspbridge/io_sm.h>
-#include <dspbridge/chnl_sm.h>
 
 /*  ----------------------------------- OS Adaptation Layer */
 #include <dspbridge/mem.h>
@@ -180,19 +179,19 @@ dsp_status sleep_dsp(struct wmd_dev_context *dev_context, IN u32 dw_cmd,
 	case BRD_RUNNING:
 		omap_mbox_save_ctx(dev_context->mbox);
 		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
-			chnlsm_interrupt_dsp2(dev_context, MBX_PM_DSPHIBERNATE);
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
 			dev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",
 				__func__);
 			target_pwr_state = HW_PWR_STATE_OFF;
 		} else {
-			chnlsm_interrupt_dsp2(dev_context, MBX_PM_DSPRETENTION);
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPRETENTION);
 			target_pwr_state = HW_PWR_STATE_RET;
 		}
 		break;
 	case BRD_RETENTION:
 		omap_mbox_save_ctx(dev_context->mbox);
 		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
-			chnlsm_interrupt_dsp2(dev_context, MBX_PM_DSPHIBERNATE);
+			sm_interrupt_dsp(dev_context, MBX_PM_DSPHIBERNATE);
 			target_pwr_state = HW_PWR_STATE_OFF;
 		} else
 			return DSP_SOK;
@@ -279,7 +278,7 @@ dsp_status wake_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 	}
 
 	/* Send a wakeup message to DSP */
-	chnlsm_interrupt_dsp2(dev_context, MBX_PM_DSPWAKEUP);
+	sm_interrupt_dsp(dev_context, MBX_PM_DSPWAKEUP);
 
 	/* Set the device state to RUNNIG */
 	dev_context->dw_brd_state = BRD_RUNNING;
@@ -408,7 +407,7 @@ dsp_status pre_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 	} else if ((dev_context->dw_brd_state == BRD_RUNNING)) {
 		/* Send a prenotificatio to DSP */
 		dev_dbg(bridge, "OPP: %s sent notification to DSP\n", __func__);
-		chnlsm_interrupt_dsp2(dev_context, MBX_PM_SETPOINT_PRENOTIFY);
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_PRENOTIFY);
 		return DSP_SOK;
 	} else {
 		return DSP_EFAIL;
@@ -449,7 +448,7 @@ dsp_status post_scale_dsp(struct wmd_dev_context *dev_context, IN void *pargs)
 		/* Update the OPP value in shared memory */
 		io_sh_msetting(hio_mgr, SHM_CURROPP, &level);
 		/* Send a post notification to DSP */
-		chnlsm_interrupt_dsp2(dev_context, MBX_PM_SETPOINT_POSTNOTIFY);
+		sm_interrupt_dsp(dev_context, MBX_PM_SETPOINT_POSTNOTIFY);
 		dev_dbg(bridge, "OPP: %s wrote to shm. Sent post notification "
 			"to DSP\n", __func__);
 	} else {
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.c b/drivers/dsp/bridge/wmd/tiomap_io.c
index b8087ae..b5504a9 100644
--- a/drivers/dsp/bridge/wmd/tiomap_io.c
+++ b/drivers/dsp/bridge/wmd/tiomap_io.c
@@ -393,3 +393,73 @@ dsp_status write_ext_dsp_data(struct wmd_dev_context *dev_context,
 	symbols_reloaded = false;
 	return ret;
 }
+
+dsp_status sm_interrupt_dsp(struct wmd_dev_context *dev_context, u16 mb_val)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
+	u32 opplevel = 0;
+#endif
+	struct cfg_hostres resources;
+	dsp_status status = DSP_SOK;
+	u32 temp;
+
+	if (!dev_context->mbox)
+		return DSP_SOK;
+
+	status = cfg_get_host_resources((struct cfg_devnode *)
+					drv_get_first_dev_extension(),
+					&resources);
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
+	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
+	    dev_context->dw_brd_state == BRD_HIBERNATION) {
+#ifdef CONFIG_BRIDGE_DVFS
+		if (pdata->dsp_get_opp)
+			opplevel = (*pdata->dsp_get_opp) ();
+		if (opplevel == VDD1_OPP1) {
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp) (VDD1_OPP2);
+		}
+#endif
+		/* Restart the peripheral clocks */
+		dsp_peripheral_clocks_enable(dev_context, NULL);
+
+		/*
+		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
+		 *     in CM_AUTOIDLE_PLL_IVA2 register
+		 */
+		*(reg_uword32 *) (resources.dw_cm_base + 0x34) = 0x1;
+
+		/*
+		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
+		 *     0.75 MHz - 1.0 MHz
+		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
+		 */
+		temp = *(reg_uword32 *) (resources.dw_cm_base + 0x4);
+		temp = (temp & 0xFFFFFF08) | 0x37;
+		*(reg_uword32 *) (resources.dw_cm_base + 0x4) = temp;
+
+		/* Restore mailbox settings */
+		omap_mbox_restore_ctx(dev_context->mbox);
+
+		/* Access MMU SYS CONFIG register to generate a short wakeup */
+		temp = *(reg_uword32 *) (resources.dw_dmmu_base + 0x10);
+
+		dev_context->dw_brd_state = BRD_RUNNING;
+	} else if (dev_context->dw_brd_state == BRD_RETENTION) {
+		/* Restart the peripheral clocks */
+		dsp_peripheral_clocks_enable(dev_context, NULL);
+	}
+
+	status = omap_mbox_msg_send(dev_context->mbox, mb_val);
+
+	if (status) {
+		pr_err("omap_mbox_msg_send Fail and status = %d\n", status);
+		status = DSP_EFAIL;
+	}
+
+	return DSP_SOK;
+}
\ No newline at end of file
diff --git a/drivers/dsp/bridge/wmd/tiomap_sm.c b/drivers/dsp/bridge/wmd/tiomap_sm.c
deleted file mode 100644
index 70b9cd9..0000000
--- a/drivers/dsp/bridge/wmd/tiomap_sm.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * tiomap_sm.c
- *
- * DSP-BIOS Bridge driver support functions for TI OMAP processors.
- *
- * Copyright (C) 2005-2006 Texas Instruments, Inc.
- *
- * This package is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
- * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
- */
-
-#include <dspbridge/dbdefs.h>
-#include <dspbridge/errbase.h>
-
-#include <dspbridge/cfg.h>
-#include <dspbridge/drv.h>
-#include <dspbridge/dev.h>
-
-#include "_tiomap.h"
-#include "_tiomap_pwr.h"
-
-
-dsp_status chnlsm_interrupt_dsp2(struct wmd_dev_context *dev_context,
-				 u16 mb_val)
-{
-#ifdef CONFIG_BRIDGE_DVFS
-	struct dspbridge_platform_data *pdata =
-	    omap_dspbridge_dev->dev.platform_data;
-	u32 opplevel = 0;
-#endif
-	struct cfg_hostres resources;
-	dsp_status status = DSP_SOK;
-	u32 temp;
-
-	if (!dev_context->mbox)
-		return DSP_SOK;
-
-	status = cfg_get_host_resources((struct cfg_devnode *)
-					drv_get_first_dev_extension(),
-					&resources);
-	if (DSP_FAILED(status))
-		return DSP_EFAIL;
-
-	if (dev_context->dw_brd_state == BRD_DSP_HIBERNATION ||
-	    dev_context->dw_brd_state == BRD_HIBERNATION) {
-#ifdef CONFIG_BRIDGE_DVFS
-		if (pdata->dsp_get_opp)
-			opplevel = (*pdata->dsp_get_opp) ();
-		if (opplevel == VDD1_OPP1) {
-			if (pdata->dsp_set_min_opp)
-				(*pdata->dsp_set_min_opp) (VDD1_OPP2);
-		}
-#endif
-		/* Restart the peripheral clocks */
-		dsp_peripheral_clocks_enable(dev_context, NULL);
-
-		/*
-		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
-		 *     in CM_AUTOIDLE_PLL_IVA2 register
-		 */
-		*(reg_uword32 *) (resources.dw_cm_base + 0x34) = 0x1;
-
-		/*
-		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
-		 *     0.75 MHz - 1.0 MHz
-		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
-		 */
-		temp = *(reg_uword32 *) (resources.dw_cm_base + 0x4);
-		temp = (temp & 0xFFFFFF08) | 0x37;
-		*(reg_uword32 *) (resources.dw_cm_base + 0x4) = temp;
-
-		/* Restore mailbox settings */
-		omap_mbox_restore_ctx(dev_context->mbox);
-
-		/* Access MMU SYS CONFIG register to generate a short wakeup */
-		temp = *(reg_uword32 *) (resources.dw_dmmu_base + 0x10);
-
-		dev_context->dw_brd_state = BRD_RUNNING;
-	} else if (dev_context->dw_brd_state == BRD_RETENTION) {
-		/* Restart the peripheral clocks */
-		dsp_peripheral_clocks_enable(dev_context, NULL);
-	}
-
-	status = omap_mbox_msg_send(dev_context->mbox, mb_val);
-
-	if (status) {
-		pr_err("omap_mbox_msg_send Fail and status = %d\n", status);
-		status = DSP_EFAIL;
-	}
-
-	return DSP_SOK;
-}
-- 
1.7.0.4

