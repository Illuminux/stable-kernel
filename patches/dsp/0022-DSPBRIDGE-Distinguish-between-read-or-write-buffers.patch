From 3464eb12c3ea2c37c748028d793656e7855e9b7c Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <omar.ramirez@ti.com>
Date: Fri, 26 Mar 2010 21:02:28 +0000
Subject: [PATCH 022/135] DSPBRIDGE: Distinguish between read or write buffers

This patch introduces the check to differentiate the buffers
coming to the dsp through bridgedriver. So far they can be
input (read) or output (write) or rw (which are treated the
same way as an output buffer), this distinctions are made from
dsp perspective.

Since this needs to be checked on map function, unused
bits (15, 14) of flags were used to check for this argument.

As 128 byte alignment limitation doesn't affect input buffers
only writable buffers are checked. Default value for read buffers
is set to be 1, this will enforce that users of bridge will fill
the flags with significant values otherwise (if enabled) check
will reject buffers not aligned to 128 bytes (even if they fall in
the input category).

Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/dbdefs.h |    7 ++++++-
 drivers/dsp/bridge/rmgr/proc.c                |   16 ++++++++++++----
 drivers/dsp/bridge/wmd/tiomap3430.c           |    4 ++--
 3 files changed, 20 insertions(+), 7 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index 7fcc4aa..d01d9ae 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -490,7 +490,10 @@ bit 3 - MMU element size = 8bit (valid only for non mixed page entries)
 bit 4 - MMU element size = 16bit (valid only for non mixed page entries)
 bit 5 - MMU element size = 32bit (valid only for non mixed page entries)
 bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
- */
+
+bit 14 - Input (read only) buffer
+bit 15 - Output (writeable) buffer
+*/
 
 /* Types of mapping attributes */
 
@@ -518,6 +521,8 @@ bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
 
 #define DSP_MAPDONOTLOCK	   0x00000100
 
+#define DSP_MAP_DIR_MASK		0x3FFF
+
 #define GEM_CACHE_LINE_SIZE     128
 #define GEM_L1P_PREFETCH_SIZE   128
 
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 5de50ce..1f7dd09 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -71,6 +71,12 @@
 
 #define DSP_CACHE_LINE 128
 
+#define BUFMODE_MASK	(3 << 14)
+
+/* Buffer modes from DSP perspective */
+#define RBUF		0x4000		/* Input buffer */
+#define WBUF		0x8000		/* Output Buffer */
+
 extern char *iva_img;
 
 /*  ----------------------------------- Globals */
@@ -1071,11 +1077,13 @@ dsp_status proc_map(void *hprocessor, void *pmpu_addr, u32 ul_size,
 	struct dmm_map_object *map_obj;
 
 #ifdef CONFIG_BRIDGE_CACHE_LINE_CHECK
-	if (!IS_ALIGNED((u32)pmpu_addr, DSP_CACHE_LINE) ||
-	    !IS_ALIGNED(ul_size, DSP_CACHE_LINE)) {
-		pr_err("%s: not aligned: 0x%x (%d)\n", __func__,
+	if ((ul_map_attr & BUFMODE_MASK) != RBUF) {
+		if (!IS_ALIGNED((u32)pmpu_addr, DSP_CACHE_LINE) ||
+		    !IS_ALIGNED(ul_size, DSP_CACHE_LINE)) {
+			pr_err("%s: not aligned: 0x%x (%d)\n", __func__,
 						(u32)pmpu_addr, ul_size);
-		return -EFAULT;
+			return -EFAULT;
+		}
 	}
 #endif
 
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index ed51875..0c6cf2f 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -1300,11 +1300,11 @@ static dsp_status bridge_brd_mem_map(struct wmd_dev_context *hDevContext,
 	if (ul_num_bytes == 0)
 		return DSP_EINVALIDARG;
 
-	if (ul_map_attr != 0) {
+	if (ul_map_attr & DSP_MAP_DIR_MASK) {
 		attrs = ul_map_attr;
 	} else {
 		/* Assign default attributes */
-		attrs = DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16;
+		attrs = ul_map_attr | (DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16);
 	}
 	/* Take mapping properties */
 	if (attrs & DSP_MAPBIGENDIAN)
-- 
1.7.0.4

