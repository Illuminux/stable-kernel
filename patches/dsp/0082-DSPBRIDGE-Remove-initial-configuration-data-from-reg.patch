From a4b44690274654823b8cd25adc381b574d14424b Mon Sep 17 00:00:00 2001
From: Ernesto Ramos <ernesto@ti.com>
Date: Thu, 8 Apr 2010 13:24:43 -0500
Subject: [PATCH 082/135] DSPBRIDGE: Remove initial configuration data from registry

Remove initial configuration data from registry.

Signed-off-by: Ernesto Ramos <ernesto@ti.com>
---
 arch/arm/plat-omap/include/dspbridge/dbdefs.h |    7 ----
 arch/arm/plat-omap/include/dspbridge/drv.h    |    7 ++++
 drivers/dsp/bridge/rmgr/drv.c                 |    8 ++--
 drivers/dsp/bridge/rmgr/drv_interface.c       |   43 +++++++++++-------------
 drivers/dsp/bridge/rmgr/proc.c                |    9 +++++-
 drivers/dsp/bridge/services/cfg.c             |   30 +++++++----------
 drivers/dsp/bridge/wmd/tiomap3430.c           |   26 ++++++---------
 7 files changed, 63 insertions(+), 67 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
index 61f28df..d3e115f 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -546,11 +546,4 @@ bit 15 - Output (writeable) buffer
 /* Max registry path length. Also the max registry value length. */
 #define MAXREGPATHLENGTH	255
 
-/* MiniDriver related definitions */
-#define DEFEXEC		"DefaultExecutable"	/* Default executable */
-#define AUTOSTART	"AutoStart"	/* Statically load flag */
-#define CURRENTCONFIG	"CurrentConfig"	/* Current resources */
-#define SHMSIZE		"SHMSize"	/* Size of shm reservd on MPU */
-#define TCWORDSWAP	"TCWordSwap"	/* Traffic Controller WordSwp */
-
 #endif /* DBDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
index b8d5347..0b73d63 100644
--- a/arch/arm/plat-omap/include/dspbridge/drv.h
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -122,6 +122,13 @@ enum gpp_proc_res_state {
 	PROC_RES_FREED
 };
 
+/* Bridge Data */
+struct drv_data {
+	char *base_img;
+	s32 shm_size;
+	int tc_wordswapon;
+};
+
 /* Process Context */
 struct process_context {
 	/* Process State */
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index 2dd6b60..26a9789 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -868,6 +868,7 @@ dsp_status drv_request_bridge_res_dsp(void **phost_resources)
 	u32 dw_buff_size;
 	u32 dma_addr;
 	u32 shm_size;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	dw_buff_size = sizeof(struct cfg_hostres);
 
@@ -905,10 +906,9 @@ dsp_status drv_request_bridge_res_dsp(void **phost_resources)
 		dev_dbg(bridge, "dw_mem_base[4] 0x%x\n",
 			host_res->dw_mem_base[4]);
 		dev_dbg(bridge, "dw_dmmu_base %p\n", host_res->dw_dmmu_base);
-		dw_buff_size = sizeof(shm_size);
-		status =
-		    reg_get_value(SHMSIZE, (u8 *) &shm_size, &dw_buff_size);
-		if (DSP_SUCCEEDED(status)) {
+
+		shm_size = drv_datap->shm_size;
+		if (shm_size >= 0x10000) {
 			/* Allocate Physically contiguous,
 			 * non-cacheable  memory */
 			host_res->dw_mem_base[1] =
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.c b/drivers/dsp/bridge/rmgr/drv_interface.c
index bd98605..58d3275 100644
--- a/drivers/dsp/bridge/rmgr/drv_interface.c
+++ b/drivers/dsp/bridge/rmgr/drv_interface.c
@@ -238,14 +238,14 @@ static struct notifier_block iva_clk_notifier = {
 static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 {
 	int status;
-	u32 init_status;
-	u32 temp;
+	u32 init_status = DSP_SOK;
 	dev_t dev = 0;
 	int result;
 #ifdef CONFIG_BRIDGE_DVFS
 	int i = 0;
 #endif
 	struct dspbridge_platform_data *pdata = pdev->dev.platform_data;
+	struct drv_data *drv_datap = NULL;
 
 	omap_dspbridge_dev = pdev;
 
@@ -291,21 +291,23 @@ static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 
 	/*  Autostart flag.  This should be set to true if the DSP image should
 	 *  be loaded and run during bridge module initialization */
-
-	if (base_img) {
-		temp = true;
-		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
-		reg_set_value(DEFEXEC, (u8 *) base_img, strlen(base_img) + 1);
+	drv_datap = mem_calloc(sizeof(struct drv_data), MEM_PAGED);
+	if (drv_datap) {
+		drv_datap->shm_size = shm_size;
+		drv_datap->tc_wordswapon = tc_wordswapon;
+		if (base_img) {
+			drv_datap->base_img = kmalloc(strlen(base_img) + 1,
+								GFP_KERNEL);
+			if (drv_datap->base_img)
+				strncpy(drv_datap->base_img, base_img,
+							strlen(base_img) + 1);
+			else
+				status = -ENOMEM;
+		}
 	} else {
-		temp = false;
-		reg_set_value(AUTOSTART, (u8 *) &temp, sizeof(temp));
-		reg_set_value(DEFEXEC, (u8 *) "\0", (u32) 2);
+		init_status = -ENOMEM;
 	}
-
-	if (shm_size >= 0x10000) {	/* 64 KB */
-		init_status = reg_set_value(SHMSIZE, (u8 *) &shm_size,
-					    sizeof(shm_size));
-	} else {
+	if (shm_size < 0x10000) {	/* 64 KB */
 		init_status = -EINVAL;
 		status = -1;
 		pr_err("%s: shm size must be at least 64 KB\n", __func__);
@@ -315,15 +317,9 @@ static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 	if ((pdata->phys_mempool_base > 0) && (pdata->phys_mempool_size > 0))
 		mem_ext_phys_pool_init(pdata->phys_mempool_base,
 						pdata->phys_mempool_size);
-	if (tc_wordswapon) {
+	if (tc_wordswapon)
 		dev_dbg(bridge, "%s: TC Word Swap is enabled\n", __func__);
-		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
-			      sizeof(tc_wordswapon));
-	} else {
-		dev_dbg(bridge, "%s: TC Word Swap is disabled\n", __func__);
-		reg_set_value(TCWORDSWAP, (u8 *) &tc_wordswapon,
-			      sizeof(tc_wordswapon));
-	}
+
 	if (DSP_SUCCEEDED(init_status)) {
 #ifdef CONFIG_BRIDGE_DVFS
 		for (i = 0; i < 6; i++)
@@ -338,6 +334,7 @@ static int __devinit omap34_xx_bridge_probe(struct platform_device *pdev)
 			pr_err("%s: clk_notifier_register failed for iva2_ck\n",
 			       __func__);
 #endif
+		dev_set_drvdata(bridge, drv_datap);
 		driver_context = dsp_init(&init_status);
 		if (DSP_FAILED(init_status)) {
 			status = -1;
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index 11a56ab..b2f031c 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -824,6 +824,7 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 	u32 dw_ext_end;
 	u32 proc_id;
 	int brd_state;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 #ifdef OPT_LOAD_TIME_INSTRUMENTATION
 	struct timeval tv1;
@@ -1034,8 +1035,14 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 		if (DSP_SUCCEEDED((*p_proc_object->intf_fxns->pfn_brd_status)
 				  (p_proc_object->hwmd_context, &brd_state))) {
 			pr_info("%s: Processor Loaded %s\n", __func__, pargv0);
-			reg_set_value(DEFEXEC, (u8 *)pargv0,
+			kfree(drv_datap->base_img);
+			drv_datap->base_img = kmalloc(strlen(pargv0) + 1,
+								GFP_KERNEL);
+			if (drv_datap->base_img)
+				strncpy(drv_datap->base_img, pargv0,
 							strlen(pargv0) + 1);
+			else
+				status = -ENOMEM;
 			DBC_ASSERT(brd_state == BRD_LOADED);
 		}
 	}
diff --git a/drivers/dsp/bridge/services/cfg.c b/drivers/dsp/bridge/services/cfg.c
index fc54ff7..7426fd9 100644
--- a/drivers/dsp/bridge/services/cfg.c
+++ b/drivers/dsp/bridge/services/cfg.c
@@ -29,6 +29,7 @@
 
 /*  ----------------------------------- This */
 #include <dspbridge/cfg.h>
+#include <dspbridge/drv.h>
 
 struct drv_ext {
 	struct list_head link;
@@ -55,18 +56,15 @@ dsp_status cfg_get_auto_start(struct cfg_devnode *dev_node_obj,
 {
 	dsp_status status = DSP_SOK;
 	u32 dw_buf_size;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	dw_buf_size = sizeof(*pdwAutoStart);
 	if (!dev_node_obj)
 		status = -EFAULT;
-	if (!pdwAutoStart)
+	if (!pdwAutoStart || !drv_datap)
 		status = -EFAULT;
-	if (DSP_SUCCEEDED(status)) {
-		status = reg_get_value(AUTOSTART, (u8 *) pdwAutoStart,
-				       &dw_buf_size);
-		if (DSP_FAILED(status))
-			status = -ENODATA;
-	}
+	if (DSP_SUCCEEDED(status))
+		*pdwAutoStart = (drv_datap->base_img) ? 1 : 0;
 
 	DBC_ENSURE((status == DSP_SOK &&
 		    (*pdwAutoStart == 0 || *pdwAutoStart == 1))
@@ -117,22 +115,20 @@ dsp_status cfg_get_exec_file(struct cfg_devnode *dev_node_obj, u32 ul_buf_size,
 			     OUT char *pstrExecFile)
 {
 	dsp_status status = DSP_SOK;
-	u32 exec_size = ul_buf_size;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	if (!dev_node_obj)
 		status = -EFAULT;
-	else if (!pstrExecFile)
+
+	else if (!pstrExecFile || !drv_datap)
 		status = -EFAULT;
 
-	if (DSP_SUCCEEDED(status)) {
-		status =
-		    reg_get_value(DEFEXEC, (u8 *) pstrExecFile, &exec_size);
-		if (DSP_FAILED(status))
-			status = -ENODATA;
-		else if (exec_size > ul_buf_size)
-			status = -EINVAL;
+	if (strlen(drv_datap->base_img) > ul_buf_size)
+		status = -EINVAL;
+
+	if (DSP_SUCCEEDED(status) && drv_datap->base_img)
+		strcpy(pstrExecFile, drv_datap->base_img);
 
-	}
 	if (DSP_FAILED(status))
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	DBC_ENSURE(((status == DSP_SOK) &&
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 1d6081b..5235018 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -877,13 +877,12 @@ static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
 	dsp_status status = DSP_SOK;
 	struct wmd_dev_context *dev_context = NULL;
 	s32 entry_ndx;
-	s32 tc_word_swap;
-	u32 tc_word_swap_size = sizeof(tc_word_swap);
 	struct cfg_hostres *resources = pConfig;
 	struct pg_table_attrs *pt_attrs;
 	u32 pg_tbl_pa;
 	u32 pg_tbl_va;
 	u32 align_size;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	/* Allocate and initialize a data structure to contain the mini driver
 	 *  state, which becomes the context for later calls into this WMD. */
@@ -997,14 +996,10 @@ static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
 
 	if (DSP_SUCCEEDED(status)) {
 		spin_lock_init(&pt_attrs->pg_lock);
-		/* Set the Endianism Register *//* Need to set this */
-		/* Retrieve the TC u16 SWAP Option */
-		status = reg_get_value(TCWORDSWAP, (u8 *) &tc_word_swap,
-				       &tc_word_swap_size);
-		/* Save the value */
-		dev_context->tc_word_swap_on = tc_word_swap;
-	}
-	if (DSP_SUCCEEDED(status)) {
+		dev_context->tc_word_swap_on = drv_datap->tc_wordswapon;
+
+		/* Set the Clock Divisor for the DSP module */
+		udelay(5);
 		/* 24xx-Linux MMU address is obtained from the host
 		 * resources struct */
 		dev_context->dw_dsp_mmu_base = resources->dw_dmmu_base;
@@ -1106,8 +1101,8 @@ static dsp_status bridge_dev_destroy(struct wmd_dev_context *hDevContext)
 	struct wmd_dev_context *dev_context = (struct wmd_dev_context *)
 	    hDevContext;
 	struct cfg_hostres *host_res;
-	u32 dw_buff_size;
 	u32 shm_size;
+	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	/* It should never happen */
 	if (!hDevContext)
@@ -1135,10 +1130,8 @@ static dsp_status bridge_dev_destroy(struct wmd_dev_context *hDevContext)
 
 	if (dev_context->resources) {
 		host_res = dev_context->resources;
-		dw_buff_size = sizeof(shm_size);
-		status = reg_get_value(SHMSIZE, (u8 *) &shm_size,
-					       &dw_buff_size);
-		if (DSP_SUCCEEDED(status)) {
+		shm_size = drv_datap->shm_size;
+		if (shm_size >= 0x10000) {
 			if ((host_res->dw_mem_base[1]) &&
 			    (host_res->dw_mem_phys[1])) {
 				mem_free_phys_mem((void *)
@@ -1186,6 +1179,9 @@ static dsp_status bridge_dev_destroy(struct wmd_dev_context *hDevContext)
 	}
 
 	/* Free the driver's device context: */
+	kfree(drv_datap->base_img);
+	kfree(drv_datap);
+	dev_set_drvdata(bridge, NULL);
 	kfree((void *)hDevContext);
 	return status;
 }
-- 
1.7.0.4

