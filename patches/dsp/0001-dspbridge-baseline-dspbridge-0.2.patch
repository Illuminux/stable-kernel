From 1cd3839aa13774844bb5dd297e33bc986673574c Mon Sep 17 00:00:00 2001
From: Omar Ramirez Luna <omar.ramirez@ti.com>
Date: Thu, 20 May 2010 17:11:21 -0500
Subject: [PATCH 001/135] dspbridge: baseline dspbridge 0.2

Use dspbridge 0.2 as the baseline instead of rebasing all the
patches.

Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
---
 arch/arm/mach-omap2/dspbridge.c                    |   76 +
 arch/arm/plat-omap/include/dspbridge/_chnl_sm.h    |  178 ++
 arch/arm/plat-omap/include/dspbridge/_dcd.h        |  175 ++
 arch/arm/plat-omap/include/dspbridge/brddefs.h     |   39 +
 arch/arm/plat-omap/include/dspbridge/cfg.h         |  293 ++
 arch/arm/plat-omap/include/dspbridge/cfgdefs.h     |   93 +
 arch/arm/plat-omap/include/dspbridge/chnl.h        |  135 +
 arch/arm/plat-omap/include/dspbridge/chnl_sm.h     |  154 +
 arch/arm/plat-omap/include/dspbridge/chnldefs.h    |   68 +
 arch/arm/plat-omap/include/dspbridge/chnlpriv.h    |  109 +
 arch/arm/plat-omap/include/dspbridge/clk.h         |  148 +
 arch/arm/plat-omap/include/dspbridge/cmm.h         |  386 +++
 arch/arm/plat-omap/include/dspbridge/cmmdefs.h     |  105 +
 arch/arm/plat-omap/include/dspbridge/cod.h         |  383 +++
 arch/arm/plat-omap/include/dspbridge/dbc.h         |   46 +
 arch/arm/plat-omap/include/dspbridge/dbdcd.h       |  366 +++
 arch/arm/plat-omap/include/dspbridge/dbdcddef.h    |   71 +
 arch/arm/plat-omap/include/dspbridge/dbdefs.h      |  550 ++++
 arch/arm/plat-omap/include/dspbridge/dbldefs.h     |  145 +
 arch/arm/plat-omap/include/dspbridge/dbll.h        |   61 +
 arch/arm/plat-omap/include/dspbridge/dblldefs.h    |  498 ++++
 arch/arm/plat-omap/include/dspbridge/dbtype.h      |   90 +
 arch/arm/plat-omap/include/dspbridge/dehdefs.h     |   32 +
 arch/arm/plat-omap/include/dspbridge/dev.h         |  725 +++++
 arch/arm/plat-omap/include/dspbridge/devdefs.h     |   26 +
 arch/arm/plat-omap/include/dspbridge/disp.h        |  209 ++
 arch/arm/plat-omap/include/dspbridge/dispdefs.h    |   35 +
 arch/arm/plat-omap/include/dspbridge/dmm.h         |   72 +
 arch/arm/plat-omap/include/dspbridge/drv.h         |  396 +++
 arch/arm/plat-omap/include/dspbridge/drvdefs.h     |   25 +
 arch/arm/plat-omap/include/dspbridge/dspdrv.h      |   62 +
 .../plat-omap/include/dspbridge/dynamic_loader.h   |  505 ++++
 arch/arm/plat-omap/include/dspbridge/errbase.h     |  446 +++
 arch/arm/plat-omap/include/dspbridge/gb.h          |   79 +
 arch/arm/plat-omap/include/dspbridge/getsection.h  |  113 +
 arch/arm/plat-omap/include/dspbridge/gh.h          |   29 +
 arch/arm/plat-omap/include/dspbridge/gs.h          |   59 +
 arch/arm/plat-omap/include/dspbridge/host_os.h     |   81 +
 arch/arm/plat-omap/include/dspbridge/io.h          |  115 +
 arch/arm/plat-omap/include/dspbridge/io_sm.h       |  302 ++
 arch/arm/plat-omap/include/dspbridge/iodefs.h      |   36 +
 arch/arm/plat-omap/include/dspbridge/ldr.h         |   29 +
 arch/arm/plat-omap/include/dspbridge/list.h        |  224 ++
 arch/arm/plat-omap/include/dspbridge/mbx_sh.h      |  198 ++
 arch/arm/plat-omap/include/dspbridge/mem.h         |  282 ++
 arch/arm/plat-omap/include/dspbridge/memdefs.h     |   37 +
 arch/arm/plat-omap/include/dspbridge/mgr.h         |  206 ++
 arch/arm/plat-omap/include/dspbridge/mgrpriv.h     |   45 +
 arch/arm/plat-omap/include/dspbridge/msg.h         |   86 +
 arch/arm/plat-omap/include/dspbridge/msgdefs.h     |   32 +
 arch/arm/plat-omap/include/dspbridge/nldr.h        |   55 +
 arch/arm/plat-omap/include/dspbridge/nldrdefs.h    |  296 ++
 arch/arm/plat-omap/include/dspbridge/node.h        |  578 ++++
 arch/arm/plat-omap/include/dspbridge/nodedefs.h    |   28 +
 arch/arm/plat-omap/include/dspbridge/nodepriv.h    |  183 ++
 arch/arm/plat-omap/include/dspbridge/ntfy.h        |  128 +
 arch/arm/plat-omap/include/dspbridge/proc.h        |  608 ++++
 arch/arm/plat-omap/include/dspbridge/procpriv.h    |   26 +
 arch/arm/plat-omap/include/dspbridge/pwr.h         |  110 +
 arch/arm/plat-omap/include/dspbridge/pwr_sh.h      |   33 +
 arch/arm/plat-omap/include/dspbridge/reg.h         |  150 +
 .../plat-omap/include/dspbridge/resourcecleanup.h  |   64 +
 arch/arm/plat-omap/include/dspbridge/rmm.h         |  181 ++
 arch/arm/plat-omap/include/dspbridge/rms_sh.h      |   97 +
 arch/arm/plat-omap/include/dspbridge/rmstypes.h    |   29 +
 arch/arm/plat-omap/include/dspbridge/services.h    |   50 +
 arch/arm/plat-omap/include/dspbridge/std.h         |   95 +
 arch/arm/plat-omap/include/dspbridge/strm.h        |  409 +++
 arch/arm/plat-omap/include/dspbridge/strmdefs.h    |   47 +
 arch/arm/plat-omap/include/dspbridge/sync.h        |  304 ++
 arch/arm/plat-omap/include/dspbridge/utildefs.h    |   39 +
 arch/arm/plat-omap/include/dspbridge/uuidutil.h    |   62 +
 arch/arm/plat-omap/include/dspbridge/wcd.h         |   36 +
 arch/arm/plat-omap/include/dspbridge/wcdioctl.h    |  496 +++
 arch/arm/plat-omap/include/dspbridge/wmd.h         | 1160 +++++++
 arch/arm/plat-omap/include/dspbridge/wmdchnl.h     |   75 +
 arch/arm/plat-omap/include/dspbridge/wmddeh.h      |   48 +
 arch/arm/plat-omap/include/dspbridge/wmdio.h       |   41 +
 arch/arm/plat-omap/include/dspbridge/wmdioctl.h    |   69 +
 arch/arm/plat-omap/include/dspbridge/wmdmsg.h      |   57 +
 drivers/dsp/bridge/Kconfig                         |   47 +
 drivers/dsp/bridge/Makefile                        |   34 +
 drivers/dsp/bridge/dynload/cload.c                 | 1925 ++++++++++++
 drivers/dsp/bridge/dynload/dload_internal.h        |  356 +++
 drivers/dsp/bridge/dynload/doff.h                  |  344 +++
 drivers/dsp/bridge/dynload/getsection.c            |  412 +++
 drivers/dsp/bridge/dynload/header.h                |   59 +
 drivers/dsp/bridge/dynload/module_list.h           |  155 +
 drivers/dsp/bridge/dynload/params.h                |  226 ++
 drivers/dsp/bridge/dynload/reloc.c                 |  477 +++
 drivers/dsp/bridge/dynload/reloc_table.h           |  102 +
 drivers/dsp/bridge/dynload/reloc_table_c6000.c     |  258 ++
 drivers/dsp/bridge/dynload/tramp.c                 | 1118 +++++++
 drivers/dsp/bridge/dynload/tramp_table_c6000.c     |  172 ++
 drivers/dsp/bridge/gen/gb.c                        |  169 ++
 drivers/dsp/bridge/gen/gh.c                        |  186 ++
 drivers/dsp/bridge/gen/gs.c                        |   89 +
 drivers/dsp/bridge/gen/uuidutil.c                  |  222 ++
 drivers/dsp/bridge/hw/EasiGlobal.h                 |   42 +
 drivers/dsp/bridge/hw/GlobalTypes.h                |  317 ++
 drivers/dsp/bridge/hw/IPIAccInt.h                  |   26 +
 drivers/dsp/bridge/hw/IVA2RegAcM.h                 |   28 +
 drivers/dsp/bridge/hw/MLBAccInt.h                  |  132 +
 drivers/dsp/bridge/hw/MLBRegAcM.h                  |  201 ++
 drivers/dsp/bridge/hw/MMUAccInt.h                  |   76 +
 drivers/dsp/bridge/hw/MMURegAcM.h                  |  253 ++
 drivers/dsp/bridge/hw/PRCMAccInt.h                 |  300 ++
 drivers/dsp/bridge/hw/PRCMRegAcM.h                 |  670 +++++
 drivers/dsp/bridge/hw/hw_defs.h                    |   62 +
 drivers/dsp/bridge/hw/hw_dspssC64P.c               |   47 +
 drivers/dsp/bridge/hw/hw_dspssC64P.h               |   37 +
 drivers/dsp/bridge/hw/hw_mbox.c                    |  248 ++
 drivers/dsp/bridge/hw/hw_mbox.h                    |  326 ++
 drivers/dsp/bridge/hw/hw_mmu.c                     |  585 ++++
 drivers/dsp/bridge/hw/hw_mmu.h                     |  165 +
 drivers/dsp/bridge/hw/hw_prcm.c                    |  157 +
 drivers/dsp/bridge/hw/hw_prcm.h                    |  161 +
 drivers/dsp/bridge/pmgr/chnl.c                     |  170 ++
 drivers/dsp/bridge/pmgr/chnlobj.h                  |   56 +
 drivers/dsp/bridge/pmgr/cmm.c                      | 1155 +++++++
 drivers/dsp/bridge/pmgr/cod.c                      |  660 ++++
 drivers/dsp/bridge/pmgr/dbll.c                     | 1481 +++++++++
 drivers/dsp/bridge/pmgr/dev.c                      | 1203 ++++++++
 drivers/dsp/bridge/pmgr/dmm.c                      |  560 ++++
 drivers/dsp/bridge/pmgr/io.c                       |  144 +
 drivers/dsp/bridge/pmgr/ioobj.h                    |   39 +
 drivers/dsp/bridge/pmgr/msg.c                      |  133 +
 drivers/dsp/bridge/pmgr/msgobj.h                   |   39 +
 drivers/dsp/bridge/pmgr/wcd.c                      | 1645 ++++++++++
 drivers/dsp/bridge/rmgr/dbdcd.c                    | 1377 +++++++++
 drivers/dsp/bridge/rmgr/disp.c                     |  738 +++++
 drivers/dsp/bridge/rmgr/drv.c                      | 1086 +++++++
 drivers/dsp/bridge/rmgr/drv_interface.c            |  573 ++++
 drivers/dsp/bridge/rmgr/drv_interface.h            |   28 +
 drivers/dsp/bridge/rmgr/dspdrv.c                   |  144 +
 drivers/dsp/bridge/rmgr/mgr.c                      |  389 +++
 drivers/dsp/bridge/rmgr/nldr.c                     | 1844 ++++++++++++
 drivers/dsp/bridge/rmgr/node.c                     | 3148 ++++++++++++++++++++
 drivers/dsp/bridge/rmgr/proc.c                     | 1638 ++++++++++
 drivers/dsp/bridge/rmgr/pwr.c                      |  169 ++
 drivers/dsp/bridge/rmgr/rmm.c                      |  537 ++++
 drivers/dsp/bridge/rmgr/strm.c                     |  854 ++++++
 drivers/dsp/bridge/services/cfg.c                  |  309 ++
 drivers/dsp/bridge/services/clk.c                  |  328 ++
 drivers/dsp/bridge/services/mem.c                  |  267 ++
 drivers/dsp/bridge/services/ntfy.c                 |  296 ++
 drivers/dsp/bridge/services/reg.c                  |  143 +
 drivers/dsp/bridge/services/regsup.c               |  246 ++
 drivers/dsp/bridge/services/regsup.h               |   47 +
 drivers/dsp/bridge/services/services.c             |  100 +
 drivers/dsp/bridge/services/sync.c                 |  453 +++
 drivers/dsp/bridge/wmd/_cmm.h                      |   45 +
 drivers/dsp/bridge/wmd/_deh.h                      |   38 +
 drivers/dsp/bridge/wmd/_msg_sm.h                   |  143 +
 drivers/dsp/bridge/wmd/_tiomap.h                   |  360 +++
 drivers/dsp/bridge/wmd/_tiomap_mmu.h               |   41 +
 drivers/dsp/bridge/wmd/_tiomap_pwr.h               |   93 +
 drivers/dsp/bridge/wmd/_tiomap_util.h              |   43 +
 drivers/dsp/bridge/wmd/chnl_sm.c                   |  982 ++++++
 drivers/dsp/bridge/wmd/io_sm.c                     | 2002 +++++++++++++
 drivers/dsp/bridge/wmd/mmu_fault.c                 |  142 +
 drivers/dsp/bridge/wmd/mmu_fault.h                 |   35 +
 drivers/dsp/bridge/wmd/msg_sm.c                    |  653 ++++
 drivers/dsp/bridge/wmd/tiomap3430.c                | 1916 ++++++++++++
 drivers/dsp/bridge/wmd/tiomap3430_pwr.c            |  715 +++++
 drivers/dsp/bridge/wmd/tiomap_io.c                 |  373 +++
 drivers/dsp/bridge/wmd/tiomap_io.h                 |  102 +
 drivers/dsp/bridge/wmd/tiomap_sm.c                 |  184 ++
 drivers/dsp/bridge/wmd/ue_deh.c                    |  319 ++
 169 files changed, 54578 insertions(+), 0 deletions(-)
 create mode 100644 arch/arm/mach-omap2/dspbridge.c
 create mode 100644 arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/_dcd.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/brddefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/cfg.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/cfgdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/chnl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/chnl_sm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/chnldefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/chnlpriv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/clk.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/cmm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/cmmdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/cod.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbc.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbdcd.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbdcddef.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbldefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbll.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dblldefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dbtype.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dehdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dev.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/devdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/disp.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dispdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dmm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/drv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/drvdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dspdrv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/errbase.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/gb.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/getsection.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/gh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/gs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/host_os.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/io.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/io_sm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/iodefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/ldr.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/list.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/mbx_sh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/mem.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/memdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/mgr.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/mgrpriv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/msg.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/msgdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/nldr.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/nldrdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/node.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/nodedefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/nodepriv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/ntfy.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/proc.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/procpriv.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/pwr.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/pwr_sh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/reg.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/rmm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/rms_sh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/rmstypes.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/services.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/std.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/strm.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/strmdefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/sync.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/utildefs.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/uuidutil.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wcd.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wcdioctl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmd.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmdchnl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmddeh.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmdio.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmdioctl.h
 create mode 100644 arch/arm/plat-omap/include/dspbridge/wmdmsg.h
 create mode 100644 drivers/dsp/bridge/Kconfig
 create mode 100644 drivers/dsp/bridge/Makefile
 create mode 100644 drivers/dsp/bridge/dynload/cload.c
 create mode 100644 drivers/dsp/bridge/dynload/dload_internal.h
 create mode 100644 drivers/dsp/bridge/dynload/doff.h
 create mode 100644 drivers/dsp/bridge/dynload/getsection.c
 create mode 100644 drivers/dsp/bridge/dynload/header.h
 create mode 100644 drivers/dsp/bridge/dynload/module_list.h
 create mode 100644 drivers/dsp/bridge/dynload/params.h
 create mode 100644 drivers/dsp/bridge/dynload/reloc.c
 create mode 100644 drivers/dsp/bridge/dynload/reloc_table.h
 create mode 100644 drivers/dsp/bridge/dynload/reloc_table_c6000.c
 create mode 100644 drivers/dsp/bridge/dynload/tramp.c
 create mode 100644 drivers/dsp/bridge/dynload/tramp_table_c6000.c
 create mode 100644 drivers/dsp/bridge/gen/gb.c
 create mode 100644 drivers/dsp/bridge/gen/gh.c
 create mode 100644 drivers/dsp/bridge/gen/gs.c
 create mode 100644 drivers/dsp/bridge/gen/uuidutil.c
 create mode 100644 drivers/dsp/bridge/hw/EasiGlobal.h
 create mode 100644 drivers/dsp/bridge/hw/GlobalTypes.h
 create mode 100644 drivers/dsp/bridge/hw/IPIAccInt.h
 create mode 100644 drivers/dsp/bridge/hw/IVA2RegAcM.h
 create mode 100644 drivers/dsp/bridge/hw/MLBAccInt.h
 create mode 100644 drivers/dsp/bridge/hw/MLBRegAcM.h
 create mode 100644 drivers/dsp/bridge/hw/MMUAccInt.h
 create mode 100644 drivers/dsp/bridge/hw/MMURegAcM.h
 create mode 100644 drivers/dsp/bridge/hw/PRCMAccInt.h
 create mode 100644 drivers/dsp/bridge/hw/PRCMRegAcM.h
 create mode 100644 drivers/dsp/bridge/hw/hw_defs.h
 create mode 100644 drivers/dsp/bridge/hw/hw_dspssC64P.c
 create mode 100644 drivers/dsp/bridge/hw/hw_dspssC64P.h
 create mode 100644 drivers/dsp/bridge/hw/hw_mbox.c
 create mode 100644 drivers/dsp/bridge/hw/hw_mbox.h
 create mode 100644 drivers/dsp/bridge/hw/hw_mmu.c
 create mode 100644 drivers/dsp/bridge/hw/hw_mmu.h
 create mode 100644 drivers/dsp/bridge/hw/hw_prcm.c
 create mode 100644 drivers/dsp/bridge/hw/hw_prcm.h
 create mode 100644 drivers/dsp/bridge/pmgr/chnl.c
 create mode 100644 drivers/dsp/bridge/pmgr/chnlobj.h
 create mode 100644 drivers/dsp/bridge/pmgr/cmm.c
 create mode 100644 drivers/dsp/bridge/pmgr/cod.c
 create mode 100644 drivers/dsp/bridge/pmgr/dbll.c
 create mode 100644 drivers/dsp/bridge/pmgr/dev.c
 create mode 100644 drivers/dsp/bridge/pmgr/dmm.c
 create mode 100644 drivers/dsp/bridge/pmgr/io.c
 create mode 100644 drivers/dsp/bridge/pmgr/ioobj.h
 create mode 100644 drivers/dsp/bridge/pmgr/msg.c
 create mode 100644 drivers/dsp/bridge/pmgr/msgobj.h
 create mode 100644 drivers/dsp/bridge/pmgr/wcd.c
 create mode 100644 drivers/dsp/bridge/rmgr/dbdcd.c
 create mode 100644 drivers/dsp/bridge/rmgr/disp.c
 create mode 100644 drivers/dsp/bridge/rmgr/drv.c
 create mode 100644 drivers/dsp/bridge/rmgr/drv_interface.c
 create mode 100644 drivers/dsp/bridge/rmgr/drv_interface.h
 create mode 100644 drivers/dsp/bridge/rmgr/dspdrv.c
 create mode 100644 drivers/dsp/bridge/rmgr/mgr.c
 create mode 100644 drivers/dsp/bridge/rmgr/nldr.c
 create mode 100644 drivers/dsp/bridge/rmgr/node.c
 create mode 100644 drivers/dsp/bridge/rmgr/proc.c
 create mode 100644 drivers/dsp/bridge/rmgr/pwr.c
 create mode 100644 drivers/dsp/bridge/rmgr/rmm.c
 create mode 100644 drivers/dsp/bridge/rmgr/strm.c
 create mode 100644 drivers/dsp/bridge/services/cfg.c
 create mode 100644 drivers/dsp/bridge/services/clk.c
 create mode 100644 drivers/dsp/bridge/services/mem.c
 create mode 100644 drivers/dsp/bridge/services/ntfy.c
 create mode 100644 drivers/dsp/bridge/services/reg.c
 create mode 100644 drivers/dsp/bridge/services/regsup.c
 create mode 100644 drivers/dsp/bridge/services/regsup.h
 create mode 100644 drivers/dsp/bridge/services/services.c
 create mode 100644 drivers/dsp/bridge/services/sync.c
 create mode 100644 drivers/dsp/bridge/wmd/_cmm.h
 create mode 100644 drivers/dsp/bridge/wmd/_deh.h
 create mode 100644 drivers/dsp/bridge/wmd/_msg_sm.h
 create mode 100644 drivers/dsp/bridge/wmd/_tiomap.h
 create mode 100644 drivers/dsp/bridge/wmd/_tiomap_mmu.h
 create mode 100644 drivers/dsp/bridge/wmd/_tiomap_pwr.h
 create mode 100644 drivers/dsp/bridge/wmd/_tiomap_util.h
 create mode 100644 drivers/dsp/bridge/wmd/chnl_sm.c
 create mode 100644 drivers/dsp/bridge/wmd/io_sm.c
 create mode 100644 drivers/dsp/bridge/wmd/mmu_fault.c
 create mode 100644 drivers/dsp/bridge/wmd/mmu_fault.h
 create mode 100644 drivers/dsp/bridge/wmd/msg_sm.c
 create mode 100644 drivers/dsp/bridge/wmd/tiomap3430.c
 create mode 100644 drivers/dsp/bridge/wmd/tiomap3430_pwr.c
 create mode 100644 drivers/dsp/bridge/wmd/tiomap_io.c
 create mode 100644 drivers/dsp/bridge/wmd/tiomap_io.h
 create mode 100644 drivers/dsp/bridge/wmd/tiomap_sm.c
 create mode 100644 drivers/dsp/bridge/wmd/ue_deh.c

diff --git a/arch/arm/mach-omap2/dspbridge.c b/arch/arm/mach-omap2/dspbridge.c
new file mode 100644
index 0000000..ea109a3
--- /dev/null
+++ b/arch/arm/mach-omap2/dspbridge.c
@@ -0,0 +1,76 @@
+/*
+ * TI's dspbridge platform device registration
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ * Copyright (C) 2009 Nokia Corporation
+ *
+ * Written by Hiroshi DOYU <Hiroshi.DOYU@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_BRIDGE_DVFS
+#include <mach/omap-pm.h>
+#endif
+
+#include <dspbridge/host_os.h>
+
+static struct platform_device *dspbridge_pdev;
+
+static struct dspbridge_platform_data dspbridge_pdata __initdata = {
+#ifdef CONFIG_BRIDGE_DVFS
+	.dsp_set_min_opp = omap_pm_dsp_set_min_opp,
+	.dsp_get_opp	 = omap_pm_dsp_get_opp,
+	.cpu_set_freq	 = omap_pm_cpu_set_freq,
+	.cpu_get_freq	 = omap_pm_cpu_get_freq,
+#endif
+};
+
+static int __init dspbridge_init(void)
+{
+	struct platform_device *pdev;
+	int err = -ENOMEM;
+	struct dspbridge_platform_data *pdata = &dspbridge_pdata;
+
+	pdata->phys_mempool_base = dspbridge_get_mempool_base();
+
+	if (pdata->phys_mempool_base) {
+		pdata->phys_mempool_size = CONFIG_BRIDGE_MEMPOOL_SIZE;
+		pr_info("%s: %x bytes @ %x\n", __func__,
+			pdata->phys_mempool_size, pdata->phys_mempool_base);
+	}
+
+	pdev = platform_device_alloc("C6410", -1);
+	if (!pdev)
+		goto err_out;
+
+	err = platform_device_add_data(pdev, pdata, sizeof(*pdata));
+	if (err)
+		goto err_out;
+
+	err = platform_device_add(pdev);
+	if (err)
+		goto err_out;
+
+	dspbridge_pdev = pdev;
+	return 0;
+
+err_out:
+	platform_device_put(pdev);
+	return err;
+}
+module_init(dspbridge_init);
+
+static void __exit dspbridge_exit(void)
+{
+	platform_device_unregister(dspbridge_pdev);
+}
+module_exit(dspbridge_exit);
+
+MODULE_AUTHOR("Hiroshi DOYU");
+MODULE_DESCRIPTION("TI's dspbridge platform device registration");
+MODULE_LICENSE("GPL v2");
diff --git a/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
new file mode 100644
index 0000000..b142ede
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/_chnl_sm.h
@@ -0,0 +1,178 @@
+/*
+ * _chnl_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private header file defining channel manager and channel objects for
+ * a shared memory channel driver.
+ *
+ * Shared between the modules implementing the shared memory channel class
+ * library.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _CHNL_SM_
+#define _CHNL_SM_
+
+#include <dspbridge/wcd.h>
+#include <dspbridge/wmd.h>
+
+#include <dspbridge/list.h>
+#include <dspbridge/ntfy.h>
+
+/*
+ *  These target side symbols define the beginning and ending addresses
+ *  of shared memory buffer. They are defined in the *cfg.cmd file by
+ *  cdb code.
+ */
+#define CHNL_SHARED_BUFFER_BASE_SYM "_SHM_BEG"
+#define CHNL_SHARED_BUFFER_LIMIT_SYM "_SHM_END"
+#define BRIDGEINIT_BIOSGPTIMER "_BRIDGEINIT_BIOSGPTIMER"
+#define BRIDGEINIT_LOADMON_GPTIMER "_BRIDGEINIT_LOADMON_GPTIMER"
+
+#ifndef _CHNL_WORDSIZE
+#define _CHNL_WORDSIZE 4	/* default _CHNL_WORDSIZE is 2 bytes/word */
+#endif
+
+#define MAXOPPS 16
+
+/* Shared memory config options */
+#define SHM_CURROPP	0	/* Set current OPP in SHM */
+#define SHM_OPPINFO	1	/* Set dsp voltage and freq table values */
+#define SHM_GETOPP	2	/* Get opp requested by DSP */
+
+struct oppTableEntry {
+    u32 voltage;
+    u32 frequency;
+    u32 minFreq;
+    u32 maxFreq;
+} ;
+
+struct oppStruct {
+    u32 currOppPt;
+    u32 numOppPts;
+    struct oppTableEntry oppPoint[MAXOPPS];
+} ;
+
+/* Request to MPU */
+struct oppRqstStruct {
+    u32 rqstDspFreq;
+    u32 rqstOppPt;
+};
+
+/* Info to MPU */
+struct loadMonStruct {
+    u32 currDspLoad;
+    u32 currDspFreq;
+    u32 predDspLoad;
+    u32 predDspFreq;
+};
+
+/* Structure in shared between DSP and PC for communication.*/
+	struct SHM {
+		u32 dspFreeMask;	/* Written by DSP, read by PC. */
+		u32 hostFreeMask;	/* Written by PC, read by DSP */
+
+		u32 inputFull;	/* Input channel has unread data. */
+		u32 inputId;	/* Channel for which input is available. */
+		u32 inputSize;	/* Size of data block (in DSP words). */
+
+		u32 outputFull;	/* Output channel has unread data. */
+		u32 outputId;	/* Channel for which output is available. */
+		u32 outputSize;	/* Size of data block (in DSP words). */
+
+		u32 arg;	/* Arg for Issue/Reclaim (23 bits for 55x). */
+		u32 resvd;	/* Keep structure size even for 32-bit DSPs */
+
+		/* Operating Point structure */
+		struct oppStruct  oppTableStruct;
+		/* Operating Point Request structure */
+		struct oppRqstStruct oppRequest;
+		/* load monitor information structure*/
+		struct loadMonStruct loadMonInfo;
+		char dummy[184];             /* padding to 256 byte boundary */
+		u32 shm_dbg_var[64];         /* shared memory debug variables */
+	} ;
+
+	/* Channel Manager: only one created per board: */
+	struct CHNL_MGR {
+		u32 dwSignature;	/* Used for object validation */
+		/* Function interface to WMD */
+		struct WMD_DRV_INTERFACE *pIntfFxns;
+		struct IO_MGR *hIOMgr;	/* IO manager */
+		/* Device this board represents */
+		struct DEV_OBJECT *hDevObject;
+
+		/* These fields initialized in WMD_CHNL_Create():    */
+		u32 dwOutputMask; /* Host output channels w/ full buffers */
+		u32 dwLastOutput;	/* Last output channel fired from DPC */
+		/* Critical section object handle */
+		struct SYNC_CSOBJECT *hCSObj;
+		u32 uWordSize;	/* Size in bytes of DSP word */
+		u32 cChannels;	/* Total number of channels */
+		u32 cOpenChannels;	/* Total number of open channels */
+		struct CHNL_OBJECT **apChannel;	/* Array of channels */
+		u32 dwType;	/* Type of channel class library */
+		/* If no SHM syms, return for CHNL_Open */
+		DSP_STATUS chnlOpenStatus;
+	} ;
+
+/*
+ *  Channel: up to CHNL_MAXCHANNELS per board or if DSP-DMA supported then
+ *     up to CHNL_MAXCHANNELS + CHNL_MAXDDMACHNLS per board.
+ */
+	struct CHNL_OBJECT {
+		u32 dwSignature;	/* Used for object validation */
+		/* Pointer back to channel manager */
+		struct CHNL_MGR *pChnlMgr;
+		u32 uId;	/* Channel id */
+		u32 dwState;	/* Current channel state */
+		u32 uMode;	/* Chnl mode and attributes */
+		/* Chnl I/O completion event (user mode) */
+		HANDLE hUserEvent;
+		/* Abstract syncronization object */
+		struct SYNC_OBJECT *hSyncEvent;
+		/* Name of Sync event */
+		char szEventName[SYNC_MAXNAMELENGTH + 1];
+		u32 hProcess;   /* Process which created this channel */
+		u32 pCBArg;	/* Argument to use with callback */
+		struct LST_LIST *pIORequests;	/* List of IOR's to driver */
+		s32 cIOCs;	/* Number of IOC's in queue */
+		s32 cIOReqs;	/* Number of IORequests in queue */
+		s32 cChirps;	/* Initial number of free Irps */
+		/* List of IOC's from driver */
+		struct LST_LIST *pIOCompletions;
+		struct LST_LIST *pFreeList;	/* List of free Irps */
+		struct NTFY_OBJECT *hNtfy;
+		u32 cBytesMoved;	/* Total number of bytes transfered */
+
+		/* For DSP-DMA */
+
+		/* Type of chnl transport:CHNL_[PCPY][DDMA] */
+		u32 uChnlType;
+	} ;
+
+/* I/O Request/completion packet: */
+	struct CHNL_IRP {
+		struct list_head link;	/* Link to next CHIRP in queue. */
+		/* Buffer to be filled/emptied. (User)   */
+		u8 *pHostUserBuf;
+		/* Buffer to be filled/emptied. (System) */
+		u8 *pHostSysBuf;
+		u32 dwArg;	/* Issue/Reclaim argument.               */
+		u32 uDspAddr;	/* Transfer address on DSP side.         */
+		u32 cBytes;	/* Bytes transferred.                    */
+		u32 cBufSize;	/* Actual buffer size when allocated.    */
+		u32 status;	/* Status of IO completion.              */
+	} ;
+
+#endif				/* _CHNL_SM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/_dcd.h b/arch/arm/plat-omap/include/dspbridge/_dcd.h
new file mode 100644
index 0000000..c6bc61d
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/_dcd.h
@@ -0,0 +1,175 @@
+/*
+ * _dcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Includes the wrapper functions called directly by the
+ * DeviceIOControl interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _WCD_
+#define _WCD_
+
+#include <dspbridge/wcdioctl.h>
+
+/*
+ *  ======== WCD_CallDevIOCtl ========
+ *  Purpose:
+ *      Call the (wrapper) function for the corresponding WCD IOCTL.
+ *  Parameters:
+ *      cmd:        IOCTL id, base 0.
+ *      args:       Argument structure.
+ *      pResult:
+ *  Returns:
+ *      DSP_SOK if command called; DSP_EINVALIDARG if command not in IOCTL
+ *      table.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS WCD_CallDevIOCtl(unsigned int cmd,
+					   union Trapped_Args *args,
+					   u32 *pResult, void *pr_ctxt);
+
+/*
+ *  ======== WCD_Init ========
+ *  Purpose:
+ *      Initialize WCD modules, and export WCD services to WMD's.
+ *      This procedure is called when the class driver is loaded.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern bool WCD_Init(void);
+
+/*
+ *  ======== WCD_InitComplete2 ========
+ *  Purpose:
+ *      Perform any required WCD, and WMD initialization which
+ *      cannot not be performed in WCD_Init(void) or DEV_StartDevice() due
+ *      to the fact that some services are not yet
+ *      completely initialized.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Allow this device to load
+ *      DSP_EFAIL:      Failure.
+ *  Requires:
+ *      WCD initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS WCD_InitComplete2(void);
+
+/*
+ *  ======== WCD_Exit ========
+ *  Purpose:
+ *      Exit all modules initialized in WCD_Init(void).
+ *      This procedure is called when the class driver is unloaded.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      WCD_Init(void) was previously called.
+ *  Ensures:
+ *      Resources acquired in WCD_Init(void) are freed.
+ */
+	extern void WCD_Exit(void);
+
+/* MGR wrapper functions */
+	extern u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_RegisterObject(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_UnregisterObject(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args,
+			void *pr_ctxt);
+
+	extern u32 MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
+			void *pr_ctxt);
+
+/* CPRC (Processor) wrapper Functions */
+	extern u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_EnumResources(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_ReserveMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_FlushMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args,
+			void *pr_ctxt);
+
+/* NODE wrapper functions */
+	extern u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_ChangePriority(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_GetMessage(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_PutMessage(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 NODEWRAP_Terminate(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args,
+			void *pr_ctxt);
+
+/* STRM wrapper functions */
+	extern u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_FreeBuffer(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_GetEventHandle(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 STRMWRAP_RegisterNotify(union Trapped_Args *args,
+			void *pr_ctxt);
+	extern u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt);
+
+	extern u32 CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt);
+	extern u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt);
+
+#endif				/* _WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/brddefs.h b/arch/arm/plat-omap/include/dspbridge/brddefs.h
new file mode 100644
index 0000000..ff83166
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/brddefs.h
@@ -0,0 +1,39 @@
+/*
+ * brddefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global BRD constants and types, shared between WCD and WMD.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef BRDDEFS_
+#define BRDDEFS_
+
+/* platform status values */
+#define BRD_STOPPED     0x0	/* No Monitor Loaded, Not running. */
+#define BRD_IDLE        0x1	/* Monitor Loaded, but suspended.  */
+#define BRD_RUNNING     0x2	/* Monitor loaded, and executing.  */
+#define BRD_UNKNOWN     0x3	/* Board state is indeterminate. */
+#define BRD_SYNCINIT    0x4
+#define BRD_LOADED      0x5
+#define BRD_LASTSTATE   BRD_LOADED	/* Set to highest legal board state. */
+#define BRD_SLEEP_TRANSITION 0x6	/* Sleep transition in progress  */
+#define BRD_HIBERNATION 0x7		/* MPU initiated hibernation */
+#define BRD_RETENTION     0x8       /* Retention mode */
+#define BRD_DSP_HIBERNATION     0x9       /* DSP initiated hibernation */
+#define BRD_ERROR		0xA       /* Board state is Error */
+
+/* BRD Object */
+	struct BRD_OBJECT;
+
+#endif				/* BRDDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cfg.h b/arch/arm/plat-omap/include/dspbridge/cfg.h
new file mode 100644
index 0000000..62cb6df
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cfg.h
@@ -0,0 +1,293 @@
+/*
+ * cfg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * PM Configuration module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CFG_
+#define CFG_
+#include <dspbridge/host_os.h>
+#include <dspbridge/cfgdefs.h>
+
+/*
+ *  ======== CFG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CFG module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CFG_Init(void) was previously called.
+ *  Ensures:
+ *      Resources acquired in CFG_Init(void) are freed.
+ */
+	extern void CFG_Exit(void);
+
+/*
+ *  ======== CFG_GetAutoStart ========
+ *  Purpose:
+ *      Retreive the autostart mask, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      pdwAutoStart:   Ptr to location for 32 bit autostart mask.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: Unable to retreive resource.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        *pdwAutoStart contains autostart mask for this devnode.
+ */
+	extern DSP_STATUS CFG_GetAutoStart(IN struct CFG_DEVNODE *hDevNode,
+					   OUT u32 *pdwAutoStart);
+
+/*
+ *  ======== CFG_GetCDVersion ========
+ *  Purpose:
+ *      Retrieves the version of the PM Class Driver.
+ *  Parameters:
+ *      pdwVersion: Ptr to u32 to contain version number upon return.
+ *  Returns:
+ *      DSP_SOK:    Success.  pdwVersion contains Class Driver version in
+ *                  the form: 0xAABBCCDD where AABB is Major version and
+ *                  CCDD is Minor.
+ *      DSP_EFAIL:  Failure.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Success.
+ *      else:       *pdwVersion is NULL.
+ */
+	extern DSP_STATUS CFG_GetCDVersion(OUT u32 *pdwVersion);
+
+/*
+ *  ======== CFG_GetDevObject ========
+ *  Purpose:
+ *      Retrieve the Device Object handle for a given devnode.
+ *  Parameters:
+ *      hDevNode:       Platform's DevNode handle from which to retrieve value.
+ *      pdwValue:       Ptr to location to store the value.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDPOINTER:   phDevObject is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    *pdwValue is set to the retrieved u32.
+ *      else:       *pdwValue is set to 0L.
+ */
+	extern DSP_STATUS CFG_GetDevObject(IN struct CFG_DEVNODE *hDevNode,
+					   OUT u32 *pdwValue);
+
+/*
+ *  ======== CFG_GetDSPResources ========
+ *  Purpose:
+ *      Get the DSP resources available to a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      pDSPResTable:   Ptr to a location to store the DSP resource table.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The DSP Resource information is not
+ *                              available
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    pDSPResTable points to a filled table of resources allocated
+ *                  for the specified WMD.
+ */
+	extern DSP_STATUS CFG_GetDSPResources(IN struct CFG_DEVNODE *hDevNode,
+				      OUT struct CFG_DSPRES *pDSPResTable);
+
+
+/*
+ *  ======== CFG_GetExecFile ========
+ *  Purpose:
+ *      Retreive the default executable, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pstrExecFile:   Ptr to character buf to hold ExecFile.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_INVALIDPOINTER:   pstrExecFile is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Not more than cBufSize bytes were copied into pstrExecFile,
+ *                  and *pstrExecFile contains default executable for this
+ *                  devnode.
+ */
+	extern DSP_STATUS CFG_GetExecFile(IN struct CFG_DEVNODE *hDevNode,
+					  IN u32 cBufSize,
+					  OUT char *pstrExecFile);
+
+/*
+ *  ======== CFG_GetHostResources ========
+ *  Purpose:
+ *      Get the Host PC allocated resources assigned to a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DEVNODE who's resources we are querying.
+ *      pHostResTable:  Ptr to a location to store the host resource table.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDPOINTER:   pHostResTable is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The resource is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    pHostResTable points to a filled table of resources
+ *                  allocated for the specified WMD.
+ *
+ */
+	extern DSP_STATUS CFG_GetHostResources(IN struct CFG_DEVNODE *hDevNode,
+				       OUT struct CFG_HOSTRES *pHostResTable);
+
+/*
+ *  ======== CFG_GetObject ========
+ *  Purpose:
+ *      Retrieve the Driver Object handle From the Registry
+ *  Parameters:
+ *      pdwValue:   Ptr to location to store the value.
+ *      dwType      Type of Object to Get
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    *pdwValue is set to the retrieved u32(non-Zero).
+ *      else:       *pdwValue is set to 0L.
+ */
+	extern DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType);
+
+/*
+ *  ======== CFG_GetPerfValue ========
+ *  Purpose:
+ *      Retrieve a flag indicating whether PERF should log statistics for the
+ *      PM class driver.
+ *  Parameters:
+ *      pfEnablePerf:   Location to store flag.  0 indicates the key was
+ *                      not found, or had a zero value.  A nonzero value
+ *                      means the key was found and had a nonzero value.
+ *  Returns:
+ *  Requires:
+ *      pfEnablePerf != NULL;
+ *  Ensures:
+ */
+	extern void CFG_GetPerfValue(OUT bool *pfEnablePerf);
+
+/*
+ *  ======== CFG_GetWMDFileName ========
+ *  Purpose:
+ *    Get the mini-driver file name for a given device.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pWMDFileName:   Ptr to a character buffer to hold the WMD filename.
+ *  Returns:
+ *      DSP_SOK:                On success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: The filename is not available.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        Not more than cBufSize bytes were copied
+ *                      into pWMDFileName.
+ *
+ */
+	extern DSP_STATUS CFG_GetWMDFileName(IN struct CFG_DEVNODE *hDevNode,
+					     IN u32 cBufSize,
+					     OUT char *pWMDFileName);
+
+/*
+ *  ======== CFG_GetZLFile ========
+ *  Purpose:
+ *      Retreive the ZLFile, if any, for this board.
+ *  Parameters:
+ *      hDevNode:       Handle to the DevNode who's WMD we are querying.
+ *      cBufSize:       Size of buffer.
+ *      pstrZLFileName: Ptr to character buf to hold ZLFileName.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDPOINTER:   pstrZLFileName is invalid.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      CFG_E_RESOURCENOTAVAIL: couldn't find the ZLFileName.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    Not more than cBufSize bytes were copied into
+ *                  pstrZLFileName, and *pstrZLFileName contains ZLFileName
+ *                  for this devnode.
+ */
+	extern DSP_STATUS CFG_GetZLFile(IN struct CFG_DEVNODE *hDevNode,
+					IN u32 cBufSize,
+					OUT char *pstrZLFileName);
+
+/*
+ *  ======== CFG_Init ========
+ *  Purpose:
+ *      Initialize the CFG module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CFG functions.
+ */
+	extern bool CFG_Init(void);
+
+/*
+ *  ======== CFG_SetDevObject ========
+ *  Purpose:
+ *      Store the Device Object handle for a given devnode.
+ *  Parameters:
+ *      hDevNode:   Platform's DevNode handle we are storing value with.
+ *      dwValue:    Arbitrary value to store.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      CFG_E_INVALIDHDEVNODE:  hDevNode is invalid.
+ *      DSP_EFAIL:              Internal Error.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:    The Private u32 was successfully set.
+ */
+	extern DSP_STATUS CFG_SetDevObject(IN struct CFG_DEVNODE *hDevNode,
+					   IN u32 dwValue);
+
+/*
+ *  ======== CFG_SetDrvObject ========
+ *  Purpose:
+ *      Store the Driver Object handle.
+ *  Parameters:
+ *      dwValue:        Arbitrary value to store.
+ *      dwType          Type of Object to Store
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Internal Error.
+ *  Requires:
+ *      CFG initialized.
+ *  Ensures:
+ *      DSP_SOK:        The Private u32 was successfully set.
+ */
+	extern DSP_STATUS CFG_SetObject(IN u32 dwValue, IN u32 dwType);
+
+#endif				/* CFG_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cfgdefs.h b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
new file mode 100644
index 0000000..55c6634
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cfgdefs.h
@@ -0,0 +1,93 @@
+/*
+ * cfgdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global CFG constants and types, shared between class and mini driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CFGDEFS_
+#define CFGDEFS_
+
+/* Maximum length of module search path. */
+#define CFG_MAXSEARCHPATHLEN    255
+
+/* Maximum length of general paths. */
+#define CFG_MAXPATH             255
+
+/* Host Resources:  */
+#define CFG_MAXMEMREGISTERS     9
+#define CFG_MAXIOPORTS          20
+#define CFG_MAXIRQS             7
+#define CFG_MAXDMACHANNELS      7
+
+/* IRQ flag */
+#define CFG_IRQSHARED           0x01	/* IRQ can be shared */
+
+/* DSP Resources: */
+#define CFG_DSPMAXMEMTYPES      10
+#define CFG_DEFAULT_NUM_WINDOWS 1	/* We support only one window. */
+
+/* A platform-related device handle: */
+	struct CFG_DEVNODE;
+
+/*
+ *  Host resource structure.
+ */
+	struct CFG_HOSTRES {
+		u32 wNumMemWindows;	/* Set to default */
+		/* This is the base.memory */
+		u32 dwMemBase[CFG_MAXMEMREGISTERS];  /* SHM virtual address */
+		u32 dwMemLength[CFG_MAXMEMREGISTERS]; /* Length of the Base */
+		u32 dwMemPhys[CFG_MAXMEMREGISTERS]; /* SHM Physical address */
+		u8 bIRQRegisters;	/* IRQ Number */
+		u8 bIRQAttrib;	/* IRQ Attribute */
+		u32 dwOffsetForMonitor;	/* The Shared memory starts from
+					 * dwMemBase + this offset */
+	/*
+	 *  Info needed by NODE for allocating channels to communicate with RMS:
+	 *      dwChnlOffset:       Offset of RMS channels. Lower channels are
+	 *                          reserved.
+	 *      dwChnlBufSize:      Size of channel buffer to send to RMS
+	 *      dwNumChnls:       Total number of channels (including reserved).
+	 */
+		u32 dwChnlOffset;
+		u32 dwChnlBufSize;
+		u32 dwNumChnls;
+		void __iomem *dwPrmBase;
+		void __iomem *dwCmBase;
+		void __iomem *dwPerBase;
+		u32 dwPerPmBase;
+		u32 dwCorePmBase;
+		void __iomem *dwWdTimerDspBase;
+		void __iomem *dwMboxBase;
+		void __iomem *dwDmmuBase;
+		void __iomem *dwSysCtrlBase;
+	} ;
+
+	struct CFG_DSPMEMDESC {
+		u32 uMemType;	/* Type of memory.                        */
+		u32 ulMin;	/* Minimum amount of memory of this type. */
+		u32 ulMax;	/* Maximum amount of memory of this type. */
+	} ;
+
+	struct CFG_DSPRES {
+		u32 uChipType;	/* DSP chip type.               */
+		u32 uWordSize;	/* Number of bytes in a word    */
+		u32 cChips;	/* Number of chips.             */
+		u32 cMemTypes;	/* Types of memory.             */
+		struct CFG_DSPMEMDESC aMemDesc[CFG_DSPMAXMEMTYPES];
+		/* DSP Memory types */
+	} ;
+
+#endif				/* CFGDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnl.h b/arch/arm/plat-omap/include/dspbridge/chnl.h
new file mode 100644
index 0000000..4a6e4d5
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnl.h
@@ -0,0 +1,135 @@
+/*
+ * chnl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a mini-driver.
+ *
+ * See DSP API chnl.h for more details.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CHNL_
+#define CHNL_
+
+#include <dspbridge/chnlpriv.h>
+
+/*
+ *  ======== CHNL_Close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *      CHNL_Init(void) called.
+ *      No thread must be blocked on this channel's I/O completion event.
+ *  Ensures:
+ *      DSP_SOK:        The I/O completion event for this channel is freed.
+ *                      hChnl is no longer valid.
+ */
+	extern DSP_STATUS CHNL_Close(struct CHNL_OBJECT *hChnl);
+
+
+/*
+ *  ======== CHNL_Create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given board.
+ *  Parameters:
+ *      phChnlMgr:      Location to store a channel manager object on output.
+ *      hDevObject:     Handle to a device object.
+ *      pMgrAttrs:      Channel manager attributes.
+ *      pMgrAttrs->cChannels:   Max channels
+ *      pMgrAttrs->bIRQ:        Channel's I/O IRQ number.
+ *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EHANDLE:            hDevObject is invalid.
+ *      DSP_EINVALIDARG:        cChannels is 0.
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
+ *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
+ *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
+ *      CHNL_E_MGREXISTS:       Channel manager already exists for this device.
+ *  Requires:
+ *      CHNL_Init(void) called.
+ *      phChnlMgr != NULL.
+ *      pMgrAttrs != NULL.
+ *  Ensures:
+ *      DSP_SOK:                Subsequent calls to CHNL_Create() for the same
+ *                              board without an intervening call to
+ *                              CHNL_Destroy() will fail.
+ */
+	extern DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct CHNL_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ *  Parameters:
+ *      hChnlMgr:           Channel manager object.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        hChnlMgr was invalid.
+ *  Requires:
+ *      CHNL_Init(void) called.
+ *  Ensures:
+ *      DSP_SOK:            Cancels I/O on each open channel.
+ *                          Closes each open channel.
+ *                          CHNL_Create may subsequently be called for the
+ *                          same board.
+ */
+	extern DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+
+/*
+ *  ======== CHNL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CHNL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CHNL_Init(void) previously called.
+ *  Ensures:
+ *      Resources, if any acquired in CHNL_Init(void), are freed when the last
+ *      client of CHNL calls CHNL_Exit(void).
+ */
+	extern void CHNL_Exit(void);
+
+
+/*
+ *  ======== CHNL_Init ========
+ *  Purpose:
+ *      Initialize the CHNL module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occurred.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CHNL functions.
+ */
+	extern bool CHNL_Init(void);
+
+
+
+#endif				/* CHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnl_sm.h b/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
new file mode 100644
index 0000000..e1e3f06
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnl_sm.h
@@ -0,0 +1,154 @@
+/*
+ * chnl_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Prototypes for channel lower edge functions for a Bridge mini driver
+ * implementing data transfer via shared memory.
+ *
+ * Notes:
+ *   These lower edge functions must be implemented by the WMD writer.
+ *   Currently, CHNLSM_Read() and CHNLSM_Write() are not called, but must
+ *   be defined to link.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CHNLSM_
+#define CHNLSM_
+
+#include <dspbridge/wmd.h>
+
+/*
+ *  ======== CHNLSM_DisableInterrupt ========
+ *  Purpose:
+ *      Disable interrupts from the DSP board to the PC.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT*
+							hDevContext);
+
+/*
+ *  ======== CHNLSM_EnableInterrupt ========
+ *  Purpose:
+ *      Enable interrupts from the DSP board to the PC.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT*
+						       hDevContext);
+
+/*
+ *  ======== CHNLSM_InterruptDSP2 ========
+ *  Purpose:
+ *      Set interrupt value & send an interrupt to the DSP processor(s).
+ *      This is typicaly used when mailbox interrupt mechanisms allow data
+ *      to be associated with interrupt such as for OMAP's CMD/DATA regs.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      wMbVal:         Value associated with interrupt(e.g. mailbox value).
+ *  Returns:
+ *      DSP_SOK:        Interrupt sent;
+ *      else:           Unable to send interrupt.
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT*
+						     hDevContext, u16 wMbVal);
+
+/*
+ *  ======== CHNLSM_ISR ========
+ *  Purpose:
+ *      Mini-driver's ISR, called by WCD when the board interrupts the host.
+ *  Parameters:
+ *      hDevContext:    Handle to the mini-driver defined device info.
+ *      pfSchedDPC:     Set to TRUE to schedule a deferred procedure call
+ *                      to advance the channel protocol.  The channel class
+ *                      library will call the WMD's CHNLSM_DPC routine during
+ *                      its own DPC, before dispatching I/O.
+ *                      The channel class library should ignore *pfSchedDPC when
+ *                      CHNLSM_ISR returns FALSE.
+ *      pwMBRegVal:     Value of mailbox register.
+ *  Returns:
+ *      TRUE if this interrupt is was generated by the DSP board.
+ *      FALSE otherwise.
+ *  Requires:
+ *      Interrupts to the host processor are disabled on entry.
+ *      Must only call functions which are in page locked memory.
+ *      Must only call asynchronous OS services.
+ *      The EOI for this interrupt has already been sent to the PIC.
+ *  Ensures:
+ *      If the interrupt is *not* shared, this routine must return TRUE.
+ */
+       extern bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *hDevContext,
+				     OUT bool *pfSchedDPC,
+				     OUT u16 *pwIntrVal);
+
+/*
+ *  ======== CHNLSM_Read ========
+ *  Purpose:
+ *      Read data from DSP board memory into a Host buffer.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Destination).
+ *      dwDSPAddr:      Address on DSP board (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_Read(struct WMD_DEV_CONTEXT *hDevContext,
+					    OUT u8 *pHostBuf,
+					    u32 dwDSPAddr, u32 ulNumBytes);
+
+/*
+ *  ======== CHNLSM_UpdateSHMLength ========
+ *  Purpose:
+ *      Allow the minidriver a chance to override the SHM length as reported
+ *      to the mini driver (chnl_sm.lib) by Windows Plug and Play.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pSHMLength:     Pointer to size of SHM window (in DSP words).
+ *  Returns:
+ *      TRUE if pSHMLength updated; FALSE otherwise.
+ *  Requires:
+ *      pSHMLength != NULL.
+ *  Ensures:
+ *      No more than sizeof(u32) bytes written to *pSHMLength
+ */
+	extern bool CHNLSM_UpdateSHMLength(struct WMD_DEV_CONTEXT *hDevContext,
+					   IN OUT u32 *pSHMLength);
+
+/*
+ *  ======== CHNLSM_Write ========
+ *  Purpose:
+ *      Write data from a Host buffer to DSP board memory.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS CHNLSM_Write(struct WMD_DEV_CONTEXT *hDevContext,
+					    IN u8 *pHostBuf,
+					    u32 dwDSPAddr, u32 ulNumBytes);
+
+#endif				/* CHNLSM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnldefs.h b/arch/arm/plat-omap/include/dspbridge/chnldefs.h
new file mode 100644
index 0000000..43df8b7
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnldefs.h
@@ -0,0 +1,68 @@
+/*
+ * chnldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * System-wide channel objects and constants.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CHNLDEFS_
+#define CHNLDEFS_
+
+/* Channel id option. */
+#define CHNL_PICKFREE       (~0UL)	/* Let manager pick a free channel. */
+
+/* Channel manager limits: */
+#define CHNL_INITIOREQS      4	/* Default # of I/O requests.       */
+
+/* Channel modes */
+#define CHNL_MODETODSP       0x0000	/* Data streaming to the DSP.      */
+#define CHNL_MODEFROMDSP     0x0001	/* Data streaming from the DSP.    */
+
+/* GetIOCompletion flags */
+#define CHNL_IOCINFINITE     0xffffffff	/* Wait forever for IO completion. */
+#define CHNL_IOCNOWAIT       0x0	/* Dequeue an IOC, if available.   */
+
+/* IO Completion Record status: */
+#define CHNL_IOCSTATCOMPLETE 0x0000	/* IO Completed.             */
+#define CHNL_IOCSTATCANCEL   0x0002	/* IO was cancelled          */
+#define CHNL_IOCSTATTIMEOUT  0x0008	/* Wait for IOC timed out.   */
+#define CHNL_IOCSTATEOS      0x8000	/* End Of Stream reached.    */
+
+/* Macros for checking I/O Completion status: */
+#define CHNL_IsEOS(ioc)         (ioc.status & CHNL_IOCSTATEOS)
+#define CHNL_IsIOComplete(ioc)  (!(ioc.status & ~CHNL_IOCSTATEOS))
+#define CHNL_IsIOCancelled(ioc) (ioc.status & CHNL_IOCSTATCANCEL)
+#define CHNL_IsTimedOut(ioc)    (ioc.status & CHNL_IOCSTATTIMEOUT)
+
+
+/* Channel attributes: */
+	struct CHNL_ATTRS {
+		u32 uIOReqs;	/* Max # of preallocated I/O requests.    */
+		HANDLE hEvent;	/* User supplied auto-reset event object. */
+		char *pstrEventName;	/* Ptr to name of user event object.  */
+		HANDLE hReserved1;	/* Reserved for future use.         */
+		u32 hReserved2;	/* Reserved for future use.        */
+
+	};
+
+/* I/O completion record: */
+	struct CHNL_IOC {
+		void *pBuf;	/* Buffer to be filled/emptied.           */
+		u32 cBytes;	/* Bytes transferred.                     */
+		u32 cBufSize;	/* Actual buffer size in bytes            */
+		u32 status;	/* Status of IO completion.               */
+		u32 dwArg;	/* User argument associated with pBuf.    */
+	} ;
+
+#endif				/* CHNLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/chnlpriv.h b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
new file mode 100644
index 0000000..2eadfa0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/chnlpriv.h
@@ -0,0 +1,109 @@
+/*
+ * chnlpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private channel header shared between DSPSYS, WCD and WMD modules.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CHNLPRIV_
+#define CHNLPRIV_
+
+#include <dspbridge/chnldefs.h>
+#include <dspbridge/devdefs.h>
+#include <dspbridge/sync.h>
+
+/* CHNL Object validation signatures: */
+#define CHNL_MGRSIGNATURE   0x52474D43	/* "CMGR" (in reverse). */
+#define CHNL_SIGNATURE      0x4C4E4843	/* "CHNL" (in reverse). */
+
+/* Channel manager limits: */
+#define CHNL_MAXCHANNELS    32	/* Max channels available per transport */
+
+
+/*
+ *  Trans port channel Id definitions:(must match dsp-side).
+ *
+ *  For CHNL_MAXCHANNELS = 16:
+ *
+ *  ChnlIds:
+ *      0-15  (PCPY) - transport 0)
+ *      16-31 (DDMA) - transport 1)
+ *      32-47 (ZCPY) - transport 2)
+ */
+#define CHNL_PCPY       0	/* Proc-copy transport 0 */
+
+#define CHNL_MAXIRQ     0xff	/* Arbitrarily large number. */
+
+/* The following modes are private: */
+#define CHNL_MODEUSEREVENT  0x1000	/* User provided the channel event. */
+#define CHNL_MODEMASK       0x1001
+
+/* Higher level channel states: */
+#define CHNL_STATEREADY     0x0000	/* Channel ready for I/O.    */
+#define CHNL_STATECANCEL    0x0001	/* I/O was cancelled.        */
+#define CHNL_STATEEOS       0x0002	/* End Of Stream reached.    */
+
+/* Determine if user supplied an event for this channel:  */
+#define CHNL_IsUserEvent(mode)  (mode & CHNL_MODEUSEREVENT)
+
+/* Macros for checking mode: */
+#define CHNL_IsInput(mode)      (mode & CHNL_MODEFROMDSP)
+#define CHNL_IsOutput(mode)     (!CHNL_IsInput(mode))
+
+/* Types of channel class libraries: */
+#define CHNL_TYPESM         1	/* Shared memory driver. */
+#define CHNL_TYPEBM         2	/* Bus Mastering driver. */
+
+/* Max string length of channel I/O completion event name - change if needed */
+#define CHNL_MAXEVTNAMELEN  32
+
+/* Max memory pages lockable in CHNL_PrepareBuffer() - change if needed */
+#define CHNL_MAXLOCKPAGES   64
+
+/* Channel info.  */
+	 struct CHNL_INFO {
+		struct CHNL_MGR *hChnlMgr;	/* Owning channel manager.   */
+		u32 dwID;	/* Channel ID.                            */
+		HANDLE hEvent;	/* Channel I/O completion event.          */
+		/*Abstraction of I/O completion event.*/
+		struct SYNC_OBJECT *hSyncEvent;
+		u32 dwMode;	/* Channel mode.                          */
+		u32 dwState;	/* Current channel state.                 */
+		u32 cPosition;	/* Total bytes transferred.        */
+		u32 cIOCs;	/* Number of IOCs in queue.               */
+		u32 cIOReqs;	/* Number of IO Requests in queue.        */
+		u32 hProcess;   /* Process owning this channel.     */
+		/*
+		 * Name of channel I/O completion event. Not required in Linux
+		 */
+		char szEventName[CHNL_MAXEVTNAMELEN + 1];
+	} ;
+
+/* Channel manager info: */
+	struct CHNL_MGRINFO {
+		u32 dwType;	/* Type of channel class library.         */
+		/* Channel handle, given the channel id. */
+		struct CHNL_OBJECT *hChnl;
+		u32 cOpenChannels;	/* Number of open channels.     */
+		u32 cChannels;	/* total # of chnls supported */
+	} ;
+
+/* Channel Manager Attrs: */
+	struct CHNL_MGRATTRS {
+		/* Max number of channels this manager can use. */
+		u32 cChannels;
+		u32 uWordSize;	/* DSP Word size.                       */
+	} ;
+
+#endif				/* CHNLPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/clk.h b/arch/arm/plat-omap/include/dspbridge/clk.h
new file mode 100644
index 0000000..9a0fb0f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/clk.h
@@ -0,0 +1,148 @@
+/*
+ * clk.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provides Clock functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _CLK_H
+#define _CLK_H
+
+	/* Generic TIMER object: */
+	struct TIMER_OBJECT;
+	enum SERVICES_ClkId {
+		SERVICESCLK_iva2_ck = 0,
+		SERVICESCLK_mailbox_ick,
+		SERVICESCLK_gpt5_fck,
+		SERVICESCLK_gpt5_ick,
+		SERVICESCLK_gpt6_fck,
+		SERVICESCLK_gpt6_ick,
+		SERVICESCLK_gpt7_fck,
+		SERVICESCLK_gpt7_ick,
+		SERVICESCLK_gpt8_fck,
+		SERVICESCLK_gpt8_ick,
+		SERVICESCLK_wdt3_fck,
+		SERVICESCLK_wdt3_ick,
+		SERVICESCLK_mcbsp1_fck,
+		SERVICESCLK_mcbsp1_ick,
+		SERVICESCLK_mcbsp2_fck,
+		SERVICESCLK_mcbsp2_ick,
+		SERVICESCLK_mcbsp3_fck,
+		SERVICESCLK_mcbsp3_ick,
+		SERVICESCLK_mcbsp4_fck,
+		SERVICESCLK_mcbsp4_ick,
+		SERVICESCLK_mcbsp5_fck,
+		SERVICESCLK_mcbsp5_ick,
+		SERVICESCLK_ssi_fck,
+		SERVICESCLK_ssi_ick,
+		SERVICESCLK_sys_32k_ck,
+		SERVICESCLK_sys_ck,
+		SERVICESCLK_NOT_DEFINED
+	} ;
+
+/*
+ *  ======== CLK_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      CLK initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void CLK_Exit(void);
+
+/*
+ *  ======== CLK_Init ========
+ *  Purpose:
+ *      Initializes private state of CLK module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      CLK initialized.
+ */
+	extern bool CLK_Init(void);
+
+
+/*
+ *  ======== CLK_Enable ========
+ *  Purpose:
+ *      Enables the clock requested.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:	Success.
+ *	DSP_EFAIL:	Error occured while enabling the clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id);
+
+/*
+ *  ======== CLK_Disable ========
+ *  Purpose:
+ *      Disables the clock requested.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while disabling the clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id);
+
+/*
+ *  ======== CLK_GetRate ========
+ *  Purpose:
+ *      Get the clock rate of requested clock.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while Getting the clock rate.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id,
+				     u32 *speedMhz);
+/*
+ *  ======== CLK_Set_32KHz ========
+ *  Purpose:
+ *      Set the requested clock to 32KHz.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Error occured while setting the clock parent to 32KHz.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id);
+	extern void SSI_Clk_Prepare(bool FLAG);
+
+/*
+ *  ======== CLK_Get_RefCnt ========
+ *  Purpose:
+ *      get the reference count for the clock.
+ *  Parameters:
+ *  Returns:
+ *      s32:        Reference Count for the clock.
+ *      DSP_EFAIL:  Error occured while getting the reference count of a clock.
+ *  Requires:
+ *  Ensures:
+ */
+	extern s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id);
+
+#endif				/* _SYNC_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/cmm.h b/arch/arm/plat-omap/include/dspbridge/cmm.h
new file mode 100644
index 0000000..31911b9
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cmm.h
@@ -0,0 +1,386 @@
+/*
+ * cmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * The Communication Memory Management(CMM) module provides shared memory
+ * management services for DSP/BIOS Bridge data streaming and messaging.
+ * Multiple shared memory segments can be registered with CMM. Memory is
+ * coelesced back to the appropriate pool when a buffer is freed.
+ *
+ * The CMM_Xlator[xxx] functions are used for node messaging and data
+ * streaming address translation to perform zero-copy inter-processor
+ * data transfer(GPP<->DSP). A "translator" object is created for a node or
+ * stream object that contains per thread virtual address information. This
+ * translator info is used at runtime to perform SM address translation
+ * to/from the DSP address space.
+ *
+ * Notes:
+ *   CMM_XlatorAllocBuf - Used by Node and Stream modules for SM address
+ *			  translation.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CMM_
+#define CMM_
+
+#include <dspbridge/devdefs.h>
+
+#include <dspbridge/cmmdefs.h>
+#include <dspbridge/host_os.h>
+
+/*
+ *  ======== CMM_CallocBuf ========
+ *  Purpose:
+ *      Allocate memory buffers that can be used for data streaming or
+ *      messaging.
+ *  Parameters:
+ *      hCmmMgr:   Cmm Mgr handle.
+ *      uSize:     Number of bytes to allocate.
+ *      pAttr:     Attributes of memory to allocate.
+ *      ppBufVA:   Address of where to place VA.
+ *  Returns:
+ *      Pointer to a zero'd block of SM memory;
+ *      NULL if memory couldn't be allocated,
+ *      or if cBytes == 0,
+ *  Requires:
+ *      Valid hCmmMgr.
+ *      CMM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.
+ *
+ */
+	extern void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr,
+				   u32 uSize, struct CMM_ATTRS *pAttrs,
+				   OUT void **ppBufVA);
+
+/*
+ *  ======== CMM_Create ========
+ *  Purpose:
+ *      Create a communication memory manager object.
+ *  Parameters:
+ *      phCmmMgr:   Location to store a communication manager handle on output.
+ *      hDevObject: Handle to a device object.
+ *      pMgrAttrs:  Comm mem manager attributes.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      Failed to initialize critical sect sync object.
+ *
+ *  Requires:
+ *      CMM_Init(void) called.
+ *      phCmmMgr != NULL.
+ *      pMgrAttrs->ulMinBlockSize >= 4 bytes.
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     IN CONST struct CMM_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== CMM_Destroy ========
+ *  Purpose:
+ *      Destroy the communication memory manager object.
+ *  Parameters:
+ *      hCmmMgr:   Cmm Mgr handle.
+ *      bForce:    Force deallocation of all cmm memory immediately if set TRUE.
+ *                 If FALSE, and outstanding allocations will return DSP_EFAIL
+ *                 status.
+ *  Returns:
+ *      DSP_SOK:        CMM object & resources deleted.
+ *      DSP_EFAIL:      Unable to free CMM object due to outstanding allocation.
+ *      DSP_EHANDLE:    Unable to free CMM due to bad handle.
+ *  Requires:
+ *      CMM is initialized.
+ *      hCmmMgr != NULL.
+ *  Ensures:
+ *      Memory resources used by Cmm Mgr are freed.
+ */
+	extern DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce);
+
+/*
+ *  ======== CMM_Exit ========
+ *  Purpose:
+ *     Discontinue usage of module. Cleanup CMM module if CMM cRef reaches zero.
+ *  Parameters:
+ *     n/a
+ *  Returns:
+ *     n/a
+ *  Requires:
+ *     CMM is initialized.
+ *  Ensures:
+ */
+	extern void CMM_Exit(void);
+
+/*
+ *  ======== CMM_FreeBuf ========
+ *  Purpose:
+ *      Free the given buffer.
+ *  Parameters:
+ *      hCmmMgr:    Cmm Mgr handle.
+ *      pBuf:       Pointer to memory allocated by CMM_CallocBuf().
+ *      ulSegId:    SM segment Id used in CMM_Calloc() attrs.
+ *                  Set to 0 to use default segment.
+ *  Returns:
+ *      DSP_SOK
+ *      DSP_EFAIL
+ *  Requires:
+ *      CMM initialized.
+ *      pBufPA != NULL
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr,
+				      void *pBufPA, u32 ulSegId);
+
+/*
+ *  ======== CMM_GetHandle ========
+ *  Purpose:
+ *      Return the handle to the cmm mgr for the given device obj.
+ *  Parameters:
+ *      hProcessor:   Handle to a Processor.
+ *      phCmmMgr:     Location to store the shared memory mgr handle on output.
+ *
+ *  Returns:
+ *      DSP_SOK:        Cmm Mgr opaque handle returned.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      phCmmMgr != NULL
+ *      hDevObject != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS CMM_GetHandle(void *hProcessor,
+					OUT struct CMM_OBJECT **phCmmMgr);
+
+/*
+ *  ======== CMM_GetInfo ========
+ *  Purpose:
+ *      Return the current SM and VM utilization information.
+ *  Parameters:
+ *      hCmmMgr:     Handle to a Cmm Mgr.
+ *      pCmmInfo:    Location to store the Cmm information on output.
+ *
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *      DSP_EINVALIDARG Invalid input argument.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
+				      OUT struct CMM_INFO *pCmmInfo);
+
+/*
+ *  ======== CMM_Init ========
+ *  Purpose:
+ *      Initializes private state of CMM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      CMM initialized.
+ */
+	extern bool CMM_Init(void);
+
+/*
+ *  ======== CMM_RegisterGPPSMSeg ========
+ *  Purpose:
+ *      Register a block of SM with the CMM.
+ *  Parameters:
+ *      hCmmMgr:         Handle to a Cmm Mgr.
+ *      lpGPPBasePA:     GPP Base Physical address.
+ *      ulSize:          Size in GPP bytes.
+ *      dwDSPAddrOffset  GPP PA to DSP PA Offset.
+ *      cFactor:         Add offset if CMM_ADDTODSPPA, sub if CMM_SUBFROMDSPPA.
+ *      dwDSPBase:       DSP virtual base byte address.
+ *      ulDSPSize:       Size of DSP segment in bytes.
+ *      pulSegId:        Address to store segment Id.
+ *
+ *  Returns:
+ *      DSP_SOK:         Success.
+ *      DSP_EHANDLE:     Invalid hCmmMgr handle.
+ *      DSP_EINVALIDARG: Invalid input argument.
+ *      DSP_EFAIL:       Unable to register.
+ *      - On success *pulSegId is a valid SM segment ID.
+ *  Requires:
+ *      ulSize > 0
+ *      pulSegId != NULL
+ *      dwGPPBasePA != 0
+ *      cFactor = CMM_ADDTODSPPA || cFactor = CMM_SUBFROMDSPPA
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
+					       unsigned int dwGPPBasePA,
+					       u32 ulSize,
+					       u32 dwDSPAddrOffset,
+					       s8  cFactor,
+					       unsigned int dwDSPBase,
+					       u32 ulDSPSize,
+					       u32 *pulSegId,
+					       u32 dwGPPBaseBA);
+
+/*
+ *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  Purpose:
+ *      Unregister the given memory segment that was previously registered
+ *      by CMM_RegisterGPPSMSeg.
+ *  Parameters:
+ *      hCmmMgr:    Handle to a Cmm Mgr.
+ *      ulSegId     Segment identifier returned by CMM_RegisterGPPSMSeg.
+ *  Returns:
+ *       DSP_SOK:         Success.
+ *       DSP_EHANDLE:     Invalid handle.
+ *       DSP_EINVALIDARG: Invalid ulSegId.
+ *       DSP_EFAIL:       Unable to unregister for unknown reason.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr,
+						 u32 ulSegId);
+
+/*
+ *  ======== CMM_XlatorAllocBuf ========
+ *  Purpose:
+ *      Allocate the specified SM buffer and create a local memory descriptor.
+ *      Place on the descriptor on the translator's HaQ (Host Alloc'd Queue).
+ *  Parameters:
+ *      hXlator:    Handle to a Xlator object.
+ *      pVaBuf:     Virtual address ptr(client context)
+ *      uPaSize:    Size of SM memory to allocate.
+ *  Returns:
+ *      Ptr to valid physical address(Pa) of uPaSize bytes, NULL if failed.
+ *  Requires:
+ *      pVaBuf != 0.
+ *      uPaSize != 0.
+ *  Ensures:
+ *
+ */
+	extern void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator,
+					void *pVaBuf, u32 uPaSize);
+
+/*
+ *  ======== CMM_XlatorCreate ========
+ *  Purpose:
+ *     Create a translator(xlator) object used for process specific Va<->Pa
+ *     address translation. Node messaging and streams use this to perform
+ *     inter-processor(GPP<->DSP) zero-copy data transfer.
+ *  Parameters:
+ *     phXlator:       Address to place handle to a new Xlator handle.
+ *     hCmmMgr:        Handle to Cmm Mgr associated with this translator.
+ *     pXlatorAttrs:   Translator attributes used for the client NODE or STREAM.
+ *  Returns:
+ *     DSP_SOK:            Success.
+ *     DSP_EINVALIDARG:    Bad input Attrs.
+ *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
+ *  Requires:
+ *     phXlator != NULL
+ *     hCmmMgr != NULL
+ *     pXlatorAttrs != NULL
+ *  Ensures:
+ *
+ */
+      extern DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
+					 struct CMM_OBJECT *hCmmMgr,
+					 struct CMM_XLATORATTRS *pXlatorAttrs);
+
+/*
+ *  ======== CMM_XlatorDelete ========
+ *  Purpose:
+ *      Delete translator resources
+ *  Parameters:
+ *      hXlator:    handle to translator.
+ *      bForce:     bForce = TRUE will free XLators SM buffers/dscriptrs.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *      DSP_EFAIL:      Unable to free translator resources.
+ *  Requires:
+ *      cRefs > 0
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator,
+					   bool bForce);
+
+/*
+ *  ======== CMM_XlatorFreeBuf ========
+ *  Purpose:
+ *      Free SM buffer and descriptor.
+ *      Does not free client process VM.
+ *  Parameters:
+ *      hXlator:    handle to translator.
+ *      pBufVa      Virtual address of PA to free.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *  Requires:
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator,
+					    void *pBufVa);
+
+/*
+ *  ======== CMM_XlatorInfo ========
+ *  Purpose:
+ *      Set/Get process specific "translator" address info.
+ *      This is used to perform fast virtaul address translation
+ *      for shared memory buffers between the GPP and DSP.
+ *  Parameters:
+ *     hXlator:     handle to translator.
+ *     pAddr:       Virtual base address of segment.
+ *     ulSize:      Size in bytes.
+ *     uSegId:      Segment identifier of SM segment(s)
+ *     bSetInfo     Set xlator fields if TRUE, else return base addr
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Bad translator handle.
+ *  Requires:
+ *      (cRefs > 0)
+ *      (pAddr != NULL)
+ *      (ulSize > 0)
+ *  Ensures:
+ *
+ */
+	extern DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator,
+					 IN OUT u8 **pAddr,
+					 u32 ulSize, u32 uSegId,
+					 bool bSetInfo);
+
+/*
+ *  ======== CMM_XlatorTranslate ========
+ *  Purpose:
+ *      Perform address translation VA<->PA for the specified stream or
+ *      message shared memory buffer.
+ *  Parameters:
+ *     hXlator: handle to translator.
+ *     pAddr    address of buffer to translate.
+ *     xType    Type of address xlation. CMM_PA2VA or CMM_VA2PA.
+ *  Returns:
+ *     Valid address on success, else NULL.
+ *  Requires:
+ *      cRefs > 0
+ *      pAddr != NULL
+ *      xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA)
+ *  Ensures:
+ *
+ */
+	extern void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator,
+					 void *pAddr, enum CMM_XLATETYPE xType);
+
+#endif				/* CMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cmmdefs.h b/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
new file mode 100644
index 0000000..c6eb6dd
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cmmdefs.h
@@ -0,0 +1,105 @@
+/*
+ * cmmdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global MEM constants and types.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CMMDEFS_
+#define CMMDEFS_
+
+#include <dspbridge/list.h>
+
+/* Cmm attributes used in CMM_Create() */
+	struct CMM_MGRATTRS {
+		/* Minimum SM allocation; default 32 bytes.  */
+		u32 ulMinBlockSize;
+	} ;
+
+/* Attributes for CMM_AllocBuf() & CMM_AllocDesc() */
+	struct CMM_ATTRS {
+		u32 ulSegId;	/*  1,2... are SM segments. 0 is not. */
+		u32 ulAlignment;	/*  0,1,2,4....ulMinBlockSize */
+	} ;
+
+/*
+ *  DSPPa to GPPPa Conversion Factor.
+ *
+ *  For typical platforms:
+ *      converted Address = PaDSP + ( cFactor * addressToConvert).
+ */
+#define CMM_SUBFROMDSPPA	-1
+#define CMM_ADDTODSPPA		1
+
+#define CMM_ALLSEGMENTS         0xFFFFFF	/* All SegIds */
+#define CMM_MAXGPPSEGS          1	/* Maximum # of SM segs */
+
+/*
+ *  SMSEGs are SM segments the DSP allocates from.
+ *
+ *  This info is used by the GPP to xlate DSP allocated PAs.
+ */
+
+	struct CMM_SEGINFO {
+		u32 dwSegBasePa;	/* Start Phys address of SM segment */
+		/* Total size in bytes of segment: DSP+GPP */
+		u32 ulTotalSegSize;
+		u32 dwGPPBasePA;	/* Start Phys addr of Gpp SM seg */
+		u32 ulGPPSize;	/* Size of Gpp SM seg in bytes */
+		u32 dwDSPBaseVA;	/* DSP virt base byte address */
+		u32 ulDSPSize;	/* DSP seg size in bytes */
+		/* # of current GPP allocations from this segment */
+		u32 ulInUseCnt;
+		u32 dwSegBaseVa;	/* Start Virt address of SM seg */
+
+	} ;
+
+/* CMM useful information */
+	struct CMM_INFO {
+		/* # of SM segments registered with this Cmm. */
+		u32 ulNumGPPSMSegs;
+		/* Total # of allocations outstanding for CMM */
+		u32 ulTotalInUseCnt;
+		/* Min SM block size allocation from CMM_Create() */
+		u32 ulMinBlockSize;
+		/* Info per registered SM segment. */
+		struct CMM_SEGINFO segInfo[CMM_MAXGPPSEGS];
+	} ;
+
+/* XlatorCreate attributes */
+	struct CMM_XLATORATTRS {
+		u32 ulSegId;	/* segment Id used for SM allocations */
+		u32 dwDSPBufs;	/* # of DSP-side bufs */
+		u32 dwDSPBufSize;	/* size of DSP-side bufs in GPP bytes */
+		/* Vm base address alloc'd in client process context */
+		void *pVmBase;
+		/* dwVmSize must be >= (dwMaxNumBufs * dwMaxSize) */
+		u32 dwVmSize;
+	} ;
+
+/*
+ * Cmm translation types. Use to map SM addresses to process context.
+ */
+	enum CMM_XLATETYPE {
+		CMM_VA2PA = 0,	/* Virtual to GPP physical address xlation */
+		CMM_PA2VA = 1,	/* GPP Physical to virtual  */
+		CMM_VA2DSPPA = 2,	/* Va to DSP Pa  */
+		CMM_PA2DSPPA = 3,	/* GPP Pa to DSP Pa */
+		CMM_DSPPA2PA = 4,	/* DSP Pa to GPP Pa */
+	} ;
+
+	struct CMM_OBJECT;
+	struct CMM_XLATOROBJECT;
+
+#endif				/* CMMDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/cod.h b/arch/arm/plat-omap/include/dspbridge/cod.h
new file mode 100644
index 0000000..b2f82fd
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/cod.h
@@ -0,0 +1,383 @@
+/*
+ * cod.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Code management module for DSPs. This module provides an interface
+ * interface for loading both static and dynamic code objects onto DSP
+ * systems.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef COD_
+#define COD_
+
+#include <dspbridge/dblldefs.h>
+
+#define COD_MAXPATHLENGTH       255
+#define COD_TRACEBEG            "SYS_PUTCBEG"
+#define COD_TRACEEND            "SYS_PUTCEND"
+#define COD_TRACESECT           "trace"
+#define COD_TRACEBEGOLD         "PUTCBEG"
+#define COD_TRACEENDOLD         "PUTCEND"
+
+#define COD_NOLOAD              DBLL_NOLOAD
+#define COD_SYMB                DBLL_SYMB
+
+/* Flags passed to COD_Open */
+	typedef DBLL_Flags COD_FLAGS;
+
+/* COD code manager handle */
+	struct COD_MANAGER;
+
+/* COD library handle */
+	struct COD_LIBRARYOBJ;
+
+/* COD attributes */
+	 struct COD_ATTRS {
+		u32 ulReserved;
+	} ;
+
+/*
+ *  Function prototypes for writing memory to a DSP system, allocating
+ *  and freeing DSP memory.
+ */
+       typedef u32(*COD_WRITEFXN) (void *pPrivRef, u32 ulDspAddr,
+					     void *pBuf, u32 ulNumBytes,
+					     u32 nMemSpace);
+
+
+/*
+ *  ======== COD_Close ========
+ *  Purpose:
+ *      Close a library opened with COD_Open().
+ *  Parameters:
+ *      lib             - Library handle returned by COD_Open().
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD module initialized.
+ *      valid lib.
+ *  Ensures:
+ *
+ */
+       extern void COD_Close(struct COD_LIBRARYOBJ *lib);
+
+/*
+ *  ======== COD_Create ========
+ *  Purpose:
+ *      Create an object to manage code on a DSP system. This object can be
+ *      used to load an initial program image with arguments that can later
+ *      be expanded with dynamically loaded object files.
+ *      Symbol table information is managed by this object and can be retrieved
+ *      using the COD_GetSymValue() function.
+ *  Parameters:
+ *      phManager:      created manager object
+ *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
+ *      attrs:          attributes to be used by this object. A NULL value
+ *                      will cause default attrs to be used.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      COD_E_NOZLFUNCTIONS:    Could not initialize ZL functions.
+ *      COD_E_ZLCREATEFAILED:   ZL_Create failed.
+ *      DSP_ENOTIMPL:           attrs was not NULL.  We don't yet support
+ *                              non default values of attrs.
+ *  Requires:
+ *      COD module initialized.
+ *      pstrZLFile != NULL
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_Create(OUT struct COD_MANAGER **phManager,
+				    char *pstrZLFile,
+				    IN OPTIONAL CONST struct COD_ATTRS *attrs);
+
+/*
+ *  ======== COD_Delete ========
+ *  Purpose:
+ *      Delete a code manager object.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *  Ensures:
+ */
+       extern void COD_Delete(struct COD_MANAGER *hManager);
+
+/*
+ *  ======== COD_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the COD module.
+ *  Parameters:
+ *      None.
+ *  Returns:
+ *      None.
+ *  Requires:
+ *      COD initialized.
+ *  Ensures:
+ *      Resources acquired in COD_Init(void) are freed.
+ */
+       extern void COD_Exit(void);
+
+/*
+ *  ======== COD_GetBaseLib ========
+ *  Purpose:
+ *      Get handle to the base image DBL library.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      plib:       location to store library handle on output.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      plib != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
+					       struct DBLL_LibraryObj **plib);
+
+/*
+ *  ======== COD_GetBaseName ========
+ *  Purpose:
+ *      Get the name of the base image DBL library.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      pszName:    location to store library name on output.
+ *      uSize:       size of name buffer.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Buffer too small.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pszName != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager,
+						char *pszName, u32 uSize);
+
+/*
+ *  ======== COD_GetEntry ========
+ *  Purpose:
+ *      Retrieve the entry point of a loaded DSP program image
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      pulEntry:   pointer to location for entry point
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pulEntry != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager,
+					     u32 *pulEntry);
+
+/*
+ *  ======== COD_GetLoader ========
+ *  Purpose:
+ *      Get handle to the DBL loader.
+ *  Parameters:
+ *      hManager:   handle of manager to be deleted
+ *      phLoader:   location to store loader handle on output.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      phLoader != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
+					      struct DBLL_TarObj **phLoader);
+
+/*
+ *  ======== COD_GetSection ========
+ *  Purpose:
+ *      Retrieve the starting address and length of a section in the COFF file
+ *      given the section name.
+ *  Parameters:
+ *      lib         Library handle returned from COD_Open().
+ *      pstrSect:   name of the section, with or without leading "."
+ *      puAddr:     Location to store address.
+ *      puLen:      Location to store length.
+ *  Returns:
+ *      DSP_SOK:                Success
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pstrSect != NULL;
+ *      puAddr != NULL;
+ *      puLen != NULL;
+ *  Ensures:
+ *      DSP_SOK:  *puAddr and *puLen contain the address and length of the
+ *                 section.
+ *      else:  *puAddr == 0 and *puLen == 0;
+ *
+ */
+       extern DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib,
+					       IN char *pstrSect,
+					       OUT u32 *puAddr,
+					       OUT u32 *puLen);
+
+/*
+ *  ======== COD_GetSymValue ========
+ *  Purpose:
+ *      Retrieve the value for the specified symbol. The symbol is first
+ *      searched for literally and then, if not found, searched for as a
+ *      C symbol.
+ *  Parameters:
+ *      lib:        library handle returned from COD_Open().
+ *      pstrSymbol: name of the symbol
+ *      value:      value of the symbol
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      COD module initialized.
+ *      Valid hManager.
+ *      pstrSym != NULL.
+ *      pulValue != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hManager,
+						IN char *pstrSym,
+						OUT u32 *pulValue);
+
+/*
+ *  ======== COD_Init ========
+ *  Purpose:
+ *      Initialize the COD module's private state.
+ *  Parameters:
+ *      None.
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public COD functions.
+ */
+       extern bool COD_Init(void);
+
+/*
+ *  ======== COD_LoadBase ========
+ *  Purpose:
+ *      Load the initial program image, optionally with command-line arguments,
+ *      on the DSP system managed by the supplied handle. The program to be
+ *      loaded must be the first element of the args array and must be a fully
+ *      qualified pathname.
+ *  Parameters:
+ *      hMgr:       manager to load the code with
+ *      nArgc:      number of arguments in the args array
+ *      args:       array of strings for arguments to DSP program
+ *      writeFxn:   board-specific function to write data to DSP system
+ *      pArb:       arbitrary pointer to be passed as first arg to writeFxn
+ *      envp:       array of environment strings for DSP exec.
+ *  Returns:
+ *      DSP_SOK:                   Success.
+ *      COD_E_OPENFAILED:       Failed to open target code.
+ *      COD_E_LOADFAILED:       Failed to load code onto target.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      nArgc > 0.
+ *      aArgs != NULL.
+ *      aArgs[0] != NULL.
+ *      pfnWrite != NULL.
+ *  Ensures:
+ */
+       extern DSP_STATUS COD_LoadBase(struct COD_MANAGER *hManager,
+					     u32 nArgc, char *aArgs[],
+					     COD_WRITEFXN pfnWrite, void *pArb,
+					     char *envp[]);
+
+
+/*
+ *  ======== COD_Open ========
+ *  Purpose:
+ *      Open a library for reading sections. Does not load or set the base.
+ *  Parameters:
+ *      hMgr:           manager to load the code with
+ *      pszCoffPath:    Coff file to open.
+ *      flags:          COD_NOLOAD (don't load symbols) or COD_SYMB (load
+ *                      symbols).
+ *      pLib:           Handle returned that can be used in calls to COD_Close
+ *                      and COD_GetSection.
+ *  Returns:
+ *      S_OK:                   Success.
+ *      COD_E_OPENFAILED:       Failed to open target code.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      flags == COD_NOLOAD || flags == COD_SYMB.
+ *      pszCoffPath != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS COD_Open(struct COD_MANAGER *hMgr,
+				   IN char *pszCoffPath,
+				   COD_FLAGS flags,
+				   OUT struct COD_LIBRARYOBJ **pLib);
+
+/*
+ *  ======== COD_OpenBase ========
+ *  Purpose:
+ *      Open base image for reading sections. Does not load the base.
+ *  Parameters:
+ *      hMgr:           manager to load the code with
+ *      pszCoffPath:    Coff file to open.
+ *      flags:          Specifies whether to load symbols.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      COD_E_OPENFAILED:   Failed to open target code.
+ *  Requires:
+ *      COD module initialized.
+ *      hMgr is valid.
+ *      pszCoffPath != NULL.
+ *  Ensures:
+ */
+extern DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
+				       DBLL_Flags flags);
+
+/*
+ *  ======== COD_ReadSection ========
+ *  Purpose:
+ *      Retrieve the content of a code section given the section name.
+ *  Parameters:
+ *      hManager    - manager in which to search for the symbol
+ *      pstrSect    - name of the section, with or without leading "."
+ *      pstrContent - buffer to store content of the section.
+ *  Returns:
+ *      DSP_SOK: on success, error code on failure
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_READFAILED: Failed to read content of code section.
+ *  Requires:
+ *      COD module initialized.
+ *      valid hManager.
+ *      pstrSect != NULL;
+ *      pstrContent != NULL;
+ *  Ensures:
+ *      DSP_SOK:  *pstrContent stores the content of the named section.
+ */
+       extern DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib,
+						IN char *pstrSect,
+						OUT char *pstrContent,
+						IN u32 cContentSize);
+
+
+
+#endif				/* COD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbc.h b/arch/arm/plat-omap/include/dspbridge/dbc.h
new file mode 100644
index 0000000..90cad03
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbc.h
@@ -0,0 +1,46 @@
+/*
+ * dbc.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * "Design by Contract" programming macros.
+ *
+ * Notes:
+ *   Requires that the GT->ERROR function has been defaulted to a valid
+ *   error handler for the given execution environment.
+ *
+ *   Does not require that GT_init() be called.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBC_
+#define DBC_
+
+/* Assertion Macros: */
+#ifdef CONFIG_BRIDGE_DEBUG
+
+#define DBC_Assert(exp) \
+    if (!(exp)) \
+	pr_err("%s, line %d: Assertion (" #exp ") failed.\n", \
+	__FILE__, __LINE__)
+#define DBC_Require DBC_Assert	/* Function Precondition.  */
+#define DBC_Ensure  DBC_Assert	/* Function Postcondition. */
+
+#else
+
+#define DBC_Assert(exp) {}
+#define DBC_Require(exp) {}
+#define DBC_Ensure(exp) {}
+
+#endif				/* DEBUG */
+
+#endif				/* DBC_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcd.h b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
new file mode 100644
index 0000000..5939058
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
@@ -0,0 +1,366 @@
+/*
+ * dbdcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Defines the DSP/BIOS Bridge Configuration Database (DCD) API.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBDCD_
+#define DBDCD_
+
+#include <dspbridge/dbdcddef.h>
+#include <dspbridge/host_os.h>
+#include <dspbridge/nldrdefs.h>
+
+/*
+ *  ======== DCD_AutoRegister ========
+ *  Purpose:
+ *      This function automatically registers DCD objects specified in a
+ *      special COFF section called ".dcd_register"
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing DCD
+ *                              objects to be registered.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto registration.
+ */
+	extern DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
+					   IN char *pszCoffPath);
+
+/*
+ *  ======== DCD_AutoUnregister ========
+ *  Purpose:
+ *      This function automatically unregisters DCD objects specified in a
+ *      special COFF section called ".dcd_register"
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing
+ *                              DCD objects to be unregistered.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find auto-registration section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto unregistration.
+ */
+	extern DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
+					     IN char *pszCoffPath);
+
+/*
+ *  ======== DCD_CreateManager ========
+ *  Purpose:
+ *      This function creates a DCD module manager.
+ *  Parameters:
+ *      pszZlDllName:   Pointer to a DLL name string.
+ *      phDcdMgr:       A pointer to a DCD manager handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Unable to allocate memory for DCD manager handle.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      pszZlDllName is non-NULL.
+ *      phDcdMgr is non-NULL.
+ *  Ensures:
+ *      A DCD manager handle is created.
+ */
+	extern DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
+					    OUT struct DCD_MANAGER **phDcdMgr);
+
+/*
+ *  ======== DCD_DestroyManager ========
+ *  Purpose:
+ *      This function destroys a DCD module manager.
+ *  Parameters:
+ *      hDcdMgr:        A DCD manager handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid DCD manager handle.
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr);
+
+/*
+ *  ======== DCD_EnumerateObject ========
+ *  Purpose:
+ *      This function enumerates currently visible DSP/BIOS Bridge objects
+ *      and returns the UUID and type of each enumerated object.
+ *  Parameters:
+ *      cIndex:             The object enumeration index.
+ *      objType:            Type of object to enumerate.
+ *      pUuid:              Pointer to a DSP_UUID object.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EFAIL:          Unable to enumerate through the DCD database.
+ *      DSP_SENUMCOMPLETE:  Enumeration completed. This is not an error code.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid is a valid pointer.
+ *  Ensures:
+ *  Details:
+ *      This function can be used in conjunction with DCD_GetObjectDef to
+ *      retrieve object properties.
+ */
+	extern DSP_STATUS DCD_EnumerateObject(IN s32 cIndex,
+					      IN enum DSP_DCDOBJTYPE objType,
+					      OUT struct DSP_UUID *pUuid);
+
+/*
+ *  ======== DCD_Exit ========
+ *  Purpose:
+ *      This function cleans up the DCD module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ */
+	extern void DCD_Exit(void);
+
+/*
+ *  ======== DCD_GetDepLibs ========
+ *  Purpose:
+ *      Given the uuid of a library and size of array of uuids, this function
+ *      fills the array with the uuids of all dependent libraries of the input
+ *      library.
+ *  Parameters:
+ *      hDcdMgr: A DCD manager handle.
+ *      pUuid: Pointer to a DSP_UUID for a library.
+ *      numLibs: Size of uuid array (number of library uuids).
+ *      pDepLibUuids: Array of dependent library uuids to be filled in.
+ *      pPersistentDepLibs: Array indicating if corresponding lib is persistent.
+ *      phase: phase to obtain correct input library
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EMEMORY: Memory allocation failure.
+ *      DSP_EDCDREADSECT: Failure to read section containing library info.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pUuid != NULL
+ *      pDepLibUuids != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+					 IN struct DSP_UUID *pUuid,
+					 u16 numLibs,
+					 OUT struct DSP_UUID *pDepLibUuids,
+					 OUT bool *pPersistentDepLibs,
+					 IN enum NLDR_PHASE phase);
+
+/*
+ *  ======== DCD_GetNumDepLibs ========
+ *  Purpose:
+ *      Given the uuid of a library, determine its number of dependent
+ *      libraries.
+ *  Parameters:
+ *      hDcdMgr:        A DCD manager handle.
+ *      pUuid:          Pointer to a DSP_UUID for a library.
+ *      pNumLibs:       Size of uuid array (number of library uuids).
+ *      pNumPersLibs:   number of persistent dependent library.
+ *      phase:          Phase to obtain correct input library
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EMEMORY: Memory allocation failure.
+ *      DSP_EDCDREADSECT: Failure to read section containing library info.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pUuid != NULL
+ *      pNumLibs != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+					    IN struct DSP_UUID *pUuid,
+					    OUT u16 *pNumLibs,
+					    OUT u16 *pNumPersLibs,
+					    IN enum NLDR_PHASE phase);
+
+/*
+ *  ======== DCD_GetLibraryName ========
+ *  Purpose:
+ *      This function returns the name of a (dynamic) library for a given
+ *      UUID.
+ *  Parameters:
+ *      hDcdMgr: A DCD manager handle.
+ *      pUuid:          Pointer to a DSP_UUID that represents a unique DSP/BIOS
+ *                      Bridge object.
+ *      pstrLibName: Buffer to hold library name.
+ *      pdwSize: Contains buffer size. Set to string size on output.
+ *      phase:          Which phase to load
+ *      fPhaseSplit:    Are phases in multiple libraries
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EFAIL: General failure.
+ *  Requires:
+ *      DCD initialized.
+ *      Valid hDcdMgr.
+ *      pstrLibName != NULL.
+ *      pUuid != NULL
+ *      pdwSize != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
+					     IN struct DSP_UUID *pUuid,
+					     IN OUT char *pstrLibName,
+					     IN OUT u32 *pdwSize,
+					     IN enum NLDR_PHASE phase,
+					     OUT bool *fPhaseSplit);
+
+/*
+ *  ======== DCD_GetObjectDef ========
+ *  Purpose:
+ *      This function returns the properties/attributes of a DSP/BIOS Bridge
+ *      object.
+ *  Parameters:
+ *      hDcdMgr:            A DCD manager handle.
+ *      pUuid:              Pointer to a DSP_UUID that represents a unique
+ *                          DSP/BIOS Bridge object.
+ *      objType:            The type of DSP/BIOS Bridge object to be
+ *                          referenced (node, processor, etc).
+ *      pObjDef:            Pointer to an object definition structure. A
+ *                          union of various possible DCD object types.
+ *  Returns:
+ *      DSP_SOK: Success.
+ *      DSP_EDCDPARSESECT:  Unable to parse content of object code section.
+ *      DSP_EDCDREADSECT:   Unable to read object code section.
+ *      DSP_EDCDGETSECT:    Unable to access object code section.
+ *      DSP_EDCDLOADBASE:   Unable to load code base.
+ *      DSP_EFAIL:          General failure.
+ *      DSP_EHANDLE:        Invalid DCD_HMANAGER handle.
+ *  Requires:
+ *      DCD initialized.
+ *      pObjUuid is non-NULL.
+ *      pObjDef is non-NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
+					   IN struct DSP_UUID *pObjUuid,
+					   IN enum DSP_DCDOBJTYPE objType,
+					   OUT struct DCD_GENERICOBJ *pObjDef);
+
+/*
+ *  ======== DCD_GetObjects ========
+ *  Purpose:
+ *      This function finds all DCD objects specified in a special
+ *      COFF section called ".dcd_register", and for each object,
+ *      call a "register" function.  The "register" function may perform
+ *      various actions, such as 1) register nodes in the node database, 2)
+ *      unregister nodes from the node database, and 3) add overlay nodes.
+ *  Parameters:
+ *      hDcdMgr:                A DCD manager handle.
+ *      pszCoffPath:            Pointer to name of COFF file containing DCD
+ *                              objects.
+ *      registerFxn:            Callback fxn to be applied on each located
+ *                              DCD object.
+ *      handle:                 Handle to pass to callback.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EDCDNOAUTOREGISTER: Unable to find .dcd_register section.
+ *      DSP_EDCDREADSECT:       Unable to read object code section.
+ *      DSP_EDCDLOADBASE:       Unable to load code base.
+ *      DSP_EHANDLE:            Invalid DCD_HMANAGER handle..
+ *  Requires:
+ *      DCD initialized.
+ *  Ensures:
+ *  Note:
+ *      Due to the DCD database construction, it is essential for a DCD-enabled
+ *      COFF file to contain the right COFF sections, especially
+ *      ".dcd_register", which is used for auto registration.
+ */
+	extern DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr,
+					 IN char *pszCoffPath,
+					 DCD_REGISTERFXN registerFxn,
+					 void *handle);
+
+/*
+ *  ======== DCD_Init ========
+ *  Purpose:
+ *      This function initializes DCD.
+ *  Parameters:
+ *  Returns:
+ *      FALSE:  Initialization failed.
+ *      TRUE:   Initialization succeeded.
+ *  Requires:
+ *  Ensures:
+ *      DCD initialized.
+ */
+	extern bool DCD_Init(void);
+
+/*
+ *  ======== DCD_RegisterObject ========
+ *  Purpose:
+ *      This function registers a DSP/BIOS Bridge object in the DCD database.
+ *  Parameters:
+ *      pUuid:          Pointer to a DSP_UUID that identifies a DSP/BIOS
+ *                      Bridge object.
+ *      objType:        Type of object.
+ *      pszPathName:    Path to the object's COFF file.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to register object.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid and szPathName are non-NULL values.
+ *      objType is a valid type value.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
+					     IN enum DSP_DCDOBJTYPE objType,
+					     IN char *pszPathName);
+
+/*
+ *  ======== DCD_UnregisterObject ========
+ *  Purpose:
+ *      This function de-registers a valid DSP/BIOS Bridge object from the DCD
+ *      database.
+ *  Parameters:
+ *      pUuid:      Pointer to a DSP_UUID that identifies a DSP/BIOS Bridge
+ *                  object.
+ *      objType:    Type of object.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Unable to de-register the specified object.
+ *  Requires:
+ *      DCD initialized.
+ *      pUuid is a non-NULL value.
+ *      objType is a valid type value.
+ *  Ensures:
+ */
+	extern DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
+					       IN enum DSP_DCDOBJTYPE objType);
+
+#endif				/* _DBDCD_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcddef.h b/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
new file mode 100644
index 0000000..4abb1cd
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcddef.h
@@ -0,0 +1,71 @@
+/*
+ * dbdcddef.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DCD (DSP/BIOS Bridge Configuration Database) constants and types.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBDCDDEF_
+#define DBDCDDEF_
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/mgrpriv.h>		/* for MGR_PROCESSOREXTINFO */
+
+/*
+ *  The following defines are critical elements for the DCD module:
+ *
+ * - DCD_REGKEY enables DCD functions to locate registered DCD objects.
+ * - DCD_REGISTER_SECTION identifies the COFF section where the UUID of
+ *   registered DCD objects are stored.
+ */
+#define DCD_REGKEY              "Software\\TexasInstruments\\DspBridge\\DCD"
+#define DCD_REGISTER_SECTION    ".dcd_register"
+
+/* DCD Manager Object */
+	struct DCD_MANAGER;
+
+/* DCD Node Properties */
+	struct DCD_NODEPROPS {
+		struct DSP_NDBPROPS ndbProps;
+		u32 uMsgSegid;
+		u32 uMsgNotifyType;
+		char *pstrCreatePhaseFxn;
+		char *pstrDeletePhaseFxn;
+		char *pstrExecutePhaseFxn;
+		char *pstrIAlgName;
+
+		/* Dynamic load properties */
+		u16 usLoadType;	/* Static, dynamic, overlay */
+		u32 ulDataMemSegMask;	/* Data memory requirements */
+		u32 ulCodeMemSegMask;	/* Code memory requirements */
+	} ;
+
+/* DCD Generic Object Type */
+	struct DCD_GENERICOBJ {
+		union dcdObjUnion {
+			struct DCD_NODEPROPS nodeObj;	/* node object. */
+			/* processor object. */
+			struct DSP_PROCESSORINFO procObj;
+			/* extended proc object (private) */
+			struct MGR_PROCESSOREXTINFO extProcObj;
+		} objData;
+	} ;
+
+/* DCD Internal Callback Type */
+       typedef DSP_STATUS(*DCD_REGISTERFXN) (IN struct DSP_UUID *pUuid,
+						IN enum DSP_DCDOBJTYPE objType,
+						IN void *handle);
+
+#endif				/* DBDCDDEF_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdefs.h b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
new file mode 100644
index 0000000..9d6b0c0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbdefs.h
@@ -0,0 +1,550 @@
+/*
+ * dbdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global definitions and constants for DSP/BIOS Bridge.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBDEFS_
+#define DBDEFS_
+
+#include <linux/types.h>
+
+#include <dspbridge/dbtype.h>		/* GPP side type definitions */
+#include <dspbridge/std.h>		/* DSP/BIOS type definitions */
+#include <dspbridge/rms_sh.h>		/* Types shared between GPP and DSP */
+
+#define PG_SIZE_4K 4096
+#define PG_MASK(pg_size) (~((pg_size)-1))
+#define PG_ALIGN_LOW(addr, pg_size) ((addr) & PG_MASK(pg_size))
+#define PG_ALIGN_HIGH(addr, pg_size) (((addr)+(pg_size)-1) & PG_MASK(pg_size))
+
+/* API return value and calling convention */
+#define DBAPI                       DSP_STATUS
+
+/* Infinite time value for the uTimeout parameter to DSPStream_Select() */
+#define DSP_FOREVER                 (-1)
+
+/* Maximum length of node name, used in DSP_NDBPROPS */
+#define DSP_MAXNAMELEN              32
+
+/* uNotifyType values for the RegisterNotify() functions. */
+#define DSP_SIGNALEVENT             0x00000001
+
+/* Types of events for processors */
+#define DSP_PROCESSORSTATECHANGE    0x00000001
+#define DSP_PROCESSORATTACH         0x00000002
+#define DSP_PROCESSORDETACH         0x00000004
+#define DSP_PROCESSORRESTART        0x00000008
+
+/* DSP exception events (DSP/BIOS and DSP MMU fault) */
+#define DSP_MMUFAULT                0x00000010
+#define DSP_SYSERROR                0x00000020
+#define DSP_EXCEPTIONABORT          0x00000300
+#define DSP_PWRERROR                0x00000080
+
+/* IVA exception events (IVA MMU fault) */
+#define IVA_MMUFAULT                0x00000040
+/* Types of events for nodes */
+#define DSP_NODESTATECHANGE         0x00000100
+#define DSP_NODEMESSAGEREADY        0x00000200
+
+/* Types of events for streams */
+#define DSP_STREAMDONE              0x00001000
+#define DSP_STREAMIOCOMPLETION      0x00002000
+
+/* Handle definition representing the GPP node in DSPNode_Connect() calls */
+#define DSP_HGPPNODE                0xFFFFFFFF
+
+/* Node directions used in DSPNode_Connect() */
+#define DSP_TONODE                  1
+#define DSP_FROMNODE                2
+
+/* Define Node Minimum and Maximum Priorities */
+#define DSP_NODE_MIN_PRIORITY       1
+#define DSP_NODE_MAX_PRIORITY       15
+
+/* Pre-Defined Message Command Codes available to user: */
+#define DSP_RMSUSERCODESTART RMS_USER	/* Start of RMS user cmd codes */
+/* end of user codes */
+#define DSP_RMSUSERCODEEND (RMS_USER + RMS_MAXUSERCODES);
+#define DSP_RMSBUFDESC RMS_BUFDESC	/* MSG contains SM buffer description */
+
+/* Shared memory identifier for MEM segment named "SHMSEG0" */
+#define DSP_SHMSEG0     (u32)(-1)
+
+/* Processor ID numbers */
+#define DSP_UNIT    0
+#define IVA_UNIT    1
+
+#define DSPWORD       unsigned char
+#define DSPWORDSIZE     sizeof(DSPWORD)
+
+/* Success & Failure macros  */
+#define DSP_SUCCEEDED(Status)      likely((s32)(Status) >= 0)
+#define DSP_FAILED(Status)         unlikely((s32)(Status) < 0)
+
+/* Power control enumerations */
+#define PROC_PWRCONTROL             0x8070
+
+#define PROC_PWRMGT_ENABLE          (PROC_PWRCONTROL + 0x3)
+#define PROC_PWRMGT_DISABLE         (PROC_PWRCONTROL + 0x4)
+
+/* Bridge Code Version */
+#define BRIDGE_VERSION_CODE         333
+
+#define    MAX_PROFILES     16
+
+/* DSP chip type */
+#define DSPTYPE_64	0x99
+
+/* Types defined for 'Bridge API */
+	typedef u32 DSP_STATUS;	/* API return code type         */
+
+/* Handy Macros */
+#define IsValidProcEvent(x) (((x) == 0) || (((x) & (DSP_PROCESSORSTATECHANGE | \
+				    DSP_PROCESSORATTACH | \
+				    DSP_PROCESSORDETACH | \
+				    DSP_PROCESSORRESTART | \
+				    DSP_NODESTATECHANGE | \
+				    DSP_STREAMDONE | \
+				    DSP_STREAMIOCOMPLETION | \
+				    DSP_MMUFAULT | \
+				    DSP_SYSERROR | \
+				    DSP_PWRERROR)) && \
+				!((x) & ~(DSP_PROCESSORSTATECHANGE | \
+				    DSP_PROCESSORATTACH | \
+				    DSP_PROCESSORDETACH | \
+				    DSP_PROCESSORRESTART | \
+				    DSP_NODESTATECHANGE | \
+				    DSP_STREAMDONE | \
+				    DSP_STREAMIOCOMPLETION | \
+				    DSP_MMUFAULT | \
+				    DSP_SYSERROR | \
+				    DSP_PWRERROR))))
+
+#define IsValidNodeEvent(x)    (((x) == 0) || (((x) & (DSP_NODESTATECHANGE | \
+				DSP_NODEMESSAGEREADY)) && \
+				!((x) & ~(DSP_NODESTATECHANGE | \
+				DSP_NODEMESSAGEREADY))))
+
+#define IsValidStrmEvent(x)     (((x) == 0) || (((x) & (DSP_STREAMDONE | \
+				DSP_STREAMIOCOMPLETION)) && \
+				!((x) & ~(DSP_STREAMDONE | \
+				DSP_STREAMIOCOMPLETION))))
+
+#define IsValidNotifyMask(x)   ((x) & DSP_SIGNALEVENT)
+
+/* The Node UUID structure */
+	struct DSP_UUID {
+		u32 ulData1;
+		u16 usData2;
+		u16 usData3;
+		u8 ucData4;
+		u8 ucData5;
+		u8 ucData6[6];
+	};
+
+/* DCD types */
+	enum DSP_DCDOBJTYPE {
+		DSP_DCDNODETYPE,
+		DSP_DCDPROCESSORTYPE,
+		DSP_DCDLIBRARYTYPE,
+		DSP_DCDCREATELIBTYPE,
+		DSP_DCDEXECUTELIBTYPE,
+		DSP_DCDDELETELIBTYPE,
+		/* DSP_DCDMAXOBJTYPE is meant to be the last DCD object type */
+		DSP_DCDMAXOBJTYPE
+	} ;
+
+/* Processor states */
+	enum DSP_PROCSTATE {
+		PROC_STOPPED,
+		PROC_LOADED,
+		PROC_RUNNING,
+		PROC_ERROR
+	} ;
+
+/*
+ *  Node types: Message node, task node, xDAIS socket node, and
+ *  device node. _NODE_GPP is used when defining a stream connection
+ *  between a task or socket node and the GPP.
+ *
+ */
+	enum NODE_TYPE {
+		NODE_DEVICE,
+		NODE_TASK,
+		NODE_DAISSOCKET,
+		NODE_MESSAGE,
+		NODE_GPP
+	} ;
+
+/*
+ *  ======== NODE_STATE ========
+ *  Internal node states.
+ */
+	enum NODE_STATE {
+		NODE_ALLOCATED,
+		NODE_CREATED,
+		NODE_RUNNING,
+		NODE_PAUSED,
+		NODE_DONE,
+		NODE_CREATING,
+		NODE_STARTING,
+		NODE_PAUSING,
+		NODE_TERMINATING,
+		NODE_DELETING,
+	} ;
+
+/* Stream states */
+	enum DSP_STREAMSTATE {
+		STREAM_IDLE,
+		STREAM_READY,
+		STREAM_PENDING,
+		STREAM_DONE
+	} ;
+
+/* Stream connect types */
+	enum DSP_CONNECTTYPE {
+		CONNECTTYPE_NODEOUTPUT,
+		CONNECTTYPE_GPPOUTPUT,
+		CONNECTTYPE_NODEINPUT,
+		CONNECTTYPE_GPPINPUT
+	} ;
+
+/* Stream mode types */
+	enum DSP_STRMMODE {
+		STRMMODE_PROCCOPY, /* Processor(s) copy stream data payloads */
+		STRMMODE_ZEROCOPY, /* Strm buffer ptrs swapped no data copied */
+		STRMMODE_LDMA,	/* Local DMA : OMAP's System-DMA device */
+		STRMMODE_RDMA	/* Remote DMA: OMAP's DSP-DMA device */
+	} ;
+
+/* Resource Types */
+	enum DSP_RESOURCEINFOTYPE {
+		DSP_RESOURCE_DYNDARAM = 0,
+		DSP_RESOURCE_DYNSARAM,
+		DSP_RESOURCE_DYNEXTERNAL,
+		DSP_RESOURCE_DYNSRAM,
+		DSP_RESOURCE_PROCLOAD
+	} ;
+
+/* Memory Segment Types */
+	enum DSP_MEMTYPE {
+		DSP_DYNDARAM = 0,
+		DSP_DYNSARAM,
+		DSP_DYNEXTERNAL,
+		DSP_DYNSRAM
+	} ;
+
+/* Memory Flush Types */
+       enum DSP_FLUSHTYPE {
+		PROC_INVALIDATE_MEM = 0,
+		PROC_WRITEBACK_MEM,
+		PROC_WRITEBACK_INVALIDATE_MEM,
+	} ;
+
+/* Memory Segment Status Values */
+	struct DSP_MEMSTAT {
+		u32 ulSize;
+		u32 ulTotalFreeSize;
+		u32 ulLenMaxFreeBlock;
+		u32 ulNumFreeBlocks;
+		u32 ulNumAllocBlocks;
+	} ;
+
+/* Processor Load information Values */
+	 struct DSP_PROCLOADSTAT {
+		u32 uCurrLoad;
+		u32 uPredictedLoad;
+		u32 uCurrDspFreq;
+		u32 uPredictedFreq;
+	} ;
+
+/* Attributes for STRM connections between nodes */
+	struct DSP_STRMATTR {
+		u32 uSegid;	/* Memory segment on DSP to allocate buffers */
+		u32 uBufsize;	/* Buffer size (DSP words) */
+		u32 uNumBufs;	/* Number of buffers */
+		u32 uAlignment;	/* Buffer alignment */
+		u32 uTimeout;	/* Timeout for blocking STRM calls */
+		enum DSP_STRMMODE lMode;	/* mode of stream when opened */
+		/* DMA chnl id if DSP_STRMMODE is LDMA or RDMA */
+		u32 uDMAChnlId;
+		u32 uDMAPriority;  /* DMA channel priority 0=lowest, >0=high */
+	} ;
+
+/* The DSP_CBDATA structure */
+	struct DSP_CBDATA {
+		u32 cbData;
+		u8 cData[1];
+	} ;
+
+/* The DSP_MSG structure */
+	struct DSP_MSG {
+		u32 dwCmd;
+		u32 dwArg1;
+		u32 dwArg2;
+	} ;
+
+/* The DSP_RESOURCEREQMTS structure for node's resource requirements  */
+	struct DSP_RESOURCEREQMTS {
+		u32 cbStruct;
+		u32 uStaticDataSize;
+		u32 uGlobalDataSize;
+		u32 uProgramMemSize;
+		u32 uWCExecutionTime;
+		u32 uWCPeriod;
+		u32 uWCDeadline;
+		u32 uAvgExectionTime;
+		u32 uMinimumPeriod;
+	} ;
+
+/*
+ * The DSP_STREAMCONNECT structure describes a stream connection
+ * between two nodes, or between a node and the GPP
+ */
+	struct DSP_STREAMCONNECT {
+		u32 cbStruct;
+		enum DSP_CONNECTTYPE lType;
+		u32 uThisNodeStreamIndex;
+		void *hConnectedNode;
+		struct DSP_UUID uiConnectedNodeID;
+		u32 uConnectedNodeStreamIndex;
+	} ;
+
+	struct DSP_NODEPROFS {
+		u32 ulHeapSize;
+	} ;
+
+/* The DSP_NDBPROPS structure reports the attributes of a node */
+	struct DSP_NDBPROPS {
+		u32 cbStruct;
+		struct DSP_UUID uiNodeID;
+		char acName[DSP_MAXNAMELEN];
+		enum NODE_TYPE uNodeType;
+		u32 bCacheOnGPP;
+		struct DSP_RESOURCEREQMTS dspResourceReqmts;
+		s32 iPriority;
+		u32 uStackSize;
+		u32 uSysStackSize;
+		u32 uStackSeg;
+		u32 uMessageDepth;
+		u32 uNumInputStreams;
+		u32 uNumOutputStreams;
+		u32 uTimeout;
+		u32 uCountProfiles;	/* Number of supported profiles */
+		/* Array of profiles */
+		struct DSP_NODEPROFS aProfiles[MAX_PROFILES];
+		u32 uStackSegName; /* Stack Segment Name */
+	} ;
+
+	/* The DSP_NODEATTRIN structure describes the attributes of a
+	 * node client */
+	struct DSP_NODEATTRIN {
+		u32 cbStruct;
+		s32 iPriority;
+		u32 uTimeout;
+		u32    uProfileID;
+		/* Reserved, for Bridge Internal use only */
+		u32    uHeapSize;
+		void *pGPPVirtAddr; /* Reserved, for Bridge Internal use only */
+	} ;
+
+	/* The DSP_NODEINFO structure is used to retrieve information
+	 * about a node */
+	struct DSP_NODEINFO {
+		u32 cbStruct;
+		struct DSP_NDBPROPS nbNodeDatabaseProps;
+		u32 uExecutionPriority;
+		enum NODE_STATE nsExecutionState;
+		void *hDeviceOwner;
+		u32 uNumberStreams;
+		struct DSP_STREAMCONNECT scStreamConnection[16];
+		u32 uNodeEnv;
+	} ;
+
+	/* The DSP_NODEATTR structure describes the attributes of a node */
+	struct DSP_NODEATTR {
+		u32 cbStruct;
+		struct DSP_NODEATTRIN inNodeAttrIn;
+		u32 uInputs;
+		u32 uOutputs;
+		struct DSP_NODEINFO iNodeInfo;
+	} ;
+
+/*
+ *  Notification type: either the name of an opened event, or an event or
+ *  window handle.
+ */
+	struct DSP_NOTIFICATION {
+		char *psName;
+		HANDLE handle;
+	} ;
+
+/* The DSP_PROCESSORATTRIN structure describes the attributes of a processor */
+	struct DSP_PROCESSORATTRIN{
+		u32 cbStruct;
+		u32 uTimeout;
+	} ;
+/*
+ * The DSP_PROCESSORINFO structure describes basic capabilities of a
+ * DSP processor
+ */
+	struct DSP_PROCESSORINFO {
+		u32 cbStruct;
+		int uProcessorFamily;
+		int uProcessorType;
+		u32 uClockRate;
+		u32 ulInternalMemSize;
+		u32 ulExternalMemSize;
+		u32 uProcessorID;
+		int tyRunningRTOS;
+		s32 nNodeMinPriority;
+		s32 nNodeMaxPriority;
+	} ;
+
+/* Error information of last DSP exception signalled to the GPP */
+	struct DSP_ERRORINFO {
+		u32 dwErrMask;
+		u32 dwVal1;
+		u32 dwVal2;
+		u32 dwVal3;
+	} ;
+
+/* The DSP_PROCESSORSTATE structure describes the state of a DSP processor */
+	struct DSP_PROCESSORSTATE {
+		u32 cbStruct;
+		enum DSP_PROCSTATE iState;
+		struct DSP_ERRORINFO errInfo;
+	} ;
+
+/*
+ * The DSP_RESOURCEINFO structure is used to retrieve information about a
+ * processor's resources
+ */
+	struct DSP_RESOURCEINFO {
+		u32 cbStruct;
+		enum DSP_RESOURCEINFOTYPE uResourceType;
+		union {
+			u32 ulResource;
+			struct DSP_MEMSTAT memStat;
+			struct DSP_PROCLOADSTAT procLoadStat;
+		} result;
+	} ;
+
+/*
+ * The DSP_STREAMATTRIN structure describes the attributes of a stream,
+ * including segment and alignment of data buffers allocated with
+ * DSPStream_AllocateBuffers(), if applicable
+ */
+	struct DSP_STREAMATTRIN {
+		u32 cbStruct;
+		u32 uTimeout;
+		u32 uSegment;
+		u32 uAlignment;
+		u32 uNumBufs;
+		enum DSP_STRMMODE lMode;
+		u32 uDMAChnlId;
+		u32 uDMAPriority;
+	} ;
+
+/* The DSP_BUFFERATTR structure describes the attributes of a data buffer */
+	struct DSP_BUFFERATTR {
+		u32 cbStruct;
+		u32 uSegment;
+		u32 uAlignment;
+	} ;
+
+/*
+ *  The DSP_STREAMINFO structure is used to retrieve information
+ *  about a stream.
+ */
+	struct DSP_STREAMINFO {
+		u32 cbStruct;
+		u32 uNumberBufsAllowed;
+		u32 uNumberBufsInStream;
+		u32 ulNumberBytes;
+		HANDLE hSyncObjectHandle;
+		enum DSP_STREAMSTATE ssStreamState;
+	} ;
+
+/* DMM MAP attributes
+It is a bit mask with each bit value indicating a specific attribute
+bit 0 - GPP address type (user virtual=0, physical=1)
+bit 1 - MMU Endianism (Big Endian=1, Little Endian=0)
+bit 2 - MMU mixed page attribute (Mixed/ CPUES=1, TLBES =0)
+bit 3 - MMU element size = 8bit (valid only for non mixed page entries)
+bit 4 - MMU element size = 16bit (valid only for non mixed page entries)
+bit 5 - MMU element size = 32bit (valid only for non mixed page entries)
+bit 6 - MMU element size = 64bit (valid only for non mixed page entries)
+*/
+
+/* Types of mapping attributes */
+
+/* MPU address is virtual and needs to be translated to physical addr */
+#define DSP_MAPVIRTUALADDR          0x00000000
+#define DSP_MAPPHYSICALADDR         0x00000001
+
+/* Mapped data is big endian */
+#define DSP_MAPBIGENDIAN            0x00000002
+#define DSP_MAPLITTLEENDIAN         0x00000000
+
+/* Element size is based on DSP r/w access size */
+#define DSP_MAPMIXEDELEMSIZE        0x00000004
+
+/*
+ * Element size for MMU mapping (8, 16, 32, or 64 bit)
+ * Ignored if DSP_MAPMIXEDELEMSIZE enabled
+ */
+#define DSP_MAPELEMSIZE8            0x00000008
+#define DSP_MAPELEMSIZE16           0x00000010
+#define DSP_MAPELEMSIZE32           0x00000020
+#define DSP_MAPELEMSIZE64           0x00000040
+
+#define DSP_MAPVMALLOCADDR         0x00000080
+
+#define DSP_MAPDONOTLOCK	   0x00000100
+
+
+#define GEM_CACHE_LINE_SIZE     128
+#define GEM_L1P_PREFETCH_SIZE   128
+
+
+/*
+ * Definitions from dbreg.h
+ */
+
+#define DSPPROCTYPE_C64		6410
+#define IVAPROCTYPE_ARM7	470
+
+#define REG_MGR_OBJECT	1
+#define REG_DRV_OBJECT	2
+
+/* registry */
+#define DRVOBJECT	"DrvObject"
+#define MGROBJECT	"MgrObject"
+
+/* Max registry path length. Also the max registry value length. */
+#define MAXREGPATHLENGTH	255
+
+/* MiniDriver related definitions */
+#define DEFEXEC		"DefaultExecutable"	/* Default executable */
+#define AUTOSTART	"AutoStart"		/* Statically load flag */
+#define CURRENTCONFIG	"CurrentConfig"		/* Current resources */
+#define SHMSIZE		"SHMSize"		/* Size of SHM reservd on MPU */
+#define TCWORDSWAP	"TCWordSwap"		/* Traffic Controller WordSwp */
+#define DSPRESOURCES	"DspTMSResources"	/* C55 DSP resurces on OMAP */
+
+#endif				/* DBDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbldefs.h b/arch/arm/plat-omap/include/dspbridge/dbldefs.h
new file mode 100644
index 0000000..a180218
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbldefs.h
@@ -0,0 +1,145 @@
+/*
+ * dbldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBLDEFS_
+#define DBLDEFS_
+
+/*
+ *  Bit masks for DBL_Flags.
+ */
+#define DBL_NOLOAD   0x0	/* Don't load symbols, code, or data */
+#define DBL_SYMB     0x1	/* load symbols */
+#define DBL_CODE     0x2	/* load code */
+#define DBL_DATA     0x4	/* load data */
+#define DBL_DYNAMIC  0x8	/* dynamic load */
+#define DBL_BSS      0x20	/* Unitialized section */
+
+#define DBL_MAXPATHLENGTH       255
+
+
+
+/*
+ *  ======== DBL_Flags ========
+ *  Specifies whether to load code, data, or symbols
+ */
+typedef s32 DBL_Flags;
+
+/*
+ *  ======== DBL_SectInfo ========
+ *  For collecting info on overlay sections
+ */
+struct DBL_SectInfo {
+	const char *name;	/* name of section */
+	u32 runAddr;		/* run address of section */
+	u32 loadAddr;		/* load address of section */
+	u32 size;		/* size of section (target MAUs) */
+	DBL_Flags type;		/* Code, data, or BSS */
+} ;
+
+/*
+ *  ======== DBL_Symbol ========
+ *  (Needed for dynamic load library)
+ */
+struct DBL_Symbol {
+	u32 value;
+};
+
+/*
+ *  ======== DBL_AllocFxn ========
+ *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
+ *  "size" bytes of memory from segment "space" and return the address in
+ *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
+ *  success, or an error code on failure.
+ */
+typedef s32(*DBL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
+			u32 *dspAddr, s32 segId, s32 req, bool reserved);
+
+
+
+/*
+ *  ======== DBL_FreeFxn ========
+ *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
+ *  bytes of memory from segment "space"
+ */
+typedef bool(*DBL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
+			    bool reserved);
+
+/*
+ *  ======== DBL_LogWriteFxn ========
+ *  Function to call when writing data from a section, to log the info.
+ *  Can be NULL if no logging is required.
+ */
+typedef DSP_STATUS(*DBL_LogWriteFxn) (void *handle, struct DBL_SectInfo *sect,
+				      u32 addr, u32 nBytes);
+
+
+/*
+ *  ======== DBL_SymLookup ========
+ *  Symbol lookup function - Find the symbol name and return its value.
+ *
+ *  Parameters:
+ *      handle          - Opaque handle
+ *      pArg            - Opaque argument.
+ *      name            - Name of symbol to lookup.
+ *      sym             - Location to store address of symbol structure.
+ *
+ *  Returns:
+ *      TRUE:           Success (symbol was found).
+ *      FALSE:          Failed to find symbol.
+ */
+typedef bool(*DBL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
+			      const char *name, struct DBL_Symbol **sym);
+
+
+/*
+ *  ======== DBL_WriteFxn ========
+ *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
+ *  starting at address "dspAddr" from the buffer "buf".  The buffer is
+ *  formatted as an array of words appropriate for the DSP.
+ */
+typedef s32(*DBL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
+			    u32 n, s32 mtype);
+
+/*
+ *  ======== DBL_Attrs ========
+ */
+struct DBL_Attrs {
+	DBL_AllocFxn alloc;
+	DBL_FreeFxn free;
+	void *rmmHandle;	/* Handle to pass to alloc, free functions */
+	DBL_WriteFxn write;
+	void *wHandle;		/* Handle to pass to write, cinit function */
+
+	DBL_LogWriteFxn logWrite;
+	void *logWriteHandle;
+
+	/* Symbol matching function and handle to pass to it */
+	DBL_SymLookup symLookup;
+	void *symHandle;
+	void *symArg;
+
+	/*
+	 *  These file manipulation functions should be compatible with the
+	 *  "C" run time library functions of the same name.
+	 */
+	s32(*fread) (void *, size_t, size_t, void *);
+	s32(*fseek) (void *, long, int);
+	s32(*ftell) (void *);
+	s32(*fclose) (void *);
+	void *(*fopen) (const char *, const char *);
+} ;
+
+#endif				/* DBLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbll.h b/arch/arm/plat-omap/include/dspbridge/dbll.h
new file mode 100644
index 0000000..8c6eea7
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbll.h
@@ -0,0 +1,61 @@
+/*
+ * dbll.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ *  DSP/BIOS Bridge Dynamic load library module interface. Function header
+ *  comments are in the file dblldefs.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBLL_
+#define DBLL_
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/dblldefs.h>
+
+	extern void DBLL_close(struct DBLL_LibraryObj *lib);
+	extern DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget,
+				      struct DBLL_Attrs *pAttrs);
+	extern void DBLL_delete(struct DBLL_TarObj *target);
+	extern void DBLL_exit(void);
+	extern bool DBLL_getAddr(struct DBLL_LibraryObj *lib, char *name,
+				 struct DBLL_Symbol **ppSym);
+	extern void DBLL_getAttrs(struct DBLL_TarObj *target,
+				  struct DBLL_Attrs *pAttrs);
+	extern bool DBLL_getCAddr(struct DBLL_LibraryObj *lib, char *name,
+				  struct DBLL_Symbol **ppSym);
+	extern DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name,
+				       u32 *pAddr, u32 *pSize);
+	extern bool DBLL_init(void);
+	extern DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib,
+				    DBLL_Flags flags,
+				    struct DBLL_Attrs *attrs, u32 *pEntry);
+	extern DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *lib,
+					char *sectName,
+					struct DBLL_Attrs *attrs);
+	extern DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file,
+				    DBLL_Flags flags,
+				    struct DBLL_LibraryObj **pLib);
+	extern DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib,
+					char *name,
+					char *pBuf, u32 size);
+	extern void DBLL_setAttrs(struct DBLL_TarObj *target,
+				  struct DBLL_Attrs *pAttrs);
+	extern void DBLL_unload(struct DBLL_LibraryObj *lib,
+				struct DBLL_Attrs *attrs);
+	extern DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib,
+					  char *sectName,
+					  struct DBLL_Attrs *attrs);
+
+#endif				/* DBLL_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/dblldefs.h b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
new file mode 100644
index 0000000..21e661d
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
@@ -0,0 +1,498 @@
+/*
+ * dblldefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBLLDEFS_
+#define DBLLDEFS_
+
+/*
+ *  Bit masks for DBL_Flags.
+ */
+#define DBLL_NOLOAD   0x0	/* Don't load symbols, code, or data */
+#define DBLL_SYMB     0x1	/* load symbols */
+#define DBLL_CODE     0x2	/* load code */
+#define DBLL_DATA     0x4	/* load data */
+#define DBLL_DYNAMIC  0x8	/* dynamic load */
+#define DBLL_BSS      0x20	/* Unitialized section */
+
+#define DBLL_MAXPATHLENGTH       255
+
+
+/*
+ *  ======== DBLL_Target ========
+ *
+ */
+struct DBLL_TarObj;
+
+/*
+ *  ======== DBLL_Flags ========
+ *  Specifies whether to load code, data, or symbols
+ */
+typedef s32 DBLL_Flags;
+
+/*
+ *  ======== DBLL_Library ========
+ *
+ */
+struct DBLL_LibraryObj;
+
+/*
+ *  ======== DBLL_SectInfo ========
+ *  For collecting info on overlay sections
+ */
+struct DBLL_SectInfo {
+	const char *name;	/* name of section */
+	u32 runAddr;		/* run address of section */
+	u32 loadAddr;		/* load address of section */
+	u32 size;		/* size of section (target MAUs) */
+	DBLL_Flags type;	/* Code, data, or BSS */
+} ;
+
+/*
+ *  ======== DBLL_Symbol ========
+ *  (Needed for dynamic load library)
+ */
+struct DBLL_Symbol {
+	u32 value;
+};
+
+/*
+ *  ======== DBLL_AllocFxn ========
+ *  Allocate memory function.  Allocate or reserve (if reserved == TRUE)
+ *  "size" bytes of memory from segment "space" and return the address in
+ *  *dspAddr (or starting at *dspAddr if reserve == TRUE). Returns 0 on
+ *  success, or an error code on failure.
+ */
+typedef s32(*DBLL_AllocFxn) (void *hdl, s32 space, u32 size, u32 align,
+			     u32 *dspAddr, s32 segId, s32 req,
+			     bool reserved);
+
+/*
+ *  ======== DBLL_CloseFxn ========
+ */
+typedef s32(*DBLL_FCloseFxn) (void *);
+
+/*
+ *  ======== DBLL_FreeFxn ========
+ *  Free memory function.  Free, or unreserve (if reserved == TRUE) "size"
+ *  bytes of memory from segment "space"
+ */
+typedef bool(*DBLL_FreeFxn) (void *hdl, u32 addr, s32 space, u32 size,
+			     bool reserved);
+
+/*
+ *  ======== DBLL_FOpenFxn ========
+ */
+typedef void *(*DBLL_FOpenFxn) (const char *, const char *);
+
+/*
+ *  ======== DBLL_LogWriteFxn ========
+ *  Function to call when writing data from a section, to log the info.
+ *  Can be NULL if no logging is required.
+ */
+typedef DSP_STATUS(*DBLL_LogWriteFxn)(void *handle, struct DBLL_SectInfo *sect,
+				       u32 addr, u32 nBytes);
+
+/*
+ *  ======== DBLL_ReadFxn ========
+ */
+typedef s32(*DBLL_ReadFxn) (void *, size_t, size_t, void *);
+
+/*
+ *  ======== DBLL_SeekFxn ========
+ */
+typedef s32(*DBLL_SeekFxn) (void *, long, int);
+
+/*
+ *  ======== DBLL_SymLookup ========
+ *  Symbol lookup function - Find the symbol name and return its value.
+ *
+ *  Parameters:
+ *      handle          - Opaque handle
+ *      pArg            - Opaque argument.
+ *      name            - Name of symbol to lookup.
+ *      sym             - Location to store address of symbol structure.
+ *
+ *  Returns:
+ *      TRUE:           Success (symbol was found).
+ *      FALSE:          Failed to find symbol.
+ */
+typedef bool(*DBLL_SymLookup) (void *handle, void *pArg, void *rmmHandle,
+			       const char *name, struct DBLL_Symbol **sym);
+
+/*
+ *  ======== DBLL_TellFxn ========
+ */
+typedef s32(*DBLL_TellFxn) (void *);
+
+/*
+ *  ======== DBLL_WriteFxn ========
+ *  Write memory function.  Write "n" HOST bytes of memory to segment "mtype"
+ *  starting at address "dspAddr" from the buffer "buf".  The buffer is
+ *  formatted as an array of words appropriate for the DSP.
+ */
+typedef s32(*DBLL_WriteFxn) (void *hdl, u32 dspAddr, void *buf,
+			     u32 n, s32 mtype);
+
+/*
+ *  ======== DBLL_Attrs ========
+ */
+struct DBLL_Attrs {
+	DBLL_AllocFxn alloc;
+	DBLL_FreeFxn free;
+	void *rmmHandle;	/* Handle to pass to alloc, free functions */
+	DBLL_WriteFxn write;
+	void *wHandle;		/* Handle to pass to write, cinit function */
+	bool baseImage;
+	DBLL_LogWriteFxn logWrite;
+	void *logWriteHandle;
+
+	/* Symbol matching function and handle to pass to it */
+	DBLL_SymLookup symLookup;
+	void *symHandle;
+	void *symArg;
+
+	/*
+	 *  These file manipulation functions should be compatible with the
+	 *  "C" run time library functions of the same name.
+	 */
+	 s32(*fread) (void *, size_t, size_t, void *);
+	 s32(*fseek) (void *, long, int);
+	 s32(*ftell) (void *);
+	 s32(*fclose) (void *);
+	void *(*fopen) (const char *, const char *);
+} ;
+
+/*
+ *  ======== DBLL_close ========
+ *  Close library opened with DBLL_open.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+typedef void(*DBLL_CloseFxn) (struct DBLL_LibraryObj *library);
+
+/*
+ *  ======== DBLL_create ========
+ *  Create a target object, specifying the alloc, free, and write functions.
+ *  Parameters:
+ *      pTarget         - Location to store target handle on output.
+ *      pAttrs          - Attributes.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *      DBL initialized.
+ *      pAttrs != NULL.
+ *      pTarget != NULL;
+ *  Ensures:
+ *      Success:        *pTarget != NULL.
+ *      Failure:        *pTarget == NULL.
+ */
+typedef DSP_STATUS(*DBLL_CreateFxn)(struct DBLL_TarObj **pTarget,
+				    struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_delete ========
+ *  Delete target object and free resources for any loaded libraries.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_Create().
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *  Ensures:
+ */
+typedef void(*DBLL_DeleteFxn) (struct DBLL_TarObj *target);
+
+/*
+ *  ======== DBLL_exit ========
+ *  Discontinue use of DBL module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      cRefs > 0.
+ *  Ensures:
+ *      cRefs >= 0.
+ */
+typedef void(*DBLL_ExitFxn) (void);
+
+/*
+ *  ======== DBLL_getAddr ========
+ *  Get address of name in the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid library.
+ *      name != NULL.
+ *      ppSym != NULL.
+ *  Ensures:
+ */
+typedef bool(*DBLL_GetAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
+				struct DBLL_Symbol **ppSym);
+
+/*
+ *  ======== DBLL_getAttrs ========
+ *  Retrieve the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_Create().
+ *      pAttrs          - Location to store attributes on output.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+typedef void(*DBLL_GetAttrsFxn) (struct DBLL_TarObj *target,
+				 struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_getCAddr ========
+ *  Get address of "C" name on the specified library.
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      name            - Name of symbol
+ *      ppSym           - Location to store symbol address on output.
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Symbol not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      name != NULL.
+ *      ppSym != NULL.
+ *  Ensures:
+ */
+typedef bool(*DBLL_GetCAddrFxn) (struct DBLL_LibraryObj *lib, char *name,
+				 struct DBLL_Symbol **ppSym);
+
+/*
+ *  ======== DBLL_getSect ========
+ *  Get address and size of a named section.
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      name            - Name of section.
+ *      pAddr           - Location to store section address on output.
+ *      pSize           - Location to store section size on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pAddr != NULL;
+ *      pSize != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_GetSectFxn) (struct DBLL_LibraryObj *lib, char *name,
+				      u32 *addr, u32 *size);
+
+/*
+ *  ======== DBLL_init ========
+ *  Initialize DBL module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE:           Success.
+ *      FALSE:          Failure.
+ *  Requires:
+ *      cRefs >= 0.
+ *  Ensures:
+ *      Success:        cRefs > 0.
+ *      Failure:        cRefs >= 0.
+ */
+typedef bool(*DBLL_InitFxn) (void);
+
+/*
+ *  ======== DBLL_load ========
+ *  Load library onto the target.
+ *
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      flags           - Load code, data and/or symbols.
+ *      attrs           - May contain alloc, free, and write function.
+ *      pulEntry        - Location to store program entry on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFREAD:     File read failed.
+ *      DSP_EFWRITE:    Write to target failed.
+ *      DSP_EDYNLOAD:   Failure in dynamic loader library.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      pEntry != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_LoadFxn) (struct DBLL_LibraryObj *lib,
+				   DBLL_Flags flags,
+				   struct DBLL_Attrs *attrs, u32 *entry);
+
+/*
+ *  ======== DBLL_loadSect ========
+ *  Load a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains write function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Section not found.
+ *      DSP_EFWRITE:    Write function failed.
+ *      DSP_ENOTIMPL:   Function not implemented.
+ *  Requires:
+ *      Valid lib.
+ *      sectName != NULL.
+ *      attrs != NULL.
+ *      attrs->write != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_LoadSectFxn) (struct DBLL_LibraryObj *lib,
+				       char *pszSectName,
+				       struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_open ========
+ *  DBLL_open() returns a library handle that can be used to load/unload
+ *  the symbols/code/data via DBLL_load()/DBLL_unload().
+ *  Parameters:
+ *      target          - Handle returned from DBLL_create().
+ *      file            - Name of file to open.
+ *      flags           - If flags & DBLL_SYMB, load symbols.
+ *      pLib            - Location to store library handle on output.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Memory allocation failure.
+ *      DSP_EFOPEN:         File open failure.
+ *      DSP_EFREAD:         File read failure.
+ *      DSP_ECORRUPTFILE:   Unable to determine target type.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      file != NULL.
+ *      pLib != NULL.
+ *      DBLL_Attrs fopen function non-NULL.
+ *  Ensures:
+ *      Success:        Valid *pLib.
+ *      Failure:        *pLib == NULL.
+ */
+typedef DSP_STATUS(*DBLL_OpenFxn) (struct DBLL_TarObj *target, char *file,
+				   DBLL_Flags flags,
+				   struct DBLL_LibraryObj **pLib);
+
+/*
+ *  ======== DBLL_readSect ========
+ *  Read COFF section into a character buffer.
+ *  Parameters:
+ *      lib             - Library handle returned from DBLL_open().
+ *      name            - Name of section.
+ *      pBuf            - Buffer to write section contents into.
+ *      size            - Buffer size
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section does not exists.
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      name != NULL.
+ *      pBuf != NULL.
+ *      size != 0.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_ReadSectFxn) (struct DBLL_LibraryObj *lib, char *name,
+				       char *content, u32 uContentSize);
+
+/*
+ *  ======== DBLL_setAttrs ========
+ *  Set the attributes of the target.
+ *  Parameters:
+ *      target          - Handle returned from DBLL_create().
+ *      pAttrs          - New attributes.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid target.
+ *      pAttrs != NULL.
+ *  Ensures:
+ */
+typedef void(*DBLL_SetAttrsFxn)(struct DBLL_TarObj *target,
+				struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_unload ========
+ *  Unload library loaded with DBLL_load().
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *  Ensures:
+ */
+typedef void(*DBLL_UnloadFxn) (struct DBLL_LibraryObj *library,
+			       struct DBLL_Attrs *attrs);
+
+/*
+ *  ======== DBLL_unloadSect ========
+ *  Unload a named section from an library (for overlay support).
+ *  Parameters:
+ *      lib             - Handle returned from DBLL_open().
+ *      sectName        - Name of section to load.
+ *      attrs           - Contains free() function and handle to pass to it.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ENOSECT:    Named section not found.
+ *      DSP_ENOTIMPL
+ *  Requires:
+ *      DBL initialized.
+ *      Valid lib.
+ *      sectName != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*DBLL_UnloadSectFxn) (struct DBLL_LibraryObj *lib,
+					 char *pszSectName,
+					 struct DBLL_Attrs *attrs);
+
+struct DBLL_Fxns {
+	DBLL_CloseFxn closeFxn;
+	DBLL_CreateFxn createFxn;
+	DBLL_DeleteFxn deleteFxn;
+	DBLL_ExitFxn exitFxn;
+	DBLL_GetAttrsFxn getAttrsFxn;
+	DBLL_GetAddrFxn getAddrFxn;
+	DBLL_GetCAddrFxn getCAddrFxn;
+	DBLL_GetSectFxn getSectFxn;
+	DBLL_InitFxn initFxn;
+	DBLL_LoadFxn loadFxn;
+	DBLL_LoadSectFxn loadSectFxn;
+	DBLL_OpenFxn openFxn;
+	DBLL_ReadSectFxn readSectFxn;
+	DBLL_SetAttrsFxn setAttrsFxn;
+	DBLL_UnloadFxn unloadFxn;
+	DBLL_UnloadSectFxn unloadSectFxn;
+} ;
+
+#endif				/* DBLDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dbtype.h b/arch/arm/plat-omap/include/dspbridge/dbtype.h
new file mode 100644
index 0000000..019652e
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dbtype.h
@@ -0,0 +1,90 @@
+/*
+ * dbtype.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This header defines data types for DSP/BIOS Bridge APIs and device
+ * driver modules. It also defines the Hungarian prefix to use for each
+ * base type.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DBTYPE_
+#define DBTYPE_
+
+/*============================================================================*/
+/*  Argument specification syntax                                             */
+/*============================================================================*/
+
+#ifndef IN
+#define IN			/* Following parameter is for input. */
+#endif
+
+#ifndef OUT
+#define OUT			/* Following parameter is for output. */
+#endif
+
+#ifndef OPTIONAL
+#define OPTIONAL	  /* Function may optionally use previous parameter. */
+#endif
+
+#ifndef CONST
+#define CONST   const
+#endif
+
+/*============================================================================*/
+/*  Boolean constants                                                         */
+/*============================================================================*/
+
+#ifndef FALSE
+#define FALSE   0
+#endif
+#ifndef TRUE
+#define TRUE    1
+#endif
+
+/*============================================================================*/
+/*  NULL    (Definition is language specific)                                 */
+/*============================================================================*/
+
+#ifndef NULL
+#define NULL    ((void *)0)	/* Null pointer. */
+#endif
+
+/*============================================================================*/
+/*  NULL character   (normally used for string termination)                   */
+/*============================================================================*/
+
+#ifndef NULL_CHAR
+#define NULL_CHAR    '\0'	/* Null character. */
+#endif
+
+/*============================================================================*/
+/*  Basic Type definitions (with Prefixes for Hungarian notation)             */
+/*============================================================================*/
+
+#ifndef OMAPBRIDGE_TYPES
+#define OMAPBRIDGE_TYPES
+typedef volatile unsigned short REG_UWORD16;
+#endif
+
+typedef void *HANDLE;		/* h    */
+
+#define TEXT(x) x
+
+#define DLLIMPORT
+#define DLLEXPORT
+
+/* Define DSPAPIDLL correctly in dspapi.h */
+#define _DSPSYSDLL32_
+
+#endif				/* DBTYPE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dehdefs.h b/arch/arm/plat-omap/include/dspbridge/dehdefs.h
new file mode 100644
index 0000000..587df7f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dehdefs.h
@@ -0,0 +1,32 @@
+/*
+ * dehdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definition for mini-driver module DEH.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DEHDEFS_
+#define DEHDEFS_
+
+#include <dspbridge/mbx_sh.h>		/* shared mailbox codes */
+
+/* DEH object manager */
+	struct DEH_MGR;
+
+/* Magic code used to determine if DSP signaled exception. */
+#define DEH_BASE        MBX_DEH_BASE
+#define DEH_USERS_BASE  MBX_DEH_USERS_BASE
+#define DEH_LIMIT       MBX_DEH_LIMIT
+
+#endif				/* _DEHDEFS_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/dev.h b/arch/arm/plat-omap/include/dspbridge/dev.h
new file mode 100644
index 0000000..cb594f7
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -0,0 +1,725 @@
+/*
+ * dev.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Bridge Mini-driver device operations.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DEV_
+#define DEV_
+
+/*  ----------------------------------- Module Dependent Headers */
+#include <dspbridge/chnldefs.h>
+#include <dspbridge/cmm.h>
+#include <dspbridge/cod.h>
+#include <dspbridge/dehdefs.h>
+#include <dspbridge/nodedefs.h>
+#include <dspbridge/dispdefs.h>
+#include <dspbridge/wmd.h>
+#include <dspbridge/dmm.h>
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/devdefs.h>
+
+
+/*
+ *  ======== DEV_BrdWriteFxn ========
+ *  Purpose:
+ *      Exported function to be used as the COD write function.  This function
+ *      is passed a handle to a DEV_hObject by ZL in pArb, then calls the
+ *      device's WMD_BRD_Write() function.
+ *  Parameters:
+ *      pArb:           Handle to a Device Object.
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      Number of bytes written.  Returns 0 if the DEV_hObject passed in via
+ *      pArb is invalid.
+ *  Requires:
+ *      DEV Initialized.
+ *      pHostBuf != NULL
+ *  Ensures:
+ */
+       extern u32 DEV_BrdWriteFxn(void *pArb,
+					   u32 ulDspAddr,
+					   void *pHostBuf,
+					   u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== DEV_CreateDevice ========
+ *  Purpose:
+ *      Called by the operating system to load the 'Bridge Mini Driver for a
+ *      'Bridge device.
+ *  Parameters:
+ *      phDevObject:    Ptr to location to receive the device object handle.
+ *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
+ *                      path is not provided, the file is loaded through
+ *                      'Bridge's module search path.
+ *      pHostConfig:    Host configuration information, to be passed down
+ *                      to the WMD when WMD_DEV_Create() is called.
+ *      pDspConfig:     DSP resources, to be passed down to the WMD when
+ *                      WMD_DEV_Create() is called.
+ *      hDevNode:       Platform (Windows) specific device node.
+ *  Returns:
+ *      DSP_SOK:            Module is loaded, device object has been created
+ *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
+ *                          for this hDevNode.
+ *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
+ *      LDR_E_NOMEMORY:         PELDR is out of resources.
+ *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
+ *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
+ *  Requires:
+ *      DEV Initialized.
+ *      phDevObject != NULL.
+ *      pstrWMDFileName != NULL.
+ *      pHostConfig != NULL.
+ *      pDspConfig != NULL.
+ *  Ensures:
+ *      DSP_SOK:  *phDevObject will contain handle to the new device object.
+ *      Otherwise, does not create the device object, ensures the WMD module is
+ *      unloaded, and sets *phDevObject to NULL.
+ */
+       extern DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT
+						 **phDevObject,
+						 IN CONST char *pstrWMDFileName,
+						 IN CONST struct CFG_HOSTRES
+						 *pHostConfig,
+						 IN CONST struct CFG_DSPRES
+						 *pDspConfig,
+						 struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_CreateIVADevice ========
+ *  Purpose:
+ *      Called by the operating system to load the 'Bridge Mini Driver for IVA.
+ *  Parameters:
+ *      phDevObject:    Ptr to location to receive the device object handle.
+ *      pstrWMDFileName: Name of WMD PE DLL file to load.  If the absolute
+ *                      path is not provided, the file is loaded through
+ *                      'Bridge's module search path.
+ *      pHostConfig:    Host configuration information, to be passed down
+ *                      to the WMD when WMD_DEV_Create() is called.
+ *      pDspConfig:     DSP resources, to be passed down to the WMD when
+ *                      WMD_DEV_Create() is called.
+ *      hDevNode:       Platform (Windows) specific device node.
+ *  Returns:
+ *      DSP_SOK:            Module is loaded, device object has been created
+ *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
+ *      DEV_E_NULLWMDINTF:  WMD passed back a NULL Fxn Interface Struct Ptr
+ *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
+ *                          for this hDevNode.
+ *      LDR_E_FILEUNABLETOOPEN: Unable to open the specified WMD.
+ *      LDR_E_NOMEMORY:         PELDR is out of resources.
+ *      DSP_EFAIL:              Unable to find WMD entry point function.
+ *      COD_E_NOZLFUNCTIONS:    One or more ZL functions exports not found.
+ *      COD_E_ZLCREATEFAILED:   Unable to load ZL DLL.
+ *  Requires:
+ *      DEV Initialized.
+ *      phDevObject != NULL.
+ *      pstrWMDFileName != NULL.
+ *      pHostConfig != NULL.
+ *      pDspConfig != NULL.
+ *  Ensures:
+ *      DSP_SOK:  *phDevObject will contain handle to the new device object.
+ *      Otherwise, does not create the device object, ensures the WMD module is
+ *      unloaded, and sets *phDevObject to NULL.
+ */
+       extern DSP_STATUS DEV_CreateIVADevice(OUT struct DEV_OBJECT
+				**phDevObject,
+				IN CONST char *pstrWMDFileName,
+				IN CONST struct CFG_HOSTRES *pHostConfig,
+				IN CONST struct CFG_DSPRES *pDspConfig,
+				struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_Create2 ========
+ *  Purpose:
+ *      After successful loading of the image from WCD_InitComplete2
+ *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      the Node Manager and updates the DEV Object.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:    Successful Creation of Node Manager
+ *      DSP_EFAIL:  Some Error Occurred.
+ *  Requires:
+ *      DEV Initialized
+ *      Valid hDevObject
+ *  Ensures:
+ *      DSP_SOK and hDevObject->hNodeMgr != NULL
+ *      else    hDevObject->hNodeMgr == NULL
+ */
+       extern DSP_STATUS DEV_Create2(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_Destroy2 ========
+ *  Purpose:
+ *      Destroys the Node manager for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:    Successful Creation of Node Manager
+ *      DSP_EFAIL:  Some Error Occurred.
+ *  Requires:
+ *      DEV Initialized
+ *      Valid hDevObject
+ *  Ensures:
+ *      DSP_SOK and hDevObject->hNodeMgr == NULL
+ *      else    DSP_EFAIL.
+ */
+       extern DSP_STATUS DEV_Destroy2(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_DestroyDevice ========
+ *  Purpose:
+ *      Destroys the channel manager for this device, if any, calls
+ *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *      DSP_EFAIL:      The WMD failed it's WMD_DEV_Destroy() function.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT
+						  *hDevObject);
+
+/*
+ *  ======== DEV_GetChnlMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the channel manager created for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
+					       OUT struct CHNL_MGR **phMgr);
+
+/*
+ *  ======== DEV_GetCmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the shared memory manager created for this
+ *      device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct CMM_OBJECT **phMgr);
+
+/*
+ *  ======== DEV_GetDmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the dynamic memory manager created for this
+ *      device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to a channel manager object,
+ *                      or NULL.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct DMM_OBJECT **phMgr);
+
+/*
+ *  ======== DEV_GetCodMgr ========
+ *  Purpose:
+ *      Retrieve the COD manager create for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phCodMgr:      Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phCodMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phCodMgr contains a handle to a COD manager object.
+ *      else:           *phCodMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
+					     OUT struct COD_MANAGER **phCodMgr);
+
+/*
+ *  ======== DEV_GetDehMgr ========
+ *  Purpose:
+ *      Retrieve the DEH manager created for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      *phDehMgr:  Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EHANDLE:   Invalid hDevObject.
+ *  Requires:
+ *      phDehMgr != NULL.
+ *      DEH Initialized.
+ *  Ensures:
+ *      DSP_SOK:    *phDehMgr contains a handle to a DEH manager object.
+ *      else:       *phDehMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
+					      OUT struct DEH_MGR **phDehMgr);
+
+/*
+ *  ======== DEV_GetDevNode ========
+ *  Purpose:
+ *      Retrieve the platform specific device ID for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      phDevNode:      Ptr to location to get the device node handle.
+ *  Returns:
+ *      DSP_SOK:        In Win95, returns a DEVNODE in *hDevNode; In NT, ???
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phDevNode != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phDevNode contains a platform specific device ID;
+ *      else:           *phDevNode is NULL.
+ */
+       extern DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
+					OUT struct CFG_DEVNODE **phDevNode);
+
+/*
+ *  ======== DEV_GetDevType ========
+ *  Purpose:
+ *      Retrieve the platform specific device ID for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      phDevNode:      Ptr to location to get the device node handle.
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phDevNode != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phDevNode contains a platform specific device ID;
+ *      else:           *phDevNode is NULL.
+ */
+       extern DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject,
+					       u32 *devType);
+
+/*
+ *  ======== DEV_GetFirst ========
+ *  Purpose:
+ *      Retrieve the first Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DEV.
+ *  Parameters:
+ *  Returns:
+ *      NULL if there are no device objects stored; else
+ *      a valid DEV_HOBJECT.
+ *  Requires:
+ *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
+ *      internal device object list) may occur between calls to DEV_GetFirst
+ *      and DEV_GetNext.
+ *  Ensures:
+ *      The DEV_HOBJECT returned is valid.
+ *      A subsequent call to DEV_GetNext will return the next device object in
+ *      the list.
+ */
+       extern struct DEV_OBJECT *DEV_GetFirst(void);
+
+/*
+ *  ======== DEV_GetIntfFxns ========
+ *  Purpose:
+ *      Retrieve the WMD interface function structure for the loaded WMD.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *ppIntfFxns:    Ptr to location to store fxn interface.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      ppIntfFxns != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *ppIntfFxns contains a pointer to the WMD interface;
+ *      else:           *ppIntfFxns is NULL.
+ */
+       extern DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
+				OUT struct WMD_DRV_INTERFACE **ppIntfFxns);
+
+/*
+ *  ======== DEV_GetIOMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the IO manager created for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      *phMgr:         Ptr to location to store handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phMgr != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phMgr contains a handle to an IO manager object.
+ *      else:           *phMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
+					     OUT struct IO_MGR **phMgr);
+
+/*
+ *  ======== DEV_GetNext ========
+ *  Purpose:
+ *      Retrieve the next Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DEV, after having previously called
+ *      DEV_GetFirst() and zero or more DEV_GetNext
+ *  Parameters:
+ *      hDevObject: Handle to the device object returned from a previous
+ *                  call to DEV_GetFirst() or DEV_GetNext().
+ *  Returns:
+ *      NULL if there are no further device objects on the list or hDevObject
+ *      was invalid;
+ *      else the next valid DEV_HOBJECT in the list.
+ *  Requires:
+ *      No calls to DEV_CreateDevice or DEV_DestroyDevice (which my modify the
+ *      internal device object list) may occur between calls to DEV_GetFirst
+ *      and DEV_GetNext.
+ *  Ensures:
+ *      The DEV_HOBJECT returned is valid.
+ *      A subsequent call to DEV_GetNext will return the next device object in
+ *      the list.
+ */
+       extern struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT
+						    *hDevObject);
+
+/*
+ *  ========= DEV_GetMsgMgr ========
+ *  Purpose:
+ *      Retrieve the MSG Manager Handle from the DevObject.
+ *  Parameters:
+ *      hDevObject: Handle to the Dev Object
+ *      phMsgMgr:   Location where MSG Manager handle will be returned.
+ *  Returns:
+ *  Requires:
+ *      DEV Initialized.
+ *      Valid hDevObject.
+ *      phNodeMgr != NULL.
+ *  Ensures:
+ */
+       extern void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
+					OUT struct MSG_MGR **phMsgMgr);
+
+/*
+ *  ========= DEV_GetNodeManager ========
+ *  Purpose:
+ *      Retrieve the Node Manager Handle from the DevObject. It is an
+ *      accessor function
+ *  Parameters:
+ *      hDevObject:     Handle to the Dev Object
+ *      phNodeMgr:      Location where Handle to the Node Manager will be
+ *                      returned..
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EHANDLE:    Invalid Dev Object handle.
+ *  Requires:
+ *      DEV Initialized.
+ *      phNodeMgr is not null
+ *  Ensures:
+ *      DSP_SOK:        *phNodeMgr contains a handle to a Node manager object.
+ *      else:           *phNodeMgr is NULL.
+ */
+       extern DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT
+					*hDevObject,
+					OUT struct NODE_MGR **phNodeMgr);
+
+/*
+ *  ======== DEV_GetSymbol ========
+ *  Purpose:
+ *      Get the value of a symbol in the currently loaded program.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      pstrSym:        Name of symbol to look up.
+ *      pulValue:       Ptr to symbol value.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *      COD_E_NOSYMBOLSLOADED:  Symbols have not been loaded onto the board.
+ *      COD_E_SYMBOLNOTFOUND:   The symbol could not be found.
+ *  Requires:
+ *      pstrSym != NULL.
+ *      pulValue != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *pulValue contains the symbol value;
+ */
+       extern DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
+					      IN CONST char *pstrSym,
+					      OUT u32 *pulValue);
+
+/*
+ *  ======== DEV_GetWMDContext ========
+ *  Purpose:
+ *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with DEV_CreateDevice()
+ *      *phWmdContext:  Ptr to location to store context handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      phWmdContext != NULL.
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK:        *phWmdContext contains context handle;
+ *      else:           *phWmdContext is NULL;
+ */
+       extern DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
+				OUT struct WMD_DEV_CONTEXT **phWmdContext);
+
+/*
+ *  ======== DEV_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DEV is initialized.
+ *  Ensures:
+ *      When reference count == 0, DEV's private resources are freed.
+ */
+       extern void DEV_Exit(void);
+
+/*
+ *  ======== DEV_Init ========
+ *  Purpose:
+ *      Initialize DEV's private state, keeping a reference count on each call.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public DEV functions.
+ */
+       extern bool DEV_Init(void);
+
+/*
+ *  ======== DEV_IsLocked ========
+ *  Purpose:
+ *      Predicate function to determine if the device has been
+ *      locked by a client for exclusive access.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *  Returns:
+ *      DSP_SOK:        TRUE: device has been locked.
+ *      DSP_SFALSE:     FALSE: device not locked.
+ *      DSP_EHANDLE:    hDevObject was invalid.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_IsLocked(IN struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DEV_InsertProcObject ========
+ *  Purpose:
+ *      Inserts the Processor Object into the List of PROC Objects
+ *      kept in the DEV Object
+ *  Parameters:
+ *      hProcObject:    Handle to the Proc Object
+ *      hDevObject      Handle to the Dev Object
+ *      bAttachedNew    Specifies if there are already processors attached
+ *  Returns:
+ *      DSP_SOK:        Successfully inserted into the list
+ *  Requires:
+ *      hProcObject is not NULL
+ *      hDevObject is a valid handle to the DEV.
+ *      DEV Initialized.
+ *      List(of Proc object in Dev) Exists.
+ *  Ensures:
+ *      DSP_SOK & the PROC Object is inserted and the list is not empty
+ *  Details:
+ *      If the List of Proc Object is empty bAttachedNew is TRUE, it indicated
+ *      this is the first Processor attaching.
+ *      If it is False, there are already processors attached.
+ */
+       extern DSP_STATUS DEV_InsertProcObject(IN struct DEV_OBJECT
+						     *hDevObject,
+						     IN u32 hProcObject,
+						     OUT bool *
+						     pbAlreadyAttached);
+
+/*
+ *  ======== DEV_RemoveProcObject ========
+ *  Purpose:
+ *      Search for and remove a Proc object from the given list maintained
+ *      by the DEV
+ *  Parameters:
+ *      pProcObject:        Ptr to ProcObject to insert.
+ *      pDevObject:         Ptr to Dev Object where the list is.
+ *      pbAlreadyAttached:  Ptr to return the bool
+ *  Returns:
+ *      DSP_SOK:            If successful.
+ *      DSP_EFAIL           Failure to Remove the PROC Object from the list
+ *  Requires:
+ *      DevObject is Valid
+ *      hProcObject != 0
+ *      pDevObject->procList != NULL
+ *      !LST_IsEmpty(pDevObject->procList)
+ *      pbAlreadyAttached !=NULL
+ *  Ensures:
+ *  Details:
+ *      List will be deleted when the DEV is destroyed.
+ *
+ */
+       extern DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT
+						     *hDevObject,
+						     u32 hProcObject);
+
+/*
+ *  ======== DEV_NotifyClients ========
+ *  Purpose:
+ *      Notify all clients of this device of a change in device status.
+ *      Clients may include multiple users of BRD, as well as CHNL.
+ *      This function is asychronous, and may be called by a timer event
+ *      set up by a watchdog timer.
+ *  Parameters:
+ *      hDevObject:  Handle to device object created with DEV_CreateDevice().
+ *      ulStatus:    A status word, most likely a BRD_STATUS.
+ *  Returns:
+ *      DSP_SOK:     All registered clients were asynchronously notified.
+ *      DSP_EINVALIDARG:   Invalid hDevObject.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ *      DSP_SOK: Notifications are queued by the operating system to be
+ *      delivered to clients.  This function does not ensure that
+ *      the notifications will ever be delivered.
+ */
+       extern DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject,
+						  u32 ulStatus);
+
+
+
+/*
+ *  ======== DEV_RemoveDevice ========
+ *  Purpose:
+ *      Destroys the Device Object created by DEV_StartDevice.
+ *  Parameters:
+ *      hDevNode:       Device node as it is know to OS.
+ *  Returns:
+ *      DSP_SOK:        If success;
+ *      <error code>    Otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== DEV_SetChnlMgr ========
+ *  Purpose:
+ *      Set the channel manager for this device.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *      hMgr:           Handle to a channel manager, or NULL.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hDevObject.
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject,
+					       struct CHNL_MGR *hMgr);
+
+/*
+ *  ======== DEV_SetMsgMgr ========
+ *  Purpose:
+ *      Set the Message manager for this device.
+ *  Parameters:
+ *      hDevObject: Handle to device object created with DEV_CreateDevice().
+ *      hMgr:       Handle to a message manager, or NULL.
+ *  Returns:
+ *  Requires:
+ *      DEV Initialized.
+ *  Ensures:
+ */
+       extern void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject,
+					struct MSG_MGR *hMgr);
+
+/*
+ *  ======== DEV_StartDevice ========
+ *  Purpose:
+ *      Initializes the new device with the WinBRIDGE environment.  This
+ *      involves querying CM for allocated resources, querying the registry
+ *      for necessary dsp resources (requested in the INF file), and using
+ *      this information to create a WinBRIDGE device object.
+ *  Parameters:
+ *      hDevNode:       Device node as it is know to OS.
+ *  Returns:
+ *      DSP_SOK:        If success;
+ *      <error code>    Otherwise.
+ *  Requires:
+ *      DEV initialized.
+ *  Ensures:
+ */
+       extern DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode);
+
+#endif				/* DEV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/devdefs.h b/arch/arm/plat-omap/include/dspbridge/devdefs.h
new file mode 100644
index 0000000..08b2490
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/devdefs.h
@@ -0,0 +1,26 @@
+/*
+ * devdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definition of common include typedef between wmd.h and dev.h. Required
+ * to break circular dependency between WMD and DEV include files.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DEVDEFS_
+#define DEVDEFS_
+
+/* WCD Device Object */
+	struct DEV_OBJECT;
+
+#endif				/* DEVDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/disp.h b/arch/arm/plat-omap/include/dspbridge/disp.h
new file mode 100644
index 0000000..135f266
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/disp.h
@@ -0,0 +1,209 @@
+/*
+ * disp.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Node Dispatcher.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DISP_
+#define DISP_
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/nodedefs.h>
+#include <dspbridge/nodepriv.h>
+#include <dspbridge/dispdefs.h>
+
+/*
+ *  ======== DISP_Create ========
+ *  Create a NODE Dispatcher object. This object handles the creation,
+ *  deletion, and execution of nodes on the DSP target, through communication
+ *  with the Resource Manager Server running on the target. Each NODE
+ *  Manager object should have exactly one NODE Dispatcher.
+ *
+ *  Parameters:
+ *      phDispObject:   Location to store node dispatcher object on output.
+ *      hDevObject:     Device for this processor.
+ *      pDispAttrs:     Node dispatcher attributes.
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      DSP_EFAIL:              Unable to create dispatcher.
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      pDispAttrs != NULL.
+ *      hDevObject != NULL.
+ *      phDispObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        IsValid(*phDispObject).
+ *      error:          *phDispObject == NULL.
+ */
+	extern DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct DISP_ATTRS *pDispAttrs);
+
+/*
+ *  ======== DISP_Delete ========
+ *  Delete the NODE Dispatcher.
+ *
+ *  Parameters:
+ *      hDispObject:  Node Dispatcher object.
+ *  Returns:
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      Valid hDispObject.
+ *  Ensures:
+ *      hDispObject is invalid.
+ */
+	extern void DISP_Delete(struct DISP_OBJECT *hDispObject);
+
+/*
+ *  ======== DISP_Exit ========
+ *  Discontinue usage of DISP module.
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      DISP_Init(void) previously called.
+ *  Ensures:
+ *      Any resources acquired in DISP_Init(void) will be freed when last DISP
+ *      client calls DISP_Exit(void).
+ */
+	extern void DISP_Exit(void);
+
+/*
+ *  ======== DISP_Init ========
+ *  Initialize the DISP module.
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool DISP_Init(void);
+
+/*
+ *  ======== DISP_NodeChangePriority ========
+ *  Change the priority of a node currently running on the target.
+ *
+ *  Parameters:
+ *      hDispObject:            Node Dispatcher object.
+ *      hNode:                  Node object representing a node currently
+ *                              allocated or running on the DSP.
+ *      ulFxnAddress:           Address of RMS function for changing priority.
+ *      nodeEnv:                Address of node's environment structure.
+ *      nPriority:              New priority level to set node's priority to.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_ETIMEOUT:           A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT
+						  *hDispObject,
+						  struct NODE_OBJECT *hNode,
+						  u32 ulFxnAddr,
+						  NODE_ENV nodeEnv,
+						  s32 nPriority);
+
+/*
+ *  ======== DISP_NodeCreate ========
+ *  Create a node on the DSP by remotely calling the node's create function.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node handle obtained from NODE_Allocate().
+ *      ulFxnAddr:      Address or RMS create node function.
+ *      ulCreateFxn:    Address of node's create function.
+ *      pArgs:          Arguments to pass to RMS node create function.
+ *      pNodeEnv:       Location to store node environment pointer on
+ *                      output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETASK:      Unable to create the node's task or process on the DSP.
+ *      DSP_ESTREAM:    Stream creation failure on the DSP.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *      DSP_EUSER:      A user-defined failure occurred.
+ *      DSP_EFAIL:      A failure occurred, unable to create node.
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      Valid hDispObject.
+ *      pArgs != NULL.
+ *      hNode != NULL.
+ *      pNodeEnv != NULL.
+ *      NODE_GetType(hNode) != NODE_DEVICE.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDispObject,
+					  struct NODE_OBJECT *hNode,
+					  u32 ulFxnAddr,
+					  u32 ulCreateFxn,
+					  IN CONST struct NODE_CREATEARGS
+					  *pArgs,
+					  OUT NODE_ENV *pNodeEnv);
+
+/*
+ *  ======== DISP_NodeDelete ========
+ *  Delete a node on the DSP by remotely calling the node's delete function.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node object representing a node currently
+ *                      loaded on the DSP.
+ *      ulFxnAddr:      Address or RMS delete node function.
+ *      ulDeleteFxn:    Address of node's delete function.
+ *      nodeEnv:        Address of node's environment structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDispObject,
+					  struct NODE_OBJECT *hNode,
+					  u32 ulFxnAddr,
+					  u32 ulDeleteFxn, NODE_ENV nodeEnv);
+
+/*
+ *  ======== DISP_NodeRun ========
+ *  Start execution of a node's execute phase, or resume execution of a node
+ *  that has been suspended (via DISP_NodePause()) on the DSP.
+ *
+ *  Parameters:
+ *      hDispObject:    Node Dispatcher object.
+ *      hNode:          Node object representing a node to be executed
+ *                      on the DSP.
+ *      ulFxnAddr:      Address or RMS node execute function.
+ *      ulExecuteFxn:   Address of node's execute function.
+ *      nodeEnv:        Address of node's environment structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   A timeout occurred before the DSP responded.
+ *  Requires:
+ *      DISP_Init(void) called.
+ *      Valid hDispObject.
+ *      hNode != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDispObject,
+				       struct NODE_OBJECT *hNode,
+				       u32 ulFxnAddr,
+				       u32 ulExecuteFxn, NODE_ENV nodeEnv);
+
+#endif				/* DISP_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dispdefs.h b/arch/arm/plat-omap/include/dspbridge/dispdefs.h
new file mode 100644
index 0000000..b237450
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dispdefs.h
@@ -0,0 +1,35 @@
+/*
+ * dispdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global DISP constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DISPDEFS_
+#define DISPDEFS_
+
+	struct DISP_OBJECT;
+
+/* Node Dispatcher attributes */
+	struct DISP_ATTRS {
+		u32 ulChnlOffset; /* Offset of channel ids reserved for RMS */
+		/* Size of buffer for sending data to RMS */
+		u32 ulChnlBufSize;
+		int procFamily;	/* eg, 5000 */
+		int procType;		/* eg, 5510 */
+		HANDLE hReserved1;	/* Reserved for future use. */
+		u32 hReserved2;	/* Reserved for future use. */
+	} ;
+
+#endif				/* DISPDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dmm.h b/arch/arm/plat-omap/include/dspbridge/dmm.h
new file mode 100644
index 0000000..688473a
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dmm.h
@@ -0,0 +1,72 @@
+/*
+ * dmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * The Dynamic Memory Mapping(DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DMM_
+#define DMM_
+
+#include <dspbridge/dbdefs.h>
+
+	struct DMM_OBJECT;
+
+/* DMM attributes used in DMM_Create() */
+	struct DMM_MGRATTRS {
+		u32 reserved;
+	} ;
+
+#define DMMPOOLSIZE      0x4000000
+
+/*
+ *  ======== DMM_GetHandle ========
+ *  Purpose:
+ *      Return the dynamic memory manager object for this device.
+ *      This is typically called from the client process.
+ */
+
+	extern DSP_STATUS DMM_GetHandle(void *hProcessor,
+					OUT struct DMM_OBJECT **phDmmMgr);
+
+	extern DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr,
+					    u32 size,
+					    u32 *pRsvAddr);
+
+	extern DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr,
+					      u32 rsvAddr);
+
+	extern DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr,
+					u32 size);
+
+	extern DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr,
+					  u32 addr,
+					  u32 *pSize);
+
+	extern DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr);
+
+	extern DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr);
+
+	extern DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     IN CONST struct DMM_MGRATTRS *pMgrAttrs);
+
+	extern bool DMM_Init(void);
+
+	extern void DMM_Exit(void);
+
+	extern DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr,
+						u32 addr, u32 size);
+#endif				/* DMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
new file mode 100644
index 0000000..3f714b2
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -0,0 +1,396 @@
+/*
+ * drv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DRV Resource allocation module. Driver Object gets Created
+ * at the time of Loading. It holds the List of Device Objects
+ * in the system.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DRV_
+#define DRV_
+
+#include <dspbridge/devdefs.h>
+
+#include <dspbridge/drvdefs.h>
+
+#define DRV_ASSIGN     1
+#define DRV_RELEASE    0
+
+/* Provide the DSP Internal memory windows that can be accessed from L3 address
+ * space */
+
+#define OMAP_GEM_BASE   0x107F8000
+#define OMAP_DSP_SIZE   0x00720000
+
+/* MEM1 is L2 RAM + L2 Cache space */
+#define OMAP_DSP_MEM1_BASE 0x5C7F8000
+#define OMAP_DSP_MEM1_SIZE 0x18000
+#define OMAP_DSP_GEM1_BASE 0x107F8000
+
+
+/* MEM2 is L1P RAM/CACHE space */
+#define OMAP_DSP_MEM2_BASE 0x5CE00000
+#define OMAP_DSP_MEM2_SIZE 0x8000
+#define OMAP_DSP_GEM2_BASE 0x10E00000
+
+/* MEM3 is L1D RAM/CACHE space */
+#define OMAP_DSP_MEM3_BASE 0x5CF04000
+#define OMAP_DSP_MEM3_SIZE 0x14000
+#define OMAP_DSP_GEM3_BASE 0x10F04000
+
+
+#define OMAP_IVA2_PRM_BASE 0x48306000
+#define OMAP_IVA2_PRM_SIZE 0x1000
+
+#define OMAP_IVA2_CM_BASE 0x48004000
+#define OMAP_IVA2_CM_SIZE 0x1000
+
+#define OMAP_PER_CM_BASE 0x48005000
+#define OMAP_PER_CM_SIZE 0x1000
+
+#define OMAP_PER_PRM_BASE 0x48307000
+#define OMAP_PER_PRM_SIZE 0x1000
+
+#define OMAP_CORE_PRM_BASE 0x48306A00
+#define OMAP_CORE_PRM_SIZE 0x1000
+
+#define OMAP_SYSC_BASE 0x48002000
+#define OMAP_SYSC_SIZE 0x1000
+
+#define OMAP_MBOX_BASE 0x48094000
+#define OMAP_MBOX_SIZE 0x1000
+
+#define OMAP_DMMU_BASE 0x5D000000
+#define OMAP_DMMU_SIZE 0x1000
+
+#define OMAP_PRCM_VDD1_DOMAIN 1
+#define OMAP_PRCM_VDD2_DOMAIN 2
+
+
+/* GPP PROCESS CLEANUP Data structures */
+
+/* New structure (member of process context) abstracts NODE resource info */
+struct NODE_RES_OBJECT {
+	void *hNode;
+	s32            nodeAllocated; /* Node status */
+	s32            heapAllocated; /* Heap status */
+	s32            streamsAllocated; /* Streams status */
+	struct NODE_RES_OBJECT         *next;
+} ;
+
+/* Used for DMM mapped memory accounting */
+struct DMM_MAP_OBJECT {
+	struct	list_head	link;
+	u32	dsp_addr;
+};
+
+/* Used for DMM reserved memory accounting */
+struct DMM_RSV_OBJECT {
+	struct	list_head	link;
+	u32	dsp_reserved_addr;
+};
+
+/* New structure (member of process context) abstracts DMM resource info */
+struct DSPHEAP_RES_OBJECT {
+	s32            heapAllocated; /* DMM status */
+	u32           ulMpuAddr;
+	u32           ulDSPAddr;
+	u32           ulDSPResAddr;
+	u32           heapSize;
+	HANDLE          hProcessor;
+	struct DSPHEAP_RES_OBJECT  *next;
+} ;
+
+/* New structure (member of process context) abstracts stream resource info */
+struct STRM_RES_OBJECT {
+	s32                    streamAllocated; /* Stream status */
+	void *hStream;
+	u32                    uNumBufs;
+	u32                    uDir;
+	struct STRM_RES_OBJECT         *next;
+} ;
+
+/* Overall Bridge process resource usage state */
+enum GPP_PROC_RES_STATE {
+	PROC_RES_ALLOCATED,
+	PROC_RES_FREED
+} ;
+
+/* Process Context */
+struct PROCESS_CONTEXT{
+	/* Process State */
+	enum GPP_PROC_RES_STATE resState;
+
+	/* Handle to Processor */
+	void *hProcessor;
+
+	/* DSP Node resources */
+	struct NODE_RES_OBJECT *pNodeList;
+	struct mutex node_mutex;
+
+	/* DMM mapped memory resources */
+	struct list_head dmm_map_list;
+	spinlock_t dmm_map_lock;
+
+	/* DMM reserved memory resources */
+	struct list_head dmm_rsv_list;
+	spinlock_t dmm_rsv_lock;
+
+	/* DSP Heap resources */
+	struct DSPHEAP_RES_OBJECT *pDSPHEAPList;
+
+	/* Stream resources */
+	struct STRM_RES_OBJECT *pSTRMList;
+	struct mutex strm_mutex;
+} ;
+
+
+/*
+ *  ======== DRV_Create ========
+ *  Purpose:
+ *      Creates the Driver Object. This is done during the driver loading.
+ *      There is only one Driver Object in the DSP/BIOS Bridge.
+ *  Parameters:
+ *      phDrvObject:    Location to store created DRV Object handle.
+ *  Returns:
+ *      DSP_SOK:        Sucess
+ *      DSP_EMEMORY:    Failed in Memory allocation
+ *      DSP_EFAIL:      General Failure
+ *  Requires:
+ *      DRV Initialized (cRefs > 0 )
+ *      phDrvObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        - *phDrvObject is a valid DRV interface to the device.
+ *                      - List of DevObject Created and Initialized.
+ *                      - List of DevNode String created and intialized.
+ *                      - Registry is updated with the DRV Object.
+ *      !DSP_SOK:       DRV Object not created
+ *  Details:
+ *      There is one Driver Object for the Driver representing
+ *      the driver itself. It contains the list of device
+ *      Objects and the list of Device Extensions in the system.
+ *      Also it can hold other neccessary
+ *      information in its storage area.
+ */
+	extern DSP_STATUS DRV_Create(struct DRV_OBJECT **phDrvObject);
+
+/*
+ *  ======== DRV_Destroy ========
+ *  Purpose:
+ *      destroys the Dev Object list, DrvExt list
+ *      and destroy the DRV object
+ *      Called upon driver unLoading.or unsuccesful loading of the driver.
+ *  Parameters:
+ *      hDrvObject:     Handle to Driver object .
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to destroy DRV Object
+ *  Requires:
+ *      DRV Initialized (cRegs > 0 )
+ *      hDrvObject is not NULL and a valid DRV handle .
+ *      List of DevObject is Empty.
+ *      List of DrvExt is Empty
+ *  Ensures:
+ *      DSP_SOK:        - DRV Object destroyed and hDrvObject is not a valid
+ *                        DRV handle.
+ *                      - Registry is updated with "0" as the DRV Object.
+ */
+	extern DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDrvObject);
+
+/*
+ *  ======== DRV_Exit ========
+ *  Purpose:
+ *      Exit the DRV module, freeing any modules initialized in DRV_Init.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *  Ensures:
+ */
+	extern void DRV_Exit(void);
+
+/*
+ *  ======== DRV_GetFirstDevObject ========
+ *  Purpose:
+ *      Returns the Ptr to the FirstDev Object in the List
+ *  Parameters:
+ *  Requires:
+ *      DRV Initialized
+ *  Returns:
+ *      dwDevObject:  Ptr to the First Dev Object as a u32
+ *      0 if it fails to retrieve the First Dev Object
+ *  Ensures:
+ */
+	extern u32 DRV_GetFirstDevObject(void);
+
+/*
+ *  ======== DRV_GetFirstDevExtension ========
+ *  Purpose:
+ *      Returns the Ptr to the First Device Extension in the List
+ *  Parameters:
+ *  Requires:
+ *      DRV Initialized
+ *  Returns:
+ *      dwDevExtension:     Ptr to the First Device Extension as a u32
+ *      0:                  Failed to Get the Device Extension
+ *  Ensures:
+ */
+	extern u32 DRV_GetFirstDevExtension(void);
+
+/*
+ *  ======== DRV_GetDevObject ========
+ *  Purpose:
+ *      Given a index, returns a handle to DevObject from the list
+ *  Parameters:
+ *      hDrvObject:     Handle to the Manager
+ *      phDevObject:    Location to store the Dev Handle
+ *  Requires:
+ *      DRV Initialized
+ *      uIndex >= 0
+ *      hDrvObject is not NULL and Valid DRV Object
+ *      phDevObject is not NULL
+ *      Device Object List not Empty
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EFAIL:      Failed to Get the Dev Object
+ *  Ensures:
+ *      DSP_SOK:        *phDevObject != NULL
+ *      DSP_EFAIL:      *phDevObject = NULL
+ */
+	extern DSP_STATUS DRV_GetDevObject(u32 uIndex,
+					   struct DRV_OBJECT *hDrvObject,
+					   struct DEV_OBJECT **phDevObject);
+
+/*
+ *  ======== DRV_GetNextDevObject ========
+ *  Purpose:
+ *      Returns the Ptr to the Next Device Object from the the List
+ *  Parameters:
+ *      hDevObject:     Handle to the Device Object
+ *  Requires:
+ *      DRV Initialized
+ *      hDevObject != 0
+ *  Returns:
+ *      dwDevObject:    Ptr to the Next Dev Object as a u32
+ *      0:              If it fail to get the next Dev Object.
+ *  Ensures:
+ */
+	extern u32 DRV_GetNextDevObject(u32 hDevObject);
+
+/*
+ *  ======== DRV_GetNextDevExtension ========
+ *  Purpose:
+ *      Returns the Ptr to the Next Device Extension from the the List
+ *  Parameters:
+ *      hDevExtension:      Handle to the Device Extension
+ *  Requires:
+ *      DRV Initialized
+ *      hDevExtension != 0.
+ *  Returns:
+ *      dwDevExtension:     Ptr to the Next Dev Extension
+ *      0:                  If it fail to Get the next Dev Extension
+ *  Ensures:
+ */
+	extern u32 DRV_GetNextDevExtension(u32 hDevExtension);
+
+/*
+ *  ======== DRV_Init ========
+ *  Purpose:
+ *      Initialize the DRV module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS DRV_Init(void);
+
+/*
+ *  ======== DRV_InsertDevObject ========
+ *  Purpose:
+ *      Insert a DeviceObject into the list of Driver object.
+ *  Parameters:
+ *      hDrvObject:     Handle to DrvObject
+ *      hDevObject:     Handle to DeviceObject to insert.
+ *  Returns:
+ *      DSP_SOK:        If successful.
+ *      DSP_EFAIL:      General Failure:
+ *  Requires:
+ *      hDrvObject != NULL and Valid DRV Handle.
+ *      hDevObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Device Object is inserted and the List is not empty.
+ */
+	extern DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDrvObject,
+					      struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DRV_RemoveDevObject ========
+ *  Purpose:
+ *      Search for and remove a Device object from the given list of Device Obj
+ *      objects.
+ *  Parameters:
+ *      hDrvObject:     Handle to DrvObject
+ *      hDevObject:     Handle to DevObject to Remove
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to find pDevObject.
+ *  Requires:
+ *      hDrvObject != NULL and a Valid DRV Handle.
+ *      hDevObject != NULL.
+ *      List exists and is not empty.
+ *  Ensures:
+ *      List either does not exist (NULL), or is not empty if it does exist.
+*/
+	extern DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDrvObject,
+					      struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== DRV_RequestResources ========
+ *  Purpose:
+ *      Assigns the Resources or Releases them.
+ *  Parameters:
+ *      dwContext:          Path to the driver Registry Key.
+ *      pDevNodeString:     Ptr to DevNode String stored in the Device Ext.
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ *      The Resources are assigned based on Bus type.
+ *      The hardware is initialized. Resource information is
+ *      gathered from the Registry(ISA, PCMCIA)or scanned(PCI)
+ *      Resource structure is stored in the registry which will be
+ *      later used by the CFG module.
+ */
+	extern DSP_STATUS DRV_RequestResources(IN u32 dwContext,
+					       OUT u32 *pDevNodeString);
+
+/*
+ *  ======== DRV_ReleaseResources ========
+ *  Purpose:
+ *      Assigns the Resources or Releases them.
+ *  Parameters:
+ *      dwContext:      Path to the driver Registry Key.
+ *      hDrvObject:     Handle to the Driver Object.
+ *  Returns:
+ *      TRUE if success; FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ *      The Resources are released based on Bus type.
+ *      Resource structure is deleted from the registry
+ */
+	extern DSP_STATUS DRV_ReleaseResources(IN u32 dwContext,
+					       struct DRV_OBJECT *hDrvObject);
+
+#endif				/* DRV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/drvdefs.h b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
new file mode 100644
index 0000000..041de39
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/drvdefs.h
@@ -0,0 +1,25 @@
+/*
+ * drvdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definition of common struct between wmd.h and drv.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef DRVDEFS_
+#define DRVDEFS_
+
+/* WCD Driver Object */
+	struct DRV_OBJECT;
+
+#endif				/* DRVDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/dspdrv.h b/arch/arm/plat-omap/include/dspbridge/dspdrv.h
new file mode 100644
index 0000000..11add1d
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dspdrv.h
@@ -0,0 +1,62 @@
+/*
+ * dspdrv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This is the Stream Interface for the DDSP Class driver.
+ * All Device operations are performed via DeviceIOControl.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#if !defined __DSPDRV_h__
+#define __DSPDRV_h__
+
+#define MAX_DEV     10		/* Max support of 10 devices */
+
+/*
+ *  ======== DSP_Deinit ========
+ *  Purpose:
+ *      This function is called by Device Manager to de-initialize a device.
+ *      This function is not called by applications.
+ *  Parameters:
+ *      dwDeviceContext:Handle to the device context. The XXX_Init function
+ *      creates and returns this identifier.
+ *  Returns:
+ *      TRUE indicates the device successfully de-initialized. Otherwise it
+ *      returns FALSE.
+ *  Requires:
+ *      dwDeviceContext!= NULL. For a built in device this should never
+ *      get called.
+ *  Ensures:
+ */
+extern bool DSP_Deinit(u32 dwDeviceContext);
+
+/*
+ *  ======== DSP_Init ========
+ *  Purpose:
+ *      This function is called by Device Manager to initialize a device.
+ *      This function is not called by applications
+ *  Parameters:
+ *      dwContext:  Specifies a pointer to a string containing the registry
+ *                  path to the active key for the stream interface driver.
+ *                  HKEY_LOCAL_MACHINE\Drivers\Active
+ *  Returns:
+ *      Returns a handle to the device context created. This is the our actual
+ *      Device Object representing the DSP Device instance.
+ *  Requires:
+ *  Ensures:
+ *      Succeeded:  device context > 0
+ *      Failed:     device Context = 0
+ */
+extern u32 DSP_Init(OUT u32 *initStatus);
+
+#endif
diff --git a/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h b/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
new file mode 100644
index 0000000..ea5f77f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/dynamic_loader.h
@@ -0,0 +1,505 @@
+/*
+ * dynamic_loader.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef _DYNAMIC_LOADER_H_
+#define _DYNAMIC_LOADER_H_
+#include <linux/kernel.h>
+#include <linux/types.h>
+
+/*
+ * Dynamic Loader
+ *
+ * The function of the dynamic loader is to load a "module" containing
+ * instructions for a "target" processor into that processor.  In the process
+ * it assigns memory for the module, resolves symbol references made by the
+ * module, and remembers symbols defined by the module.
+ *
+ * The dynamic loader is parameterized for a particular system by 4 classes
+ * that supply the module and system specific functions it requires
+ */
+	/* The read functions for the module image to be loaded */
+	struct Dynamic_Loader_Stream;
+
+	/* This class defines "host" symbol and support functions */
+	struct Dynamic_Loader_Sym;
+
+	/* This class defines the allocator for "target" memory */
+	struct Dynamic_Loader_Allocate;
+
+	/* This class defines the copy-into-target-memory functions */
+	struct Dynamic_Loader_Initialize;
+
+/*
+ * Option flags to modify the behavior of module loading
+ */
+#define DLOAD_INITBSS 0x1	/* initialize BSS sections to zero */
+#define DLOAD_BIGEND 0x2	/* require big-endian load module */
+#define DLOAD_LITTLE 0x4	/* require little-endian load module */
+
+	typedef void *DLOAD_mhandle;	/* module handle for loaded modules */
+
+/*****************************************************************************
+ * Procedure Dynamic_Load_Module
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *  init    Target-side memory initialization, or NULL for symbol read only
+ *  options Option flags DLOAD_*
+ *  mhandle A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *  The module image is read using *module.  Target storage for the new image is
+ * obtained from *alloc.  Symbols defined and referenced by the module are
+ * managed using *syms.  The image is then relocated and references resolved
+ * as necessary, and the resulting executable bits are placed into target memory
+ * using *init.
+ *
+ * Returns:
+ *  On a successful load, a module handle is placed in *mhandle, and zero is
+ * returned.  On error, the number of errors detected is returned.  Individual
+ * errors are reported during the load process using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Load_Module(
+				       /* the source for the module image*/
+				       struct Dynamic_Loader_Stream *module,
+				       /* host support for symbols and storage*/
+				       struct Dynamic_Loader_Sym *syms,
+				       /* the target memory allocator*/
+				       struct Dynamic_Loader_Allocate *alloc,
+				       /* the target memory initializer*/
+				       struct Dynamic_Loader_Initialize *init,
+				       unsigned options,       /* option flags*/
+				       /* the returned module handle*/
+				       DLOAD_mhandle *mhandle
+	    );
+
+/*****************************************************************************
+ * Procedure Dynamic_Open_Module
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *  init    Target-side memory initialization, or NULL for symbol read only
+ *  options Option flags DLOAD_*
+ *  mhandle A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *  The module image is read using *module.  Target storage for the new image is
+ * obtained from *alloc.  Symbols defined and referenced by the module are
+ * managed using *syms.  The image is then relocated and references resolved
+ * as necessary, and the resulting executable bits are placed into target memory
+ * using *init.
+ *
+ * Returns:
+ *  On a successful load, a module handle is placed in *mhandle, and zero is
+ * returned.  On error, the number of errors detected is returned.  Individual
+ * errors are reported during the load process using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Open_Module(
+				      /* the source for the module image */
+				      struct Dynamic_Loader_Stream *module,
+				      /* host support for symbols and storage */
+				      struct Dynamic_Loader_Sym *syms,
+				      /* the target memory allocator */
+				      struct Dynamic_Loader_Allocate *alloc,
+				      /* the target memory initializer */
+				      struct Dynamic_Loader_Initialize *init,
+				      unsigned options, /* option flags */
+				      /* the returned module handle */
+				      DLOAD_mhandle *mhandle
+	);
+
+/*****************************************************************************
+ * Procedure Dynamic_Unload_Module
+ *
+ * Parameters:
+ *  mhandle A module handle from Dynamic_Load_Module
+ *  syms    Host-side symbol table and malloc/free functions
+ *  alloc   Target-side memory allocation
+ *
+ * Effect:
+ *  The module specified by mhandle is unloaded.  Unloading causes all
+ * target memory to be deallocated, all symbols defined by the module to
+ * be purged, and any host-side storage used by the dynamic loader for
+ * this module to be released.
+ *
+ * Returns:
+ *  Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report().
+ *****************************************************************************/
+	extern int Dynamic_Unload_Module(DLOAD_mhandle mhandle,	/* the module
+								 * handle*/
+					 /* host support for symbols and
+					  * storage */
+					 struct Dynamic_Loader_Sym *syms,
+					 /* the target memory allocator*/
+					 struct Dynamic_Loader_Allocate *alloc,
+					 /* the target memory initializer*/
+					 struct Dynamic_Loader_Initialize *init
+	    );
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader for input of the module image
+ *****************************************************************************
+ *****************************************************************************/
+	struct Dynamic_Loader_Stream {
+/* public: */
+    /*************************************************************************
+     * read_buffer
+     *
+     * PARAMETERS :
+     *  buffer  Pointer to the buffer to fill
+     *  bufsiz  Amount of data desired in sizeof() units
+     *
+     * EFFECT :
+     *  Reads the specified amount of data from the module input stream
+     * into the specified buffer.  Returns the amount of data read in sizeof()
+     * units (which if less than the specification, represents an error).
+     *
+     * NOTES:
+     *  In release 1 increments the file position by the number of bytes read
+     *
+     *************************************************************************/
+		int (*read_buffer) (struct Dynamic_Loader_Stream *thisptr,
+				    void *buffer, unsigned bufsiz);
+
+    /*************************************************************************
+     * set_file_posn (release 1 only)
+     *
+     * PARAMETERS :
+     *  posn  Desired file position relative to start of file in sizeof() units.
+     *
+     * EFFECT :
+     *  Adjusts the internal state of the stream object so that the next
+     * read_buffer call will begin to read at the specified offset from
+     * the beginning of the input module.  Returns 0 for success, non-zero
+     * for failure.
+     *
+     *************************************************************************/
+		int (*set_file_posn) (struct Dynamic_Loader_Stream *thisptr,
+					/* to be eliminated in release 2*/
+					unsigned int posn);
+
+	};
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader for symbol table support and
+ * miscellaneous host-side functions
+ *****************************************************************************
+ *****************************************************************************/
+
+	typedef u32 LDR_ADDR;
+
+/*
+ * the structure of a symbol known to the dynamic loader
+ */
+	struct dynload_symbol {
+		LDR_ADDR value;
+	} ;
+
+	struct Dynamic_Loader_Sym {
+/* public: */
+    /*************************************************************************
+     * Find_Matching_Symbol
+     *
+     * PARAMETERS :
+     *  name    The name of the desired symbol
+     *
+     * EFFECT :
+     *  Locates a symbol matching the name specified.  A pointer to the
+     * symbol is returned if it exists; 0 is returned if no such symbol is
+     * found.
+     *
+     *************************************************************************/
+		struct dynload_symbol *(*Find_Matching_Symbol)
+			(struct Dynamic_Loader_Sym *
+							 thisptr,
+							 const char *name);
+
+    /*************************************************************************
+     * Add_To_Symbol_Table
+     *
+     * PARAMETERS :
+     *  nname       Pointer to the name of the new symbol
+     *  moduleid    An opaque module id assigned by the dynamic loader
+     *
+     * EFFECT :
+     *  The new symbol is added to the table.  A pointer to the symbol is
+     * returned, or NULL is returned for failure.
+     *
+     * NOTES:
+     *  It is permissible for this function to return NULL; the effect is that
+     * the named symbol will not be available to resolve references in
+     * subsequent loads.  Returning NULL will not cause the current load
+     * to fail.
+     *************************************************************************/
+		struct dynload_symbol *(*Add_To_Symbol_Table)
+						(struct Dynamic_Loader_Sym *
+							thisptr,
+							const char *nname,
+							unsigned moduleid);
+
+    /*************************************************************************
+     * Purge_Symbol_Table
+     *
+     * PARAMETERS :
+     *  moduleid    An opaque module id assigned by the dynamic loader
+     *
+     * EFFECT :
+     *  Each symbol in the symbol table whose moduleid matches the argument
+     * is removed from the table.
+     *************************************************************************/
+		void (*Purge_Symbol_Table) (struct Dynamic_Loader_Sym *thisptr,
+					    unsigned moduleid);
+
+    /*************************************************************************
+     * Allocate
+     *
+     * PARAMETERS :
+     *  memsiz  size of desired memory in sizeof() units
+     *
+     * EFFECT :
+     *  Returns a pointer to some "host" memory for use by the dynamic
+     * loader, or NULL for failure.
+     * This function is serves as a replaceable form of "malloc" to
+     * allow the user to configure the memory usage of the dynamic loader.
+     *************************************************************************/
+		void *(*Allocate) (struct Dynamic_Loader_Sym *thisptr,
+				   unsigned memsiz);
+
+    /*************************************************************************
+     * Deallocate
+     *
+     * PARAMETERS :
+     *  memptr  pointer to previously allocated memory
+     *
+     * EFFECT :
+     *  Releases the previously allocated "host" memory.
+     *************************************************************************/
+		void (*Deallocate) (struct Dynamic_Loader_Sym *thisptr,
+				    void *memptr);
+
+    /*************************************************************************
+     * Error_Report
+     *
+     * PARAMETERS :
+     *  errstr  pointer to an error string
+     *  args    additional arguments
+     *
+     * EFFECT :
+     *  This function provides an error reporting interface for the dynamic
+     * loader.  The error string and arguments are designed as for the
+     * library function vprintf.
+     *************************************************************************/
+		void (*Error_Report) (struct Dynamic_Loader_Sym *thisptr,
+				      const char *errstr, va_list args);
+
+	};			/* class Dynamic_Loader_Sym */
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader to allocate and deallocate target memory.
+ *****************************************************************************
+ *****************************************************************************/
+
+	struct LDR_SECTION_INFO {
+		/* Name of the memory section assigned at build time */
+		const char *name;
+		LDR_ADDR run_addr;	/* execution address of the section */
+		LDR_ADDR load_addr;	/* load address of the section */
+		LDR_ADDR size;	/* size of the section in addressable units */
+#ifndef _BIG_ENDIAN
+		u16 page;	/* memory page or view */
+		u16 type;	/* one of the section types below */
+#else
+		u16 type;	/* one of the section types below */
+		u16 page;	/* memory page or view */
+#endif
+		/* a context field for use by Dynamic_Loader_Allocate;
+		 *   ignored but maintained by the dynamic loader */
+		u32 context;
+	} ;
+
+/* use this macro to extract type of section from LDR_SECTION_INFO.type field */
+#define DLOAD_SECTION_TYPE(typeinfo) (typeinfo & 0xF)
+
+/* type of section to be allocated */
+#define DLOAD_TEXT 0
+#define DLOAD_DATA 1
+#define DLOAD_BSS 2
+	/* internal use only, run-time cinit will be of type DLOAD_DATA */
+#define DLOAD_CINIT 3
+
+	struct Dynamic_Loader_Allocate {
+/* public: */
+
+    /*************************************************************************
+    * Function allocate
+    *
+    * Parameters:
+    *   info        A pointer to an information block for the section
+    *   align       The alignment of the storage in target AUs
+    *
+    * Effect:
+    *   Allocates target memory for the specified section and fills in the
+    * load_addr and run_addr fields of the section info structure. Returns TRUE
+    * for success, FALSE for failure.
+    *
+    * Notes:
+    *   Frequently load_addr and run_addr are the same, but if they are not
+    * load_addr is used with Dynamic_Loader_Initialize, and run_addr is
+    * used for almost all relocations.  This function should always initialize
+    * both fields.
+    *************************************************************************/
+		int (*Allocate) (struct Dynamic_Loader_Allocate *thisptr,
+				 struct LDR_SECTION_INFO *info, unsigned align);
+
+    /*************************************************************************
+    * Function deallocate
+    *
+    * Parameters:
+    *   info        A pointer to an information block for the section
+    *
+    * Effect:
+    *   Releases the target memory previously allocated.
+    *
+    * Notes:
+    * The content of the info->name field is undefined on call to this function.
+    *************************************************************************/
+		void (*Deallocate) (struct Dynamic_Loader_Allocate *thisptr,
+				    struct LDR_SECTION_INFO *info);
+
+	};			/* class Dynamic_Loader_Allocate */
+
+/*****************************************************************************
+ *****************************************************************************
+ * A class used by the dynamic loader to load data into a target.  This class
+ * provides the interface-specific functions needed to load data.
+ *****************************************************************************
+ *****************************************************************************/
+
+	struct Dynamic_Loader_Initialize {
+/* public: */
+    /*************************************************************************
+    * Function connect
+    *
+    * Parameters:
+    *   none
+    *
+    * Effect:
+    *   Connect to the initialization interface. Returns TRUE for success,
+    * FALSE for failure.
+    *
+    * Notes:
+    *   This function is called prior to use of any other functions in
+    * this interface.
+    *************************************************************************/
+		int (*connect) (struct Dynamic_Loader_Initialize *thisptr);
+
+    /*************************************************************************
+    * Function readmem
+    *
+    * Parameters:
+    *   bufr        Pointer to a word-aligned buffer for the result
+    *   locn        Target address of first data element
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be read in sizeof() units
+    *
+    * Effect:
+    *   Fills the specified buffer with data from the target.  Returns TRUE for
+    * success, FALSE for failure.
+    *************************************************************************/
+		int (*readmem) (struct Dynamic_Loader_Initialize *thisptr,
+				void *bufr,
+				LDR_ADDR locn,
+				struct LDR_SECTION_INFO *info,
+				unsigned bytsiz);
+
+    /*************************************************************************
+    * Function writemem
+    *
+    * Parameters:
+    *   bufr        Pointer to a word-aligned buffer of data
+    *   locn        Target address of first data element to be written
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be written in sizeof() units
+    *
+    * Effect:
+    *   Writes the specified buffer to the target.  Returns TRUE for success,
+    * FALSE for failure.
+    *************************************************************************/
+		int (*writemem) (struct Dynamic_Loader_Initialize *thisptr,
+				 void *bufr,
+				 LDR_ADDR locn,
+				 struct LDR_SECTION_INFO *info,
+				 unsigned bytsiz);
+
+    /*************************************************************************
+    * Function fillmem
+    *
+    * Parameters:
+    *   locn        Target address of first data element to be written
+    *   info        Section info for the section in which the address resides
+    *   bytsiz      Size of the data to be written in sizeof() units
+    *   val         Value to be written in each byte
+    * Effect:
+    *   Fills the specified area of target memory.  Returns TRUE for success,
+    * FALSE for failure.
+    *************************************************************************/
+		int (*fillmem) (struct Dynamic_Loader_Initialize *thisptr,
+				LDR_ADDR locn, struct LDR_SECTION_INFO *info,
+				unsigned bytsiz, unsigned val);
+
+    /*************************************************************************
+    * Function execute
+    *
+    * Parameters:
+    *   start       Starting address
+    *
+    * Effect:
+    *   The target code at the specified starting address is executed.
+    *
+    * Notes:
+    *   This function is called at the end of the dynamic load process
+    * if the input module has specified a starting address.
+    *************************************************************************/
+		int (*execute) (struct Dynamic_Loader_Initialize *thisptr,
+				LDR_ADDR start);
+
+    /*************************************************************************
+    * Function release
+    *
+    * Parameters:
+    *   none
+    *
+    * Effect:
+    *   Releases the connection to the load interface.
+    *
+    * Notes:
+    *   This function is called at the end of the dynamic load process.
+    *************************************************************************/
+		void (*release) (struct Dynamic_Loader_Initialize *thisptr);
+
+	};			/* class Dynamic_Loader_Initialize */
+
+#endif				/* _DYNAMIC_LOADER_H_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/errbase.h b/arch/arm/plat-omap/include/dspbridge/errbase.h
new file mode 100644
index 0000000..f7706b0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/errbase.h
@@ -0,0 +1,446 @@
+/*
+ * errbase.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Central repository for DSP/BIOS Bridge error and status code.
+ *
+ * Error codes are of the form:
+ *     [<MODULE>]_E<ERRORCODE>
+ *
+ * Success codes are of the form:
+ *     [<MODULE>]_S<SUCCESSCODE>
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef ERRBASE_
+#define ERRBASE_
+
+/* Base of generic errors and component errors */
+#define DSP_SBASE               (DSP_STATUS)0x00008000
+#define DSP_EBASE               (DSP_STATUS)0x80008000
+
+#define DSP_COMP_EBASE          (DSP_STATUS)0x80040200
+#define DSP_COMP_ELAST          (DSP_STATUS)0x80047fff
+
+/* SUCCESS Codes */
+
+/* Generic success code */
+#define DSP_SOK                     (DSP_SBASE + 0)
+
+/* GPP is already attached to this DSP processor */
+#define DSP_SALREADYATTACHED        (DSP_SBASE + 1)
+
+/* This is the last object available for enumeration. */
+#define DSP_SENUMCOMPLETE           (DSP_SBASE + 2)
+
+/* The DSP is already asleep. */
+#define DSP_SALREADYASLEEP          (DSP_SBASE + 3)
+
+/* The DSP is already awake. */
+#define DSP_SALREADYAWAKE           (DSP_SBASE + 4)
+
+/* TRUE */
+#define DSP_STRUE                   (DSP_SBASE + 5)
+
+/* FALSE */
+#define DSP_SFALSE                  (DSP_SBASE + 6)
+
+/* A library contains no dependent library references */
+#define DSP_SNODEPENDENTLIBS        (DSP_SBASE + 7)
+
+/* A persistent library is already loaded by the dynamic loader */
+#define DSP_SALREADYLOADED          (DSP_SBASE + 8)
+
+/* Some error occured, but it is OK to continue */
+#define DSP_OKTO_CONTINUE          (DSP_SBASE + 9)
+
+/* FAILURE Codes */
+
+/* The caller does not have access privileges to call this function */
+#define DSP_EACCESSDENIED           (DSP_EBASE + 0)
+
+/* The Specified Connection already exists */
+#define DSP_EALREADYCONNECTED       (DSP_EBASE + 1)
+
+/* The GPP must be detached from the DSP before this function is called */
+#define DSP_EATTACHED               (DSP_EBASE + 2)
+
+/* During enumeration a change in the number or properties of the objects
+ * has occurred. */
+#define DSP_ECHANGEDURINGENUM       (DSP_EBASE + 3)
+
+/* An error occurred while parsing the DSP executable file */
+#define DSP_ECORRUPTFILE            (DSP_EBASE + 4)
+
+/* A failure occurred during a delete operation */
+#define DSP_EDELETE                 (DSP_EBASE + 5)
+
+/* The specified direction is invalid */
+#define DSP_EDIRECTION              (DSP_EBASE + 6)
+
+/* A stream has been issued the maximum number of buffers allowed in the
+ * stream at once ;  buffers must be reclaimed from the stream before any
+ * more can be issued. */
+#define DSP_ESTREAMFULL             (DSP_EBASE + 7)
+
+/* A general failure occurred */
+#define DSP_EFAIL                   (DSP_EBASE + 8)
+
+/* The specified executable file could not be found. */
+#define DSP_EFILE                   (DSP_EBASE + 9)
+
+/* The specified handle is invalid. */
+#define DSP_EHANDLE                 (DSP_EBASE + 0xa)
+
+/* An invalid argument was specified. */
+#define DSP_EINVALIDARG             (DSP_EBASE + 0xb)
+
+/* A memory allocation failure occurred. */
+#define DSP_EMEMORY                 (DSP_EBASE + 0xc)
+
+/* The requested operation is invalid for this node type. */
+#define DSP_ENODETYPE               (DSP_EBASE + 0xd)
+
+/* No error text was found for the specified error code. */
+#define DSP_ENOERRTEXT              (DSP_EBASE + 0xe)
+
+/* No more connections can be made for this node. */
+#define DSP_ENOMORECONNECTIONS      (DSP_EBASE + 0xf)
+
+/* The indicated operation is not supported. */
+#define DSP_ENOTIMPL                (DSP_EBASE + 0x10)
+
+/* I/O is currently pending. */
+#define DSP_EPENDING                (DSP_EBASE + 0x11)
+
+/* An invalid pointer was specified. */
+#define DSP_EPOINTER                (DSP_EBASE + 0x12)
+
+/* A parameter is specified outside its valid range. */
+#define DSP_ERANGE                  (DSP_EBASE + 0x13)
+
+/* An invalid size parameter was specified. */
+#define DSP_ESIZE                   (DSP_EBASE + 0x14)
+
+/* A stream creation failure occurred on the DSP. */
+#define DSP_ESTREAM                 (DSP_EBASE + 0x15)
+
+/* A task creation failure occurred on the DSP. */
+#define DSP_ETASK                   (DSP_EBASE + 0x16)
+
+/* A timeout occurred before the requested operation could complete. */
+
+#define DSP_ETIMEOUT                (DSP_EBASE + 0x17)
+
+/* A data truncation occurred, e.g., when requesting a descriptive error
+ * string, not enough space was allocated for the complete error message. */
+
+#define DSP_ETRUNCATED              (DSP_EBASE + 0x18)
+
+/* A parameter is invalid. */
+#define DSP_EVALUE                  (DSP_EBASE + 0x1a)
+
+/* The state of the specified object is incorrect for the requested
+ * operation. */
+#define DSP_EWRONGSTATE             (DSP_EBASE + 0x1b)
+
+/* Symbol not found in the COFF file.  DSPNode_Create will return this if
+ * the iAlg function table for an xDAIS socket is not found in the COFF file.
+ * In this case, force the symbol to be linked into the COFF file.
+ * DSPNode_Create, DSPNode_Execute, and DSPNode_Delete will return this if
+ * the create, execute, or delete phase function, respectively, could not be
+ * found in the COFF file. */
+#define DSP_ESYMBOL                 (DSP_EBASE + 0x1c)
+
+/* UUID not found in registry.  */
+#define DSP_EUUID                   (DSP_EBASE + 0x1d)
+
+/* Unable to read content of DCD data section ; this is typically caused by
+ * improperly configured nodes. */
+#define DSP_EDCDREADSECT            (DSP_EBASE + 0x1e)
+
+/* Unable to decode DCD data section content ; this is typically caused by
+ * changes to DSP/BIOS Bridge data structures. */
+#define DSP_EDCDPARSESECT           (DSP_EBASE + 0x1f)
+
+/* Unable to get pointer to DCD data section ; this is typically caused by
+ * improperly configured UUIDs. */
+#define DSP_EDCDGETSECT             (DSP_EBASE + 0x20)
+
+/* Unable to load file containing DCD data section ; this is typically
+ * caused by a missing COFF file. */
+#define DSP_EDCDLOADBASE            (DSP_EBASE + 0x21)
+
+/* The specified COFF file does not contain a valid node registration
+ * section. */
+#define DSP_EDCDNOAUTOREGISTER      (DSP_EBASE + 0x22)
+
+/* A requested resource is not available. */
+#define DSP_ERESOURCE               (DSP_EBASE + 0x28)
+
+/* A critical error has occurred, and the DSP is being re-started. */
+#define DSP_ERESTART                (DSP_EBASE + 0x29)
+
+/* A DSP memory free operation failed. */
+#define DSP_EFREE                   (DSP_EBASE + 0x2a)
+
+/* A DSP I/O free operation failed. */
+#define DSP_EIOFREE                 (DSP_EBASE + 0x2b)
+
+/* Multiple instances are not allowed. */
+#define DSP_EMULINST                (DSP_EBASE + 0x2c)
+
+/* A specified entity was not found.  */
+#define DSP_ENOTFOUND               (DSP_EBASE + 0x2d)
+
+/* A DSP I/O resource is not available. */
+#define DSP_EOUTOFIO                (DSP_EBASE + 0x2e)
+
+/* A shared memory buffer contained in a message or stream could not be
+ * mapped to the GPP client process's virtual space. */
+#define DSP_ETRANSLATE              (DSP_EBASE + 0x2f)
+
+/* File or section load write function failed to write to DSP */
+#define DSP_EFWRITE                 (DSP_EBASE + 0x31)
+
+/* Unable to find a named section in DSP executable */
+#define DSP_ENOSECT                 (DSP_EBASE + 0x32)
+
+/* Unable to open file */
+#define DSP_EFOPEN                  (DSP_EBASE + 0x33)
+
+/* Unable to read file */
+#define DSP_EFREAD                  (DSP_EBASE + 0x34)
+
+/* A non-existent memory segment identifier was specified */
+#define DSP_EOVERLAYMEMORY          (DSP_EBASE + 0x37)
+
+/* Invalid segment ID */
+#define DSP_EBADSEGID               (DSP_EBASE + 0x38)
+
+/* Invalid alignment */
+#define DSP_EALIGNMENT               (DSP_EBASE + 0x39)
+
+/* Invalid stream mode */
+#define DSP_ESTRMMODE               (DSP_EBASE + 0x3a)
+
+/* Nodes not connected */
+#define DSP_ENOTCONNECTED           (DSP_EBASE + 0x3b)
+
+/* Not shared memory */
+#define DSP_ENOTSHAREDMEM           (DSP_EBASE + 0x3c)
+
+/* Error occurred in a dynamic loader library function */
+#define DSP_EDYNLOAD                (DSP_EBASE + 0x3d)
+
+/* Device in 'sleep/suspend' mode due to DPM */
+#define DSP_EDPMSUSPEND             (DSP_EBASE + 0x3e)
+
+/* A node-specific error has occurred. */
+#define DSP_EUSER1                  (DSP_EBASE + 0x40)
+#define DSP_EUSER2                  (DSP_EBASE + 0x41)
+#define DSP_EUSER3                  (DSP_EBASE + 0x42)
+#define DSP_EUSER4                  (DSP_EBASE + 0x43)
+#define DSP_EUSER5                  (DSP_EBASE + 0x44)
+#define DSP_EUSER6                  (DSP_EBASE + 0x45)
+#define DSP_EUSER7                  (DSP_EBASE + 0x46)
+#define DSP_EUSER8                  (DSP_EBASE + 0x47)
+#define DSP_EUSER9                  (DSP_EBASE + 0x48)
+#define DSP_EUSER10                 (DSP_EBASE + 0x49)
+#define DSP_EUSER11                 (DSP_EBASE + 0x4a)
+#define DSP_EUSER12                 (DSP_EBASE + 0x4b)
+#define DSP_EUSER13                 (DSP_EBASE + 0x4c)
+#define DSP_EUSER14                 (DSP_EBASE + 0x4d)
+#define DSP_EUSER15                 (DSP_EBASE + 0x4e)
+#define DSP_EUSER16                 (DSP_EBASE + 0x4f)
+
+/* FAILURE Codes : DEV */
+#define DEV_EBASE                   (DSP_COMP_EBASE + 0x000)
+
+/* The mini-driver expected a newer version of the class driver. */
+#define DEV_E_NEWWMD                (DEV_EBASE + 0x00)
+
+/* WMD_DRV_Entry function returned a NULL function interface table. */
+#define DEV_E_NULLWMDINTF           (DEV_EBASE + 0x01)
+
+/* FAILURE Codes : LDR */
+#define LDR_EBASE                   (DSP_COMP_EBASE + 0x100)
+
+/* Insufficient memory to export class driver services. */
+#define LDR_E_NOMEMORY              (LDR_EBASE + 0x00)
+
+/* Unable to find WMD file in system directory. */
+#define LDR_E_FILEUNABLETOOPEN      (LDR_EBASE + 0x01)
+
+/* FAILURE Codes : CFG */
+#define CFG_EBASE                   (DSP_COMP_EBASE + 0x200)
+
+/* Invalid pointer passed into a configuration module function */
+#define CFG_E_INVALIDPOINTER        (CFG_EBASE + 0x00)
+
+/* Invalid device node handle passed into a configuration module function. */
+#define CFG_E_INVALIDHDEVNODE       (CFG_EBASE + 0x01)
+
+/* Unable to retrieve resource information from the registry. */
+#define CFG_E_RESOURCENOTAVAIL      (CFG_EBASE + 0x02)
+
+/* Unable to find board name key in registry. */
+#define CFG_E_INVALIDBOARDNAME      (CFG_EBASE + 0x03)
+
+/* Unable to find a device node in registry with given unit number. */
+#define CFG_E_INVALIDUNITNUM        (CFG_EBASE + 0x04)
+
+/* Insufficient buffer size */
+#define CFG_E_INSUFFICIENTBUFSIZE   (CFG_EBASE + 0x05)
+
+/* FAILURE Codes : COD */
+#define COD_EBASE                   (DSP_COMP_EBASE + 0x400)
+
+/* No symbol table is loaded for this board. */
+#define COD_E_NOSYMBOLSLOADED       (COD_EBASE + 0x00)
+
+/* Symbol not found in for this board. */
+#define COD_E_SYMBOLNOTFOUND        (COD_EBASE + 0x01)
+
+/* ZL DLL module is not exporting the correct function interface. */
+#define COD_E_NOZLFUNCTIONS         (COD_EBASE + 0x02)
+
+/* Unable to initialize the ZL COFF parsing module. */
+#define COD_E_ZLCREATEFAILED        (COD_EBASE + 0x03)
+
+/* Unable to open DSP executable COFF file. */
+#define COD_E_OPENFAILED            (COD_EBASE + 0x04)
+
+/* Unable to parse DSP executable COFF file. */
+#define COD_E_LOADFAILED            (COD_EBASE + 0x05)
+
+/* Unable to read DSP executable COFF file. */
+#define COD_E_READFAILED            (COD_EBASE + 0x06)
+
+/* FAILURE Codes : CHNL */
+#define CHNL_EBASE                  (DSP_COMP_EBASE + 0x500)
+
+/* Attempt to created channel manager with too many channels. */
+#define CHNL_E_MAXCHANNELS          (CHNL_EBASE + 0x00)
+
+/* No channel manager exists for this mini-driver. */
+#define CHNL_E_NOMGR                (CHNL_EBASE + 0x01)
+
+/* No free channels are available. */
+#define CHNL_E_OUTOFSTREAMS         (CHNL_EBASE + 0x02)
+
+/* Channel ID is out of range. */
+#define CHNL_E_BADCHANID            (CHNL_EBASE + 0x03)
+
+/* Channel is already in use. */
+#define CHNL_E_CHANBUSY             (CHNL_EBASE + 0x04)
+
+/* Invalid channel mode argument. */
+#define CHNL_E_BADMODE              (CHNL_EBASE + 0x05)
+
+/* dwTimeOut parameter was CHNL_IOCNOWAIT, yet no I/O completions were
+ * queued. */
+#define CHNL_E_NOIOC                (CHNL_EBASE + 0x06)
+
+/* I/O has been cancelled on this channel. */
+#define CHNL_E_CANCELLED            (CHNL_EBASE + 0x07)
+
+/* End of stream was already requested on this output channel. */
+#define CHNL_E_EOS                  (CHNL_EBASE + 0x09)
+
+/* Unable to create the channel event object. */
+#define CHNL_E_CREATEEVENT          (CHNL_EBASE + 0x0A)
+
+/* Board name and unit number do not identify a valid board name. */
+#define CHNL_E_BRDID                (CHNL_EBASE + 0x0B)
+
+/* Invalid IRQ configured for this WMD for this system. */
+#define CHNL_E_INVALIDIRQ           (CHNL_EBASE + 0x0C)
+
+/* DSP word size of zero configured for this device. */
+#define CHNL_E_INVALIDWORDSIZE      (CHNL_EBASE + 0x0D)
+
+/* A zero length memory base was specified for a shared memory class driver. */
+#define CHNL_E_INVALIDMEMBASE       (CHNL_EBASE + 0x0E)
+
+/* Memory map is not configured, or unable to map physical to linear
+ * address. */
+#define CHNL_E_NOMEMMAP             (CHNL_EBASE + 0x0F)
+
+/* Attempted to create a channel manager  when one already exists. */
+#define CHNL_E_MGREXISTS            (CHNL_EBASE + 0x10)
+
+/* Unable to plug channel ISR for configured IRQ. */
+#define CHNL_E_ISR                  (CHNL_EBASE + 0x11)
+
+/* No free I/O request packets are available. */
+#define CHNL_E_NOIORPS              (CHNL_EBASE + 0x12)
+
+/* Buffer size is larger than the size of physical channel. */
+#define CHNL_E_BUFSIZE              (CHNL_EBASE + 0x13)
+
+/* User cannot mark end of stream on an input channel. */
+#define CHNL_E_NOEOS                (CHNL_EBASE + 0x14)
+
+/* Wait for flush operation on an output channel timed out. */
+#define CHNL_E_WAITTIMEOUT          (CHNL_EBASE + 0x15)
+
+/* User supplied hEvent must be specified with pstrEventName attribute */
+#define CHNL_E_BADUSEREVENT         (CHNL_EBASE + 0x16)
+
+/* Illegal user event name specified */
+#define CHNL_E_USEREVENTNAME        (CHNL_EBASE + 0x17)
+
+/* Unable to prepare buffer specified */
+#define CHNL_E_PREPFAILED           (CHNL_EBASE + 0x18)
+
+/* Unable to Unprepare buffer specified */
+#define CHNL_E_UNPREPFAILED         (CHNL_EBASE + 0x19)
+
+/* FAILURE Codes : SYNC */
+#define SYNC_EBASE                  (DSP_COMP_EBASE + 0x600)
+
+/* Wait on a kernel event failed. */
+#define SYNC_E_FAIL                 (SYNC_EBASE + 0x00)
+
+/* Timeout expired while waiting for event to be signalled. */
+#define SYNC_E_TIMEOUT              (SYNC_EBASE + 0x01)
+
+/* FAILURE Codes : WMD */
+#define WMD_EBASE                   (DSP_COMP_EBASE + 0x700)
+
+/* A test of hardware assumptions or integrity failed. */
+#define WMD_E_HARDWARE              (WMD_EBASE + 0x00)
+
+/* One or more configuration parameters violated WMD hardware assumptions. */
+#define WMD_E_BADCONFIG             (WMD_EBASE + 0x01)
+
+/* Timeout occurred waiting for a response from the hardware. */
+#define WMD_E_TIMEOUT               (WMD_EBASE + 0x02)
+
+/* FAILURE Codes : REG */
+#define REG_EBASE                   (DSP_COMP_EBASE + 0x800)
+
+/* Invalid subkey parameter. */
+#define REG_E_INVALIDSUBKEY         (REG_EBASE + 0x00)
+
+/* Invalid entry parameter. */
+#define REG_E_INVALIDENTRY          (REG_EBASE + 0x01)
+
+/* No more registry values. */
+#define REG_E_NOMOREITEMS           (REG_EBASE + 0x02)
+
+/* Insufficient space to hold data in registry value. */
+#define REG_E_MOREDATA              (REG_EBASE + 0x03)
+
+#endif				/* ERRBASE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gb.h b/arch/arm/plat-omap/include/dspbridge/gb.h
new file mode 100644
index 0000000..9365072
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gb.h
@@ -0,0 +1,79 @@
+/*
+ * gb.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Generic bitmap manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef GB_
+#define GB_
+
+#define GB_NOBITS (~0)
+#include <dspbridge/host_os.h>
+typedef s32 GB_BitNum;
+struct GB_TMap;
+
+/*
+ *  ======== GB_clear ========
+ *  Clear the bit in position bitn in the bitmap map.  Bit positions are
+ *  zero based.
+ */
+
+extern void GB_clear(struct GB_TMap *map, GB_BitNum bitn);
+
+/*
+ *  ======== GB_create ========
+ *  Create a bit map with len bits.  Initially all bits are cleared.
+ */
+
+extern struct GB_TMap *GB_create(GB_BitNum len);
+
+/*
+ *  ======== GB_delete ========
+ *  Delete previously created bit map
+ */
+
+extern void GB_delete(struct GB_TMap *map);
+
+/*
+ *  ======== GB_findandset ========
+ *  Finds a clear bit, sets it, and returns the position
+ */
+
+extern GB_BitNum GB_findandset(struct GB_TMap *map);
+
+/*
+ *  ======== GB_minclear ========
+ *  GB_minclear returns the minimum clear bit position.  If no bit is
+ *  clear, GB_minclear returns -1.
+ */
+extern GB_BitNum GB_minclear(struct GB_TMap *map);
+
+/*
+ *  ======== GB_set ========
+ *  Set the bit in position bitn in the bitmap map.  Bit positions are
+ *  zero based.
+ */
+
+extern void GB_set(struct GB_TMap *map, GB_BitNum bitn);
+
+/*
+ *  ======== GB_test ========
+ *  Returns TRUE if the bit in position bitn is set in map; otherwise
+ *  GB_test returns FALSE.  Bit positions are zero based.
+ */
+
+extern bool GB_test(struct GB_TMap *map, GB_BitNum bitn);
+
+#endif				/*GB_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/getsection.h b/arch/arm/plat-omap/include/dspbridge/getsection.h
new file mode 100644
index 0000000..28c11e8
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/getsection.h
@@ -0,0 +1,113 @@
+/*
+ * getsection.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This file provides an API add-on to the dynamic loader that allows the user
+ * to query section information and extract section data from dynamic load
+ * modules.
+ *
+ * Notes:
+ *   Functions in this API assume that the supplied Dynamic_Loader_Stream
+ *   object supports the set_file_posn method.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _GETSECTION_H_
+#define _GETSECTION_H_
+
+
+#include "dynamic_loader.h"
+
+	/* opaque handle for module information */
+	typedef void *DLOAD_module_info;
+
+/*
+ * Procedure DLOAD_module_open
+ *
+ * Parameters:
+ *  module  The input stream that supplies the module image
+ *  syms    Host-side malloc/free and error reporting functions.
+ *          Other methods are unused.
+ *
+ * Effect:
+ *  Reads header information from a dynamic loader module using the specified
+ * stream object, and returns a handle for the module information.  This
+ * handle may be used in subsequent query calls to obtain information
+ * contained in the module.
+ *
+ * Returns:
+ *  NULL if an error is encountered, otherwise a module handle for use
+ * in subsequent operations.
+ */
+	extern DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream
+						   *module,
+						   struct Dynamic_Loader_Sym
+						   *syms);
+
+/*
+ * Procedure DLOAD_GetSectionInfo
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *  sectionName Pointer to the string name of the section desired
+ *  sectionInfo Address of a section info structure pointer to be initialized
+ *
+ * Effect:
+ *  Finds the specified section in the module information, and fills in
+ * the provided LDR_SECTION_INFO structure.
+ *
+ * Returns:
+ *  TRUE for success, FALSE for section not found
+ */
+	extern int DLOAD_GetSectionInfo(DLOAD_module_info minfo,
+					const char *sectionName,
+					const struct LDR_SECTION_INFO
+					** const sectionInfo);
+
+/*
+ * Procedure DLOAD_GetSection
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *  sectionInfo Pointer to a section info structure for the desired section
+ *  sectionData Buffer to contain the section initialized data
+ *
+ * Effect:
+ *  Copies the initialized data for the specified section into the
+ * supplied buffer.
+ *
+ * Returns:
+ *  TRUE for success, FALSE for section not found
+ */
+	extern int DLOAD_GetSection(DLOAD_module_info minfo,
+				    const struct LDR_SECTION_INFO *sectionInfo,
+				    void *sectionData);
+
+/*
+ * Procedure DLOAD_module_close
+ *
+ * Parameters:
+ *  minfo       Handle from DLOAD_module_open for this module
+ *
+ * Effect:
+ *  Releases any storage associated with the module handle.  On return,
+ * the module handle is invalid.
+ *
+ * Returns:
+ *  Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report(), where syms was
+ * an argument to DLOAD_module_open
+ */
+	extern void DLOAD_module_close(DLOAD_module_info minfo);
+
+#endif				/* _GETSECTION_H_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gh.h b/arch/arm/plat-omap/include/dspbridge/gh.h
new file mode 100644
index 0000000..8bff0b4
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gh.h
@@ -0,0 +1,29 @@
+/*
+ * gh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef GH_
+#define GH_
+#include <dspbridge/host_os.h>
+
+extern struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
+		u16(*hash) (void *, u16), bool(*match) (void *, void *),
+		void(*delete) (void *));
+extern void GH_delete(struct GH_THashTab *hashTab);
+extern void GH_exit(void);
+extern void *GH_find(struct GH_THashTab *hashTab, void *key);
+extern void GH_init(void);
+extern void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value);
+#endif				/* GH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/gs.h b/arch/arm/plat-omap/include/dspbridge/gs.h
new file mode 100644
index 0000000..5dada9f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/gs.h
@@ -0,0 +1,59 @@
+/*
+ * gs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Memory allocation/release wrappers.  This module allows clients to
+ * avoid OS spacific issues related to memory allocation.  It also provides
+ * simple diagnostic capabilities to assist in the detection of memory
+ * leaks.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef GS_
+#define GS_
+
+/*
+ *  ======== GS_alloc ========
+ *  Alloc size bytes of space.  Returns pointer to space
+ *  allocated, otherwise NULL.
+ */
+extern void *GS_alloc(u32 size);
+
+/*
+ *  ======== GS_exit ========
+ *  Module exit.  Do not change to "#define GS_init()"; in
+ *  some environments this operation must actually do some work!
+ */
+extern void GS_exit(void);
+
+/*
+ *  ======== GS_free ========
+ *  Free space allocated by GS_alloc() or GS_calloc().
+ */
+extern void GS_free(void *ptr);
+
+/*
+ *  ======== GS_frees ========
+ *  Free space allocated by GS_alloc() or GS_calloc() and assert that
+ *  the size of the allocation is size bytes.
+ */
+extern void GS_frees(void *ptr, u32 size);
+
+/*
+ *  ======== GS_init ========
+ *  Module initialization.  Do not change to "#define GS_init()"; in
+ *  some environments this operation must actually do some work!
+ */
+extern void GS_init(void);
+
+#endif				/*GS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/host_os.h b/arch/arm/plat-omap/include/dspbridge/host_os.h
new file mode 100644
index 0000000..8cc1c6f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/host_os.h
@@ -0,0 +1,81 @@
+/*
+ * host_os.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _HOST_OS_H_
+#define _HOST_OS_H_
+
+#include <linux/autoconf.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <linux/semaphore.h>
+#include <linux/uaccess.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/syscalls.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/stddef.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <dspbridge/dbtype.h>
+#include <mach/clock.h>
+#include <linux/clk.h>
+#include <linux/pagemap.h>
+#include <asm/cacheflush.h>
+#include <linux/dma-mapping.h>
+
+/* TODO -- Remove, once BP defines them */
+#define INT_MAIL_MPU_IRQ        26
+#define INT_DSP_MMU_IRQ        28
+
+struct dspbridge_platform_data {
+	void 	(*dsp_set_min_opp)(u8 opp_id);
+	u8 	(*dsp_get_opp)(void);
+	void 	(*cpu_set_freq)(unsigned long f);
+	unsigned long (*cpu_get_freq)(void);
+	unsigned long mpu_speed[6];
+
+	u32 phys_mempool_base;
+	u32 phys_mempool_size;
+};
+
+#define PRCM_VDD1 1
+
+extern struct platform_device *omap_dspbridge_dev;
+extern struct device *bridge;
+
+#if defined(CONFIG_MPU_BRIDGE) || defined(CONFIG_MPU_BRIDGE_MODULE)
+extern void dspbridge_reserve_sdram(void);
+#else
+static inline void dspbridge_reserve_sdram(void) {}
+#endif
+
+extern unsigned long dspbridge_get_mempool_base(void);
+#endif
+
diff --git a/arch/arm/plat-omap/include/dspbridge/io.h b/arch/arm/plat-omap/include/dspbridge/io.h
new file mode 100644
index 0000000..c42cf52
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/io.h
@@ -0,0 +1,115 @@
+/*
+ * io.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * The io module manages IO between CHNL and MSG.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef IO_
+#define IO_
+
+#include <dspbridge/cfgdefs.h>
+#include <dspbridge/devdefs.h>
+
+#include <dspbridge/iodefs.h>
+
+/*
+ *  ======== IO_Create ========
+ *  Purpose:
+ *      Create an IO manager object, responsible for managing IO between
+ *      CHNL and MSG.
+ *  Parameters:
+ *      phChnlMgr:              Location to store a channel manager object on
+ *                              output.
+ *      hDevObject:             Handle to a device object.
+ *      pMgrAttrs:              IO manager attributes.
+ *      pMgrAttrs->bIRQ:        I/O IRQ number.
+ *      pMgrAttrs->fShared:     TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize:   DSP Word size in equivalent PC bytes..
+ *  Returns:
+ *      DSP_SOK:                Success;
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
+ *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= bIRQ <= 15.
+ *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
+ *      CHNL_E_INVALIDMEMBASE:  Invalid base address for DSP communications.
+ *  Requires:
+ *      IO_Init(void) called.
+ *      phIOMgr != NULL.
+ *      pMgrAttrs != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr,
+				    struct DEV_OBJECT *hDevObject,
+				    IN CONST struct IO_ATTRS *pMgrAttrs);
+
+/*
+ *  ======== IO_Destroy ========
+ *  Purpose:
+ *      Destroy the IO manager.
+ *  Parameters:
+ *      hIOMgr:         IOmanager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hIOMgr was invalid.
+ *  Requires:
+ *      IO_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== IO_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the IO module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      IO_Init(void) previously called.
+ *  Ensures:
+ *      Resources, if any acquired in IO_Init(void), are freed when the last
+ *      client of IO calls IO_Exit(void).
+ */
+	extern void IO_Exit(void);
+
+/*
+ *  ======== IO_Init ========
+ *  Purpose:
+ *      Initialize the IO module's private state.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occurred.
+ *  Requires:
+ *  Ensures:
+ *      A requirement for each of the other public CHNL functions.
+ */
+	extern bool IO_Init(void);
+
+/*
+ *  ======== IO_OnLoaded ========
+ *  Purpose:
+ *      Called when a program is loaded so IO manager can update its
+ *      internal state.
+ *  Parameters:
+ *      hIOMgr:         IOmanager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hIOMgr was invalid.
+ *  Requires:
+ *      IO_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_OnLoaded(struct IO_MGR *hIOMgr);
+
+#endif				/* CHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/io_sm.h b/arch/arm/plat-omap/include/dspbridge/io_sm.h
new file mode 100644
index 0000000..8eae7af
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/io_sm.h
@@ -0,0 +1,302 @@
+/*
+ * io_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * IO dispatcher for a shared memory channel driver.
+ * Also, includes macros to simulate SHM via port io calls.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef IOSM_
+#define IOSM_
+
+#include <dspbridge/_chnl_sm.h>
+#include <dspbridge/host_os.h>
+
+#include <dspbridge/iodefs.h>
+
+#define IO_INPUT            0
+#define IO_OUTPUT           1
+#define IO_SERVICE          2
+#define IO_MAXSERVICE       IO_SERVICE
+
+#define IO_MGRSIGNATURE     0x494f4D43	/* "IOGR" */
+
+#define DSPFieldAddr(type, field, base, wordsize) \
+    ((((s32)&(((type *)0)->field)) / wordsize) + (u32)base)
+
+/* Access can be different SM access word size (e.g. 16/32 bit words) */
+#define IO_SetValue(pContext, type, base, field, value) (base->field = value)
+#define IO_GetValue(pContext, type, base, field)	(base->field)
+#define IO_OrValue(pContext, type, base, field, value)  (base->field |= value)
+#define IO_AndValue(pContext, type, base, field, value) (base->field &= value)
+#define IO_SetLong(pContext, type, base, field, value)  (base->field = value)
+#define IO_GetLong(pContext, type, base, field)         (base->field)
+
+#define IO_DisableInterrupt(h)  CHNLSM_DisableInterrupt(h)
+#define IO_EnableInterrupt(h)   CHNLSM_EnableInterrupt(h)
+#define IO_CALLISR(h, pFlag, pwMBRegVal)   CHNLSM_ISR(h, pFlag, pwMBRegVal)
+
+/*
+ *  ======== IO_CancelChnl ========
+ *  Purpose:
+ *      Cancel IO on a given channel.
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *      ulChnl:     Index of channel to cancel IO on.
+ *  Returns:
+ *  Requires:
+ *      Valid hIOMgr.
+ *  Ensures:
+ */
+	extern void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl);
+
+/*
+ *  ======== IO_DPC ========
+ *  Purpose:
+ *      Deferred procedure call for shared memory channel driver ISR.  Carries
+ *      out the dispatch of I/O.
+ *  Parameters:
+ *      pRefData:   Pointer to reference data registered via a call to
+ *                  DPC_Create().
+ *  Returns:
+ *  Requires:
+ *      Must not block.
+ *      Must not acquire resources.
+ *      All data touched must be locked in memory if running in kernel mode.
+ *  Ensures:
+ *      Non-preemptible (but interruptible).
+ */
+	extern void IO_DPC(IN OUT unsigned long pRefData);
+
+/*
+ *  ======== IO_ISR ========
+ *  Purpose:
+ *      Main interrupt handler for the shared memory WMD channel manager.
+ *      Calls the WMD's CHNLSM_ISR to determine if this interrupt is ours, then
+ *      schedules a DPC to dispatch I/O..
+ *  Parameters:
+ *      pRefData:   Pointer to the channel manager object for this board.
+ *                  Set in an initial call to ISR_Install().
+ *  Returns:
+ *      TRUE if interrupt handled; FALSE otherwise.
+ *  Requires:
+ *      Must be in locked memory if executing in kernel mode.
+ *      Must only call functions which are in locked memory if Kernel mode.
+ *      Must only call asynchronous services.
+ *      Interrupts are disabled and EOI for this interrupt has been sent.
+ *  Ensures:
+ */
+       irqreturn_t IO_ISR(int irq, IN void *pRefData);
+/*
+ *  ======== IO_RequestChnl ========
+ *  Purpose:
+ *      Request I/O from the DSP. Sets flags in shared memory, then interrupts
+ *      the DSP.
+ *  Parameters:
+ *      hIOMgr:     IO manager handle.
+ *      pChnl:      Ptr to the channel requesting I/O.
+ *      iMode:      Mode of channel: {IO_INPUT | IO_OUTPUT}.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *  Ensures:
+ */
+	extern void IO_RequestChnl(struct IO_MGR *hIOMgr,
+				   struct CHNL_OBJECT *pChnl,
+				   u32 iMode, OUT u16 *pwMbVal);
+
+/*
+ *  ======== IO_Schedule ========
+ *  Purpose:
+ *      Schedule DPC for IO.
+ *  Parameters:
+ *      pIOMgr:     Ptr to a I/O manager.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *  Ensures:
+ */
+	extern void IO_Schedule(struct IO_MGR *hIOMgr);
+
+/*
+ * DSP-DMA IO functions
+ */
+
+/*
+ *  ======== IO_DDMAInitChnlDesc ========
+ *  Purpose:
+ *      Initialize DSP DMA channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uDDMAChnlId:    DDMA channel identifier.
+ *      uNumDesc:       Number of buffer descriptors(equals # of IOReqs &
+ *                      Chirps)
+ *      pDsp:           Dsp address;
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXDDMACHNLS
+ *     uNumDesc > 0
+ *     pVa != NULL
+ *     pDspPa != NULL
+ *
+ *  Ensures:
+ */
+	extern void IO_DDMAInitChnlDesc(struct IO_MGR *hIOMgr, u32 uDDMAChnlId,
+					u32 uNumDesc, void *pDsp);
+
+/*
+ *  ======== IO_DDMAClearChnlDesc ========
+ *  Purpose:
+ *      Clear DSP DMA channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uDDMAChnlId:    DDMA channel identifier.
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXDDMACHNLS
+ *  Ensures:
+ */
+	extern void IO_DDMAClearChnlDesc(struct IO_MGR *hIOMgr,
+					 u32 uDDMAChnlId);
+
+/*
+ *  ======== IO_DDMARequestChnl ========
+ *  Purpose:
+ *      Request channel DSP-DMA from the DSP. Sets up SM descriptors and
+ *      control fields in shared memory.
+ *  Parameters:
+ *      hIOMgr:     Handle to a I/O manager.
+ *      pChnl:      Ptr to channel object
+ *      pChirp:     Ptr to channel i/o request packet.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *      pChnl->cIOReqs > 0
+ *      pChirp != NULL
+ *  Ensures:
+ */
+	extern void IO_DDMARequestChnl(struct IO_MGR *hIOMgr,
+				       struct CHNL_OBJECT *pChnl,
+				       struct CHNL_IRP *pChirp,
+				       OUT u16 *pwMbVal);
+
+/*
+ * Zero-copy IO functions
+ */
+
+/*
+ *  ======== IO_DDZCInitChnlDesc ========
+ *  Purpose:
+ *      Initialize ZCPY channel descriptor.
+ *  Parameters:
+ *      hIOMgr:     Handle to a I/O manager.
+ *      uZId:       zero-copy channel identifier.
+ *  Returns:
+ *  Requires:
+ *     uDDMAChnlId < DDMA_MAXZCPYCHNLS
+ *     hIOMgr != Null
+ *  Ensures:
+ */
+	extern void IO_DDZCInitChnlDesc(struct IO_MGR *hIOMgr, u32 uZId);
+
+/*
+ *  ======== IO_DDZCClearChnlDesc ========
+ *  Purpose:
+ *      Clear DSP ZC channel descriptor.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      uChnlId:        ZC channel identifier.
+ *  Returns:
+ *  Requires:
+ *      hIOMgr is valid
+ *      uChnlId < DDMA_MAXZCPYCHNLS
+ *  Ensures:
+ */
+	extern void IO_DDZCClearChnlDesc(struct IO_MGR *hIOMgr, u32 uChnlId);
+
+/*
+ *  ======== IO_DDZCRequestChnl ========
+ *  Purpose:
+ *      Request zero-copy channel transfer. Sets up SM descriptors and
+ *      control fields in shared memory.
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      pChnl:          Ptr to channel object
+ *      pChirp:         Ptr to channel i/o request packet.
+ *  Returns:
+ *  Requires:
+ *      pChnl != NULL
+ *      pChnl->cIOReqs > 0
+ *      pChirp != NULL
+ *  Ensures:
+ */
+	extern void IO_DDZCRequestChnl(struct IO_MGR *hIOMgr,
+				       struct CHNL_OBJECT *pChnl,
+				       struct CHNL_IRP *pChirp,
+				       OUT u16 *pwMbVal);
+
+/*
+ *  ======== IO_SHMsetting ========
+ *  Purpose:
+ *      Sets the shared memory setting
+ *  Parameters:
+ *      hIOMgr:         Handle to a I/O manager.
+ *      desc:             Shared memory type
+ *      pArgs:          Ptr to SHM setting
+ *  Returns:
+ *  Requires:
+ *      hIOMgr != NULL
+ *      pArgs != NULL
+ *  Ensures:
+ */
+	extern DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr,
+					u8 desc, void *pArgs);
+
+/*
+ *  Misc functions for the CHNL_IO shared memory library:
+ */
+
+/* Maximum channel bufsize that can be used. */
+	extern u32 IO_BufSize(struct IO_MGR *hIOMgr);
+
+	extern u32 IO_ReadValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr);
+
+	extern void IO_WriteValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr, u32 dwValue);
+
+	extern u32 IO_ReadValueLong(struct WMD_DEV_CONTEXT *hDevContext,
+				      u32 dwDSPAddr);
+
+	extern void IO_WriteValueLong(struct WMD_DEV_CONTEXT *hDevContext,
+				      u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_OrSetValue(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_AndSetValue(struct WMD_DEV_CONTEXT *hDevContext,
+				   u32 dwDSPAddr, u32 dwValue);
+
+	extern void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal);
+
+	extern void IO_SM_init(void);
+
+/*
+ *  ========PrintDspTraceBuffer ========
+ *      Print DSP tracebuffer.
+ */
+	extern DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT
+						*hWmdContext);
+
+#endif				/* IOSM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/iodefs.h b/arch/arm/plat-omap/include/dspbridge/iodefs.h
new file mode 100644
index 0000000..23f22e9
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/iodefs.h
@@ -0,0 +1,36 @@
+/*
+ * iodefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * System-wide channel objects and constants.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef IODEFS_
+#define IODEFS_
+
+#define IO_MAXIRQ   0xff	/* Arbitrarily large number. */
+
+/* IO Objects: */
+	struct IO_MGR;
+
+/* IO manager attributes: */
+	struct IO_ATTRS {
+		u8 bIRQ;	/* Channel's I/O IRQ number. */
+		bool fShared;	/* TRUE if the IRQ is shareable. */
+		u32 uWordSize;	/* DSP Word size. */
+		u32 dwSMBase;	/* Physical base address of shared memory. */
+		u32 uSMLength;	/* Size (in bytes) of shared memory. */
+	} ;
+
+#endif				/* IODEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/ldr.h b/arch/arm/plat-omap/include/dspbridge/ldr.h
new file mode 100644
index 0000000..f13608f
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/ldr.h
@@ -0,0 +1,29 @@
+/*
+ * ldr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide module loading services and symbol export services.
+ *
+ * Notes:
+ *   This service is meant to be used by modules of the DSP/BIOS Bridge
+ *   class driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef LDR_
+#define LDR_
+
+/* Loader objects: */
+	struct LDR_MODULE;
+
+#endif				/* LDR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/list.h b/arch/arm/plat-omap/include/dspbridge/list.h
new file mode 100644
index 0000000..2c2e8a8
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/list.h
@@ -0,0 +1,224 @@
+/*
+ * list.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declarations of list management control structures and definitions
+ * of inline list management functions.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef LIST_
+#define LIST_
+
+#include <dspbridge/host_os.h>
+#include <linux/list.h>
+
+#define LST_IsEmpty(l)      list_empty(&(l)->head)
+
+struct LST_LIST {
+	struct list_head head;
+};
+
+/*
+ *  ======== LST_First ========
+ *  Purpose:
+ *      Returns a pointer to the first element of the list, or NULL if the list
+ *      is empty.
+ *  Parameters:
+ *      pList:  Pointer to list control structure.
+ *  Returns:
+ *      Pointer to first list element, or NULL.
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *  Ensures:
+ */
+static inline struct list_head *LST_First(struct LST_LIST *pList)
+{
+	if (pList && !list_empty(&pList->head))
+		return pList->head.next;
+	return NULL;
+}
+
+/*
+ *  ======== LST_GetHead ========
+ *  Purpose:
+ *      Pops the head off the list and returns a pointer to it.
+ *  Details:
+ *      If the list is empty, returns NULL.
+ *      Else, removes the element at the head of the list, making the next
+ *      element the head of the list.
+ *      The head is removed by making the tail element of the list point its
+ *      "next" pointer at the next element after the head, and by making the
+ *      "prev" pointer of the next element after the head point at the tail
+ *      element.  So the next element after the head becomes the new head of
+ *      the list.
+ *  Parameters:
+ *      pList:  Pointer to list control structure of list whose head
+ *              element is to be removed
+ *  Returns:
+ *      Pointer to element that was at the head of the list (success)
+ *      NULL          No elements in list
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *  Ensures:
+ *  Notes:
+ *      Because the tail of the list points forward (its "next" pointer) to
+ *      the head of the list, and the head of the list points backward (its
+ *      "prev" pointer) to the tail of the list, this list is circular.
+ */
+static inline struct list_head *LST_GetHead(struct LST_LIST *pList)
+{
+	struct list_head *pElem;
+
+	if (!pList || list_empty(&pList->head))
+		return NULL;
+
+	pElem = pList->head.next;
+	pList->head.next = pElem->next;
+	pElem->next->prev = &pList->head;
+
+	return pElem;
+}
+
+/*
+ *  ======== LST_InitElem ========
+ *  Purpose:
+ *      Initializes a list element to default (cleared) values
+ *  Details:
+ *  Parameters:
+ *      pElem:  Pointer to list element to be reset
+ *  Returns:
+ *  Requires:
+ *      LST initialized.
+ *  Ensures:
+ *  Notes:
+ *      This function must not be called to "reset" an element in the middle
+ *      of a list chain -- that would break the chain.
+ *
+ */
+static inline void LST_InitElem(struct list_head *pElem)
+{
+	if (pElem) {
+		pElem->next = NULL;
+		pElem->prev = NULL;
+	}
+}
+
+/*
+ *  ======== LST_InsertBefore ========
+ *  Purpose:
+ *     Insert the element before the existing element.
+ *  Parameters:
+ *      pList:          Pointer to list control structure.
+ *      pElem:          Pointer to element in list to insert.
+ *      pElemExisting:  Pointer to existing list element.
+ *  Returns:
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pElem != NULL.
+ *      - pElemExisting != NULL.
+ *  Ensures:
+ */
+static inline void LST_InsertBefore(struct LST_LIST *pList,
+				    struct list_head *pElem,
+				    struct list_head *pElemExisting)
+{
+	if (pList && pElem && pElemExisting)
+		list_add_tail(pElem, pElemExisting);
+}
+
+/*
+ *  ======== LST_Next ========
+ *  Purpose:
+ *      Returns a pointer to the next element of the list, or NULL if the next
+ *      element is the head of the list or the list is empty.
+ *  Parameters:
+ *      pList:      Pointer to list control structure.
+ *      pCurElem:   Pointer to element in list to remove.
+ *  Returns:
+ *      Pointer to list element, or NULL.
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pCurElem != NULL.
+ *  Ensures:
+ */
+static inline struct list_head *LST_Next(struct LST_LIST *pList,
+					 struct list_head *pCurElem)
+{
+	if (pList && !list_empty(&pList->head) && pCurElem &&
+	   (pCurElem->next != &pList->head))
+		return pCurElem->next;
+	return NULL;
+}
+
+/*
+ *  ======== LST_PutTail ========
+ *  Purpose:
+ *      Adds the specified element to the tail of the list
+ *  Details:
+ *      Sets new element's "prev" pointer to the address previously held by
+ *      the head element's prev pointer.  This is the previous tail member of
+ *      the list.
+ *      Sets the new head's prev pointer to the address of the element.
+ *      Sets next pointer of the previous tail member of the list to point to
+ *      the new element (rather than the head, which it had been pointing at).
+ *      Sets new element's next pointer to the address of the head element.
+ *      Sets head's prev pointer to the address of the new element.
+ *  Parameters:
+ *      pList:  Pointer to list control structure to which *pElem will be
+ *              added
+ *      pElem:  Pointer to list element to be added
+ *  Returns:
+ *      Void
+ *  Requires:
+ *      *pElem and *pList must both exist.
+ *      LST initialized.
+ *  Ensures:
+ *  Notes:
+ *      Because the tail is always "just before" the head of the list (the
+ *      tail's "next" pointer points at the head of the list, and the head's
+ *      "prev" pointer points at the tail of the list), the list is circular.
+ */
+static inline void LST_PutTail(struct LST_LIST *pList, struct list_head *pElem)
+{
+	if (pList && pElem)
+		list_add_tail(pElem, &pList->head);
+}
+
+/*
+ *  ======== LST_RemoveElem ========
+ *  Purpose:
+ *      Removes (unlinks) the given element from the list, if the list is not
+ *      empty.  Does not free the list element.
+ *  Parameters:
+ *      pList:      Pointer to list control structure.
+ *      pCurElem:   Pointer to element in list to remove.
+ *  Returns:
+ *  Requires:
+ *      - LST initialized.
+ *      - pList != NULL.
+ *      - pCurElem != NULL.
+ *  Ensures:
+ */
+static inline void LST_RemoveElem(struct LST_LIST *pList,
+				  struct list_head *pCurElem)
+{
+	if (pList && !list_empty(&pList->head) && pCurElem)
+		list_del_init(pCurElem);
+}
+
+#endif				/* LIST_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mbx_sh.h b/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
new file mode 100644
index 0000000..0e4e655
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mbx_sh.h
@@ -0,0 +1,198 @@
+/*
+ * mbx_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions for shared mailbox cmd/data values.(used on both
+ * the GPP and DSP sides).
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  Bridge usage of OMAP mailbox 1 is determined by the "class" of the
+ *  mailbox interrupt's cmd value received. The class value are defined
+ *  as a bit (10 thru 15) being set.
+ *
+ *  Note: Only 16 bits of each  is used. Other 16 bit data reg available.
+ *
+ *   16 bit Mbx bit defns:
+ *
+ * A). Exception/Error handling (Module DEH) : class = 0.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|0|0|x|x|x|x|x|x|x|x|x|x|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *
+ * B: DSP-DMA link driver channels (DDMA) : class = 1.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|0|1|b|b|b|b|b|c|c|c|c|c|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where b -> buffer index  (32 DDMA buffers/chnl max)
+ *         c -> channel Id    (32 DDMA chnls max)
+ *
+ *
+ * C: Proc-copy link driver channels (PCPY) : class = 2.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|0|1|0|x|x|x|x|x|x|x|x|x|x|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *
+ * D: Zero-copy link driver channels (DDZC) : class = 4.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|0|1|0|0|x|x|x|x|x|c|c|c|c|c|
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where x -> not used
+ *         c -> channel Id    (32 ZCPY chnls max)
+ *
+ *
+ * E: Power management : class = 8.
+ *
+ *    15         10                  0
+ *   ---------------------------------
+ *   |0|0|1|0|0|0|x|x|x|x|x|c|c|c|c|c|
+
+ * 	0010 00xx xxxc cccc
+ *	0010 00nn pppp qqqq
+ *	nn:
+ *	00 = reserved
+ *	01 = pwr state change
+ *	10 = opp pre-change
+ *	11 = opp post-change
+ *
+ *	if nn = pwr state change:
+ *	pppp = don't care
+ *	qqqq:
+ *	0010 = hibernate
+ *	0010 0001 0000 0010
+ *	0110 = retention
+ *	0010 0001 0000 0110
+ *	others reserved
+ *
+ *	if nn = opp pre-change:
+ *	pppp = current opp
+ *	qqqq = next opp
+ *
+ *	if nn = opp post-change:
+ *	pppp = prev opp
+ *	qqqq = current opp
+ *
+ *   ---------------------------------
+ *   |  (class)  | (module specific) |
+ *
+ *   where x -> not used
+ *         c -> Power management command
+ *
+ */
+
+#ifndef _MBX_SH_H
+#define _MBX_SH_H
+
+#define MBX_CLASS_MSK      0xFC00	/* Class bits are 10 thru 15 */
+#define MBX_VALUE_MSK      0x03FF	/* Value is 0 thru 9 */
+
+#define MBX_DEH_CLASS      0x0000	/* DEH owns Mbx INTR */
+#define MBX_DDMA_CLASS     0x0400	/* DSP-DMA link drvr chnls owns INTR */
+#define MBX_PCPY_CLASS     0x0800	/* PROC-COPY  " */
+#define MBX_ZCPY_CLASS     0x1000	/* ZERO-COPY  " */
+#define MBX_PM_CLASS       0x2000	/* Power Management */
+#define MBX_DBG_CLASS      0x4000	/* For debugging purpose */
+
+/*
+ * Exception Handler codes
+ * Magic code used to determine if DSP signaled exception.
+ */
+#define MBX_DEH_BASE        0x0
+#define MBX_DEH_USERS_BASE  0x100	/* 256 */
+#define MBX_DEH_LIMIT       0x3FF	/* 1023 */
+#define MBX_DEH_RESET       0x101	/* DSP RESET (DEH) */
+#define MBX_DEH_EMMU        0X103 /*DSP MMU FAULT RECOVERY*/
+
+/*
+ *  Link driver command/status codes.
+ */
+/* DSP-DMA */
+#define MBX_DDMA_NUMCHNLBITS 5	/* # chnl Id: # bits available */
+#define MBX_DDMA_CHNLSHIFT   0	/* # of bits to shift */
+#define MBX_DDMA_CHNLMSK     0x01F	/* bits 0 thru 4 */
+
+#define MBX_DDMA_NUMBUFBITS  5	/* buffer index: # of bits avail */
+#define MBX_DDMA_BUFSHIFT    (MBX_DDMA_NUMCHNLBITS + MBX_DDMA_CHNLSHIFT)
+#define MBX_DDMA_BUFMSK      0x3E0	/* bits 5 thru 9 */
+
+/* Zero-Copy */
+#define MBX_ZCPY_NUMCHNLBITS 5	/* # chnl Id: # bits available */
+#define MBX_ZCPY_CHNLSHIFT   0	/* # of bits to shift */
+#define MBX_ZCPY_CHNLMSK     0x01F	/* bits 0 thru 4 */
+
+/*  Power Management Commands */
+#define MBX_PM_DSPIDLE                  (MBX_PM_CLASS + 0x0)
+#define MBX_PM_DSPWAKEUP                (MBX_PM_CLASS + 0x1)
+#define MBX_PM_EMERGENCYSLEEP           (MBX_PM_CLASS + 0x2)
+#define MBX_PM_SLEEPUNTILRESTART        (MBX_PM_CLASS + 0x3)
+#define MBX_PM_DSPGLOBALIDLE_OFF        (MBX_PM_CLASS + 0x4)
+#define MBX_PM_DSPGLOBALIDLE_ON         (MBX_PM_CLASS + 0x5)
+#define MBX_PM_SETPOINT_PRENOTIFY       (MBX_PM_CLASS + 0x6)
+#define MBX_PM_SETPOINT_POSTNOTIFY      (MBX_PM_CLASS + 0x7)
+#define MBX_PM_DSPRETN                  (MBX_PM_CLASS + 0x8)
+#define MBX_PM_DSPRETENTION        (MBX_PM_CLASS + 0x8)
+#define MBX_PM_DSPHIBERNATE        (MBX_PM_CLASS + 0x9)
+#define MBX_PM_HIBERNATE_EN        (MBX_PM_CLASS + 0xA)
+#define MBX_PM_OPP_REQ                  (MBX_PM_CLASS + 0xB)
+#define MBX_PM_OPP_CHG                  (MBX_PM_CLASS + 0xC)
+
+#define MBX_PM_TYPE_MASK 0x0300
+#define MBX_PM_TYPE_PWR_CHNG 0x0100
+#define MBX_PM_TYPE_OPP_PRECHNG 0x0200
+#define MBX_PM_TYPE_OPP_POSTCHNG 0x0300
+#define MBX_PM_TYPE_OPP_MASK 0x0300
+#define MBX_PM_OPP_PRECHNG (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG)
+/* DSP to MPU */
+#define MBX_PM_OPP_CHNG(OPP) (MBX_PM_CLASS | MBX_PM_TYPE_OPP_PRECHNG | (OPP))
+#define MBX_PM_RET (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0006)
+#define MBX_PM_HIB (MBX_PM_CLASS | MBX_PM_TYPE_PWR_CHNG | 0x0002)
+#define MBX_PM_OPP_1 0
+#define MBX_PM_OPP_2 1
+#define MBX_PM_OPP_3 2
+#define MBX_PM_OPP_4 3
+#define MBX_OLDOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
+#define MBX_NEWOPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
+#define MBX_PREVOPP_EXTRACT(OPPMSG) ((0x00F0 & (OPPMSG)) >> 4)
+#define MBX_CUROPP_EXTRACT(OPPMSG) (0x000F & (OPPMSG))
+
+/* Bridge Debug Commands */
+#define MBX_DBG_SYSPRINTF       (MBX_DBG_CLASS + 0x0)
+
+/*
+ * Useful macros
+ */
+/* DSP-DMA channel */
+#define MBX_SETDDMAVAL(x, y)  (MBX_DDMA_CLASS | (x << MBX_DDMA_BUFSHIFT) | \
+	(y << MBX_DDMA_CHNLSHIFT))
+
+/* Zero-Copy channel */
+#define MBX_SETZCPYVAL(x)  (MBX_ZCPY_CLASS | (x << MBX_ZCPY_CHNLSHIFT))
+
+#endif				/* _MBX_SH_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/mem.h b/arch/arm/plat-omap/include/dspbridge/mem.h
new file mode 100644
index 0000000..9d9a7a3
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mem.h
@@ -0,0 +1,282 @@
+/*
+ * mem.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Memory management and address mapping services for the DSP/BIOS Bridge
+ * class driver and mini-driver.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MEM_
+#define MEM_
+
+#include <dspbridge/host_os.h>
+#include <dspbridge/memdefs.h>
+
+/*
+ *  ======== MEM_Alloc ========
+ *  Purpose:
+ *      Allocate memory from the paged or non-paged pools.
+ *  Parameters:
+ *      cBytes: Number of bytes to allocate.
+ *      type:   Type of memory to allocate; one of:
+ *              MEM_PAGED: Allocate from pageable memory.
+ *              MEM_NONPAGED: Allocate from page locked memory.
+ *  Returns:
+ *      Pointer to a block of memory;
+ *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      not one of MEM_PAGED or MEM_NONPAGED.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.
+ */
+	extern void *MEM_Alloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+
+/*
+ *  ======== MEM_AllocObject ========
+ *  Purpose:
+ *      Allocate an object, and set it's signature.
+ *  Parameters:
+ *      pObj:       Pointer to the new object.
+ *      Obj:        Type of the object to allocate.
+ *      Signature:  Magic field value.  Must be non-zero.
+ *  Returns:
+ *  Requires:
+ *      Same requirements as MEM_Calloc(); and
+ *      The object structure has a dwSignature field.  The compiler ensures
+ *      this requirement.
+ *  Ensures:
+ *      A subsequent call to MEM_IsValidHandle() will succeed for this object.
+ */
+#define MEM_AllocObject(pObj, Obj, Signature)           \
+{                                                       \
+    pObj = MEM_Calloc(sizeof(Obj), MEM_NONPAGED);       \
+    if (pObj) {                                         \
+	pObj->dwSignature = Signature;                  \
+    }                                                   \
+}
+
+/*  ======== MEM_AllocPhysMem ========
+ *  Purpose:
+ *      Allocate physically contiguous, uncached memory
+ *  Parameters:
+ *      cBytes:     Number of bytes to allocate.
+ *      ulAlign:    Alignment Mask.
+ *      pPhysicalAddress: Physical address of allocated memory.
+ *  Returns:
+ *      Pointer to a block of memory;
+ *      NULL if memory couldn't be allocated, or if cBytes == 0.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block of
+ *      the size requested.  Returned physical address refers to physical
+ *      location of memory.
+ */
+	extern void *MEM_AllocPhysMem(IN u32 cBytes,
+				      IN u32 ulAlign,
+				      OUT u32 *pPhysicalAddress);
+
+/*
+ *  ======== MEM_Calloc ========
+ *  Purpose:
+ *      Allocate zero-initialized memory from the paged or non-paged pools.
+ *  Parameters:
+ *      cBytes: Number of bytes to allocate.
+ *      type:   Type of memory to allocate; one of:
+ *              MEM_PAGED:   Allocate from pageable memory.
+ *              MEM_NONPAGED: Allocate from page locked memory.
+ *  Returns:
+ *      Pointer to a block of zeroed memory;
+ *      NULL if memory couldn't be allocated, if cBytes == 0, or if type is
+ *      not one of MEM_PAGED or MEM_NONPAGED.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      The returned pointer, if not NULL, points to a valid memory block
+ *      of the size requested.
+ */
+	extern void *MEM_Calloc(IN u32 cBytes, IN enum MEM_POOLATTRS type);
+
+/*
+ *  ======== MEM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MEM is initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void MEM_Exit(void);
+
+/*
+ *  ======== MEM_FlushCache ========
+ *  Purpose:
+ *      Performs system cache sync with discard
+ *  Parameters:
+ *      pMemBuf:    Pointer to memory region to be flushed.
+ *      pMemBuf:    Size of the memory region to be flushed.
+ *  Returns:
+ *  Requires:
+ *      MEM is initialized.
+ *  Ensures:
+ *      Cache is synchronized
+ */
+	extern void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType);
+
+/*
+ *  ======== MEM_FreePhysMem ========
+ *  Purpose:
+ *      Free the given block of physically contiguous memory.
+ *  Parameters:
+ *      pVirtualAddress:  Pointer to virtual memory region allocated
+ *      by MEM_AllocPhysMem().
+ *      pPhysicalAddress:  Pointer to physical memory region  allocated
+ *      by MEM_AllocPhysMem().
+ *      cBytes:  Size of the memory region allocated by MEM_AllocPhysMem().
+ *  Returns:
+ *  Requires:
+ *      MEM initialized.
+ *      pVirtualAddress is a valid memory address returned by
+ *          MEM_AllocPhysMem()
+ *  Ensures:
+ *      pVirtualAddress is no longer a valid pointer to memory.
+ */
+	extern void MEM_FreePhysMem(void *pVirtualAddress,
+				    u32 pPhysicalAddress, u32 cBytes);
+
+/*
+ *  ======== MEM_FreeObject ========
+ *  Purpose:
+ *      Utility macro to invalidate an object's signature, and deallocate it.
+ *  Parameters:
+ *      pObj:   Pointer to the object to free.
+ *  Returns:
+ *  Requires:
+ *      Same requirements as kfree().
+ *  Ensures:
+ *      A subsequent call to MEM_IsValidHandle() will fail for this object.
+ */
+#define MEM_FreeObject(pObj)    \
+{                               \
+    pObj->dwSignature = 0x00;   \
+    kfree(pObj);                \
+}
+
+/*
+ *  ======== MEM_GetNumPages ========
+ *  Purpose:
+ *      Calculate the number of pages corresponding to the supplied buffer.
+ *  Parameters:
+ *      pAddr:  Linear (virtual) address of the buffer.
+ *      cBytes: Number of bytes in the buffer.
+ *  Returns:
+ *      Number of pages.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *      If cBytes > 0, number of pages returned > 0.
+ */
+	extern s32 MEM_GetNumPages(IN void *pAddr, IN u32 cBytes);
+
+/*
+ *  ======== MEM_Init ========
+ *  Purpose:
+ *      Initializes private state of MEM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      MEM initialized.
+ */
+	extern bool MEM_Init(void);
+
+/*
+ *  ======== MEM_IsValidHandle ========
+ *  Purpose:
+ *      Validate the object handle.
+ *  Parameters:
+ *      hObj:   Handle to object created with MEM_AllocObject().
+ *      Sig:    Expected signature u32.
+ *  Returns:
+ *      TRUE if handle is valid; FALSE otherwise.
+ *  Requires:
+ *      The object structure has a dwSignature field. Ensured by compiler.
+ *  Ensures:
+ */
+#define MEM_IsValidHandle(hObj, Sig)                \
+     ((hObj != NULL) && (hObj->dwSignature == Sig))
+
+/*
+ *  ======== MEM_LinearAddress ========
+ *  Purpose:
+ *      Get the linear address corresponding to the given physical address.
+ *  Parameters:
+ *      pPhysAddr:  Physical address to be mapped.
+ *      cBytes:     Number of bytes in physical range to map.
+ *  Returns:
+ *      The corresponding linear address, or NULL if unsuccessful.
+ *  Requires:
+ *      MEM initialized.
+ *  Ensures:
+ *  Notes:
+ *      If valid linear address is returned, be sure to call
+ *      MEM_UnmapLinearAddress().
+ */
+#define MEM_LinearAddress(pPhyAddr, cBytes) pPhyAddr
+
+/*
+ *  ======== MEM_UnmapLinearAddress ========
+ *  Purpose:
+ *      Unmap the linear address mapped in MEM_LinearAddress.
+ *  Parameters:
+ *      pBaseAddr: Ptr to mapped memory (as returned by MEM_LinearAddress()).
+ *  Returns:
+ *  Requires:
+ *      - MEM initialized.
+ *      - pBaseAddr is a valid linear address mapped in MEM_LinearAddress.
+ *  Ensures:
+ *      - pBaseAddr no longer points to a valid linear address.
+ */
+#define MEM_UnmapLinearAddress(pBaseAddr) {}
+
+/*
+ *  ======== MEM_ExtPhysPoolInit ========
+ *  Purpose:
+ *      Uses the physical memory chunk passed for internal consitent memory
+ *      allocations.
+ *      physical address based on the page frame address.
+ *  Parameters:
+ *      poolPhysBase  starting address of the physical memory pool.
+ *      poolSize      size of the physical memory pool.
+ *  Returns:
+ *      none.
+ *  Requires:
+ *      - MEM initialized.
+ *      - valid physical address for the base and size > 0
+ */
+	extern void MEM_ExtPhysPoolInit(IN u32 poolPhysBase,
+					IN u32 poolSize);
+
+/*
+ *  ======== MEM_ExtPhysPoolRelease ========
+ */
+	extern void MEM_ExtPhysPoolRelease(void);
+
+#endif				/* MEM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/memdefs.h b/arch/arm/plat-omap/include/dspbridge/memdefs.h
new file mode 100644
index 0000000..2e44f5c
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/memdefs.h
@@ -0,0 +1,37 @@
+/*
+ * memdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global MEM constants and types, shared between WCD and WMD.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MEMDEFS_
+#define MEMDEFS_
+
+/* Memory Pool Attributes: */
+	enum MEM_POOLATTRS {
+		MEM_PAGED = 0,
+		MEM_NONPAGED = 1,
+		MEM_LARGEVIRTMEM = 2
+	} ;
+
+/*
+ *  MEM_VIRTUALSEGID is used by Node & Strm to access virtual address space in
+ *  the correct client process context.
+ */
+#define MEM_SETVIRTUALSEGID     0x10000000
+#define MEM_GETVIRTUALSEGID     0x20000000
+#define MEM_MASKVIRTUALSEGID    (MEM_SETVIRTUALSEGID | MEM_GETVIRTUALSEGID)
+
+#endif				/* MEMDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mgr.h b/arch/arm/plat-omap/include/dspbridge/mgr.h
new file mode 100644
index 0000000..e645b05
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mgr.h
@@ -0,0 +1,206 @@
+/*
+ * mgr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This is the Class driver RM module interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MGR_
+#define MGR_
+
+#include <dspbridge/mgrpriv.h>
+
+#define MAX_EVENTS 32
+
+/*
+ *  ======== MGR_WaitForBridgeEvents ========
+ *  Purpose:
+ *      Block on any Bridge event(s)
+ *  Parameters:
+ *      aNotifications  : array of pointers to notification objects.
+ *      uCount          : number of elements in above array
+ *      puIndex         : index of signaled event object
+ *      uTimeout        : timeout interval in milliseocnds
+ *  Returns:
+ *      DSP_SOK         : Success.
+ *      DSP_ETIMEOUT    : Wait timed out. *puIndex is undetermined.
+ *  Details:
+ */
+
+	DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION
+					   **aNotifications,
+					   u32 uCount, OUT u32 *puIndex,
+					   u32 uTimeout);
+
+/*
+ *  ======== MGR_Create ========
+ *  Purpose:
+ *      Creates the Manager Object. This is done during the driver loading.
+ *      There is only one Manager Object in the DSP/BIOS Bridge.
+ *  Parameters:
+ *      phMgrObject:    Location to store created MGR Object handle.
+ *      hDevNode:       Device object as known to Windows system.
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EMEMORY:    Failed to Create the Object
+ *      DSP_EFAIL:      General Failure
+ *  Requires:
+ *      MGR Initialized (cRefs > 0 )
+ *      phMgrObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *phMgrObject is a valid MGR interface to the device.
+ *                      MGR Object stores the DCD Manager Handle.
+ *                      MGR Object stored in the Regsitry.
+ *      !DSP_SOK:       MGR Object not created
+ *  Details:
+ *      DCD Dll is loaded and MGR Object stores the handle of the DLL.
+ */
+	extern DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **hMgrObject,
+				     struct CFG_DEVNODE *hDevNode);
+
+/*
+ *  ======== MGR_Destroy ========
+ *  Purpose:
+ *      Destroys the MGR object. Called upon driver unloading.
+ *  Parameters:
+ *      hMgrObject:     Handle to Manager object .
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *                      DCD Manager freed; MGR Object destroyed;
+ *                      MGR Object deleted from the Registry.
+ *      DSP_EFAIL:      Failed to destroy MGR Object
+ *  Requires:
+ *      MGR Initialized (cRefs > 0 )
+ *      hMgrObject is a valid MGR handle .
+ *  Ensures:
+ *      DSP_SOK:        MGR Object destroyed and hMgrObject is Invalid MGR
+ *                      Handle.
+ */
+	extern DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject);
+
+/*
+ *  ======== MGR_EnumNodeInfo ========
+ *  Purpose:
+ *      Enumerate and get configuration information about nodes configured
+ *      in the node database.
+ *  Parameters:
+ *      uNode:              The node index (base 0).
+ *      pNDBProps:          Ptr to the DSP_NDBPROPS structure for output.
+ *      uNDBPropsSize:      Size of the DSP_NDBPROPS structure.
+ *      puNumNodes:         Location where the number of nodes configured
+ *                          in the database will be returned.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EINVALIDARG:    Parameter uNode is > than the number of nodes.
+ *                          configutred in the system
+ *      DSP_ECHANGEDURINGENUM:  During Enumeration there has been a change in
+ *                              the number of nodes configured or in the
+ *                              the properties of the enumerated nodes.
+ *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *  Requires:
+ *      pNDBPROPS is not null
+ *      uNDBPropsSize >= sizeof(DSP_NDBPROPS)
+ *      puNumNodes is not null
+ *      MGR Initialized (cRefs > 0 )
+ *  Ensures:
+ *      SUCCESS on successful retreival of data and *puNumNodes > 0 OR
+ *      DSP_FAILED  && *puNumNodes == 0.
+ *  Details:
+ */
+	extern DSP_STATUS MGR_EnumNodeInfo(u32 uNode,
+					   OUT struct DSP_NDBPROPS *pNDBProps,
+					   u32 uNDBPropsSize,
+					   OUT u32 *puNumNodes);
+
+/*
+ *  ======== MGR_EnumProcessorInfo ========
+ *  Purpose:
+ *      Enumerate and get configuration information about available DSP
+ *      processors
+ *  Parameters:
+ *      uProcessor:         The processor index (zero-based).
+ *      pProcessorInfo:     Ptr to the DSP_PROCESSORINFO structure .
+ *      uProcessorInfoSize: Size of DSP_PROCESSORINFO structure.
+ *      puNumProcs:         Location where the number of DSPs configured
+ *                          in the database will be returned
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EINVALIDARG:    Parameter uProcessor is > than the number of
+ *                          DSP Processors in the system.
+ *      DSP_EFAIL:          Failed to querry the Node Data Base
+ *  Requires:
+ *      pProcessorInfo is not null
+ *      puNumProcs is not null
+ *      uProcessorInfoSize >= sizeof(DSP_PROCESSORINFO)
+ *      MGR Initialized (cRefs > 0 )
+ *  Ensures:
+ *      SUCCESS on successful retreival of data and *puNumProcs > 0 OR
+ *      DSP_FAILED && *puNumProcs == 0.
+ *  Details:
+ */
+	extern DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
+						OUT struct DSP_PROCESSORINFO *
+						pProcessorInfo,
+						u32 uProcessorInfoSize,
+						OUT u32 *puNumProcs);
+/*
+ *  ======== MGR_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MGR is initialized.
+ *  Ensures:
+ *      When reference count == 0, MGR's private resources are freed.
+ */
+       extern void MGR_Exit(void);
+
+/*
+ *  ======== MGR_GetDCDHandle ========
+ *  Purpose:
+ *      Retrieves the MGR handle. Accessor Function
+ *  Parameters:
+ *      hMGRHandle:     Handle to the Manager Object
+ *      phDCDHandle:    Ptr to receive the DCD Handle.
+ *  Returns:
+ *      DSP_SOK:        Sucess
+ *      DSP_EFAIL:      Failure to get the Handle
+ *  Requires:
+ *      MGR is initialized.
+ *      phDCDHandle != NULL
+ *  Ensures:
+ *      DSP_SOK and *phDCDHandle != NULL ||
+ *      DSP_EFAIL and *phDCDHandle == NULL
+ */
+       extern DSP_STATUS MGR_GetDCDHandle(IN struct MGR_OBJECT
+						 *hMGRHandle,
+						 OUT u32 *phDCDHandle);
+
+/*
+ *  ======== MGR_Init ========
+ *  Purpose:
+ *      Initialize MGR's private state, keeping a reference count on each
+ *      call. Intializes the DCD.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public MGR functions.
+ */
+       extern bool MGR_Init(void);
+
+#endif				/* MGR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/mgrpriv.h b/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
new file mode 100644
index 0000000..cb3b0c2
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/mgrpriv.h
@@ -0,0 +1,45 @@
+/*
+ * mgrpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global MGR constants and types, shared by PROC, MGR, and WCD.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MGRPRIV_
+#define MGRPRIV_
+
+/*
+ * OMAP1510 specific
+ */
+#define MGR_MAXTLBENTRIES  32
+
+/* RM MGR Object */
+	struct MGR_OBJECT;
+
+	struct MGR_TLBENTRY {
+		u32 ulDspVirt;	/* DSP virtual address */
+		u32 ulGppPhys;	/* GPP physical address */
+	} ;
+
+/*
+ *  The DSP_PROCESSOREXTINFO structure describes additional extended
+ *  capabilities of a DSP processor not exposed to user.
+ */
+	struct MGR_PROCESSOREXTINFO {
+		struct DSP_PROCESSORINFO tyBasic;    /* user processor info */
+		/* private dsp mmu entries */
+		struct MGR_TLBENTRY tyTlb[MGR_MAXTLBENTRIES];
+	} ;
+
+#endif				/* MGRPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/msg.h b/arch/arm/plat-omap/include/dspbridge/msg.h
new file mode 100644
index 0000000..2471603
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/msg.h
@@ -0,0 +1,86 @@
+/*
+ * msg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge MSG Module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MSG_
+#define MSG_
+
+#include <dspbridge/devdefs.h>
+#include <dspbridge/msgdefs.h>
+
+/*
+ *  ======== MSG_Create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object. The MSG manager must be created before
+ *      the IO Manager.
+ *  Parameters:
+ *      phMsgMgr:           Location to store MSG manager handle on output.
+ *      hDevObject:         The device object.
+ *      msgCallback:        Called whenever an RMS_EXIT message is received.
+ *  Returns:
+ *  Requires:
+ *      MSG_Init(void) called.
+ *      phMsgMgr != NULL.
+ *      hDevObject != NULL.
+ *      msgCallback != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+				     struct DEV_OBJECT *hDevObject,
+				     MSG_ONEXIT msgCallback);
+
+/*
+ *  ======== MSG_Delete ========
+ *  Purpose:
+ *      Delete a MSG manager allocated in MSG_Create().
+ *  Parameters:
+ *      hMsgMgr:            Handle returned from MSG_Create().
+ *  Returns:
+ *  Requires:
+ *      MSG_Init(void) called.
+ *      Valid hMsgMgr.
+ *  Ensures:
+ */
+	extern void MSG_Delete(struct MSG_MGR *hMsgMgr);
+
+/*
+ *  ======== MSG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of MSG module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      MSG_Init(void) successfully called before.
+ *  Ensures:
+ *      Any resources acquired in MSG_Init(void) will be freed when last MSG
+ *      client calls MSG_Exit(void).
+ */
+	extern void MSG_Exit(void);
+
+/*
+ *  ======== MSG_Init ========
+ *  Purpose:
+ *      Initialize the MSG module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool MSG_Init(void);
+
+#endif				/* MSG_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/msgdefs.h b/arch/arm/plat-omap/include/dspbridge/msgdefs.h
new file mode 100644
index 0000000..8220bdb
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/msgdefs.h
@@ -0,0 +1,32 @@
+/*
+ * msgdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global MSG constants and types.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MSGDEFS_
+#define MSGDEFS_
+
+#define MSGMGR_SIGNATURE    0x4d47534d	/* "MGSM" */
+
+/* MSG Objects: */
+	struct MSG_MGR;
+	struct MSG_QUEUE;
+
+/* Function prototype for callback to be called on RMS_EXIT message received */
+       typedef void(*MSG_ONEXIT) (HANDLE h, s32 nStatus);
+
+#endif				/* MSGDEFS_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/nldr.h b/arch/arm/plat-omap/include/dspbridge/nldr.h
new file mode 100644
index 0000000..4f0639a
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nldr.h
@@ -0,0 +1,55 @@
+/*
+ * nldr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge dynamic loader interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/dbdcddef.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/rmm.h>
+#include <dspbridge/nldrdefs.h>
+
+#ifndef NLDR_
+#define NLDR_
+
+	extern DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr,
+					void *pPrivRef,
+					IN CONST struct DCD_NODEPROPS
+					*pNodeProps,
+					OUT struct NLDR_NODEOBJECT **phNldrNode,
+					IN bool *pfPhaseSplit);
+
+	extern DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
+				      struct DEV_OBJECT *hDevObject,
+				      IN CONST struct NLDR_ATTRS *pAttrs);
+
+	extern void NLDR_Delete(struct NLDR_OBJECT *hNldr);
+	extern void NLDR_Exit(void);
+
+	extern DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode,
+					  char *pstrFxn, u32 *pulAddr);
+
+	extern DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
+					     OUT struct RMM_TargetObj
+					     **phRmmMgr);
+
+	extern bool NLDR_Init(void);
+	extern DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode,
+				    enum NLDR_PHASE phase);
+	extern DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode,
+				    enum NLDR_PHASE phase);
+
+#endif				/* NLDR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nldrdefs.h b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
new file mode 100644
index 0000000..b0646fa
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
@@ -0,0 +1,296 @@
+/*
+ * nldrdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global Dynamic + static/overlay Node loader (NLDR) constants and types.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef NLDRDEFS_
+#define NLDRDEFS_
+
+#include <dspbridge/dbdcddef.h>
+#include <dspbridge/devdefs.h>
+
+#define NLDR_MAXPATHLENGTH       255
+/* NLDR Objects: */
+	struct  NLDR_OBJECT;
+	struct NLDR_NODEOBJECT;
+
+/*
+ *  ======== NLDR_LOADTYPE ========
+ *  Load types for a node. Must match values in node.h55.
+ */
+	enum NLDR_LOADTYPE {
+		NLDR_STATICLOAD,	/* Linked in base image, not overlay */
+		NLDR_DYNAMICLOAD,	/* Dynamically loaded node */
+		NLDR_OVLYLOAD	/* Linked in base image, overlay node */
+	} ;
+
+/*
+ *  ======== NLDR_OVLYFXN ========
+ *  Causes code or data to be copied from load address to run address. This
+ *  is the "COD_WRITEFXN" that gets passed to the DBLL_Library and is used as
+ *  the ZL write function.
+ *
+ *  Parameters:
+ *      pPrivRef:       Handle to identify the node.
+ *      ulDspRunAddr:   Run address of code or data.
+ *      ulDspLoadAddr:  Load address of code or data.
+ *      ulNumBytes:     Number of (GPP) bytes to copy.
+ *      nMemSpace:      RMS_CODE or RMS_DATA.
+ *  Returns:
+ *      ulNumBytes:     Success.
+ *      0:              Failure.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef u32(*NLDR_OVLYFXN) (void *pPrivRef, u32 ulDspRunAddr,
+					     u32 ulDspLoadAddr,
+					     u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== NLDR_WRITEFXN ========
+ *  Write memory function. Used for dynamic load writes.
+ *  Parameters:
+ *      pPrivRef:       Handle to identify the node.
+ *      ulDspAddr:      Address of code or data.
+ *      pBuf:           Code or data to be written
+ *      ulNumBytes:     Number of (GPP) bytes to write.
+ *      nMemSpace:      DBLL_DATA or DBLL_CODE.
+ *  Returns:
+ *      ulNumBytes:     Success.
+ *      0:              Failure.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef u32(*NLDR_WRITEFXN) (void *pPrivRef,
+					      u32 ulDspAddr, void *pBuf,
+					      u32 ulNumBytes, u32 nMemSpace);
+
+/*
+ *  ======== NLDR_ATTRS ========
+ *  Attributes passed to NLDR_Create function.
+ */
+	struct NLDR_ATTRS {
+		NLDR_OVLYFXN pfnOvly;
+		NLDR_WRITEFXN pfnWrite;
+		u16 usDSPWordSize;
+		u16 usDSPMauSize;
+	} ;
+
+/*
+ *  ======== NLDR_PHASE ========
+ *  Indicates node create, delete, or execute phase function.
+ */
+	enum NLDR_PHASE {
+		NLDR_CREATE,
+		NLDR_DELETE,
+		NLDR_EXECUTE,
+		NLDR_NOPHASE
+	} ;
+
+/*
+ *  Typedefs of loader functions imported from a DLL, or defined in a
+ *  function table.
+ */
+
+/*
+ *  ======== NLDR_Allocate ========
+ *  Allocate resources to manage the loading of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldr:          Handle of loader that will load the node.
+ *      pPrivRef:       Handle to identify the node.
+ *      pNodeProps:     Pointer to a DCD_NODEPROPS for the node.
+ *      phNldrNode:     Location to store node handle on output. This handle
+ *                      will be passed to NLDR_Load/NLDR_Unload.
+ *      pfPhaseSplit:   pointer to boolean variable referenced in node.c
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldr.
+ *      pNodeProps != NULL.
+ *      phNldrNode != NULL.
+ *  Ensures:
+ *      DSP_SOK:        IsValidNode(*phNldrNode).
+ *      error:          *phNldrNode == NULL.
+ */
+	typedef DSP_STATUS(*NLDR_ALLOCATEFXN) (struct NLDR_OBJECT *hNldr,
+					       void *pPrivRef,
+					       IN CONST struct DCD_NODEPROPS
+					       *pNodeProps,
+					       OUT struct NLDR_NODEOBJECT
+					       **phNldrNode,
+					       OUT bool *pfPhaseSplit);
+
+/*
+ *  ======== NLDR_Create ========
+ *  Create a loader object. This object handles the loading and unloading of
+ *  create, delete, and execute phase functions of nodes on the DSP target.
+ *
+ *  Parameters:
+ *      phNldr:         Location to store loader handle on output.
+ *      hDevObject:     Device for this processor.
+ *      pAttrs:         Loader attributes.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      phNldr != NULL.
+ *      hDevObject != NULL.
+ *	pAttrs != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valid *phNldr.
+ *      error:          *phNldr == NULL.
+ */
+	typedef DSP_STATUS(*NLDR_CREATEFXN) (OUT struct NLDR_OBJECT **phNldr,
+					     struct DEV_OBJECT *hDevObject,
+					     IN CONST struct NLDR_ATTRS
+					     *pAttrs);
+
+/*
+ *  ======== NLDR_Delete ========
+ *  Delete the NLDR loader.
+ *
+ *  Parameters:
+ *      hNldr:          Node manager object.
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldr.
+ *  Ensures:
+ *	hNldr invalid
+ */
+	typedef void(*NLDR_DELETEFXN) (struct NLDR_OBJECT *hNldr);
+
+/*
+ *  ======== NLDR_Exit ========
+ *  Discontinue usage of NLDR module.
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init(void) successfully called before.
+ *  Ensures:
+ *      Any resources acquired in NLDR_Init(void) will be freed when last NLDR
+ *      client calls NLDR_Exit(void).
+ */
+	typedef void(*NLDR_EXITFXN) (void);
+
+/*
+ *  ======== NLDR_Free ========
+ *  Free resources allocated in NLDR_Allocate.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *  Returns:
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef void(*NLDR_FREEFXN) (struct NLDR_NODEOBJECT *hNldrNode);
+
+/*
+ *  ======== NLDR_GetFxnAddr ========
+ *  Get address of create, delete, or execute phase function of a node on
+ *  the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      pstrFxn:        Name of function.
+ *      pulAddr:        Location to store function address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ESYMBOL:    Address of function not found.
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldrNode.
+ *      pulAddr != NULL;
+ *      pstrFxn != NULL;
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_GETFXNADDRFXN) (struct NLDR_NODEOBJECT
+						 *hNldrNode,
+						 char *pstrFxn, u32 *pulAddr);
+
+/*
+ *  ======== NLDR_Init ========
+ *  Initialize the NLDR module.
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	typedef bool(*NLDR_INITFXN) (void);
+
+/*
+ *  ======== NLDR_Load ========
+ *  Load create, delete, or execute phase function of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      phase:          Type of function to load (create, delete, or execute).
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EMEMORY:            Insufficient memory on GPP.
+ *      DSP_EOVERLAYMEMORY:     Can't overlay phase because overlay memory
+ *                              is already in use.
+ *      DSP_EDYNLOAD:           Failure in dynamic loader library.
+ *      DSP_EFWRITE:            Failed to write phase's code or date to target.
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_LOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
+					   enum NLDR_PHASE phase);
+
+/*
+ *  ======== NLDR_Unload ========
+ *  Unload create, delete, or execute phase function of a node on the DSP.
+ *
+ *  Parameters:
+ *      hNldrNode:      Handle returned from NLDR_Allocate().
+ *      phase:          Node function to unload (create, delete, or execute).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *  Requires:
+ *      NLDR_Init(void) called.
+ *      Valid hNldrNode.
+ *  Ensures:
+ */
+	typedef DSP_STATUS(*NLDR_UNLOADFXN) (struct NLDR_NODEOBJECT *hNldrNode,
+					     enum NLDR_PHASE phase);
+
+/*
+ *  ======== NLDR_FXNS ========
+ */
+	struct NLDR_FXNS {
+		NLDR_ALLOCATEFXN pfnAllocate;
+		NLDR_CREATEFXN pfnCreate;
+		NLDR_DELETEFXN pfnDelete;
+		NLDR_EXITFXN pfnExit;
+		NLDR_GETFXNADDRFXN pfnGetFxnAddr;
+		NLDR_INITFXN pfnInit;
+		NLDR_LOADFXN pfnLoad;
+		NLDR_UNLOADFXN pfnUnload;
+	} ;
+
+#endif				/* NLDRDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/node.h b/arch/arm/plat-omap/include/dspbridge/node.h
new file mode 100644
index 0000000..2a45fc0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -0,0 +1,578 @@
+/*
+ * node.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Node Manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef NODE_
+#define NODE_
+
+#include <dspbridge/procpriv.h>
+
+#include <dspbridge/nodedefs.h>
+#include <dspbridge/dispdefs.h>
+#include <dspbridge/nldrdefs.h>
+#include <dspbridge/drv.h>
+
+/*
+ *  ======== NODE_Allocate ========
+ *  Purpose:
+ *      Allocate GPP resources to manage a node on the DSP.
+ *  Parameters:
+ *      hProcessor:         Handle of processor that is allocating the node.
+ *      pNodeId:            Pointer to a DSP_UUID for the node.
+ *      pArgs:              Optional arguments to be passed to the node.
+ *      pAttrIn:            Optional pointer to node attributes (priority,
+ *                          timeout...)
+ *      phNode:             Location to store node handle on output.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory on GPP.
+ *      DSP_EUUID:          Node UUID has not been registered.
+ *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
+ *      DSP_ERANGE:         pAttrIn != NULL and pAttrIn->iPriority out of
+ *                          range.
+ *      DSP_EFAIL:          A failure occured, unable to allocate node.
+ *      DSP_EWRONGSTATE:    Proccessor is not in the running state.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      hProcessor != NULL.
+ *      pNodeId != NULL.
+ *      phNode != NULL.
+ *  Ensures:
+ *      DSP_SOK:            IsValidNode(*phNode).
+ *      error:              *phNode == NULL.
+ */
+	extern DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
+					IN CONST struct DSP_UUID *pNodeId,
+					OPTIONAL IN CONST struct DSP_CBDATA
+					*pArgs,
+					OPTIONAL IN CONST struct DSP_NODEATTRIN
+					*pAttrIn,
+					OUT struct NODE_OBJECT **phNode,
+					struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== NODE_AllocMsgBuf ========
+ *  Purpose:
+ *      Allocate and Prepare a buffer whose descriptor will be passed to a
+ *      Node within a (DSP_MSG)message
+ *  Parameters:
+ *      hNode:          The node handle.
+ *      uSize:          The size of the buffer to be allocated.
+ *      pAttr:          Pointer to a DSP_BUFFERATTR structure.
+ *      pBuffer:        Location to store the address of the allocated
+ *                      buffer on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid node handle.
+ *      DSP_EMEMORY:    Insufficent memory.
+ *      DSP_EFAIL:      General Failure.
+ *      DSP_ESIZE:      Invalid Size.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_AllocMsgBuf(struct NODE_OBJECT *hNode,
+					   u32 uSize,
+					   OPTIONAL struct DSP_BUFFERATTR
+					   *pAttr,
+					   OUT u8 **pBuffer);
+
+/*
+ *  ======== NODE_ChangePriority ========
+ *  Purpose:
+ *      Change the priority of an allocated node.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate.
+ *      nPriority:          New priority level to set node's priority to.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ERANGE:         nPriority is out of range.
+ *      DSP_ENODETYPE:      The specified node is not a task node.
+ *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED, NODE_PAUSED,
+ *                          or NODE_RUNNING state.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_ERESTART:       A critical error has occurred and the DSP is
+ *                          being restarted.
+ *      DSP_EFAIL:          Unable to change node's runtime priority level.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ *      DSP_SOK && (Node's current priority == nPriority)
+ */
+	extern DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode,
+					      s32 nPriority);
+
+/*
+ *  ======== NODE_CloseOrphans ========
+ *  Purpose:
+ *      Delete all nodes whose owning processor is being destroyed.
+ *  Parameters:
+ *      hNodeMgr:       Node manager object.
+ *      hProc:          Handle to processor object being destroyed.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to delete all nodes belonging to hProc.
+ *  Requires:
+ *      Valid hNodeMgr.
+ *      hProc != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_CloseOrphans(struct NODE_MGR *hNodeMgr,
+					    struct PROC_OBJECT *hProc);
+
+/*
+ *  ======== NODE_Connect ========
+ *  Purpose:
+ *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
+ *      case that the connnection is being made between a node on the DSP and
+ *      the GPP, one of the node handles (either hNode1 or hNode2) must be
+ *      the constant NODE_HGPPNODE.
+ *  Parameters:
+ *      hNode1:         Handle of first node to connect to second node. If
+ *                      this is a connection from the GPP to hNode2, hNode1
+ *                      must be the constant NODE_HGPPNODE. Otherwise, hNode1
+ *                      must be a node handle returned from a successful call
+ *                      to Node_Allocate().
+ *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
+ *                      if this is a connection from DSP node to GPP, or a
+ *                      node handle returned from a successful call to
+ *                      NODE_Allocate().
+ *      uStream1:       Output stream index on first node, to be connected
+ *                      to second node's input stream. Value must range from
+ *                      0 <= uStream1 < number of output streams.
+ *      uStream2:       Input stream index on second node. Value must range
+ *                      from 0 <= uStream2 < number of input streams.
+ *      pAttrs:         Stream attributes (NULL ==> use defaults).
+ *      pConnParam:     A pointer to a DSP_CBDATA structure that defines
+ *                      connection parameter for device nodes to pass to DSP
+ *                      side.
+ *                      If the value of this parameter is NULL, then this API
+ *                      behaves like DSPNode_Connect. This parameter will have
+ *                      length of the string and the null terminated string in
+ *                      DSP_CBDATA struct. This can be extended in future tp
+ *                      pass binary data.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            Invalid hNode1 or hNode2.
+ *      DSP_EMEMORY:            Insufficient host memory.
+ *      DSP_EVALUE:             A stream index parameter is invalid.
+ *      DSP_EALREADYCONNECTED:  A connection already exists for one of the
+ *                              indices uStream1 or uStream2.
+ *      DSP_EWRONGSTATE:        Either hNode1 or hNode2 is not in the
+ *                              NODE_ALLOCATED state.
+ *      DSP_ENOMORECONNECTIONS: No more connections available.
+ *      DSP_EFAIL:              Attempt to make an illegal connection (eg,
+ *                              Device node to device node, or device node to
+ *                              GPP), the two nodes are on different DSPs.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1,
+				       u32 uStream1,
+				       struct NODE_OBJECT *hNode2,
+				       u32 uStream2,
+				       OPTIONAL IN struct DSP_STRMATTR *pAttrs,
+				       OPTIONAL IN struct DSP_CBDATA
+				       *pConnParam);
+
+/*
+ *  ======== NODE_Create ========
+ *  Purpose:
+ *      Create a node on the DSP by remotely calling the node's create
+ *      function. If necessary, load code that contains the node's create
+ *      function.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ESYMBOL:        Create function not found in the COFF file.
+ *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
+ *      DSP_EMEMORY:        Memory allocation failure on the DSP.
+ *      DSP_ETASK:          Unable to create node's task or process on the DSP.
+ *      DSP_ESTREAM:        Stream creation failure on the DSP.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EUSER1-16:      A user-defined failure occurred on the DSP.
+ *      DSP_EFAIL:          A failure occurred, unable to create node.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_CreateMgr ========
+ *  Purpose:
+ *      Create a NODE Manager object. This object handles the creation,
+ *      deletion, and execution of nodes on the DSP target. The NODE Manager
+ *      also maintains a pipe map of used and available node connections.
+ *      Each DEV object should have exactly one NODE Manager object.
+ *
+ *  Parameters:
+ *      phNodeMgr:      Location to store node manager handle on output.
+ *      hDevObject:     Device for this processor.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      phNodeMgr != NULL.
+ *      hDevObject != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valide *phNodeMgr.
+ *      error:          *phNodeMgr == NULL.
+ */
+	extern DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
+					 struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== NODE_Delete ========
+ *  Purpose:
+ *      Delete resources allocated in NODE_Allocate(). If the node was
+ *      created, delete the node on the DSP by remotely calling the node's
+ *      delete function. Loads the node's delete function if necessary.
+ *      GPP side resources are freed after node's delete function returns.
+ *  Parameters:
+ *      hNode:              Node handle returned from NODE_Allocate().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EDELETE:        A deletion failure occurred.
+ *      DSP_EUSER1-16:      Node specific failure occurred on the DSP.
+ *      DSP_EFAIL:          A failure occurred in deleting the node.
+ *      DSP_ESYMBOL:        Delete function not found in the COFF file.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ *      DSP_SOK:            hNode is invalid.
+ */
+	extern DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
+			struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== NODE_DeleteMgr ========
+ *  Purpose:
+ *      Delete the NODE Manager.
+ *  Parameters:
+ *      hNodeMgr:       Node manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      Valid hNodeMgr.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr);
+
+/*
+ *  ======== NODE_EnumNodes ========
+ *  Purpose:
+ *      Enumerate the nodes currently allocated for the DSP.
+ *  Parameters:
+ *      hNodeMgr:       Node manager returned from NODE_CreateMgr().
+ *      aNodeTab:       Array to copy node handles into.
+ *      uNodeTabSize:   Number of handles that can be written to aNodeTab.
+ *      puNumNodes:     Location where number of node handles written to
+ *                      aNodeTab will be written.
+ *      puAllocated:    Location to write total number of allocated nodes.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ESIZE:      aNodeTab is too small to hold all node handles.
+ *  Requires:
+ *      Valid hNodeMgr.
+ *      aNodeTab != NULL || uNodeTabSize == 0.
+ *      puNumNodes != NULL.
+ *      puAllocated != NULL.
+ *  Ensures:
+ *      - (DSP_ESIZE && *puNumNodes == 0)
+ *      - || (DSP_SOK && *puNumNodes <= uNodeTabSize)  &&
+ *        (*puAllocated == *puNumNodes)
+ */
+	extern DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr,
+					 void **aNodeTab,
+					 u32 uNodeTabSize,
+					 OUT u32 *puNumNodes,
+					 OUT u32 *puAllocated);
+
+/*
+ *  ======== NODE_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NODE module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NODE_Init(void) successfully called before.
+ *  Ensures:
+ *      Any resources acquired in NODE_Init(void) will be freed when last NODE
+ *      client calls NODE_Exit(void).
+ */
+	extern void NODE_Exit(void);
+
+/*
+ *  ======== NODE_FreeMsgBuf ========
+ *  Purpose:
+ *      Free a message buffer previously allocated with NODE_AllocMsgBuf.
+ *  Parameters:
+ *      hNode:          The node handle.
+ *      pBuffer:        (Address) Buffer allocated by NODE_AllocMsgBuf.
+ *      pAttr:          Same buffer attributes passed to NODE_AllocMsgBuf.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid node handle.
+ *      DSP_EFAIL:      Failure to free the buffer.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode,
+					  IN u8 *pBuffer,
+					  OPTIONAL struct DSP_BUFFERATTR
+					  *pAttr);
+
+/*
+ *  ======== NODE_GetAttr ========
+ *  Purpose:
+ *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      structure.
+ *  Parameters:
+ *      hNode:          Node object allocated from NODE_Allocate().
+ *      pAttr:          Pointer to DSP_NODEATTR structure to copy node's
+ *                      attributes.
+ *      uAttrSize:      Size of pAttr.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pAttr != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *pAttrs contains the node's current attributes.
+ */
+	extern DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
+				       OUT struct DSP_NODEATTR *pAttr,
+				       u32 uAttrSize);
+
+/*
+ *  ======== NODE_GetMessage ========
+ *  Purpose:
+ *      Retrieve a message from a node on the DSP. The node must be either a
+ *      message node, task node, or XDAIS socket node.
+ *      If a message is not available, this function will block until a
+ *      message is available, or the node's timeout value is reached.
+ *  Parameters:
+ *      hNode:          Node handle returned from NODE_Allocate().
+ *      pMessage:       Pointer to DSP_MSG structure to copy the
+ *                      message into.
+ *      uTimeout:       Timeout in milliseconds to wait for message.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_ENODETYPE:  Cannot retrieve messages from this type of node.
+ *      DSP_ETIMEOUT:   Timeout occurred and no message is available.
+ *      DSP_EFAIL:      Error occurred while trying to retrieve a message.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pMessage != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode,
+					  OUT struct DSP_MSG *pMessage,
+					  u32 uTimeout);
+
+/*
+ *  ======== NODE_GetNldrObj ========
+ *  Purpose:
+ *      Retrieve the Nldr manager
+ *  Parameters:
+ *      hNodeMgr:       Node Manager
+ *      phNldrObj:      Pointer to a Nldr manager handle
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
+					  OUT struct NLDR_OBJECT **phNldrObj);
+
+/*
+ *  ======== NODE_Init ========
+ *  Purpose:
+ *      Initialize the NODE module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool NODE_Init(void);
+
+/*
+ *  ======== NODE_OnExit ========
+ *  Purpose:
+ *      Gets called when RMS_EXIT is received for a node. PROC needs to pass
+ *      this function as a parameter to MSG_Create(). This function then gets
+ *      called by the mini-driver when an exit message for a node is received.
+ *  Parameters:
+ *      hNode:      Handle of the node that the exit message is for.
+ *      nStatus:    Return status of the node's execute phase.
+ *  Returns:
+ *  Ensures:
+ */
+	void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus);
+
+/*
+ *  ======== NODE_Pause ========
+ *  Purpose:
+ *      Suspend execution of a node currently running on the DSP.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      Node is not a task or socket node.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EWRONGSTSATE:   Node is not in NODE_RUNNING state.
+ *      DSP_EFAIL:          Failed to pause node.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_PutMessage ========
+ *  Purpose:
+ *      Send a message to a message node, task node, or XDAIS socket node.
+ *      This function will block until the message stream can accommodate
+ *      the message, or a timeout occurs. The message will be copied, so Msg
+ *      can be re-used immediately after return.
+ *  Parameters:
+ *      hNode:              Node handle returned by NODE_Allocate().
+ *      pMsg:               Location of message to be sent to the node.
+ *      uTimeout:           Timeout in msecs to wait.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      Messages can't be sent to this type of node.
+ *      DSP_ETIMEOUT:       Timeout occurred before message could be set.
+ *      DSP_EWRONGSTATE:    Node is in invalid state for sending messages.
+ *      DSP_EFAIL:          Unable to send message.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
+					  IN CONST struct DSP_MSG *pMsg,
+					  u32 uTimeout);
+
+/*
+ *  ======== NODE_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this node.
+ *  Parameters:
+ *      hNode:          Node handle returned by NODE_Allocate().
+ *      uEventMask:     Mask of types of events to be notified about.
+ *      uNotifyType:    Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      DSP_EVALUE:     uEventMask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *                      supported.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      hNotification != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== NODE_Run ========
+ *  Purpose:
+ *      Start execution of a node's execute phase, or resume execution of
+ *      a node that has been suspended (via NODE_Pause()) on the DSP. Load
+ *      the node's execute function if necessary.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ENODETYPE:      hNode doesn't represent a message, task or dais
+ *                          socket node.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_EWRONGSTSATE:   Node is not in NODE_PAUSED or NODE_CREATED state.
+ *      DSP_EFAIL:          Unable to start or resume execution.
+ *      DSP_ESYMBOL:        Execute function not found in the COFF file.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_Terminate ========
+ *  Purpose:
+ *      Signal a node running on the DSP that it should exit its execute
+ *      phase function.
+ *  Parameters:
+ *      hNode:              Node object representing a node currently
+ *                          running on the DSP.
+ *      pStatus:            Location to store execute-phase function return
+ *                          value (DSP_EUSER1-16).
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hNode.
+ *      DSP_ETIMEOUT:       A timeout occurred before the DSP responded.
+ *      DSP_ENODETYPE:      Type of node specified cannot be terminated.
+ *      DSP_EWRONGSTATE:    Operation not valid for the current node state.
+ *      DSP_EFAIL:          Unable to terminate the node.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      pStatus != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode,
+					 OUT DSP_STATUS *pStatus);
+
+
+
+/*
+ *  ======== NODE_GetUUIDProps ========
+ *  Purpose:
+ *      Fetch Node properties given the UUID
+ *  Parameters:
+ *
+ */
+	extern DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
+					    IN CONST struct DSP_UUID *pNodeId,
+					    OUT struct DSP_NDBPROPS
+					    *pNodeProps);
+
+#endif				/* NODE_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nodedefs.h b/arch/arm/plat-omap/include/dspbridge/nodedefs.h
new file mode 100644
index 0000000..6eb7537
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nodedefs.h
@@ -0,0 +1,28 @@
+/*
+ * nodedefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global NODE constants and types, shared by PROCESSOR, NODE, and DISP.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef NODEDEFS_
+#define NODEDEFS_
+
+#define NODE_SUSPENDEDPRI -1
+
+/* NODE Objects: */
+	struct NODE_MGR;
+	struct NODE_OBJECT;
+
+#endif				/* NODEDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/nodepriv.h b/arch/arm/plat-omap/include/dspbridge/nodepriv.h
new file mode 100644
index 0000000..cc74318
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/nodepriv.h
@@ -0,0 +1,183 @@
+/*
+ * nodepriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private node header shared by NODE and DISP.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef NODEPRIV_
+#define NODEPRIV_
+
+#include <dspbridge/strmdefs.h>
+#include <dspbridge/nodedefs.h>
+#include <dspbridge/nldrdefs.h>
+
+/* DSP address of node environment structure */
+	typedef u32 NODE_ENV;
+
+/*
+ *  Node create structures
+ */
+
+/* Message node */
+	struct NODE_MSGARGS {
+		u32 uMaxMessages; /* Max # of simultaneous messages for node */
+		u32 uSegid;	/* Segment for allocating message buffers */
+		u32 uNotifyType;  /* Notify type (SEM_post, SWI_post, etc.) */
+		u32 uArgLength;  /* Length in 32-bit words of arg data block */
+		u8 *pData;	/* Argument data for node */
+	} ;
+
+	struct NODE_STRMDEF {
+		u32 uBufsize;	/* Size of buffers for SIO stream */
+		u32 uNumBufs;	/* max # of buffers in SIO stream at once */
+		u32 uSegid;	/* Memory segment id to allocate buffers */
+		u32 uTimeout;	/* Timeout for blocking SIO calls */
+		u32 uAlignment;	/* Buffer alignment */
+		char *szDevice;	/* Device name for stream */
+	} ;
+
+/* Task node */
+	struct NODE_TASKARGS {
+		struct NODE_MSGARGS msgArgs;
+		s32 nPriority;
+		u32 uStackSize;
+		u32 uSysStackSize;
+		u32 uStackSeg;
+		u32 uDSPHeapResAddr;	/* DSP virtual heap address */
+		u32 uDSPHeapAddr;	/* DSP virtual heap address */
+		u32 uHeapSize;	/* Heap size */
+		u32 uGPPHeapAddr;	/* GPP virtual heap address */
+		u32 uProfileID;	/* Profile ID */
+		u32 uNumInputs;
+		u32 uNumOutputs;
+		u32 ulDaisArg;	/* Address of iAlg object */
+		struct NODE_STRMDEF *strmInDef;
+		struct NODE_STRMDEF *strmOutDef;
+	} ;
+
+/*
+ *  ======== NODE_CREATEARGS ========
+ */
+	struct NODE_CREATEARGS {
+		union {
+			struct NODE_MSGARGS msgArgs;
+			struct NODE_TASKARGS taskArgs;
+		} asa;
+	} ;
+
+/*
+ *  ======== NODE_GetChannelId ========
+ *  Purpose:
+ *      Get the channel index reserved for a stream connection between the
+ *      host and a node. This index is reserved when NODE_Connect() is called
+ *      to connect the node with the host. This index should be passed to
+ *      the CHNL_Open function when the stream is actually opened.
+ *  Parameters:
+ *      hNode:          Node object allocated from NODE_Allocate().
+ *      uDir:           Input (DSP_TONODE) or output (DSP_FROMNODE).
+ *      uIndex:         Stream index.
+ *      pulId:          Location to store channel index.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_ENODETYPE:  Not a task or DAIS socket node.
+ *      DSP_EVALUE:     The node's stream corresponding to uIndex and uDir
+ *                      is not a stream to or from the host.
+ *  Requires:
+ *      NODE_Init(void) called.
+ *      Valid uDir.
+ *      pulId != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode,
+					    u32 uDir,
+					    u32 uIndex, OUT u32 *pulId);
+
+/*
+ *  ======== NODE_GetStrmMgr ========
+ *  Purpose:
+ *      Get the STRM manager for a node.
+ *  Parameters:
+ *      hNode:          Node allocated with NODE_Allocate().
+ *      phStrmMgr:      Location to store STRM manager on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *  Requires:
+ *      phStrmMgr != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
+					  struct STRM_MGR **phStrmMgr);
+
+/*
+ *  ======== NODE_GetTimeout ========
+ *  Purpose:
+ *      Get the timeout value of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node's timeout value.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern u32 NODE_GetTimeout(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== NODE_GetType ========
+ *  Purpose:
+ *      Get the type (device, message, task, or XDAIS socket) of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node type:  NODE_DEVICE, NODE_TASK, NODE_XDAIS, or NODE_GPP.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode);
+
+/*
+ *  ======== GetNodeInfo ========
+ *  Purpose:
+ *      Get node information without holding semaphore.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node info:  priority, device owner, no. of streams, execution state
+ *                  NDB properties.
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern void GetNodeInfo(struct NODE_OBJECT *hNode,
+				struct DSP_NODEINFO *pNodeInfo);
+
+/*
+ *  ======== NODE_GetLoadType ========
+ *  Purpose:
+ *      Get the load type (dynamic, overlay, static) of a node.
+ *  Parameters:
+ *      hNode:      Node allocated with NODE_Allocate(), or DSP_HGPPNODE.
+ *  Returns:
+ *      Node type:  NLDR_DYNAMICLOAD, NLDR_OVLYLOAD, NLDR_STATICLOAD
+ *  Requires:
+ *      Valid hNode.
+ *  Ensures:
+ */
+	extern enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode);
+
+#endif				/* NODEPRIV_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/ntfy.h b/arch/arm/plat-omap/include/dspbridge/ntfy.h
new file mode 100644
index 0000000..3448a69
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/ntfy.h
@@ -0,0 +1,128 @@
+/*
+ * ntfy.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Manage lists of notification events.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef NTFY_
+#define NTFY_
+
+	struct NTFY_OBJECT;
+
+/*
+ *  ======== NTFY_Create ========
+ *  Purpose:
+ *      Create an empty list of notifications.
+ *  Parameters:
+ *      phNtfy:         Location to store handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *  Requires:
+ *      NTFY_Init(void) called.
+ *      phNtfy != NULL.
+ *  Ensures:
+ *      DSP_SUCCEEDED(status) <==>  IsValid(*phNtfy).
+ */
+	extern DSP_STATUS NTFY_Create(OUT struct NTFY_OBJECT **phNtfy);
+
+/*
+ *  ======== NTFY_Delete ========
+ *  Purpose:
+ *      Free resources allocated in NTFY_Create.
+ *  Parameters:
+ *      hNtfy:  Handle returned from NTFY_Create().
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init(void) called.
+ *      IsValid(hNtfy).
+ *  Ensures:
+ */
+	extern void NTFY_Delete(IN struct NTFY_OBJECT *hNtfy);
+
+/*
+ *  ======== NTFY_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NTFY module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init(void) successfully called before.
+ *  Ensures:
+ */
+	extern void NTFY_Exit(void);
+
+/*
+ *  ======== NTFY_Init ========
+ *  Purpose:
+ *      Initialize the NTFY module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Ensures:
+ */
+	extern bool NTFY_Init(void);
+
+/*
+ *  ======== NTFY_Notify ========
+ *  Purpose:
+ *      Execute notify function (signal event or post message) for every
+ *      element in the notification list that is to be notified about the
+ *      event specified in uEventMask.
+ *  Parameters:
+ *      hNtfy:      Handle returned from NTFY_Create().
+ *      uEventMask: The type of event that has occurred.
+ *  Returns:
+ *  Requires:
+ *      NTFY_Init(void) called.
+ *      IsValid(hNtfy).
+ *  Ensures:
+ */
+	extern void NTFY_Notify(IN struct NTFY_OBJECT *hNtfy,
+				IN u32 uEventMask);
+
+/*
+ *  ======== NTFY_Register ========
+ *  Purpose:
+ *      Add a notification element to the list. If the notification is already
+ *      registered, and uEventMask != 0, the notification will get posted for
+ *      events specified in the new event mask. If the notification is already
+ *      registered and uEventMask == 0, the notification will be unregistered.
+ *  Parameters:
+ *      hNtfy:              Handle returned from NTFY_Create().
+ *      hNotification:      Handle to a DSP_NOTIFICATION object.
+ *      uEventMask:         Events to be notified about.
+ *      uNotifyType:        Type of notification: DSP_SIGNALEVENT.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *      DSP_EVALUE:         uEventMask is 0 and hNotification was not
+ *                          previously registered.
+ *      DSP_EHANDLE:        NULL hNotification, hNotification event name
+ *                          too long, or hNotification event name NULL.
+ *  Requires:
+ *      NTFY_Init(void) called.
+ *      IsValid(hNtfy).
+ *      hNotification != NULL.
+ *      uNotifyType is DSP_SIGNALEVENT
+ *  Ensures:
+ */
+	extern DSP_STATUS NTFY_Register(IN struct NTFY_OBJECT *hNtfy,
+					IN struct DSP_NOTIFICATION
+					*hNotification,
+					IN u32 uEventMask,
+					IN u32 uNotifyType);
+
+#endif				/* NTFY_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/proc.h b/arch/arm/plat-omap/include/dspbridge/proc.h
new file mode 100644
index 0000000..ccafba6
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -0,0 +1,608 @@
+/*
+ * proc.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This is the Class driver RM module interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef PROC_
+#define PROC_
+
+#include <dspbridge/cfgdefs.h>
+#include <dspbridge/devdefs.h>
+#include <dspbridge/drv.h>
+
+/*
+ *  ======== PROC_Attach ========
+ *  Purpose:
+ *      Prepare for communication with a particular DSP processor, and return
+ *      a handle to the processor object. The PROC Object gets created
+ *  Parameters:
+ *      uProcessor  :	   The processor index (zero-based).
+ *      hMgrObject  :	   Handle to the Manager Object
+ *      pAttrIn     :	   Ptr to the DSP_PROCESSORATTRIN structure.
+ *			      A NULL value means use default values.
+ *      phProcessor :	   Ptr to location to store processor handle.
+ *  Returns:
+ *      DSP_SOK     :	   Success.
+ *      DSP_EFAIL   :	   General failure.
+ *      DSP_EHANDLE :	   Invalid processor handle.
+ *      DSP_SALREADYATTACHED:   Success; Processor already attached.
+ *  Requires:
+ *      phProcessor != NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ *      DSP_EFAIL, and *phProcessor == NULL, OR
+ *      Success and *phProcessor is a Valid Processor handle OR
+ *      DSP_SALREADYATTACHED and *phProcessor is a Valid Processor.
+ *  Details:
+ *      When pAttrIn is NULL, the default timeout value is 10 seconds.
+ */
+	extern DSP_STATUS PROC_Attach(u32 uProcessor,
+				      OPTIONAL CONST struct DSP_PROCESSORATTRIN
+				      *pAttrIn, void **phProcessor,
+				      struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== PROC_AutoStart =========
+ *  Purpose:
+ *      A Particular device gets loaded with the default image
+ *      if the AutoStart flag is set.
+ *  Parameters:
+ *      hDevObject  :   Handle to the Device
+ *  Returns:
+ *      DSP_SOK     :   On Successful Loading
+ *      DSP_EFILE   :   No DSP exec file found.
+ *      DSP_EFAIL   :   General Failure
+ *  Requires:
+ *      hDevObject != NULL.
+ *      hDevNode != NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
+					 struct DEV_OBJECT *hDevObject);
+
+/*
+ *  ======== PROC_Ctrl ========
+ *  Purpose:
+ *      Pass control information to the GPP device driver managing the DSP
+ *      processor. This will be an OEM-only function, and not part of the
+ *      'Bridge application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      dwCmd       :       Private driver IOCTL cmd ID.
+ *      pArgs       :       Ptr to an driver defined argument structure.
+ *  Returns:
+ *      DSP_SOK     :       SUCCESS
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_ETIMEOUT:       A Timeout Occured before the Control information
+ *			  could be sent.
+ *      DSP_EACCESSDENIED:  Client does not have the access rights required
+ *			  to call this function.
+ *      DSP_ERESTART:       A Critical error has occured and the DSP is being
+ *			  restarted.
+ *      DSP_EFAIL   :       General Failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures
+ *  Details:
+ *      This function Calls WMD_BRD_Ioctl.
+ */
+	extern DSP_STATUS PROC_Ctrl(void *hProcessor,
+				    u32 dwCmd, IN struct DSP_CBDATA *pArgs);
+
+/*
+ *  ======== PROC_Detach ========
+ *  Purpose:
+ *      Close a DSP processor and de-allocate all (GPP) resources reserved
+ *      for it. The Processor Object is deleted.
+ *  Parameters:
+ *      pr_ctxt     :   The processor handle.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   InValid Handle.
+ *      DSP_EFAIL   :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      PROC Object is destroyed.
+ */
+	extern DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== PROC_EnumNodes ========
+ *  Purpose:
+ *      Enumerate the nodes currently allocated on a processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      aNodeTab    :   The first Location of an array allocated for node
+ *		      handles.
+ *      uNodeTabSize:   The number of (DSP_HNODE) handles that can be held
+ *		      to the memory the client has allocated for aNodeTab
+ *      puNumNodes  :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of valid handles written to aNodeTab
+ *      puAllocated :   Location where DSPProcessor_EnumNodes will return
+ *		      the number of nodes that are allocated on the DSP.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_ESIZE   :   The amount of memory allocated for aNodeTab is
+ *		      insufficent. That is the number of nodes actually
+ *		      allocated on the DSP is greater than the value
+ *		      specified for uNodeTabSize.
+ *      DSP_EFAIL   :   Unable to get Resource Information.
+ *  Details:
+ *  Requires
+ *      puNumNodes is not NULL.
+ *      puAllocated is not NULL.
+ *      aNodeTab is not NULL.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_EnumNodes(void *hProcessor,
+					 void **aNodeTab,
+					 IN u32 uNodeTabSize,
+					 OUT u32 *puNumNodes,
+					 OUT u32 *puAllocated);
+
+/*
+ *  ======== PROC_GetResourceInfo ========
+ *  Purpose:
+ *      Enumerate the resources currently available on a processor.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      uResourceType:      Type of resource .
+ *      pResourceInfo:      Ptr to the DSP_RESOURCEINFO structure.
+ *      uResourceInfoSize:  Size of the structure.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    The processor is not in the PROC_RUNNING state.
+ *      DSP_ETIMEOUT:       A timeout occured before the DSP responded to the
+ *			  querry.
+ *      DSP_ERESTART:       A Critical error has occured and the DSP is being
+ *			  restarted.
+ *      DSP_EFAIL   :       Unable to get Resource Information
+ *  Requires:
+ *      pResourceInfo is not NULL.
+ *      Parameter uResourceType is Valid.[TBD]
+ *      uResourceInfoSize is >= sizeof DSP_RESOURCEINFO struct.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      This function currently returns
+ *      DSP_ENOTIMPL, and does not write any data to the pResourceInfo struct.
+ */
+	extern DSP_STATUS PROC_GetResourceInfo(void *hProcessor,
+					       u32 uResourceType,
+					       OUT struct DSP_RESOURCEINFO *
+					       pResourceInfo,
+					       u32 uResourceInfoSize);
+
+/*
+ *  ======== PROC_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      PROC is initialized.
+ *  Ensures:
+ *      When reference count == 0, PROC's private resources are freed.
+ */
+       extern void PROC_Exit(void);
+
+/*
+ * ======== PROC_GetDevObject =========
+ *  Purpose:
+ *      Returns the DEV Hanlde for a given Processor handle
+ *  Parameters:
+ *      hProcessor  :   Processor Handle
+ *      phDevObject :   Location to store the DEV Handle.
+ *  Returns:
+ *      DSP_SOK     :   Success; *phDevObject has Dev handle
+ *      DSP_EFAIL   :   Failure; *phDevObject is zero.
+ *  Requires:
+ *      phDevObject is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *      DSP_SOK     :   *phDevObject is not NULL
+ *      DSP_EFAIL   :   *phDevObject is NULL.
+ */
+	extern DSP_STATUS PROC_GetDevObject(void *hProcessor,
+					    struct DEV_OBJECT **phDevObject);
+
+/*
+ *  ======== PROC_Init ========
+ *  Purpose:
+ *      Initialize PROC's private state, keeping a reference count on each
+ *      call.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      TRUE: A requirement for the other public PROC functions.
+ */
+       extern bool PROC_Init(void);
+
+/*
+ *  ======== PROC_GetState ========
+ *  Purpose:
+ *      Report the state of the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      pProcStatus :   Ptr to location to store the DSP_PROCESSORSTATE
+ *		      structure.
+ *      uStateInfoSize: Size of DSP_PROCESSORSTATE.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while querying processor state.
+ *  Requires:
+ *      pProcStatus is not NULL
+ *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetState(void *hProcessor,
+					OUT struct DSP_PROCESSORSTATE
+					*pProcStatus,
+					u32 uStateInfoSize);
+
+/*
+ *  ======== PROC_GetProcessorID ========
+ *  Purpose:
+ *      Report the state of the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      procID      :   Processor ID
+ *
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while querying processor state.
+ *  Requires:
+ *      pProcStatus is not NULL
+ *      uStateInfoSize is >= than the size of DSP_PROCESSORSTATE structure.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetProcessorId(void *hProcessor,
+					      u32 *procID);
+
+/*
+ *  ======== PROC_GetTrace ========
+ *  Purpose:
+ *      Retrieve the trace buffer from the specified DSP processor.
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      pBuf	:   Ptr to buffer to hold trace output.
+ *      uMaxSize    :   Maximum size of the output buffer.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   General failure while retireving processor trace
+ *		      Buffer.
+ *  Requires:
+ *      pBuf is not NULL
+ *      uMaxSize is > 0.
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf,
+					u32 uMaxSize);
+
+/*
+ *  ======== PROC_Load ========
+ *  Purpose:
+ *      Reset a processor and load a new base program image.
+ *      This will be an OEM-only function.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *      iArgc       :       The number of Arguments(strings)in the aArgV[]
+ *      aArgv       :       An Array of Arguments(Unicode Strings)
+ *      aEnvp       :       An Array of Environment settings(Unicode Strings)
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EFILE   :       The DSP Execuetable was not found.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_ECORRUTFILE:    Unable to Parse the DSP Execuetable
+ *      DSP_EATTACHED:      Abort because a GPP Client is attached to the
+ *			  specified Processor
+ *      DSP_EACCESSDENIED:  Client does not have the required access rights
+ *			  to reset and load the Processor
+ *      DSP_EFAIL   :       Unable to Load the Processor
+ *  Requires:
+ *      aArgv is not NULL
+ *      iArgc is > 0
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_LOADED
+ *      or DSP_FAILED status.
+ *  Details:
+ *      Does not implement access rights to control which GPP application
+ *      can load the processor.
+ */
+	extern DSP_STATUS PROC_Load(void *hProcessor,
+				    IN CONST s32 iArgc, IN CONST char **aArgv,
+				    IN CONST char **aEnvp);
+
+/*
+ *  ======== PROC_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified of specific processor events
+ *  Parameters:
+ *      hProcessor  :   The processor handle.
+ *      uEventMask  :   Mask of types of events to be notified about.
+ *      uNotifyType :   Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle or hNotification.
+ *      DSP_EVALUE  :   Parameter uEventMask is Invalid
+ *      DSP_ENOTIMP :   The notification type specified in uNotifyMask
+ *		      is not supported.
+ *      DSP_EFAIL   :   Unable to register for notification.
+ *  Requires:
+ *      hNotification is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_RegisterNotify(void *hProcessor,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== PROC_NotifyClients ========
+ *  Purpose:
+ *      Notify the Processor Clients
+ *  Parameters:
+ *      hProc       :   The processor handle.
+ *      uEvents     :   Event to be notified about.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *  Requires:
+ *      uEvents is Supported or Valid type of Event
+ *      hProc is a valid handle
+ *      PROC Initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS PROC_NotifyClients(void *hProc,
+					     u32 uEvents);
+
+/*
+ *  ======== PROC_NotifyAllClients ========
+ *  Purpose:
+ *      Notify the Processor Clients
+ *  Parameters:
+ *      hProc       :   The processor handle.
+ *      uEvents     :   Event to be notified about.
+ *  Returns:
+ *      DSP_SOK     :   Success.
+ *      DSP_EHANDLE :   Invalid processor handle.
+ *      DSP_EFAIL   :   Failure to Set or Reset the Event
+ *  Requires:
+ *      uEvents is Supported or Valid type of Event
+ *      hProc is a valid handle
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      NODE And STRM would use this function to notify their clients
+ *      about the state changes in NODE or STRM.
+ */
+	extern DSP_STATUS PROC_NotifyAllClients(void *hProc,
+						u32 uEvents);
+
+/*
+ *  ======== PROC_Start ========
+ *  Purpose:
+ *      Start a processor running.
+ *      Processor must be in PROC_LOADED state.
+ *      This will be an OEM-only function, and not part of the 'Bridge
+ *      application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
+ *      DSP_EFAIL   :       Unable to start the processor.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Start(void *hProcessor);
+
+/*
+ *  ======== PROC_Stop ========
+ *  Purpose:
+ *      Start a processor running.
+ *      Processor must be in PROC_LOADED state.
+ *      This will be an OEM-only function, and not part of the 'Bridge
+ *      application developer's API.
+ *  Parameters:
+ *      hProcessor  :       The processor handle.
+ *  Returns:
+ *      DSP_SOK     :       Success.
+ *      DSP_EHANDLE :       Invalid processor handle.
+ *      DSP_EWRONGSTATE:    Processor is not in PROC_LOADED state.
+ *      DSP_EFAIL   :       Unable to start the processor.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *      Success and ProcState == PROC_RUNNING or DSP_FAILED status.
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Stop(void *hProcessor);
+
+/*
+ *  ======== PROC_FlushMemory ========
+ *  Purpose:
+ *      Flushes a buffer from the MPU data cache.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Buffer start address
+ *      ulSize	  :   Buffer size
+ *      ulFlags	 :   Reserved.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      All the arguments are currently ignored.
+ */
+	extern DSP_STATUS PROC_FlushMemory(void *hProcessor,
+					   void *pMpuAddr,
+					   u32 ulSize, u32 ulFlags);
+
+
+/*
+ *  ======== PROC_InvalidateMemory ========
+ *  Purpose:
+ *      Invalidates a buffer from the MPU data cache.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Buffer start address
+ *      ulSize	  :   Buffer size
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *  Requires:
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ *      All the arguments are currently ignored.
+ */
+	extern DSP_STATUS PROC_InvalidateMemory(void *hProcessor,
+					   void *pMpuAddr,
+					   u32 ulSize);
+
+/*
+ *  ======== PROC_Map ========
+ *  Purpose:
+ *      Maps a MPU buffer to DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMpuAddr	:   Starting address of the memory region to map.
+ *      ulSize	  :   Size of the memory region to map.
+ *      pReqAddr	:   Requested DSP start address. Offset-adjusted actual
+ *			  mapped address is in the last argument.
+ *      ppMapAddr       :   Ptr to DSP side mapped u8 address.
+ *      ulMapAttr       :   Optional endianness attributes, virt to phys flag.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_EMEMORY     :   MPU side memory allocation error.
+ *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pMpuAddr is not NULL
+ *      ulSize is not zero
+ *      ppMapAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_Map(void *hProcessor,
+				   void *pMpuAddr,
+				   u32 ulSize,
+				   void *pReqAddr,
+				   void **ppMapAddr, u32 ulMapAttr,
+				   struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== PROC_ReserveMemory ========
+ *  Purpose:
+ *      Reserve a virtually contiguous region of DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      ulSize	  :   Size of the address space to reserve.
+ *      ppRsvAddr       :   Ptr to DSP side reserved u8 address.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
+ *  Requires:
+ *      ppRsvAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_ReserveMemory(void *hProcessor,
+		u32 ulSize, void **ppRsvAddr, struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== PROC_UnMap ========
+ *  Purpose:
+ *      Removes a MPU buffer mapping from the DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pMapAddr	:   Starting address of the mapped memory region.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_ENOTFOUND   :   Cannot find a mapped region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pMapAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
+			struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== PROC_UnReserveMemory ========
+ *  Purpose:
+ *      Frees a previously reserved region of DSP address space.
+ *  Parameters:
+ *      hProcessor      :   The processor handle.
+ *      pRsvAddr	:   Ptr to DSP side reservedBYTE address.
+ *  Returns:
+ *      DSP_SOK	 :   Success.
+ *      DSP_EHANDLE     :   Invalid processor handle.
+ *      DSP_EFAIL       :   General failure.
+ *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
+ *		      :   address.
+ *  Requires:
+ *      pRsvAddr is not NULL
+ *      PROC Initialized.
+ *  Ensures:
+ *  Details:
+ */
+	extern DSP_STATUS PROC_UnReserveMemory(void *hProcessor,
+			void *pRsvAddr, struct PROCESS_CONTEXT *pr_ctxt);
+
+#endif				/* PROC_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/procpriv.h b/arch/arm/plat-omap/include/dspbridge/procpriv.h
new file mode 100644
index 0000000..4a24949
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/procpriv.h
@@ -0,0 +1,26 @@
+/*
+ * procpriv.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global PROC constants and types, shared by PROC, MGR and WCD.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef PROCPRIV_
+#define PROCPRIV_
+
+/* RM PROC Object */
+	struct PROC_OBJECT;
+
+#endif				/* PROCPRIV_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/pwr.h b/arch/arm/plat-omap/include/dspbridge/pwr.h
new file mode 100644
index 0000000..d1433fa
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/pwr.h
@@ -0,0 +1,110 @@
+/*
+ * pwr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef PWR_
+#define PWR_
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+#include <dspbridge/pwr_sh.h>
+
+/*
+ *  ======== PWR_SleepDSP ========
+ *      Signal the DSP to go to sleep.
+ *
+ *  Parameters:
+ *      sleepCode:          New sleep state for DSP.  (Initially, valid codes
+ *                          are PWR_DEEPSLEEP or PWR_EMERGENCYDEEPSLEEP; both of
+ *                          these codes will simply put the DSP in deep sleep.)
+ *
+ *	timeout:            Maximum time (msec) that PWR should wait for
+ *                          confirmation that the DSP sleep state has been
+ *                          reached.  If PWR should simply send the command to
+ *                          the DSP to go to sleep and then return (i.e.,
+ *                          asynchrounous sleep), the timeout should be
+ *                          specified as zero.
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYASLEEP: Success, but the DSP was already asleep.
+ *      DSP_EINVALIDARG:    The specified sleepCode is not supported.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for DSP sleep
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send sleep command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode,
+				       IN CONST u32 timeout);
+
+/*
+ *  ======== PWR_WakeDSP ========
+ *    Signal the DSP to wake from sleep.
+ *
+ *  Parameters:
+ *	timeout:            Maximum time (msec) that PWR should wait for
+ *                          confirmation that the DSP is awake.  If PWR should
+ *                          simply send a command to the DSP to wake and then
+ *                          return (i.e., asynchrounous wake), timeout should
+ *                          be specified as zero.
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout);
+
+/*
+ *  ======== PWR_PM_PreScale ========
+ *    Prescale notification to DSP.
+ *
+ *  Parameters:
+ *	voltage_domain:   The voltage domain for which notification is sent
+ *    level:			The level of voltage domain
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level);
+
+/*
+ *  ======== PWR_PM_PostScale ========
+ *    PostScale notification to DSP.
+ *
+ *  Parameters:
+ *	voltage_domain:   The voltage domain for which notification is sent
+ *    level:			The level of voltage domain
+ *
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_SALREADYAWAKE:  Success, but the DSP was already awake.
+ *      DSP_ETIMEOUT:       A timeout occured while waiting for wake
+ *                          confirmation.
+ *      DSP_EFAIL:          General failure, unable to send wake command to
+ *                          the DSP.
+ */
+	extern DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain,
+					   u32 level);
+
+#endif				/* PWR_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/pwr_sh.h b/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
new file mode 100644
index 0000000..202b225
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/pwr_sh.h
@@ -0,0 +1,33 @@
+/*
+ * pwr_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Power Manager shared definitions (used on both GPP and DSP sides).
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef PWR_SH_
+#define PWR_SH_
+
+#include <dspbridge/mbx_sh.h>
+
+/* valid sleep command codes that can be sent by GPP via mailbox: */
+#define PWR_DEEPSLEEP           MBX_PM_DSPIDLE
+#define PWR_EMERGENCYDEEPSLEEP  MBX_PM_EMERGENCYSLEEP
+#define PWR_SLEEPUNTILRESTART   MBX_PM_SLEEPUNTILRESTART
+#define PWR_WAKEUP              MBX_PM_DSPWAKEUP
+#define PWR_AUTOENABLE          MBX_PM_PWRENABLE
+#define PWR_AUTODISABLE         MBX_PM_PWRDISABLE
+#define PWR_RETENTION             MBX_PM_DSPRETN
+
+#endif				/* PWR_SH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/reg.h b/arch/arm/plat-omap/include/dspbridge/reg.h
new file mode 100644
index 0000000..4801578
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/reg.h
@@ -0,0 +1,150 @@
+/*
+ * reg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provides registry functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _REG_H
+#define _REG_H
+
+#include <linux/types.h>
+
+#define REG_MAXREGPATHLENGTH    255
+
+/*
+ *  ======== REG_DeleteValue ========
+ *  Purpose:
+ *      Deletes a registry entry. NOTE: A registry entry is not the same as
+ *      a registry key.
+ *  Parameters:
+ *      pstrValue:  Name of entry to delete.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrValue is non-NULL value.
+ *      - length of pstrValue < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ *  Details:
+ */
+extern DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue);
+
+/*
+ *  ======== REG_EnumValue ========
+ *  Purpose:
+ *      Enumerates values of a specified key. Retrieves each value name and
+ *      the data associated with the value.
+ *  Parameters:
+ *      dwIndex:        Specifies the index of the value to retrieve.
+ *      pstrKey:        The name of the registry key to be enumerated.
+ *      pstrValue:      Pointer to buffer that receives the name of the value.
+ *      pdwValueSize:   Specifies bytes of memory pstrValue points to on input,
+ *                      On output, specifies actual memory bytes written into.
+ *                      If there is no value, pdwValueSize returns NULL
+ *      pstrData:       Pointer to buffer that receives the data of a value.
+ *      pdwDataSize:    Specifies bytes of memory in pstrData on input and
+ *                      bytes of memory written into pstrData on output.
+ *                      If there is no data, pdwDataSize returns NULL.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      REG initialized.
+ *      pstrKey is a non-NULL value.
+ *      pstrValue, pstrData, pdwValueSize and pdwDataSize are valid pointers.
+ *      Length of pstrKey is less than REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+extern DSP_STATUS REG_EnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
+				IN OUT char *pstrValue,
+				IN OUT u32 *pdwValueSize,
+				IN OUT char *pstrData,
+				IN OUT u32 *pdwDataSize);
+
+/*
+ *  ======== REG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      REG initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void REG_Exit(void);
+
+/*
+ *  ======== REG_GetValue ========
+ *  Purpose:
+ *      Retrieve a value from the registry.
+ *  Parameters:
+ *      pstrEntry:      Name of entry to retrieve.
+ *      pbValue:        Upon return, points to retrieved value.
+ *      pdwValueSize:   Specifies bytes of memory pbValue points to on input,
+ *                      on output, specifies actual memory bytes written into.
+ *                      If pbValue is NULL, pdwValueSize reports the size of
+ *                      the entry in pstrEntry.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrEntry is non-NULL value.
+ *      - pbValue is a valid pointer.
+ *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+extern DSP_STATUS REG_GetValue(IN CONST char *pstrEntry, OUT u8 *pbValue,
+			       IN OUT u32 *pdwValueSize);
+
+/*
+ *  ======== REG_Init ========
+ *  Purpose:
+ *      Initializes private state of REG module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      REG initialized.
+ */
+	extern bool REG_Init(void);
+
+/*
+ *  ======== REG_SetValue ========
+ *  Purpose:
+ *      Set a value in the registry.
+ *  Parameters:
+ *      pstrEntry:      Name of entry to set.
+ *      pbValue:        Points to buffer containing new data.
+ *      dwValueSize:    Specifies bytes of memory bValue points to.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      - REG initialized.
+ *      - pstrEntry is non-NULL value.
+ *      - pbValue is a valid pointer.
+ *      - dwValuSize > 0.
+ *      - length of pstrEntry < REG_MAXREGPATHLENGTH.
+ *  Ensures:
+ */
+extern DSP_STATUS REG_SetValue(IN CONST char *pstrEntry, IN u8 *pbValue,
+			       IN u32 dwValueSize);
+
+#endif				/* _REG_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h b/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
new file mode 100644
index 0000000..2bb756a
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/resourcecleanup.h
@@ -0,0 +1,64 @@
+/*
+ * resourcecleanup.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+#include <dspbridge/nodepriv.h>
+#include <dspbridge/drv.h>
+
+
+extern DSP_STATUS DRV_GetProcCtxtList(struct PROCESS_CONTEXT **pPctxt,
+				struct DRV_OBJECT *hDrvObject);
+
+extern DSP_STATUS DRV_InsertProcContext(struct DRV_OBJECT *hDrVObject,
+					HANDLE hPCtxt);
+
+extern DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE pCtxt);
+
+extern DSP_STATUS DRV_RemoveAllNodeResElements(HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcSetPID(HANDLE pCtxt, s32 hProcess);
+
+extern DSP_STATUS DRV_RemoveAllResources(HANDLE pPctxt);
+
+extern DSP_STATUS DRV_RemoveProcContext(struct DRV_OBJECT *hDRVObject,
+				     HANDLE pr_ctxt);
+
+extern DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE nodeRes,
+					HANDLE pCtxt);
+
+extern DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE nodeRes,
+					    HANDLE pCtxt);
+
+extern void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status);
+
+extern DSP_STATUS DRV_RemoveNodeResElement(HANDLE nodeRes, HANDLE status);
+
+extern void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status);
+
+extern DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE STRMRes);
+
+extern DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
+						HANDLE pPctxt);
+
+extern DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE STRMRes,
+					HANDLE pCtxt);
+
+extern DSP_STATUS DRV_ProcRemoveSTRMResElement(HANDLE STRMRes, HANDLE pCtxt);
+
+extern DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE pCtxt);
+
+extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+
diff --git a/arch/arm/plat-omap/include/dspbridge/rmm.h b/arch/arm/plat-omap/include/dspbridge/rmm.h
new file mode 100644
index 0000000..389cf57
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rmm.h
@@ -0,0 +1,181 @@
+/*
+ * rmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This memory manager provides general heap management and arbitrary
+ * alignment for any number of memory segments, and management of overlay
+ * memory.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef RMM_
+#define RMM_
+
+/*
+ *  ======== RMM_Addr ========
+ *  DSP address + segid
+ */
+struct RMM_Addr {
+	u32 addr;
+	s32 segid;
+} ;
+
+/*
+ *  ======== RMM_Segment ========
+ *  Memory segment on the DSP available for remote allocations.
+ */
+struct RMM_Segment {
+	u32 base;		/* Base of the segment */
+	u32 length;		/* Size of the segment (target MAUs) */
+	s32 space;		/* Code or data */
+	u32 number;		/* Number of Allocated Blocks */
+} ;
+
+/*
+ *  ======== RMM_Target ========
+ */
+struct RMM_TargetObj;
+
+/*
+ *  ======== RMM_alloc ========
+ *
+ *  RMM_alloc is used to remotely allocate or reserve memory on the DSP.
+ *
+ *  Parameters:
+ *      target          - Target returned from RMM_create().
+ *      segid           - Memory segment to allocate from.
+ *      size            - Size (target MAUS) to allocate.
+ *      align           - alignment.
+ *      dspAddr         - If reserve is FALSE, the location to store allocated
+ *                        address on output, otherwise, the DSP address to
+ *                        reserve.
+ *      reserve         - If TRUE, reserve the memory specified by dspAddr.
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EMEMORY:            Memory allocation on GPP failed.
+ *      DSP_EOVERLAYMEMORY:     Cannot "allocate" overlay memory because it's
+ *                              already in use.
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *      dspAddr != NULL.
+ *      size > 0
+ *      reserve || target->numSegs > 0.
+ *  Ensures:
+ */
+extern DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
+			    u32 align, u32 *dspAdr, bool reserve);
+
+/*
+ *  ======== RMM_create ========
+ *  Create a target object with memory segments for remote allocation. If
+ *  segTab == NULL or numSegs == 0, memory can only be reserved through
+ *  RMM_alloc().
+ *
+ *  Parameters:
+ *      pTarget:        - Location to store target on output.
+ *      segTab:         - Table of memory segments.
+ *      numSegs:        - Number of memory segments.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *      RMM initialized.
+ *      pTarget != NULL.
+ *      numSegs == 0 || segTab != NULL.
+ *  Ensures:
+ *      Success:        Valid *pTarget.
+ *      Failure:        *pTarget == NULL.
+ */
+extern DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
+			     struct RMM_Segment segTab[], u32 numSegs);
+
+/*
+ *  ======== RMM_delete ========
+ *  Delete target allocated in RMM_create().
+ *
+ *  Parameters:
+ *      target          - Target returned from RMM_create().
+ *  Returns:
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *  Ensures:
+ */
+extern void RMM_delete(struct RMM_TargetObj *target);
+
+/*
+ *  ======== RMM_exit ========
+ *  Exit the RMM module
+ *
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      RMM_init successfully called.
+ *  Ensures:
+ */
+extern void RMM_exit(void);
+
+/*
+ *  ======== RMM_free ========
+ *  Free or unreserve memory allocated through RMM_alloc().
+ *
+ *  Parameters:
+ *      target:         - Target returned from RMM_create().
+ *      segid:          - Segment of memory to free.
+ *      dspAddr:        - Address to free or unreserve.
+ *      size:           - Size of memory to free or unreserve.
+ *      reserved:       - TRUE if memory was reserved only, otherwise FALSE.
+ *  Returns:
+ *  Requires:
+ *      RMM initialized.
+ *      Valid target.
+ *      reserved || segid < target->numSegs.
+ *      reserve || [dspAddr, dspAddr + size] is a valid memory range.
+ *  Ensures:
+ */
+extern bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 dspAddr,
+		     u32 size, bool reserved);
+
+/*
+ *  ======== RMM_init ========
+ *  Initialize the RMM module
+ *
+ *  Parameters:
+ *  Returns:
+ *      TRUE:   Success.
+ *      FALSE:  Failure.
+ *  Requires:
+ *  Ensures:
+ */
+extern bool RMM_init(void);
+
+/*
+ *  ======== RMM_stat ========
+ *  Obtain  memory segment status
+ *
+ *  Parameters:
+ *      segid:       Segment ID of the dynamic loading segment.
+ *      pMemStatBuf: Pointer to allocated buffer into which memory stats are
+ *                   placed.
+ *  Returns:
+ *      TRUE:   Success.
+ *      FALSE:  Failure.
+ *  Requires:
+ *      segid < target->numSegs
+ *  Ensures:
+ */
+extern bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
+		     struct DSP_MEMSTAT *pMemStatBuf);
+
+#endif				/* RMM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/rms_sh.h b/arch/arm/plat-omap/include/dspbridge/rms_sh.h
new file mode 100644
index 0000000..59c00d1
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rms_sh.h
@@ -0,0 +1,97 @@
+/*
+ * rms_sh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Resource Manager Server shared definitions (used on both
+ * GPP and DSP sides).
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef RMS_SH_
+#define RMS_SH_
+
+#include <dspbridge/rmstypes.h>
+
+/* Node Types: */
+#define RMS_TASK                1	/* Task node */
+#define RMS_DAIS                2	/* xDAIS socket node */
+#define RMS_MSG                 3	/* Message node */
+
+/* Memory Types: */
+#define RMS_CODE                0	/* Program space */
+#define RMS_DATA                1	/* Data space */
+#define RMS_IO                	2	/* I/O space */
+
+/* RM Server Command and Response Buffer Sizes: */
+#define RMS_COMMANDBUFSIZE     256	/* Size of command buffer */
+#define RMS_RESPONSEBUFSIZE    16	/* Size of response buffer */
+
+/* Pre-Defined Command/Response Codes: */
+#define RMS_EXIT                0x80000000   /* GPP->Node: shutdown */
+#define RMS_EXITACK             0x40000000   /* Node->GPP: ack shutdown */
+#define RMS_BUFDESC             0x20000000   /* Arg1 SM buf, Arg2 is SM size */
+#define RMS_KILLTASK            0x10000000  /* GPP->Node: Kill Task */
+#define RMS_USER                0x0	/* Start of user-defined msg codes */
+#define RMS_MAXUSERCODES        0xfff	/* Maximum user defined C/R Codes */
+
+
+/* RM Server RPC Command Structure: */
+	struct RMS_Command {
+		RMS_WORD fxn;	/* Server function address */
+		RMS_WORD arg1;	/* First argument */
+		RMS_WORD arg2;	/* Second argument */
+		RMS_WORD data;	/* Function-specific data array */
+	} ;
+
+/*
+ *  The RMS_StrmDef structure defines the parameters for both input and output
+ *  streams, and is passed to a node's create function.
+ */
+	struct RMS_StrmDef {
+		RMS_WORD bufsize;	/* Buffer size (in DSP words) */
+		RMS_WORD nbufs;	/* Max number of bufs in stream */
+		RMS_WORD segid;	/* Segment to allocate buffers */
+		RMS_WORD align;	/* Alignment for allocated buffers */
+		RMS_WORD timeout;	/* Timeout (msec) for blocking calls */
+		RMS_CHAR name[1];	/* Device Name (terminated by '\0') */
+	} ;
+
+/* Message node create args structure: */
+	struct RMS_MsgArgs {
+		RMS_WORD maxMessages;	/* Max # simultaneous msgs to node */
+		RMS_WORD segid;	/* Mem segment for NODE_allocMsgBuf */
+		RMS_WORD notifyType;	/* Type of message notification */
+		RMS_WORD argLength;	/* Length (in DSP chars) of arg data */
+		RMS_WORD argData;	/* Arg data for node */
+	} ;
+
+/* Partial task create args structure */
+	struct RMS_MoreTaskArgs {
+		RMS_WORD priority;	/* Task's runtime priority level */
+		RMS_WORD stackSize;	/* Task's stack size */
+		RMS_WORD sysstackSize;	/* Task's system stack size (55x) */
+		RMS_WORD stackSeg;	/* Memory segment for task's stack */
+		RMS_WORD heapAddr;   /* base address of the node memory heap in
+				      * external memory (DSP virtual address) */
+		RMS_WORD heapSize;   /* size in MAUs of the node memory heap in
+				      * external memory */
+		RMS_WORD misc;	/* Misc field.  Not used for 'normal'
+				 * task nodes; for xDAIS socket nodes
+				 * specifies the IALG_Fxn pointer.
+				 */
+		/* # input STRM definition structures */
+		RMS_WORD numInputStreams;
+	} ;
+
+#endif				/* RMS_SH_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/rmstypes.h b/arch/arm/plat-omap/include/dspbridge/rmstypes.h
new file mode 100644
index 0000000..484f539
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/rmstypes.h
@@ -0,0 +1,29 @@
+/*
+ * rmstypes.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Resource Manager Server shared data type definitions.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef RMSTYPES_
+#define RMSTYPES_
+#include <linux/types.h>
+/*
+ *  DSP-side definitions.
+ */
+#include <dspbridge/std.h>
+typedef u32 RMS_WORD;
+typedef char RMS_CHAR;
+
+#endif				/* RMSTYPES_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/services.h b/arch/arm/plat-omap/include/dspbridge/services.h
new file mode 100644
index 0000000..f44e458
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/services.h
@@ -0,0 +1,50 @@
+/*
+ * services.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide loading and unloading of SERVICES modules.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef SERVICES_
+#define SERVICES_
+
+#include <dspbridge/host_os.h>
+/*
+ *  ======== SERVICES_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      SERVICES initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void SERVICES_Exit(void);
+
+/*
+ *  ======== SERVICES_Init ========
+ *  Purpose:
+ *      Initializes SERVICES modules.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if all modules initialized; otherwise FALSE.
+ *  Requires:
+ *  Ensures:
+ *      SERVICES modules initialized.
+ */
+	extern bool SERVICES_Init(void);
+
+#endif				/* SERVICES_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/std.h b/arch/arm/plat-omap/include/dspbridge/std.h
new file mode 100644
index 0000000..19289b9
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/std.h
@@ -0,0 +1,95 @@
+/*
+ * std.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef STD_
+#define STD_
+
+#include <linux/types.h>
+
+/*
+ *  ======== _TI_ ========
+ *  _TI_ is defined for all TI targets
+ */
+#if defined(_29_) || defined(_30_) || defined(_40_) || defined(_50_) || \
+    defined(_54_) || defined(_55_) || defined(_6x_) || defined(_80_) || \
+    defined(_28_) || defined(_24_)
+#define _TI_	1
+#endif
+
+/*
+ *  ======== _FLOAT_ ========
+ *  _FLOAT_ is defined for all targets that natively support floating point
+ */
+#if defined(_SUN_) || defined(_30_) || defined(_40_) || defined(_67_) || \
+    defined(_80_)
+#define _FLOAT_	1
+#endif
+
+/*
+ *  ======== _FIXED_ ========
+ *  _FIXED_ is defined for all fixed point target architectures
+ */
+#if defined(_29_) || defined(_50_) || defined(_54_) || defined(_55_) || \
+    defined(_62_) || defined(_64_) || defined(_28_)
+#define _FIXED_	1
+#endif
+
+/*
+ *  ======== _TARGET_ ========
+ *  _TARGET_ is defined for all target architectures (as opposed to
+ *  host-side software)
+ */
+#if defined(_FIXED_) || defined(_FLOAT_)
+#define _TARGET_ 1
+#endif
+
+/*
+ *  8, 16, 32-bit type definitions
+ *
+ *  Sm*	- 8-bit type
+ *  Md* - 16-bit type
+ *  Lg* - 32-bit type
+ *
+ *  *s32 - signed type
+ *  *u32 - unsigned type
+ *  *Bits - unsigned type (bit-maps)
+ */
+
+/*
+ *  Aliases for standard C types
+ */
+
+typedef s32(*Fxn) (void);		/* generic function type */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+
+/*
+ * These macros are used to cast 'Arg' types to 's32' or 'Ptr'.
+ * These macros were added for the 55x since Arg is not the same
+ * size as s32 and Ptr in 55x large model.
+ */
+#if defined(_28l_) || defined(_55l_)
+#define ArgToInt(A)	((s32)((long)(A) & 0xffff))
+#define ArgToPtr(A)	((Ptr)(A))
+#else
+#define ArgToInt(A)	((s32)(A))
+#define ArgToPtr(A)	((Ptr)(A))
+#endif
+
+#endif				/* STD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/strm.h b/arch/arm/plat-omap/include/dspbridge/strm.h
new file mode 100644
index 0000000..a26abc3
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -0,0 +1,409 @@
+/*
+ * strm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSPBridge Stream Manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef STRM_
+#define STRM_
+
+#include <dspbridge/dev.h>
+
+#include <dspbridge/strmdefs.h>
+#include <dspbridge/proc.h>
+
+/*
+ *  ======== STRM_AllocateBuffer ========
+ *  Purpose:
+ *      Allocate data buffer(s) for use with a stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer(s).
+ *      uNumBufs:       Number of buffers to allocate.
+ *      apBuffer:       Array to hold buffer addresses.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EFAIL:      Failure occurred, unable to allocate buffers.
+ *      DSP_ESIZE:      uSize must be > 0 bytes.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      apBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm,
+					      u32 uSize,
+					      OUT u8 **apBuffer,
+					      u32 uNumBufs,
+					      struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== STRM_Close ========
+ *  Purpose:
+ *      Close a stream opened with STRM_Open().
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EPENDING:   Some data buffers issued to the stream have not
+ *                      been reclaimed.
+ *      DSP_EFAIL:      Failure to close stream.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
+				struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== STRM_Create ========
+ *  Purpose:
+ *      Create a STRM manager object. This object holds information about the
+ *      device needed to open streams.
+ *  Parameters:
+ *      phStrmMgr:      Location to store handle to STRM manager object on
+ *                      output.
+ *      hDev:           Device for this processor.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      DSP_EFAIL:      General failure.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      phStrmMgr != NULL.
+ *      hDev != NULL.
+ *  Ensures:
+ *      DSP_SOK:        Valid *phStrmMgr.
+ *      error:          *phStrmMgr == NULL.
+ */
+	extern DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr,
+				      struct DEV_OBJECT *hDev);
+
+/*
+ *  ======== STRM_Delete ========
+ *  Purpose:
+ *      Delete the STRM Object.
+ *  Parameters:
+ *      hStrmMgr:       Handle to STRM manager object from STRM_Create.
+ *  Returns:
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      Valid hStrmMgr.
+ *  Ensures:
+ *      hStrmMgr is not valid.
+ */
+	extern void STRM_Delete(struct STRM_MGR *hStrmMgr);
+
+/*
+ *  ======== STRM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of STRM module.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      STRM_Init(void) successfully called before.
+ *  Ensures:
+ */
+	extern void STRM_Exit(void);
+
+/*
+ *  ======== STRM_FreeBuffer ========
+ *  Purpose:
+ *      Free buffer(s) allocated with STRM_AllocateBuffer.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      apBuffer:       Array containing buffer addresses.
+ *      uNumBufs:       Number of buffers to be freed.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid stream handle.
+ *      DSP_EFAIL:      Failure occurred, unable to free buffers.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      apBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm,
+					  u8 **apBuffer, u32 uNumBufs,
+					  struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== STRM_GetEventHandle ========
+ *  Purpose:
+ *      Get stream's user event handle. This function is used when closing
+ *      a stream, so the event can be closed.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      phEvent:        Location to store event handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      phEvent != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_GetEventHandle(struct STRM_OBJECT *hStrm,
+					      OUT HANDLE *phEvent);
+
+/*
+ *  ======== STRM_GetInfo ========
+ *  Purpose:
+ *      Get information about a stream. User's DSP_STREAMINFO is contained
+ *      in STRM_INFO struct. STRM_INFO also contains Bridge private info.
+ *  Parameters:
+ *      hStrm:              Stream handle returned from STRM_Open().
+ *      pStreamInfo:        Location to store stream info on output.
+ *      uSteamInfoSize:     Size of user's DSP_STREAMINFO structure.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hStrm.
+ *      DSP_ESIZE:          uStreamInfoSize < sizeof(DSP_STREAMINFO).
+ *      DSP_EFAIL:          Unable to get stream info.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      pStreamInfo != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
+				       OUT struct STRM_INFO *pStreamInfo,
+				       u32 uStreamInfoSize);
+
+/*
+ *  ======== STRM_Idle ========
+ *  Purpose:
+ *      Idle a stream and optionally flush output data buffers.
+ *      If this is an output stream and fFlush is TRUE, all data currently
+ *      enqueued will be discarded.
+ *      If this is an output stream and fFlush is FALSE, this function
+ *      will block until all currently buffered data is output, or the timeout
+ *      specified has been reached.
+ *      After a successful call to STRM_Idle(), all buffers can immediately
+ *      be reclaimed.
+ *  Parameters:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      fFlush:         If TRUE, discard output buffers.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_ETIMEOUT:   A timeout occurred before the stream could be idled.
+ *      DSP_ERESTART:   A critical error occurred, DSP is being restarted.
+ *      DSP_EFAIL:      Unable to idle stream.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush);
+
+/*
+ *  ======== STRM_Init ========
+ *  Purpose:
+ *      Initialize the STRM module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialization succeeded, FALSE otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+	extern bool STRM_Init(void);
+
+/*
+ *  ======== STRM_Issue ========
+ *  Purpose:
+ *      Send a buffer of data to a stream.
+ *  Parameters:
+ *      hStrm:              Stream handle returned from STRM_Open().
+ *      pBuf:               Pointer to buffer of data to be sent to the stream.
+ *      ulBytes:            Number of bytes of data in the buffer.
+ *      ulBufSize:          Actual buffer size in bytes.
+ *      dwArg:              A user argument that travels with the buffer.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EHANDLE:        Invalid hStrm.
+ *      DSP_ESTREAMFULL:    The stream is full.
+ *      DSP_EFAIL:          Failure occurred, unable to issue buffer.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      pBuf != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf,
+				     u32 ulBytes, u32 ulBufSize,
+				     IN u32 dwArg);
+
+/*
+ *  ======== STRM_Open ========
+ *  Purpose:
+ *      Open a stream for sending/receiving data buffers to/from a task of
+ *      DAIS socket node on the DSP.
+ *  Parameters:
+ *      hNode:          Node handle returned from NODE_Allocate().
+ *      uDir:           DSP_TONODE or DSP_FROMNODE.
+ *      uIndex:         Stream index.
+ *      pAttr:          Pointer to structure containing attributes to be
+ *                      applied to stream. Cannot be NULL.
+ *      phStrm:         Location to store stream handle on output.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hNode.
+ *      DSP_EDIRECTION: Invalid uDir.
+ *      DSP_EVALUE:     Invalid uIndex.
+ *      DSP_ENODETYPE:  hNode is not a task or DAIS socket node.
+ *      DSP_EFAIL:      Unable to open stream.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      phStrm != NULL.
+ *      pAttr != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *phStrm is valid.
+ *      error:          *phStrm == NULL.
+ */
+	extern DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir,
+				    u32 uIndex, IN struct STRM_ATTR *pAttr,
+				    OUT struct STRM_OBJECT **phStrm,
+				    struct PROCESS_CONTEXT *pr_ctxt);
+
+/*
+ *  ======== STRM_PrepareBuffer ========
+ *  Purpose:
+ *      Prepare a data buffer not allocated by DSPStream_AllocateBuffers()
+ *      for use with a stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer.
+ *      pBuffer:        Buffer address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EFAIL:      Failure occurred, unable to prepare buffer.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_PrepareBuffer(struct STRM_OBJECT *hStrm,
+					     u32 uSize,
+					     u8 *pBuffer);
+
+/*
+ *  ======== STRM_Reclaim ========
+ *  Purpose:
+ *      Request a buffer back from a stream.
+ *  Parameters:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      pBufPtr:        Location to store pointer to reclaimed buffer.
+ *      pulBytes:       Location where number of bytes of data in the
+ *                      buffer will be written.
+ *      pulBufSize:     Location where actual buffer size will be written.
+ *      pdwArg:         Location where user argument that travels with
+ *                      the buffer will be written.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_ETIMEOUT:   A timeout occurred before a buffer could be
+ *                      retrieved.
+ *      DSP_EFAIL:      Failure occurred, unable to reclaim buffer.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      pBufPtr != NULL.
+ *      pulBytes != NULL.
+ *      pdwArg != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm,
+				       OUT u8 **pBufPtr, u32 *pulBytes,
+				       u32 *pulBufSize, u32 *pdwArg);
+
+/*
+ *  ======== STRM_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this stream.
+ *  Parameters:
+ *      hStrm:          Stream handle returned by STRM_Open().
+ *      uEventMask:     Mask of types of events to be notified about.
+ *      uNotifyType:    Type of notification to be sent.
+ *      hNotification:  Handle to be used for notification.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      DSP_EVALUE:     uEventMask is invalid.
+ *      DSP_ENOTIMPL:   Notification type specified by uNotifyType is not
+ *                      supported.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      hNotification != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm,
+					      u32 uEventMask, u32 uNotifyType,
+					      struct DSP_NOTIFICATION
+					      *hNotification);
+
+/*
+ *  ======== STRM_Select ========
+ *  Purpose:
+ *      Select a ready stream.
+ *  Parameters:
+ *      aStrmTab:       Array of stream handles returned from STRM_Open().
+ *      nStrms:         Number of stream handles in array.
+ *      pMask:          Location to store mask of ready streams on output.
+ *      uTimeout:       Timeout value (milliseconds).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ERANGE:     nStrms out of range.
+
+ *      DSP_EHANDLE:    Invalid stream handle in array.
+ *      DSP_ETIMEOUT:   A timeout occurred before a stream became ready.
+ *      DSP_EFAIL:      Failure occurred, unable to select a stream.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      aStrmTab != NULL.
+ *      nStrms > 0.
+ *      pMask != NULL.
+ *  Ensures:
+ *      DSP_SOK:        *pMask != 0 || uTimeout == 0.
+ *      Error:          *pMask == 0.
+ */
+	extern DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab,
+				      u32 nStrms,
+				      OUT u32 *pMask, u32 uTimeout);
+
+/*
+ *  ======== STRM_UnprepareBuffer ========
+ *  Purpose:
+ *      Unprepare a data buffer that was previously prepared for a stream
+ *      with DSPStream_PrepareBuffer(), and that will no longer be used with
+ *      the stream.
+ *  Parameter:
+ *      hStrm:          Stream handle returned from STRM_Open().
+ *      uSize:          Size (GPP bytes) of the buffer.
+ *      pBuffer:        Buffer address.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hStrm.
+ *      DSP_EFAIL:      Failure occurred, unable to unprepare buffer.
+ *  Requires:
+ *      STRM_Init(void) called.
+ *      pBuffer != NULL.
+ *  Ensures:
+ */
+	extern DSP_STATUS STRM_UnprepareBuffer(struct STRM_OBJECT *hStrm,
+					       u32 uSize,
+					       u8 *pBuffer);
+
+#endif				/* STRM_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/strmdefs.h b/arch/arm/plat-omap/include/dspbridge/strmdefs.h
new file mode 100644
index 0000000..6530de9
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/strmdefs.h
@@ -0,0 +1,47 @@
+/*
+ * strmdefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global STRM constants and types.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef STRMDEFS_
+#define STRMDEFS_
+
+#define STRM_MAXEVTNAMELEN      32
+
+	struct STRM_MGR;
+
+	struct STRM_OBJECT;
+
+	struct STRM_ATTR {
+		HANDLE hUserEvent;
+		char *pstrEventName;
+		void *pVirtBase;	/* Process virtual base address of
+					 * mapped SM */
+		u32 ulVirtSize;	/* Size of virtual space in bytes */
+		struct DSP_STREAMATTRIN *pStreamAttrIn;
+	} ;
+
+	struct STRM_INFO {
+		enum DSP_STRMMODE lMode;	/* transport mode of
+					 * stream(DMA, ZEROCOPY..) */
+		u32 uSegment;	/* Segment strm allocs from. 0 is local mem */
+		void *pVirtBase;	/* "      " Stream'process virt base */
+		struct DSP_STREAMINFO *pUser;	/* User's stream information
+						 * returned */
+	} ;
+
+#endif				/* STRMDEFS_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/sync.h b/arch/arm/plat-omap/include/dspbridge/sync.h
new file mode 100644
index 0000000..a82389e
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/sync.h
@@ -0,0 +1,304 @@
+/*
+ * sync.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide synchronization services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _SYNC_H
+#define _SYNC_H
+
+#define SIGNATURECS     0x53435953	/* "SYCS" (in reverse) */
+#define SIGNATUREDPCCS  0x53445953	/* "SYDS" (in reverse) */
+
+/* Special timeout value indicating an infinite wait: */
+#define SYNC_INFINITE  0xffffffff
+
+/* Maximum string length of a named event */
+#define SYNC_MAXNAMELENGTH 32
+
+/* Generic SYNC object: */
+	struct SYNC_OBJECT;
+
+/* Generic SYNC CS object: */
+struct SYNC_CSOBJECT {
+	u32 dwSignature;	/* used for object validation */
+	struct semaphore sem;
+} ;
+
+/* SYNC object attributes: */
+	struct SYNC_ATTRS {
+		HANDLE hUserEvent;    /* Platform's User Mode synch. object. */
+		HANDLE hKernelEvent;  /* Platform's Kernel Mode sync. object. */
+		u32 dwReserved1;	/* For future expansion.   */
+		u32 dwReserved2;	/* For future expansion.   */
+	} ;
+
+/*
+ *  ======== SYNC_CloseEvent ========
+ *  Purpose:
+ *      Close this event handle, freeing resources allocated in SYNC_OpenEvent
+ *      if necessary.
+ *  Parameters:
+ *      hEvent: Handle to a synchronization event, created/opened in
+ *              SYNC_OpenEvent.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EFAIL:      Failed to close event handle.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ *      Any subsequent usage of hEvent would be invalid.
+ */
+	extern DSP_STATUS SYNC_CloseEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_DeleteCS ========
+ *  Purpose:
+ *      Delete a critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_DeleteCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_EnterCS ========
+ *  Purpose:
+ *      Enter the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_EnterCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ *  Parameters:
+ *  Returns:
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ *      Resources used by module are freed when cRef reaches zero.
+ */
+	extern void SYNC_Exit(void);
+
+/*
+ *  ======== SYNC_Init ========
+ *  Purpose:
+ *      Initializes private state of SYNC module.
+ *  Parameters:
+ *  Returns:
+ *      TRUE if initialized; FALSE if error occured.
+ *  Requires:
+ *  Ensures:
+ *      SYNC initialized.
+ */
+	extern bool SYNC_Init(void);
+
+/*
+ *  ======== SYNC_InitializeCS ========
+ *  Purpose:
+ *      Initialize the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Out of memory.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj);
+
+/*
+ *  ======== SYNC_InitializeDPCCS ========
+ *  Purpose:
+ *      Initialize the critical section between process context and DPC.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Out of memory.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT
+					       **phCSObj);
+
+/*
+ *  ======== SYNC_LeaveCS ========
+ *  Purpose:
+ *      Leave the critical section.
+ *  Parameters:
+ *      hCSObj: critical section handle.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_LeaveCS(IN struct SYNC_CSOBJECT *hCSObj);
+
+/*
+ *  ======== SYNC_OpenEvent ========
+ *  Purpose:
+ *      Create/open and initialize an event object for thread synchronization,
+ *      which is initially in the non-signalled state.
+ *  Parameters:
+ *      phEvent:    Pointer to location to receive the event object handle.
+ *      pAttrs:     Pointer to SYNC_ATTRS object containing initial SYNC
+ *                  SYNC_OBJECT attributes.  If this pointer is NULL, then
+ *                  SYNC_OpenEvent will create and manage an OS specific
+ *                  syncronization object.
+ *          pAttrs->hUserEvent:  Platform's User Mode synchronization object.
+ *
+ *      The behaviour of the SYNC methods depend on the value of
+ *      the hUserEvent attr:
+ *
+ *      1. (hUserEvent == NULL):
+ *          A user mode event is created.
+ *      2. (hUserEvent != NULL):
+ *          A user mode event is supplied by the caller of SYNC_OpenEvent().
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Unable to create user mode event.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EINVALIDARG SYNC_ATTRS values are invalid.
+ *  Requires:
+ *      - SYNC initialized.
+ *      - phEvent != NULL.
+ *  Ensures:
+ *      If function succeeded, pEvent->hEvent must be a valid event handle.
+ */
+	extern DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
+					 IN OPTIONAL struct SYNC_ATTRS
+					 *pAttrs);
+
+/*
+ * ========= SYNC_PostMessage ========
+ *  Purpose:
+ *      To post a windows message
+ *  Parameters:
+ *      hWindow:    Handle to the window
+ *      uMsg:       Message to be posted
+ *  Returns:
+ *      DSP_SOK:        Success
+ *      DSP_EFAIL:      Post message failed
+ *      DSP_EHANDLE:    Invalid Window handle
+ *  Requires:
+ *      SYNC initialized
+ *  Ensures
+ */
+	extern DSP_STATUS SYNC_PostMessage(IN HANDLE hWindow, IN u32 uMsg);
+
+/*
+ *  ======== SYNC_ResetEvent ========
+ *  Purpose:
+ *      Reset a syncronization event object state to non-signalled.
+ *  Parameters:
+ *      hEvent:         Handle to a sync event.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EFAIL:      Failed to reset event.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_ResetEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_SetEvent ========
+ *  Purpose:
+ *      Signal the event.  Will unblock one waiting thread.
+ *  Parameters:
+ *      hEvent:         Handle to an event object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to signal event.
+ *      DSP_EHANDLE:    Invalid handle.
+ *  Requires:
+ *      SYNC initialized.
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_SetEvent(IN struct SYNC_OBJECT *hEvent);
+
+/*
+ *  ======== SYNC_WaitOnEvent ========
+ *  Purpose:
+ *      Wait for an event to be signalled, up to the specified timeout.
+ *  Parameters:
+ *      hEvent:         Handle to an event object.
+ *      dwTimeOut:      The time-out interval, in milliseconds.
+ *                      The function returns if the interval elapses, even if
+ *                      the object's state is nonsignaled.
+ *                      If zero, the function tests the object's state and
+ *                      returns immediately.
+ *                      If SYNC_INFINITE, the function's time-out interval
+ *                      never elapses.
+ *  Returns:
+ *      DSP_SOK:        The object was signalled.
+ *      DSP_EHANDLE:    Invalid handle.
+ *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
+ *      SYNC_E_TIMEOUT: Timeout expired while waiting for event to be signalled.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_WaitOnEvent(IN struct SYNC_OBJECT *hEvent,
+					   IN u32 dwTimeOut);
+
+/*
+ *  ======== SYNC_WaitOnMultipleEvents ========
+ *  Purpose:
+ *      Wait for any of an array of events to be signalled, up to the
+ *      specified timeout.
+ *      Note: dwTimeOut must be SYNC_INFINITE to signal infinite wait.
+ *  Parameters:
+ *      hSyncEvents:    Array of handles to event objects.
+ *      uCount:         Number of event handles.
+ *      dwTimeOut:      The time-out interval, in milliseconds.
+ *                      The function returns if the interval elapses, even if
+ *                      no event is signalled.
+ *                      If zero, the function tests the object's state and
+ *                      returns immediately.
+ *                      If SYNC_INFINITE, the function's time-out interval
+ *                      never elapses.
+ *      puIndex:        Location to store index of event that was signalled.
+ *  Returns:
+ *      DSP_SOK:        The object was signalled.
+ *      SYNC_E_FAIL:    Wait failed, possibly because the process terminated.
+ *      SYNC_E_TIMEOUT: Timeout expired before event was signalled.
+ *      DSP_EMEMORY:    Memory allocation failed.
+ *  Requires:
+ *  Ensures:
+ */
+	extern DSP_STATUS SYNC_WaitOnMultipleEvents(IN struct SYNC_OBJECT
+						    **hSyncEvents,
+						    IN u32 uCount,
+						    IN u32 dwTimeout,
+						    OUT u32 *puIndex);
+
+#endif				/* _SYNC_H */
diff --git a/arch/arm/plat-omap/include/dspbridge/utildefs.h b/arch/arm/plat-omap/include/dspbridge/utildefs.h
new file mode 100644
index 0000000..68c9a54
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/utildefs.h
@@ -0,0 +1,39 @@
+/*
+ * utildefs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global UTIL constants and types, shared between WCD and DSPSYS.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef UTILDEFS_
+#define UTILDEFS_
+
+/* constants taken from configmg.h */
+#define UTIL_MAXMEMREGS     9
+#define UTIL_MAXIOPORTS     20
+#define UTIL_MAXIRQS        7
+#define UTIL_MAXDMACHNLS    7
+
+/* misc. constants */
+#define UTIL_MAXARGVS       10
+
+/* Platform specific important info */
+	struct UTIL_SYSINFO {
+		/* Granularity of page protection; usually 1k or 4k */
+		u32 dwPageSize;
+		u32 dwAllocationGranularity; /* VM granularity, usually 64K */
+		u32 dwNumberOfProcessors;	/* Used as sanity check */
+	} ;
+
+#endif				/* UTILDEFS_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/uuidutil.h b/arch/arm/plat-omap/include/dspbridge/uuidutil.h
new file mode 100644
index 0000000..2f5ad0e
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/uuidutil.h
@@ -0,0 +1,62 @@
+/*
+ * uuidutil.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This file contains the specification of UUID helper functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef UUIDUTIL_
+#define UUIDUTIL_
+
+#define MAXUUIDLEN  37
+
+/*
+ *  ======== UUID_UuidToString ========
+ *  Purpose:
+ *      Converts a DSP_UUID to an ANSI string.
+ *  Parameters:
+ *      pUuid:      Pointer to a DSP_UUID object.
+ *      pszUuid:    Pointer to a buffer to receive a NULL-terminated UUID
+ *                  string.
+ *      size:	    Maximum size of the pszUuid string.
+ *  Returns:
+ *  Requires:
+ *      pUuid & pszUuid are non-NULL values.
+ *  Ensures:
+ *      Lenghth of pszUuid is less than MAXUUIDLEN.
+ *  Details:
+ *      UUID string limit currently set at MAXUUIDLEN.
+ */
+	void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
+			       s32 size);
+
+/*
+ *  ======== UUID_UuidFromString ========
+ *  Purpose:
+ *      Converts an ANSI string to a DSP_UUID.
+ *  Parameters:
+ *      pszUuid:    Pointer to a string that represents a DSP_UUID object.
+ *      pUuid:      Pointer to a DSP_UUID object.
+ *  Returns:
+ *  Requires:
+ *      pUuid & pszUuid are non-NULL values.
+ *  Ensures:
+ *  Details:
+ *      We assume the string representation of a UUID has the following format:
+ *      "12345678_1234_1234_1234_123456789abc".
+ */
+	extern void UUID_UuidFromString(IN char *pszUuid,
+					OUT struct DSP_UUID *pUuid);
+
+#endif				/* UUIDUTIL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcd.h b/arch/arm/plat-omap/include/dspbridge/wcd.h
new file mode 100644
index 0000000..35be14e
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wcd.h
@@ -0,0 +1,36 @@
+/*
+ * wcd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Bridge class driver library functions, object definitions, and
+ * return error/status codes.  To be included by Bridge mini drivers.
+ *
+ * Notes:
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.  WMD's must not call module Init/Exit
+ *   functions.
+ *
+ *   To ensure WMD binary compatibility across different platforms,
+ *   for the same processor, a WMD must restrict its usage of system
+ *   services to those exported by the 'Bridge class library.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WCD_
+#define WCD_
+
+/* This WCD Library Version:  */
+#define WCD_MAJOR_VERSION   (u32)8	/* .8x - Alpha, .9x - Beta, 1.x FCS */
+#define WCD_MINOR_VERSION   (u32)0
+
+#endif				/* WCD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wcdioctl.h b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
new file mode 100644
index 0000000..88b50d0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wcdioctl.h
@@ -0,0 +1,496 @@
+/*
+ * wcdioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Contains structures and commands that are used for interaction
+ * between the DDSP API and class driver.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WCDIOCTL_
+#define WCDIOCTL_
+
+#include <dspbridge/mem.h>
+#include <dspbridge/cmm.h>
+#include <dspbridge/strmdefs.h>
+#include <dspbridge/dbdcd.h>
+
+union Trapped_Args {
+
+	/* MGR Module */
+	struct {
+		u32 uNode;
+		struct DSP_NDBPROPS __user *pNDBProps;
+		u32 uNDBPropsSize;
+		u32 __user *puNumNodes;
+	} ARGS_MGR_ENUMNODE_INFO;
+
+	struct {
+		u32 uProcessor;
+		struct DSP_PROCESSORINFO __user *pProcessorInfo;
+		u32 uProcessorInfoSize;
+		u32 __user *puNumProcs;
+	} ARGS_MGR_ENUMPROC_INFO;
+
+	struct {
+		struct DSP_UUID *pUuid;
+		enum DSP_DCDOBJTYPE objType;
+		char *pszPathName;
+	} ARGS_MGR_REGISTEROBJECT;
+
+	struct {
+		struct DSP_UUID *pUuid;
+		enum DSP_DCDOBJTYPE objType;
+	} ARGS_MGR_UNREGISTEROBJECT;
+
+	struct {
+		struct DSP_NOTIFICATION  __user*__user *aNotifications;
+		u32 uCount;
+		u32 __user *puIndex;
+		u32 uTimeout;
+	} ARGS_MGR_WAIT;
+
+	/* PROC Module */
+	struct {
+		u32 uProcessor;
+		struct DSP_PROCESSORATTRIN __user *pAttrIn;
+		void *__user *phProcessor;
+	} ARGS_PROC_ATTACH;
+
+	struct {
+		void *hProcessor;
+		u32 dwCmd;
+		struct DSP_CBDATA __user *pArgs;
+	} ARGS_PROC_CTRL;
+
+	struct {
+		void *hProcessor;
+	} ARGS_PROC_DETACH;
+
+	struct {
+		void *hProcessor;
+		void *__user *aNodeTab;
+		u32 uNodeTabSize;
+		u32 __user *puNumNodes;
+		u32 __user *puAllocated;
+	} ARGS_PROC_ENUMNODE_INFO;
+
+	struct {
+		void *hProcessor;
+		u32 uResourceType;
+		struct DSP_RESOURCEINFO *pResourceInfo;
+		u32 uResourceInfoSize;
+	} ARGS_PROC_ENUMRESOURCES;
+
+	struct {
+		void *hProcessor;
+		struct DSP_PROCESSORSTATE __user *pProcStatus;
+		u32 uStateInfoSize;
+	} ARGS_PROC_GETSTATE;
+
+	struct {
+		void *hProcessor;
+		u8 __user *pBuf;
+		u8 __user *pSize;
+		u32 uMaxSize;
+	} ARGS_PROC_GETTRACE;
+
+	struct {
+		void *hProcessor;
+		s32 iArgc;
+		char __user*__user *aArgv;
+		char *__user *aEnvp;
+	} ARGS_PROC_LOAD;
+
+	struct {
+		void *hProcessor;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_PROC_REGISTER_NOTIFY;
+
+	struct {
+		void *hProcessor;
+	} ARGS_PROC_START;
+
+	struct {
+		void *hProcessor;
+		u32 ulSize;
+		void *__user *ppRsvAddr;
+	} ARGS_PROC_RSVMEM;
+
+	struct {
+		void *hProcessor;
+		u32 ulSize;
+		void *pRsvAddr;
+	} ARGS_PROC_UNRSVMEM;
+
+	struct {
+		void *hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+		void *pReqAddr;
+		void *__user *ppMapAddr;
+		u32 ulMapAttr;
+	} ARGS_PROC_MAPMEM;
+
+	struct {
+		void *hProcessor;
+		u32 ulSize;
+		void *pMapAddr;
+	} ARGS_PROC_UNMAPMEM;
+
+	struct {
+		void *hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+		u32 ulFlags;
+	} ARGS_PROC_FLUSHMEMORY;
+
+	struct {
+		void *hProcessor;
+	} ARGS_PROC_STOP;
+
+	struct {
+		void *hProcessor;
+		void *pMpuAddr;
+		u32 ulSize;
+	} ARGS_PROC_INVALIDATEMEMORY;
+
+
+	/* NODE Module */
+	struct {
+		void *hProcessor;
+		struct DSP_UUID __user *pNodeID;
+		struct DSP_CBDATA __user *pArgs;
+		struct DSP_NODEATTRIN __user *pAttrIn;
+		void *__user *phNode;
+	} ARGS_NODE_ALLOCATE;
+
+	struct {
+		void *hNode;
+		u32 uSize;
+		struct DSP_BUFFERATTR __user *pAttr;
+		u8 *__user *pBuffer;
+	} ARGS_NODE_ALLOCMSGBUF;
+
+	struct {
+		void *hNode;
+		s32 iPriority;
+	} ARGS_NODE_CHANGEPRIORITY;
+
+	struct {
+		void *hNode;
+		u32 uStream;
+		void *hOtherNode;
+		u32 uOtherStream;
+		struct DSP_STRMATTR __user *pAttrs;
+		struct DSP_CBDATA __user *pConnParam;
+	} ARGS_NODE_CONNECT;
+
+	struct {
+		void *hNode;
+	} ARGS_NODE_CREATE;
+
+	struct {
+		void *hNode;
+	} ARGS_NODE_DELETE;
+
+	struct {
+		void *hNode;
+		struct DSP_BUFFERATTR __user *pAttr;
+		u8 *pBuffer;
+	} ARGS_NODE_FREEMSGBUF;
+
+	struct {
+		void *hNode;
+		struct DSP_NODEATTR __user *pAttr;
+		u32 uAttrSize;
+	} ARGS_NODE_GETATTR;
+
+	struct {
+		void *hNode;
+		struct DSP_MSG __user *pMessage;
+		u32 uTimeout;
+	} ARGS_NODE_GETMESSAGE;
+
+	struct {
+		void *hNode;
+	} ARGS_NODE_PAUSE;
+
+	struct {
+		void *hNode;
+		struct DSP_MSG __user *pMessage;
+		u32 uTimeout;
+	} ARGS_NODE_PUTMESSAGE;
+
+	struct {
+		void *hNode;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_NODE_REGISTERNOTIFY;
+
+	struct {
+		void *hNode;
+	} ARGS_NODE_RUN;
+
+	struct {
+		void *hNode;
+		DSP_STATUS __user *pStatus;
+	} ARGS_NODE_TERMINATE;
+
+	struct {
+		void *hProcessor;
+		struct DSP_UUID __user *pNodeID;
+		struct DSP_NDBPROPS __user *pNodeProps;
+	} ARGS_NODE_GETUUIDPROPS;
+
+	/* STRM module */
+
+	struct {
+		void *hStream;
+		u32 uSize;
+		u8 *__user *apBuffer;
+		u32 uNumBufs;
+	} ARGS_STRM_ALLOCATEBUFFER;
+
+	struct {
+		void *hStream;
+	} ARGS_STRM_CLOSE;
+
+	struct {
+		void *hStream;
+		u8 *__user *apBuffer;
+		u32 uNumBufs;
+	} ARGS_STRM_FREEBUFFER;
+
+	struct {
+		void *hStream;
+		HANDLE *phEvent;
+	} ARGS_STRM_GETEVENTHANDLE;
+
+	struct {
+		void *hStream;
+		struct STRM_INFO __user *pStreamInfo;
+		u32 uStreamInfoSize;
+	} ARGS_STRM_GETINFO;
+
+	struct {
+		void *hStream;
+		bool bFlush;
+	} ARGS_STRM_IDLE;
+
+	struct {
+		void *hStream;
+		u8 *pBuffer;
+		u32 dwBytes;
+		u32 dwBufSize;
+		u32 dwArg;
+	} ARGS_STRM_ISSUE;
+
+	struct {
+		void *hNode;
+		u32 uDirection;
+		u32 uIndex;
+		struct STRM_ATTR __user *pAttrIn;
+		void *__user *phStream;
+	} ARGS_STRM_OPEN;
+
+	struct {
+		void *hStream;
+		u8 *__user *pBufPtr;
+		u32 __user *pBytes;
+		u32 __user *pBufSize;
+		u32 __user *pdwArg;
+	} ARGS_STRM_RECLAIM;
+
+	struct {
+		void *hStream;
+		u32 uEventMask;
+		u32 uNotifyType;
+		struct DSP_NOTIFICATION __user *hNotification;
+	} ARGS_STRM_REGISTERNOTIFY;
+
+	struct {
+		void *__user *aStreamTab;
+		u32 nStreams;
+		u32 __user *pMask;
+		u32 uTimeout;
+	} ARGS_STRM_SELECT;
+
+	/* CMM Module */
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		u32 uSize;
+		struct CMM_ATTRS *pAttrs;
+		OUT void **ppBufVA;
+	} ARGS_CMM_ALLOCBUF;
+
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		void *pBufPA;
+		u32 ulSegId;
+	} ARGS_CMM_FREEBUF;
+
+	struct {
+		void *hProcessor;
+		struct CMM_OBJECT *__user *phCmmMgr;
+	} ARGS_CMM_GETHANDLE;
+
+	struct {
+		struct CMM_OBJECT *hCmmMgr;
+		struct CMM_INFO __user *pCmmInfo;
+	} ARGS_CMM_GETINFO;
+
+	/* MEM Module */
+	struct {
+		u32 cBytes;
+		enum MEM_POOLATTRS type;
+		void *pMem;
+	} ARGS_MEM_ALLOC;
+
+	struct {
+		u32 cBytes;
+		enum MEM_POOLATTRS type;
+		void *pMem;
+	} ARGS_MEM_CALLOC;
+
+	struct {
+		void *pMem;
+	} ARGS_MEM_FREE;
+
+	struct {
+		void *pBuffer;
+		u32 cSize;
+		void *pLockedBuffer;
+	} ARGS_MEM_PAGELOCK;
+
+	struct {
+		void *pBuffer;
+		u32 cSize;
+	} ARGS_MEM_PAGEUNLOCK;
+
+	/* UTIL module */
+	struct {
+		s32 cArgc;
+		char **ppArgv;
+	} ARGS_UTIL_TESTDLL;
+} ;
+
+/*
+ * Dspbridge Ioctl numbering scheme
+ *
+ *    7                           0
+ *  ---------------------------------
+ *  |  Module   |   Ioctl Number    |
+ *  ---------------------------------
+ *  | x | x | x | 0 | 0 | 0 | 0 | 0 |
+ *  ---------------------------------
+ */
+
+/* Ioctl driver identifier */
+#define DB		0xDB
+
+/*
+ * Following are used to distinguish between module ioctls, this is needed
+ * in case new ioctls are introduced.
+ */
+#define DB_MODULE_MASK		0xE0
+#define DB_IOC_MASK		0x1F
+
+/* Ioctl module masks */
+#define DB_MGR		0x0
+#define DB_PROC		0x20
+#define DB_NODE		0x40
+#define DB_STRM		0x60
+#define DB_CMM		0x80
+
+#define DB_MODULE_SHIFT		5
+
+/* Used to calculate the ioctl per dspbridge module */
+#define DB_IOC(module, num) \
+			(((module) & DB_MODULE_MASK) | ((num) & DB_IOC_MASK))
+/* Used to get dspbridge ioctl module */
+#define DB_GET_MODULE(cmd)	((cmd) & DB_MODULE_MASK)
+/* Used to get dspbridge ioctl number */
+#define DB_GET_IOC(cmd)		((cmd) & DB_IOC_MASK)
+
+/* TODO: Remove deprecated and not implemented */
+
+/* MGR Module */
+#define MGR_ENUMNODE_INFO	_IOWR(DB, DB_IOC(DB_MGR, 0), unsigned long)
+#define MGR_ENUMPROC_INFO	_IOWR(DB, DB_IOC(DB_MGR, 1), unsigned long)
+#define MGR_REGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 2), unsigned long)
+#define MGR_UNREGISTEROBJECT	_IOWR(DB, DB_IOC(DB_MGR, 3), unsigned long)
+#define MGR_WAIT		_IOWR(DB, DB_IOC(DB_MGR, 4), unsigned long)
+/* MGR_GET_PROC_RES Deprecated */
+#define MGR_GET_PROC_RES	_IOR(DB, DB_IOC(DB_MGR, 5), unsigned long)
+
+/* PROC Module */
+#define PROC_ATTACH		_IOWR(DB, DB_IOC(DB_PROC, 0), unsigned long)
+#define PROC_CTRL		_IOR(DB, DB_IOC(DB_PROC, 1), unsigned long)
+/* PROC_DETACH Deprecated */
+#define PROC_DETACH		_IOR(DB, DB_IOC(DB_PROC, 2), unsigned long)
+#define PROC_ENUMNODE		_IOWR(DB, DB_IOC(DB_PROC, 3), unsigned long)
+#define PROC_ENUMRESOURCES	_IOWR(DB, DB_IOC(DB_PROC, 4), unsigned long)
+#define PROC_GET_STATE		_IOWR(DB, DB_IOC(DB_PROC, 5), unsigned long)
+#define PROC_GET_TRACE		_IOWR(DB, DB_IOC(DB_PROC, 6), unsigned long)
+#define PROC_LOAD		_IOW(DB, DB_IOC(DB_PROC, 7), unsigned long)
+#define PROC_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_PROC, 8), unsigned long)
+#define PROC_START		_IOW(DB, DB_IOC(DB_PROC, 9), unsigned long)
+#define PROC_RSVMEM		_IOWR(DB, DB_IOC(DB_PROC, 10), unsigned long)
+#define PROC_UNRSVMEM		_IOW(DB, DB_IOC(DB_PROC, 11), unsigned long)
+#define PROC_MAPMEM		_IOWR(DB, DB_IOC(DB_PROC, 12), unsigned long)
+#define PROC_UNMAPMEM		_IOR(DB, DB_IOC(DB_PROC, 13), unsigned long)
+#define PROC_FLUSHMEMORY	_IOW(DB, DB_IOC(DB_PROC, 14), unsigned long)
+#define PROC_STOP		_IOWR(DB, DB_IOC(DB_PROC, 15), unsigned long)
+#define PROC_INVALIDATEMEMORY	_IOW(DB, DB_IOC(DB_PROC, 16), unsigned long)
+
+/* NODE Module */
+#define NODE_ALLOCATE		_IOWR(DB, DB_IOC(DB_NODE, 0), unsigned long)
+#define NODE_ALLOCMSGBUF	_IOWR(DB, DB_IOC(DB_NODE, 1), unsigned long)
+#define NODE_CHANGEPRIORITY	_IOW(DB, DB_IOC(DB_NODE, 2), unsigned long)
+#define NODE_CONNECT		_IOW(DB, DB_IOC(DB_NODE, 3), unsigned long)
+#define NODE_CREATE		_IOW(DB, DB_IOC(DB_NODE, 4), unsigned long)
+#define NODE_DELETE		_IOW(DB, DB_IOC(DB_NODE, 5), unsigned long)
+#define NODE_FREEMSGBUF		_IOW(DB, DB_IOC(DB_NODE, 6), unsigned long)
+#define NODE_GETATTR		_IOWR(DB, DB_IOC(DB_NODE, 7), unsigned long)
+#define NODE_GETMESSAGE		_IOWR(DB, DB_IOC(DB_NODE, 8), unsigned long)
+#define NODE_PAUSE		_IOW(DB, DB_IOC(DB_NODE, 9), unsigned long)
+#define NODE_PUTMESSAGE		_IOW(DB, DB_IOC(DB_NODE, 10), unsigned long)
+#define NODE_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_NODE, 11), unsigned long)
+#define NODE_RUN		_IOW(DB, DB_IOC(DB_NODE, 12), unsigned long)
+#define NODE_TERMINATE		_IOWR(DB, DB_IOC(DB_NODE, 13), unsigned long)
+#define NODE_GETUUIDPROPS	_IOWR(DB, DB_IOC(DB_NODE, 14), unsigned long)
+
+/* STRM Module */
+#define STRM_ALLOCATEBUFFER	_IOWR(DB, DB_IOC(DB_STRM, 0), unsigned long)
+#define STRM_CLOSE		_IOW(DB, DB_IOC(DB_STRM, 1), unsigned long)
+#define STRM_FREEBUFFER		_IOWR(DB, DB_IOC(DB_STRM, 2), unsigned long)
+#define STRM_GETEVENTHANDLE	_IO(DB, DB_IOC(DB_STRM, 3))	/* Not Impl'd */
+#define STRM_GETINFO		_IOWR(DB, DB_IOC(DB_STRM, 4), unsigned long)
+#define STRM_IDLE		_IOW(DB, DB_IOC(DB_STRM, 5), unsigned long)
+#define STRM_ISSUE		_IOW(DB, DB_IOC(DB_STRM, 6), unsigned long)
+#define STRM_OPEN		_IOWR(DB, DB_IOC(DB_STRM, 7), unsigned long)
+#define STRM_RECLAIM		_IOWR(DB, DB_IOC(DB_STRM, 8), unsigned long)
+#define STRM_REGISTERNOTIFY	_IOWR(DB, DB_IOC(DB_STRM, 9), unsigned long)
+#define STRM_SELECT		_IOWR(DB, DB_IOC(DB_STRM, 10), unsigned long)
+
+/* CMM Module */
+#define CMM_ALLOCBUF		_IO(DB, DB_IOC(DB_CMM, 0))	/* Not Impl'd */
+#define CMM_FREEBUF		_IO(DB, DB_IOC(DB_CMM, 1))	/* Not Impl'd */
+#define CMM_GETHANDLE		_IOR(DB, DB_IOC(DB_CMM, 2), unsigned long)
+#define CMM_GETINFO		_IOR(DB, DB_IOC(DB_CMM, 3), unsigned long)
+
+#endif				/* WCDIOCTL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
new file mode 100644
index 0000000..3305eab
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -0,0 +1,1160 @@
+/*
+ * wmd.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Bridge mini driver entry point and interface function declarations.
+ *
+ * Notes:
+ *   The Bridge class driver obtains it's function interface to
+ *   the Bridge mini driver via a call to WMD_DRV_Entry().
+ *
+ *   Bridge Class Driver services exported to WMD's are initialized by the
+ *   WCD on behalf of the WMD.
+ *
+ *   WMD function DBC Requires and Ensures are also made by the WCD on
+ *   behalf of the WMD, to simplify the WMD code.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMD_
+#define WMD_
+
+#include <dspbridge/brddefs.h>
+#include <dspbridge/cfgdefs.h>
+#include <dspbridge/chnlpriv.h>
+#include <dspbridge/dehdefs.h>
+#include <dspbridge/devdefs.h>
+#include <dspbridge/iodefs.h>
+#include <dspbridge/msgdefs.h>
+
+/*
+ *  Any IOCTLS at or above this value are reserved for standard WMD
+ *  interfaces.
+ */
+#define WMD_RESERVEDIOCTLBASE   0x8000
+
+/* Handle to mini-driver's private device context.  */
+	struct WMD_DEV_CONTEXT;
+
+/*---------------------------------------------------------------------------*/
+/* 'Bridge MINI DRIVER FUNCTION TYPES                                        */
+/*---------------------------------------------------------------------------*/
+
+/*
+ *  ======== WMD_BRD_Monitor ========
+ *  Purpose:
+ *      Bring the board to the BRD_IDLE (monitor) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_HARDWARE: A test of hardware assumptions/integrity failed.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_IDLE state;
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(
+			   *WMD_BRD_MONITOR) (struct WMD_DEV_CONTEXT
+			   *hDevContext);
+
+/*
+ *  ======== WMD_BRD_SETSTATE ========
+ *  Purpose:
+ *      Sets the Mini driver state
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulBrdState:     Board state
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Ensures:
+ *      ulBrdState  <= BRD_LASTSTATE.
+ *  Update the Board state to the specified state.
+ */
+       typedef DSP_STATUS(
+			   *WMD_BRD_SETSTATE) (struct WMD_DEV_CONTEXT
+			   *hDevContext, u32 ulBrdState);
+
+/*
+ *  ======== WMD_BRD_Start ========
+ *  Purpose:
+ *      Bring board to the BRD_RUNNING (start) state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      dwDSPAddr:      DSP address at which to start execution.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *      Board is in monitor (BRD_IDLE) state.
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_START) (struct WMD_DEV_CONTEXT
+						*hDevContext, u32 dwDSPAddr);
+
+/*
+ *  ======== WMD_BRD_MemCopy ========
+ *  Purpose:
+ *  Copy memory from one DSP address to another
+ *  Parameters:
+ *      pDevContext:    Pointer to context handle
+ *  ulDspDestAddr:  DSP address to copy to
+ *  ulDspSrcAddr:   DSP address to copy from
+ *  ulNumBytes: Number of bytes to copy
+ *  ulMemType:  What section of memory to copy to
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      pDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_RUNNING state.
+ *                      Interrupts to the PC are enabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMCOPY) (struct WMD_DEV_CONTEXT
+					     *hDevContext,
+					     u32 ulDspDestAddr,
+					     u32 ulDspSrcAddr,
+					     u32 ulNumBytes, u32 ulMemType);
+/*
+ *  ======== WMD_BRD_MemWrite ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.  Unlike WMD_BRD_Write, this API does reset the DSP
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMWRITE) (struct WMD_DEV_CONTEXT
+					*hDevContext,
+					IN u8 *pHostBuf,
+					u32 dwDSPAddr, u32 ulNumBytes,
+					u32 ulMemType);
+
+/*
+ *  ======== WMD_BRD_MemMap ========
+ *  Purpose:
+ *      Map a MPU memory region to a DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulMpuAddr:      MPU memory region start address.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ulNumBytes:     Number of bytes to map.
+ *      mapAttrs:       Mapping attributes (e.g. endianness).
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMMAP) (struct WMD_DEV_CONTEXT
+					*hDevContext, u32 ulMpuAddr,
+					u32 ulVirtAddr, u32 ulNumBytes,
+					u32 ulMapAttrs);
+
+/*
+ *  ======== WMD_BRD_MemUnMap ========
+ *  Purpose:
+ *      UnMap an MPU memory region from DSP/IVA memory space
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      ulVirtAddr:     DSP/IVA memory region u8 address.
+ *      ulNumBytes:     Number of bytes to unmap.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_BRD_MEMUNMAP) (struct WMD_DEV_CONTEXT
+					*hDevContext,
+					u32 ulVirtAddr,
+					u32 ulNumBytes);
+
+/*
+ *  ======== WMD_BRD_Stop ========
+ *  Purpose:
+ *      Bring board to the BRD_STOPPED state.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL
+ *  Ensures:
+ *      DSP_SOK:        Board is in BRD_STOPPED (stop) state;
+ *                      Interrupts to the PC are disabled.
+ *      else:           Board state is indeterminate.
+ */
+       typedef DSP_STATUS(*WMD_BRD_STOP) (struct WMD_DEV_CONTEXT
+					*hDevContext);
+
+/*
+ *  ======== WMD_BRD_Status ========
+ *  Purpose:
+ *      Report the current state of the board.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device context.
+ *      pdwState:       Ptr to BRD status variable.
+ *  Returns:
+ *      DSP_SOK:
+ *  Requires:
+ *      pdwState != NULL;
+ *      hDevContext != NULL
+ *  Ensures:
+ *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
+ */
+       typedef DSP_STATUS(*
+			   WMD_BRD_STATUS) (struct WMD_DEV_CONTEXT *hDevContext,
+					    int *pdwState);
+
+/*
+ *  ======== WMD_BRD_Read ========
+ *  Purpose:
+ *      Read a block of DSP memory, from a given memory space, into a host
+ *      buffer.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      pHostBuf:       Pointer to host buffer (Destination).
+ *      dwDSPAddr:      Address on DSP board (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP from which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ *  Will not write more than ulNumBytes bytes into pHostBuf.
+ */
+typedef DSP_STATUS(*WMD_BRD_READ) (struct WMD_DEV_CONTEXT *hDevContext,
+						  OUT u8 *pHostBuf,
+						  u32 dwDSPAddr,
+						  u32 ulNumBytes,
+						  u32 ulMemType);
+
+/*
+ *  ======== WMD_BRD_Write ========
+ *  Purpose:
+ *      Write a block of host memory into a DSP address, into a given memory
+ *      space.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwDSPAddr:      Address on DSP board (Destination).
+ *      pHostBuf:       Pointer to host buffer (Source).
+ *      ulNumBytes:     Number of bytes to transfer.
+ *      ulMemType:      Memory space on DSP to which to transfer.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      WMD_E_TIMEOUT:  Timeout occured waiting for a response from hardware.
+ *      DSP_EFAIL:      Other, unspecified error.
+ *  Requires:
+ *      hDevContext != NULL;
+ *      pHostBuf != NULL.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*WMD_BRD_WRITE)(struct WMD_DEV_CONTEXT *hDevContext,
+						   IN u8 *pHostBuf,
+						   u32 dwDSPAddr,
+						   u32 ulNumBytes,
+						   u32 ulMemType);
+
+/*
+ *  ======== WMD_CHNL_Create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given 'Bridge board.
+ *  Parameters:
+ *      phChnlMgr:      Location to store a channel manager object on output.
+ *      hDevObject:     Handle to a device object.
+ *      pMgrAttrs:      Channel manager attributes.
+ *      pMgrAttrs->cChannels: Max channels
+ *      pMgrAttrs->bIRQ:      Channel's I/O IRQ number.
+ *      pMgrAttrs->fShared:   TRUE if the IRQ is shareable.
+ *      pMgrAttrs->uWordSize: DSP Word size in equivalent PC bytes..
+ *      pMgrAttrs->dwSMBase:  Base physical address of shared memory, if any.
+ *      pMgrAttrs->uSMLength: Bytes of shared memory block.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EMEMORY:        Insufficient memory for requested resources.
+ *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
+ *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
+ *  Requires:
+ *      phChnlMgr != NULL.
+ *      pMgrAttrs != NULL
+ *      pMgrAttrs field are all valid:
+ *          0 < cChannels <= CHNL_MAXCHANNELS.
+ *          bIRQ <= 15.
+ *          uWordSize > 0.
+ *      IsValidHandle(hDevObject)
+ *      No channel manager exists for this board.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CREATE)(OUT struct CHNL_MGR
+						    **phChnlMgr,
+						    struct DEV_OBJECT
+						    *hDevObject,
+						    IN CONST struct
+						    CHNL_MGRATTRS *pMgrAttrs);
+
+/*
+ *  ======== WMD_CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ *  Parameters:
+ *      hChnlMgr:       Channel manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    hChnlMgr was invalid.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: Cancels I/O on each open channel. Closes each open channel.
+ *          CHNL_Create may subsequently be called for the same device.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_DESTROY) (struct CHNL_MGR
+						      *hChnlMgr);
+/*
+ *  ======== WMD_DEH_Notify ========
+ *  Purpose:
+ *      When notified of DSP error, take appropriate action.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *      ulEventMask:  Indicate the type of exception
+ *      dwErrInfo:     Error information
+ *  Returns:
+ *
+ *  Requires:
+ *      hDehMgr != NULL;
+ *     ulEventMask with a valid exception
+ *  Ensures:
+ */
+       typedef void (*WMD_DEH_NOTIFY)(struct DEH_MGR *hDehMgr,
+					u32 ulEventMask, u32 dwErrInfo);
+
+
+/*
+ *  ======== WMD_CHNL_Open ========
+ *  Purpose:
+ *      Open a new half-duplex channel to the DSP board.
+ *  Parameters:
+ *      phChnl:         Location to store a channel object handle.
+ *      hChnlMgr:       Handle to channel manager, as returned by CHNL_GetMgr().
+ *      uMode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
+ *                      direction of data transfer.
+ *      uChnlId:        If CHNL_PICKFREE is specified, the channel manager will
+ *                      select a free channel id (default);
+ *                      otherwise this field specifies the id of the channel.
+ *      pAttrs:         Channel attributes.  Attribute fields are as follows:
+ *      pAttrs->uIOReqs: Specifies the maximum number of I/O requests which can
+ *                      be pending at any given time. All request packets are
+ *                      preallocated when the channel is opened.
+ *      pAttrs->hEvent: This field allows the user to supply an auto reset
+ *                      event object for channel I/O completion notifications.
+ *                      It is the responsibility of the user to destroy this
+ *                      object AFTER closing the channel.
+ *                      This channel event object can be retrieved using
+ *                      CHNL_GetEventHandle().
+ *      pAttrs->hReserved: The kernel mode handle of this event object.
+ *
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            hChnlMgr is invalid.
+ *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      DSP_EINVALIDARG:        Invalid number of IOReqs.
+ *      CHNL_E_OUTOFSTREAMS:    No free channels available.
+ *      CHNL_E_BADCHANID:       Channel ID is out of range.
+ *      CHNL_E_CHANBUSY:        Channel is in use.
+ *      CHNL_E_NOIORPS:         No free IO request packets available for
+ *                              queuing.
+ *  Requires:
+ *      phChnl != NULL.
+ *      pAttrs != NULL.
+ *      pAttrs->hEvent is a valid event handle.
+ *      pAttrs->hReserved is the kernel mode handle for pAttrs->hEvent.
+ *  Ensures:
+ *      DSP_SOK:                *phChnl is a valid channel.
+ *      else:                   *phChnl is set to NULL if (phChnl != NULL);
+ */
+       typedef DSP_STATUS(*WMD_CHNL_OPEN) (OUT struct CHNL_OBJECT
+						   **phChnl,
+						   struct CHNL_MGR *hChnlMgr,
+						   short int uMode,
+						   u32 uChnlId,
+						   CONST IN OPTIONAL struct
+						   CHNL_ATTRS *pAttrs);
+
+/*
+ *  ======== WMD_CHNL_Close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ *  Parameters:
+ *      hChnl:          Handle to a channel object.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *      No thread must be blocked on this channel's I/O completion event.
+ *  Ensures:
+ *      DSP_SOK:        hChnl is no longer valid.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CLOSE) (struct CHNL_OBJECT *hChnl);
+
+/*
+ *  ======== WMD_CHNL_AddIOReq ========
+ *  Purpose:
+ *      Enqueue an I/O request for data transfer on a channel to the DSP.
+ *      The direction (mode) is specified in the channel object. Note the DSP
+ *      address is specified for channels opened in direct I/O mode.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      pHostBuf:       Host buffer address source.
+ *      cBytes:         Number of PC bytes to transfer. A zero value indicates
+ *                      that this buffer is the last in the output channel.
+ *                      A zero value is invalid for an input channel.
+ *!     cBufSize:       Actual buffer size in host bytes.
+ *      dwDspAddr:      DSP address for transfer.  (Currently ignored).
+ *      dwArg:          A user argument that travels with the buffer.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pHostBuf is invalid.
+ *      CHNL_E_NOEOS:   User cannot mark EOS on an input channel.
+ *      CHNL_E_CANCELLED: I/O has been cancelled on this channel.  No further
+ *                      I/O is allowed.
+ *      CHNL_E_EOS:     End of stream was already marked on a previous
+ *                      IORequest on this channel.  No further I/O is expected.
+ *      CHNL_E_BUFSIZE: Buffer submitted to this output channel is larger than
+ *                      the size of the physical shared memory output window.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK: The buffer will be transferred if the channel is ready;
+ *          otherwise, will be queued for transfer when the channel becomes
+ *          ready.  In any case, notifications of I/O completion are
+ *          asynchronous.
+ *          If cBytes is 0 for an output channel, subsequent CHNL_AddIOReq's
+ *          on this channel will fail with error code CHNL_E_EOS.  The
+ *          corresponding IOC for this I/O request will have its status flag
+ *          set to CHNL_IOCSTATEOS.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_ADDIOREQ) (struct CHNL_OBJECT
+						       *hChnl,
+						       void *pHostBuf,
+						       u32 cBytes,
+						       u32 cBufSize,
+						       OPTIONAL u32 dwDspAddr,
+						       u32 dwArg);
+
+/*
+ *  ======== WMD_CHNL_GetIOC ========
+ *  Purpose:
+ *      Dequeue an I/O completion record, which contains information about the
+ *      completed I/O request.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      A value of CHNL_IOCNOWAIT will simply dequeue the
+ *                      first available IOC.
+ *      pIOC:           On output, contains host buffer address, bytes
+ *                      transferred, and status of I/O completion.
+ *      pIOC->status:   See chnldefs.h.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pIOC is invalid.
+ *      CHNL_E_NOIOC:   CHNL_IOCNOWAIT was specified as the dwTimeOut parameter
+ *                      yet no I/O completions were queued.
+ *  Requires:
+ *      dwTimeOut == CHNL_IOCNOWAIT.
+ *  Ensures:
+ *      DSP_SOK: if there are any remaining IOC's queued before this call
+ *          returns, the channel event object will be left in a signalled
+ *          state.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETIOC) (struct CHNL_OBJECT *hChnl,
+						     u32 dwTimeOut,
+						     OUT struct CHNL_IOC *pIOC);
+
+/*
+ *  ======== WMD_CHNL_CancelIO ========
+ *  Purpose:
+ *      Return all I/O requests to the client which have not yet been
+ *      transferred.  The channel's I/O completion object is
+ *      signalled, and all the I/O requests are queued as IOC's, with the
+ *      status field set to CHNL_IOCSTATCANCEL.
+ *      This call is typically used in abort situations, and is a prelude to
+ *      CHNL_Close();
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *  Requires:
+ *  Ensures:
+ *      Subsequent I/O requests to this channel will not be accepted.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_CANCELIO) (struct CHNL_OBJECT
+						       *hChnl);
+
+/*
+ *  ======== WMD_CHNL_FlushIO ========
+ *  Purpose:
+ *      For an output stream (to the DSP), indicates if any IO requests are in
+ *      the output request queue.  For input streams (from the DSP), will
+ *      cancel all pending IO requests.
+ *  Parameters:
+ *      hChnl:              Channel object handle.
+ *      dwTimeOut:          Timeout value for flush operation.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      S_CHNLIOREQUEST:    Returned if any IORequests are in the output queue.
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            No I/O requests will be pending on this channel.
+ */
+       typedef DSP_STATUS(*WMD_CHNL_FLUSHIO) (struct CHNL_OBJECT *hChnl,
+						      u32 dwTimeOut);
+
+/*
+ *  ======== WMD_CHNL_GetInfo ========
+ *  Purpose:
+ *      Retrieve information related to a channel.
+ *  Parameters:
+ *      hChnl:          Handle to a valid channel object, or NULL.
+ *      pInfo:          Location to store channel info.
+ *  Returns:
+ *      DSP_SOK:        Success;
+ *      DSP_EHANDLE:    Invalid hChnl.
+ *      DSP_EPOINTER:   pInfo == NULL.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:        pInfo points to a filled in CHNL_INFO struct,
+ *                      if (pInfo != NULL).
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETINFO) (struct CHNL_OBJECT *hChnl,
+						      OUT struct CHNL_INFO
+						      *pChnlInfo);
+
+/*
+ *  ======== WMD_CHNL_GetMgrInfo ========
+ *  Purpose:
+ *      Retrieve information related to the channel manager.
+ *  Parameters:
+ *      hChnlMgr:           Handle to a valid channel manager, or NULL.
+ *      uChnlID:            Channel ID.
+ *      pMgrInfo:           Location to store channel manager info.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnlMgr.
+ *      DSP_EPOINTER:       pMgrInfo == NULL.
+ *      CHNL_E_BADCHANID:   Invalid channel ID.
+ *  Requires:
+ *  Ensures:
+ *      DSP_SOK:            pMgrInfo points to a filled in CHNL_MGRINFO
+ *                          struct, if (pMgrInfo != NULL).
+ */
+       typedef DSP_STATUS(*WMD_CHNL_GETMGRINFO) (struct CHNL_MGR
+							 *hChnlMgr,
+							 u32 uChnlID,
+							 OUT struct CHNL_MGRINFO
+							 *pMgrInfo);
+
+/*
+ *  ======== WMD_CHNL_Idle ========
+ *  Purpose:
+ *      Idle a channel. If this is an input channel, or if this is an output
+ *      channel and fFlush is TRUE, all currently enqueued buffers will be
+ *      dequeued (data discarded for output channel).
+ *      If this is an output channel and fFlush is FALSE, this function
+ *      will block until all currently buffered data is output, or the timeout
+ *      specified has been reached.
+ *
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      dwTimeOut:      If output channel and fFlush is FALSE, timeout value
+ *                      to wait for buffers to be output. (Not used for
+ *                      input channel).
+ *      fFlush:         If output channel and fFlush is TRUE, discard any
+ *                      currently buffered data. If FALSE, wait for currently
+ *                      buffered data to be output, or timeout, whichever
+ *                      occurs first. fFlush is ignored for input channel.
+ *  Returns:
+ *      DSP_SOK:            Success;
+ *      DSP_EHANDLE:        Invalid hChnl.
+ *      CHNL_E_WAITTIMEOUT: Timeout occured before channel could be idled.
+ *  Requires:
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_IDLE) (struct CHNL_OBJECT *hChnl,
+						   u32 dwTimeOut,
+						   bool fFlush);
+
+/*
+ *  ======== WMD_CHNL_RegisterNotify ========
+ *  Purpose:
+ *      Register for notification of events on a channel.
+ *  Parameters:
+ *      hChnl:          Channel object handle.
+ *      uEventMask:     Type of events to be notified about: IO completion
+ *                      (DSP_STREAMIOCOMPLETION) or end of stream
+ *                      (DSP_STREAMDONE).
+ *      uNotifyType:    DSP_SIGNALEVENT.
+ *      hNotification:  Handle of a DSP_NOTIFICATION object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *      DSP_EVALUE:     uEventMask is 0 and hNotification was not
+ *                      previously registered.
+ *      DSP_EHANDLE:    NULL hNotification, hNotification event name
+ *                      too long, or hNotification event name NULL.
+ *  Requires:
+ *      Valid hChnl.
+ *      hNotification != NULL.
+ *      (uEventMask & ~(DSP_STREAMIOCOMPLETION | DSP_STREAMDONE)) == 0.
+ *      uNotifyType == DSP_SIGNALEVENT.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_CHNL_REGISTERNOTIFY)
+				(struct CHNL_OBJECT *hChnl,
+				u32 uEventMask,
+				u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_DEV_Create ========
+ *  Purpose:
+ *      Complete creation of the device object for this board.
+ *  Parameters:
+ *      phDevContext:   Ptr to location to store a WMD device context.
+ *      hDevObject:     Handle to a Device Object, created and managed by WCD.
+ *      pConfig:        Ptr to configuration parameters provided by the Windows
+ *                      Configuration Manager during device loading.
+ *      pDspConfig:     DSP resources, as specified in the registry key for this
+ *                      device.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Unable to allocate memory for device context.
+ *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
+ *                          parameters did not satisfy hardware assumptions
+ *                          made by this WMD.
+ *  Requires:
+ *      phDevContext != NULL;
+ *      hDevObject != NULL;
+ *      pConfig != NULL;
+ *      pDspConfig != NULL;
+ *      Fields in pConfig and pDspConfig contain valid values.
+ *  Ensures:
+ *      DSP_SOK:        All mini-driver specific DSP resource and other
+ *                      board context has been allocated.
+ *      DSP_EMEMORY:    WMD failed to allocate resources.
+ *                      Any acquired resources have been freed.  The WCD will
+ *                      not call WMD_DEV_Destroy() if WMD_DEV_Create() fails.
+ *  Details:
+ *      Called during the CONFIGMG's Device_Init phase. Based on host and
+ *      DSP configuration information, create a board context, a handle to
+ *      which is passed into other WMD BRD and CHNL functions.  The
+ *      board context contains state information for the device. Since the
+ *      addresses of all IN pointer parameters may be invalid when this
+ *      function returns, they must not be stored into the device context
+ *      structure.
+ */
+       typedef DSP_STATUS(*WMD_DEV_CREATE) (OUT struct WMD_DEV_CONTEXT
+						    **phDevContext,
+						    struct DEV_OBJECT
+						    *hDevObject,
+						    IN CONST struct CFG_HOSTRES
+						    *pConfig,
+						    IN CONST struct CFG_DSPRES
+						    *pDspConfig);
+
+/*
+ *  ======== WMD_DEV_Ctrl ========
+ *  Purpose:
+ *      Mini-driver specific interface.
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device info.
+ *      dwCmd:          WMD defined command code.
+ *      pArgs:          Pointer to an arbitrary argument structure.
+ *  Returns:
+ *      DSP_SOK or DSP_EFAIL. Actual command error codes should be passed back
+ *      in the pArgs structure, and are defined by the WMD implementor.
+ *  Requires:
+ *      All calls are currently assumed to be synchronous.  There are no
+ *      IOCTL completion routines provided.
+ *  Ensures:
+ */
+typedef DSP_STATUS(*WMD_DEV_CTRL)(struct WMD_DEV_CONTEXT *hDevContext,
+					u32 dwCmd,
+					IN OUT void *pArgs);
+
+/*
+ *  ======== WMD_DEV_Destroy ========
+ *  Purpose:
+ *      Deallocate WMD device extension structures and all other resources
+ *      acquired by the mini-driver.
+ *      No calls to other mini driver functions may subsequently
+ *      occur, except for WMD_DEV_Create().
+ *  Parameters:
+ *      hDevContext:    Handle to mini-driver defined device information.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Failed to release a resource previously acquired.
+ *  Requires:
+ *      hDevContext != NULL;
+ *  Ensures:
+ *      DSP_SOK: Device context is freed.
+ */
+       typedef DSP_STATUS(*WMD_DEV_DESTROY) (struct WMD_DEV_CONTEXT
+					     *hDevContext);
+
+/*
+ *  ======== WMD_DEH_Create ========
+ *  Purpose:
+ *      Create an object that manages DSP exceptions from the GPP.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      hDevObject:     Handle to DEV object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      hDevObject != NULL;
+ *      phDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_CREATE) (OUT struct DEH_MGR
+						    **phDehMgr,
+						    struct DEV_OBJECT
+						    *hDevObject);
+
+/*
+ *  ======== WMD_DEH_Destroy ========
+ *  Purpose:
+ *      Destroy the DEH object.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Destroy failed.
+ *  Requires:
+ *      hDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_DESTROY) (struct DEH_MGR *hDehMgr);
+
+/*
+ *  ======== WMD_DEH_RegisterNotify ========
+ *  Purpose:
+ *      Register for DEH event notification.
+ *  Parameters:
+ *      hDehMgr:        Handle to DEH manager object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Destroy failed.
+ *  Requires:
+ *      hDehMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_REGISTERNOTIFY)
+				(struct DEH_MGR *hDehMgr,
+				u32 uEventMask, u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_DEH_GetInfo ========
+ *  Purpose:
+ *      Get DSP exception info.
+ *  Parameters:
+ *      phDehMgr:       Location to store DEH manager on output.
+ *      pErrInfo:       Ptr to error info structure.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      phDehMgr != NULL;
+ *      pErrorInfo != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_DEH_GETINFO) (struct DEH_MGR *phDehMgr,
+					struct DSP_ERRORINFO *pErrInfo);
+
+/*
+ *  ======== WMD_IO_Create ========
+ *  Purpose:
+ *      Create an object that manages I/O between CHNL and MSG.
+ *  Parameters:
+ *      phIOMgr:        Location to store IO manager on output.
+ *      hChnlMgr:       Handle to channel manager.
+ *      hMsgMgr:        Handle to message manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      hDevObject != NULL;
+ *      Channel manager already created;
+ *      Message manager already created;
+ *      pMgrAttrs != NULL;
+ *      phIOMgr != NULL;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_CREATE) (OUT struct IO_MGR **phIOMgr,
+					struct DEV_OBJECT *hDevObject,
+					IN CONST struct IO_ATTRS *pMgrAttrs);
+
+/*
+ *  ======== WMD_IO_Destroy ========
+ *  Purpose:
+ *      Destroy object created in WMD_IO_Create.
+ *  Parameters:
+ *      hIOMgr:         IO Manager.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Memory allocation failure.
+ *      DSP_EFAIL:      Creation failed.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_DESTROY) (struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== WMD_IO_OnLoaded ========
+ *  Purpose:
+ *      Called whenever a program is loaded to update internal data. For
+ *      example, if shared memory is used, this function would update the
+ *      shared memory location and address.
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Internal failure occurred.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_ONLOADED) (struct IO_MGR *hIOMgr);
+
+/*
+ *  ======== WMD_IO_GETPROCLOAD ========
+ *  Purpose:
+ *      Called to get the Processor's current and predicted load
+ *  Parameters:
+ *      hIOMgr:     IO Manager.
+ *      pProcLoadStat   Processor Load statistics
+ *  Returns:
+ *      DSP_SOK:    Success.
+ *      DSP_EFAIL:  Internal failure occurred.
+ *  Requires:
+ *      Valid hIOMgr;
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_IO_GETPROCLOAD)(struct IO_MGR *hIOMgr,
+			   struct DSP_PROCLOADSTAT *pProcLoadStat);
+
+/*
+ *  ======== WMD_MSG_Create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object.
+ *  Parameters:
+ *      phMsgMgr:           Location to store MSG manager on output.
+ *      hDevObject:         Handle to a device object.
+ *      msgCallback:        Called whenever an RMS_EXIT message is received.
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *  Requires:
+ *      phMsgMgr != NULL.
+ *      msgCallback != NULL.
+ *      hDevObject != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_CREATE)
+				(OUT struct MSG_MGR **phMsgMgr,
+				struct DEV_OBJECT *hDevObject,
+				MSG_ONEXIT msgCallback);
+
+/*
+ *  ======== WMD_MSG_CreateQueue ========
+ *  Purpose:
+ *      Create a MSG queue for sending or receiving messages from a Message
+ *      node on the DSP.
+ *  Parameters:
+ *      hMsgMgr:            MSG queue manager handle returned from
+ *                          WMD_MSG_Create.
+ *      phMsgQueue:         Location to store MSG queue on output.
+ *      dwId:               Identifier for messages (node environment pointer).
+ *      uMaxMsgs:           Max number of simultaneous messages for the node.
+ *      h:                  Handle passed to hMsgMgr->msgCallback().
+ *  Returns:
+ *      DSP_SOK:            Success.
+ *      DSP_EMEMORY:        Insufficient memory.
+ *  Requires:
+ *      phMsgQueue != NULL.
+ *      h != NULL.
+ *      uMaxMsgs > 0.
+ *  Ensures:
+ *      phMsgQueue !=NULL <==> DSP_SOK.
+ */
+       typedef DSP_STATUS(*WMD_MSG_CREATEQUEUE)
+				(struct MSG_MGR *hMsgMgr,
+				OUT struct MSG_QUEUE **phMsgQueue,
+				u32 dwId, u32 uMaxMsgs, HANDLE h);
+
+/*
+ *  ======== WMD_MSG_Delete ========
+ *  Purpose:
+ *      Delete a MSG manager allocated in WMD_MSG_Create().
+ *  Parameters:
+ *      hMsgMgr:    Handle returned from WMD_MSG_Create().
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgMgr.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_DELETE) (struct MSG_MGR *hMsgMgr);
+
+/*
+ *  ======== WMD_MSG_DeleteQueue ========
+ *  Purpose:
+ *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ *  Parameters:
+ *      hMsgQueue:  Handle to MSG queue returned from
+ *                  WMD_MSG_CreateQueue.
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgQueue.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_DELETEQUEUE) (struct MSG_QUEUE *hMsgQueue);
+
+/*
+ *  ======== WMD_MSG_Get ========
+ *  Purpose:
+ *      Get a message from a MSG queue.
+ *  Parameters:
+ *      hMsgQueue:     Handle to MSG queue returned from
+ *                     WMD_MSG_CreateQueue.
+ *      pMsg:          Location to copy message into.
+ *      uTimeout:      Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:       Success.
+ *      DSP_ETIMEOUT:  Timeout occurred.
+ *      DSP_EFAIL:     No frames available for message (uMaxMessages too
+ *                     small).
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_GET) (struct MSG_QUEUE *hMsgQueue,
+						 struct DSP_MSG *pMsg,
+						 u32 uTimeout);
+
+/*
+ *  ======== WMD_MSG_Put ========
+ *  Purpose:
+ *      Put a message onto a MSG queue.
+ *  Parameters:
+ *      hMsgQueue:      Handle to MSG queue returned from
+ *                      WMD_MSG_CreateQueue.
+ *      pMsg:           Pointer to message.
+ *      uTimeout:       Timeout to wait for a message.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_ETIMEOUT:   Timeout occurred.
+ *      DSP_EFAIL:      No frames available for message (uMaxMessages too
+ *                      small).
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      pMsg != NULL.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_PUT) (struct MSG_QUEUE *hMsgQueue,
+						 IN CONST struct DSP_MSG *pMsg,
+						 u32 uTimeout);
+
+/*
+ *  ======== WMD_MSG_RegisterNotify ========
+ *  Purpose:
+ *      Register notification for when a message is ready.
+ *  Parameters:
+ *      hMsgQueue:      Handle to MSG queue returned from
+ *                      WMD_MSG_CreateQueue.
+ *      uEventMask:     Type of events to be notified about: Must be
+ *                      DSP_NODEMESSAGEREADY, or 0 to unregister.
+ *      uNotifyType:    DSP_SIGNALEVENT.
+ *      hNotification:  Handle of notification object.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Insufficient memory.
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      hNotification != NULL.
+ *      uNotifyType == DSP_SIGNALEVENT.
+ *      uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0.
+ *  Ensures:
+ */
+       typedef DSP_STATUS(*WMD_MSG_REGISTERNOTIFY)
+				(struct MSG_QUEUE *hMsgQueue,
+				u32 uEventMask, u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification);
+
+/*
+ *  ======== WMD_MSG_SetQueueId ========
+ *  Purpose:
+ *      Set message queue id to node environment. Allows WMD_MSG_CreateQueue
+ *      to be called in NODE_Allocate, before the node environment is known.
+ *  Parameters:
+ *      hMsgQueue:  Handle to MSG queue returned from
+ *                  WMD_MSG_CreateQueue.
+ *      dwId:       Node environment pointer.
+ *  Returns:
+ *  Requires:
+ *      Valid hMsgQueue.
+ *      dwId != 0.
+ *  Ensures:
+ */
+       typedef void(*WMD_MSG_SETQUEUEID) (struct MSG_QUEUE *hMsgQueue,
+						  u32 dwId);
+
+/*
+ *  'Bridge Mini Driver (WMD) interface function table.
+ *
+ *  The information in this table is filled in by the specific mini-driver,
+ *  and copied into the 'Bridge class driver's own space.  If any interface
+ *  function field is set to a value of NULL, then the class driver will
+ *  consider that function not implemented, and return the error code
+ *  DSP_ENOTIMPL when a WMD client attempts to call that function.
+ *
+ *  This function table contains WCD version numbers, which are used by the
+ *  WMD loader to help ensure backwards compatility between older WMD's and a
+ *  newer 'Bridge Class Driver.  These must be set to WCD_MAJOR_VERSION
+ *  and WCD_MINOR_VERSION, respectively.
+ *
+ *  A mini-driver need not export a CHNL interface.  In this case, *all* of
+ *  the WMD_CHNL_* entries must be set to NULL.
+ */
+	struct WMD_DRV_INTERFACE {
+		u32 dwWCDMajorVersion;	/* Set to WCD_MAJOR_VERSION. */
+		u32 dwWCDMinorVersion;	/* Set to WCD_MINOR_VERSION. */
+		WMD_DEV_CREATE pfnDevCreate;	/* Create device context     */
+		WMD_DEV_DESTROY pfnDevDestroy;	/* Destroy device context    */
+		WMD_DEV_CTRL pfnDevCntrl;	/* Optional vendor interface */
+		WMD_BRD_MONITOR pfnBrdMonitor;	/* Load and/or start monitor */
+		WMD_BRD_START pfnBrdStart;	/* Start DSP program.        */
+		WMD_BRD_STOP pfnBrdStop;	/* Stop/reset board.         */
+		WMD_BRD_STATUS pfnBrdStatus;	/* Get current board status. */
+		WMD_BRD_READ pfnBrdRead;	/* Read board memory         */
+		WMD_BRD_WRITE pfnBrdWrite;	/* Write board memory.       */
+		WMD_BRD_SETSTATE pfnBrdSetState;  /* Sets the Board State */
+		WMD_BRD_MEMCOPY pfnBrdMemCopy;	 /* Copies DSP Memory         */
+		WMD_BRD_MEMWRITE pfnBrdMemWrite; /* Write DSP Memory w/o halt */
+		WMD_BRD_MEMMAP pfnBrdMemMap;	 /* Maps MPU mem to DSP mem   */
+		WMD_BRD_MEMUNMAP pfnBrdMemUnMap; /* Unmaps MPU mem to DSP mem */
+		WMD_CHNL_CREATE pfnChnlCreate;	 /* Create channel manager.   */
+		WMD_CHNL_DESTROY pfnChnlDestroy; /* Destroy channel manager.  */
+		WMD_CHNL_OPEN pfnChnlOpen;	 /* Create a new channel.     */
+		WMD_CHNL_CLOSE pfnChnlClose;	 /* Close a channel.          */
+		WMD_CHNL_ADDIOREQ pfnChnlAddIOReq; /* Req I/O on a channel. */
+		WMD_CHNL_GETIOC pfnChnlGetIOC;	 /* Wait for I/O completion.  */
+		WMD_CHNL_CANCELIO pfnChnlCancelIO; /* Cancl I/O on a channel. */
+		WMD_CHNL_FLUSHIO pfnChnlFlushIO;	/* Flush I/O.         */
+		WMD_CHNL_GETINFO pfnChnlGetInfo; /* Get channel specific info */
+		/* Get channel manager info. */
+		WMD_CHNL_GETMGRINFO pfnChnlGetMgrInfo;
+		WMD_CHNL_IDLE pfnChnlIdle;	/* Idle the channel */
+		/* Register for notif. */
+		WMD_CHNL_REGISTERNOTIFY pfnChnlRegisterNotify;
+		WMD_DEH_CREATE pfnDehCreate;	/* Create DEH manager */
+		WMD_DEH_DESTROY pfnDehDestroy;	/* Destroy DEH manager */
+		WMD_DEH_NOTIFY pfnDehNotify;    /* Notify of DSP error */
+		/* register for deh notif. */
+		WMD_DEH_REGISTERNOTIFY pfnDehRegisterNotify;
+		WMD_DEH_GETINFO pfnDehGetInfo;	/* register for deh notif. */
+		WMD_IO_CREATE pfnIOCreate;	/* Create IO manager */
+		WMD_IO_DESTROY pfnIODestroy;	/* Destroy IO manager */
+		WMD_IO_ONLOADED pfnIOOnLoaded;	/* Notify of program loaded */
+		/* Get Processor's current and predicted load */
+		WMD_IO_GETPROCLOAD pfnIOGetProcLoad;
+		WMD_MSG_CREATE pfnMsgCreate;	/* Create message manager */
+		/* Create message queue */
+		WMD_MSG_CREATEQUEUE pfnMsgCreateQueue;
+		WMD_MSG_DELETE pfnMsgDelete;	/* Delete message manager */
+		/* Delete message queue */
+		WMD_MSG_DELETEQUEUE pfnMsgDeleteQueue;
+		WMD_MSG_GET pfnMsgGet;	/* Get a message */
+		WMD_MSG_PUT pfnMsgPut;	/* Send a message */
+		/* Register for notif. */
+		WMD_MSG_REGISTERNOTIFY pfnMsgRegisterNotify;
+		/* Set message queue id */
+		WMD_MSG_SETQUEUEID pfnMsgSetQueueId;
+	} ;
+
+/*
+ *  ======== WMD_DRV_Entry ========
+ *  Purpose:
+ *      Registers WMD functions with the class driver. Called only once
+ *      by the WCD.  The caller will first check WCD version compatibility, and
+ *      then copy the interface functions into its own memory space.
+ *  Parameters:
+ *      ppDrvInterface  Pointer to a location to receive a pointer to the
+ *                      mini driver interface.
+ *  Returns:
+ *  Requires:
+ *      The code segment this function resides in must expect to be discarded
+ *      after completion.
+ *  Ensures:
+ *      ppDrvInterface pointer initialized to WMD's function interface.
+ *      No system resources are acquired by this function.
+ *  Details:
+ *      Win95: Called during the Device_Init phase.
+ */
+       void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
+				 IN CONST char *pstrWMDFileName);
+
+#endif				/* WMD_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdchnl.h b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
new file mode 100644
index 0000000..f2608e0
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdchnl.h
@@ -0,0 +1,75 @@
+/*
+ * wmdchnl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge channel class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are implemented
+ * by every class of WMD channel library.
+ *
+ * Notes:
+ *   The function comment headers reside in wmd.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDCHNL_
+#define WMDCHNL_
+
+	extern DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+					  struct DEV_OBJECT *hDevObject,
+					  IN CONST struct CHNL_MGRATTRS
+					  *pMgrAttrs);
+
+	extern DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr);
+
+	extern DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
+					struct CHNL_MGR *hChnlMgr,
+					short int uMode,
+					u32 uChnlId,
+					CONST IN OPTIONAL struct CHNL_ATTRS
+					*pAttrs);
+
+	extern DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl);
+
+	extern DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl,
+					    void *pHostBuf,
+					    u32 cBytes, u32 cBufSize,
+					    OPTIONAL u32 dwDspAddr,
+					    u32 dwArg);
+
+	extern DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl,
+					  u32 dwTimeOut,
+					  OUT struct CHNL_IOC *pIOC);
+
+	extern DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl);
+
+	extern DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl,
+					   u32 dwTimeOut);
+
+	extern DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
+					   OUT struct CHNL_INFO *pInfo);
+
+	extern DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr,
+					      u32 uChnlID,
+					      OUT struct CHNL_MGRINFO
+					      *pMgrInfo);
+
+	extern DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl,
+					u32 dwTimeOut, bool fFlush);
+
+	extern DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl,
+						  u32 uEventMask,
+						  u32 uNotifyType,
+						  struct DSP_NOTIFICATION
+						  *hNotification);
+
+#endif				/* WMDCHNL_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmddeh.h b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
new file mode 100644
index 0000000..92c4452
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmddeh.h
@@ -0,0 +1,48 @@
+/*
+ * wmddeh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Defines upper edge DEH functions required by all WMD/WCD driver
+ * interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside with the function typedefs in wmd.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDDEH_
+#define WMDDEH_
+
+#include <dspbridge/devdefs.h>
+
+#include <dspbridge/dehdefs.h>
+
+	extern DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
+					 struct DEV_OBJECT *hDevObject);
+
+	extern DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr);
+
+	extern DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
+					  struct DSP_ERRORINFO *pErrInfo);
+
+	extern DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr,
+						 u32 uEventMask,
+						 u32 uNotifyType,
+						 struct DSP_NOTIFICATION
+						 *hNotification);
+
+	extern void WMD_DEH_Notify(struct DEH_MGR *hDehMgr,
+				   u32 ulEventMask, u32 dwErrInfo);
+
+	extern void WMD_DEH_ReleaseDummyMem(void);
+#endif				/* WMDDEH_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdio.h b/arch/arm/plat-omap/include/dspbridge/wmdio.h
new file mode 100644
index 0000000..95af696
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdio.h
@@ -0,0 +1,41 @@
+/*
+ * wmdio.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge IO functions required by all WMD / WCD
+ * driver interface tables.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDIO_
+#define WMDIO_
+
+#include <dspbridge/devdefs.h>
+#include <dspbridge/iodefs.h>
+
+	extern DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
+					struct DEV_OBJECT *hDevObject,
+					IN CONST struct IO_ATTRS *pMgrAttrs);
+
+	extern DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr);
+
+	extern DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr);
+
+	extern DSP_STATUS IVA_IO_OnLoaded(struct IO_MGR *hIOMgr);
+	extern DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
+				OUT struct DSP_PROCLOADSTAT *pProcStat);
+
+#endif				/* WMDIO_ */
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdioctl.h b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
new file mode 100644
index 0000000..3a9d65c
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdioctl.h
@@ -0,0 +1,69 @@
+/*
+ * wmdioctl.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * BRIDGE Minidriver BRD_IOCtl reserved command definitions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDIOCTL_
+#define WMDIOCTL_
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/* Any IOCTLS at or above this value are reserved for standard WMD interfaces.*/
+#define WMDIOCTL_RESERVEDBASE       0x8000
+
+#define WMDIOCTL_CHNLREAD           (WMDIOCTL_RESERVEDBASE + 0x10)
+#define WMDIOCTL_CHNLWRITE          (WMDIOCTL_RESERVEDBASE + 0x20)
+#define WMDIOCTL_GETINTRCOUNT       (WMDIOCTL_RESERVEDBASE + 0x30)
+#define WMDIOCTL_RESETINTRCOUNT     (WMDIOCTL_RESERVEDBASE + 0x40)
+#define WMDIOCTL_INTERRUPTDSP       (WMDIOCTL_RESERVEDBASE + 0x50)
+#define WMDIOCTL_SETMMUCONFIG       (WMDIOCTL_RESERVEDBASE + 0x60)   /* DMMU */
+#define WMDIOCTL_PWRCONTROL         (WMDIOCTL_RESERVEDBASE + 0x70)   /* PWR */
+
+/* attention, modifiers:
+ * Some of these control enumerations are made visible to user for power
+ * control, so any changes to this list, should also be updated in the user
+ * header file 'dbdefs.h' ***/
+/* These ioctls are reserved for PWR power commands for the DSP */
+#define WMDIOCTL_DEEPSLEEP          (WMDIOCTL_PWRCONTROL + 0x0)
+#define WMDIOCTL_EMERGENCYSLEEP     (WMDIOCTL_PWRCONTROL + 0x1)
+#define WMDIOCTL_WAKEUP             (WMDIOCTL_PWRCONTROL + 0x2)
+#define WMDIOCTL_PWRENABLE          (WMDIOCTL_PWRCONTROL + 0x3)
+#define WMDIOCTL_PWRDISABLE         (WMDIOCTL_PWRCONTROL + 0x4)
+#define WMDIOCTL_CLK_CTRL		    (WMDIOCTL_PWRCONTROL + 0x7)
+#define WMDIOCTL_PWR_HIBERNATE (WMDIOCTL_PWRCONTROL + 0x8) /*DSP Initiated
+							    * Hibernate*/
+#define WMDIOCTL_PRESCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0x9)
+#define WMDIOCTL_POSTSCALE_NOTIFY (WMDIOCTL_PWRCONTROL + 0xA)
+#define WMDIOCTL_CONSTRAINT_REQUEST (WMDIOCTL_PWRCONTROL + 0xB)
+
+/* Number of actual DSP-MMU TLB entrries */
+#define WMDIOCTL_NUMOFMMUTLB        32
+
+struct WMDIOCTL_EXTPROC {
+	u32 ulDspVa;		/* DSP virtual address */
+	u32 ulGppPa;		/* GPP physical address */
+	/* GPP virtual address. __va does not work for ioremapped addresses */
+	u32 ulGppVa;
+	u32 ulSize;		/* Size of the mapped memory in bytes */
+	enum HW_Endianism_t endianism;
+	enum HW_MMUMixedSize_t mixedMode;
+	enum HW_ElementSize_t elemSize;
+};
+
+#endif				/* WMDIOCTL_ */
+
diff --git a/arch/arm/plat-omap/include/dspbridge/wmdmsg.h b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
new file mode 100644
index 0000000..3b50e38
--- /dev/null
+++ b/arch/arm/plat-omap/include/dspbridge/wmdmsg.h
@@ -0,0 +1,57 @@
+/*
+ * wmdmsg.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Declares the upper edge message class library functions required by
+ * all WMD / WCD driver interface tables.  These functions are
+ * implemented by every class of WMD channel library.
+ *
+ * Notes:
+ *   Function comment headers reside in wmd.h.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef WMDMSG_
+#define WMDMSG_
+
+#include <dspbridge/msgdefs.h>
+
+	extern DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+					 struct DEV_OBJECT *hDevObject,
+					 MSG_ONEXIT msgCallback);
+
+	extern DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
+					      OUT struct MSG_QUEUE **phMsgQueue,
+					      u32 dwId, u32 uMaxMsgs,
+					      HANDLE h);
+
+	extern void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr);
+
+	extern void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue);
+
+	extern DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
+				      struct DSP_MSG *pMsg, u32 uTimeout);
+
+	extern DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
+				      IN CONST struct DSP_MSG *pMsg,
+				      u32 uTimeout);
+
+	extern DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue,
+						 u32 uEventMask,
+						 u32 uNotifyType,
+						 struct DSP_NOTIFICATION
+						 *hNotification);
+
+	extern void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId);
+
+#endif				/* WMDMSG_ */
diff --git a/drivers/dsp/bridge/Kconfig b/drivers/dsp/bridge/Kconfig
new file mode 100644
index 0000000..e494f02
--- /dev/null
+++ b/drivers/dsp/bridge/Kconfig
@@ -0,0 +1,47 @@
+#
+# DSP Bridge Driver Support
+#
+
+menuconfig MPU_BRIDGE
+	tristate "DSP Bridge driver"
+	default n
+	help
+	  DSP/BIOS Bridge is designed for platforms that contain a GPP and
+	  one or more attached DSPs.  The GPP is considered the master or
+	  "host" processor, and the attached DSPs are processing resources
+	  that can be utilized by applications and drivers running on the GPP.
+
+config BRIDGE_DVFS
+	bool "Enable Bridge Dynamic Voltage and Frequency Scaling (DVFS)"
+	depends on MPU_BRIDGE && OMAP_PM_SRF
+	default n
+	help
+	  DVFS allows DSP Bridge to initiate the operating point change to
+	  scale the chip voltage and frequency in order to match the
+	  performance and power consumption to the current processing
+	  requirements.
+
+config BRIDGE_MEMPOOL_SIZE
+	hex "Physical memory pool size (Byte)"
+	depends on MPU_BRIDGE
+	default 0x600000
+	help
+	  Allocate specified size of memory at booting time to avoid allocation
+	  failure under heavy memory fragmentation after some use time.
+
+config BRIDGE_DEBUG
+	bool "DSP Bridge Debug Support"
+	depends on MPU_BRIDGE
+	help
+	  Say Y to enable Bridge debugging capabilities
+
+comment "Bridge Notifications"
+	depends on MPU_BRIDGE
+
+config BRIDGE_NTFY_PWRERR
+	bool "Notify DSP Power Error"
+	depends on MPU_BRIDGE
+	help
+	  Enable notifications to registered clients on the event of power errror
+	  trying to suspend bridge driver. Say Y, to signal this event as a fatal
+	  error, this will require a bridge restart to recover.
diff --git a/drivers/dsp/bridge/Makefile b/drivers/dsp/bridge/Makefile
new file mode 100644
index 0000000..11f48cb
--- /dev/null
+++ b/drivers/dsp/bridge/Makefile
@@ -0,0 +1,34 @@
+obj-$(CONFIG_MPU_BRIDGE)	+= bridgedriver.o
+
+libgen = gen/gb.o gen/gs.o gen/gh.o gen/uuidutil.o
+libservices = services/mem.o services/sync.o \
+		services/clk.o services/cfg.o services/reg.o \
+               services/regsup.o services/ntfy.o \
+		services/services.o
+libwmd = wmd/chnl_sm.o wmd/msg_sm.o wmd/io_sm.o wmd/tiomap3430.o \
+		wmd/tiomap3430_pwr.o wmd/tiomap_sm.o wmd/tiomap_io.o \
+		wmd/mmu_fault.o wmd/ue_deh.o
+libpmgr = pmgr/chnl.o pmgr/io.o pmgr/msg.o pmgr/cod.o pmgr/dev.o pmgr/wcd.o \
+		pmgr/dmm.o pmgr/cmm.o pmgr/dbll.o
+librmgr = rmgr/dbdcd.o rmgr/disp.o rmgr/drv.o rmgr/mgr.o rmgr/node.o \
+		rmgr/proc.o rmgr/pwr.o rmgr/rmm.o rmgr/strm.o rmgr/dspdrv.o \
+		rmgr/nldr.o rmgr/drv_interface.o
+libdload = dynload/cload.o dynload/getsection.o dynload/reloc.o \
+		 dynload/tramp.o
+libhw = hw/hw_prcm.o hw/hw_dspssC64P.o hw/hw_mmu.o hw/hw_mbox.o
+
+bridgedriver-objs = $(libgen) $(libservices) $(libwmd) $(libpmgr) $(librmgr) \
+			$(libdload) $(libhw)
+
+#Machine dependent
+ccflags-y += -D_TI_ -D_DB_TIOMAP -DTMS32060 \
+		-DTICFG_PROC_VER -DTICFG_EVM_TYPE -DCHNL_SMCLASS \
+		-DCHNL_MESSAGES -DUSE_LEVEL_1_MACROS
+
+#Header files
+ccflags-y += -Idrivers/dsp/bridge/services
+ccflags-y += -Idrivers/dsp/bridge/wmd
+ccflags-y += -Idrivers/dsp/bridge/pmgr
+ccflags-y += -Idrivers/dsp/bridge/rmgr
+ccflags-y += -Idrivers/dsp/bridge/hw
+ccflags-y += -Iarch/arm
diff --git a/drivers/dsp/bridge/dynload/cload.c b/drivers/dsp/bridge/dynload/cload.c
new file mode 100644
index 0000000..505fcdf
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/cload.c
@@ -0,0 +1,1925 @@
+/*
+ * cload.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "header.h"
+
+#include "module_list.h"
+#define LINKER_MODULES_HEADER ("_" MODULES_HEADER)
+
+/*
+ * we use the fact that DOFF section records are shaped just like
+ * LDR_SECTION_INFO to reduce our section storage usage.  This macro marks
+ * the places where that assumption is made
+ */
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+
+/*
+ * forward references
+ */
+static void dload_symbols(struct dload_state *dlthis);
+static void dload_data(struct dload_state *dlthis);
+static void allocate_sections(struct dload_state *dlthis);
+static void string_table_free(struct dload_state *dlthis);
+static void symbol_table_free(struct dload_state *dlthis);
+static void section_table_free(struct dload_state *dlthis);
+static void init_module_handle(struct dload_state *dlthis);
+#if BITS_PER_AU > BITS_PER_BYTE
+static char *unpack_name(struct dload_state *dlthis, u32 soffset);
+#endif
+
+static const char CINITNAME[] = { ".cinit" };
+static const char LOADER_DLLVIEW_ROOT[] = { "?DLModules?" };
+
+/*
+ * Error strings
+ */
+static const char E_READSTRM[] = { "Error reading %s from input stream" };
+static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
+static const char E_TGTALLOC[] =
+    { "Target memory allocate failed, section %s size " FMT_UI32 };
+static const char E_INITFAIL[] = { "%s to target address " FMT_UI32 " failed" };
+static const char E_DLVWRITE[] = { "Write to DLLview list failed" };
+static const char E_ICONNECT[] = { "Connect call to init interface failed" };
+static const char E_CHECKSUM[] = { "Checksum failed on %s" };
+
+/*************************************************************************
+ * Procedure dload_error
+ *
+ * Parameters:
+ *	errtxt	description of the error, printf style
+ *	...		additional information
+ *
+ * Effect:
+ *	Reports or records the error as appropriate.
+ ************************************************************************/
+void dload_error(struct dload_state *dlthis, const char *errtxt, ...)
+{
+	va_list args;
+
+	va_start(args, errtxt);
+	dlthis->mysym->Error_Report(dlthis->mysym, errtxt, args);
+	va_end(args);
+	dlthis->dload_errcount += 1;
+
+}				/* dload_error */
+
+#define DL_ERROR(zza, zzb) dload_error(dlthis, zza, zzb)
+
+/*************************************************************************
+ * Procedure dload_syms_error
+ *
+ * Parameters:
+ *	errtxt	description of the error, printf style
+ *	...		additional information
+ *
+ * Effect:
+ *	Reports or records the error as appropriate.
+ ************************************************************************/
+void dload_syms_error(struct Dynamic_Loader_Sym *syms, const char *errtxt, ...)
+{
+	va_list args;
+
+	va_start(args, errtxt);
+	syms->Error_Report(syms, errtxt, args);
+	va_end(args);
+}
+
+/*************************************************************************
+ * Procedure Dynamic_Load_Module
+ *
+ * Parameters:
+ *	module	The input stream that supplies the module image
+ *	syms	Host-side symbol table and malloc/free functions
+ *	alloc	Target-side memory allocation
+ *	init	Target-side memory initialization
+ *	options	Option flags DLOAD_*
+ *	mhandle	A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *	The module image is read using *module.  Target storage for the new
+ *	image is
+ * obtained from *alloc.  Symbols defined and referenced by the module are
+ * managed using *syms.  The image is then relocated and references
+ *	resolved as necessary, and the resulting executable bits are placed
+ *	into target memory using *init.
+ *
+ * Returns:
+ *	On a successful load, a module handle is placed in *mhandle,
+ *	and zero is returned.  On error, the number of errors detected is
+ *	returned.  Individual errors are reported during the load process
+ *	using syms->Error_Report().
+ ***********************************************************************/
+int Dynamic_Load_Module(struct Dynamic_Loader_Stream *module,
+			struct Dynamic_Loader_Sym *syms ,
+			struct Dynamic_Loader_Allocate *alloc,
+			struct Dynamic_Loader_Initialize *init,
+			unsigned options, DLOAD_mhandle *mhandle)
+{
+	register unsigned *dp, sz;
+	struct dload_state dl_state;	/* internal state for this call */
+
+	/* blast our internal state */
+	dp = (unsigned *)&dl_state;
+	for (sz = sizeof(dl_state) / sizeof(unsigned); sz > 0; sz -= 1)
+		*dp++ = 0;
+
+	/* Enable _only_ BSS initialization if enabled by user */
+	if ((options & DLOAD_INITBSS) == DLOAD_INITBSS)
+		dl_state.myoptions = DLOAD_INITBSS;
+
+	/* Check that mandatory arguments are present */
+	if (!module || !syms) {
+		dload_error(&dl_state, "Required parameter is NULL");
+	} else {
+		dl_state.strm = module;
+		dl_state.mysym = syms;
+		dload_headers(&dl_state);
+		if (!dl_state.dload_errcount)
+			dload_strings(&dl_state, false);
+		if (!dl_state.dload_errcount)
+			dload_sections(&dl_state);
+
+		if (init && !dl_state.dload_errcount) {
+			if (init->connect(init)) {
+				dl_state.myio = init;
+				dl_state.myalloc = alloc;
+				/* do now, before reducing symbols */
+				allocate_sections(&dl_state);
+			} else
+				dload_error(&dl_state, E_ICONNECT);
+		}
+
+		if (!dl_state.dload_errcount) {
+			/* fix up entry point address */
+			unsigned sref = dl_state.dfile_hdr.df_entry_secn - 1;
+			if (sref < dl_state.allocated_secn_count)
+				dl_state.dfile_hdr.df_entrypt +=
+				    dl_state.ldr_sections[sref].run_addr;
+
+			dload_symbols(&dl_state);
+		}
+
+		if (init && !dl_state.dload_errcount)
+			dload_data(&dl_state);
+
+		init_module_handle(&dl_state);
+
+		/* dl_state.myio is init or 0 at this point. */
+		if (dl_state.myio) {
+			if ((!dl_state.dload_errcount) &&
+			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
+			    (!init->execute(init,
+					    dl_state.dfile_hdr.df_entrypt)))
+				dload_error(&dl_state,
+					    "Init->Execute Failed");
+			init->release(init);
+		}
+
+		symbol_table_free(&dl_state);
+		section_table_free(&dl_state);
+		string_table_free(&dl_state);
+		dload_tramp_cleanup(&dl_state);
+
+
+		if (dl_state.dload_errcount) {
+			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
+					     init);
+			dl_state.myhandle = NULL;
+		}
+	}
+
+	if (mhandle)
+		*mhandle = dl_state.myhandle;	/* give back the handle */
+
+	return dl_state.dload_errcount;
+}				/* DLOAD_File */
+
+/*************************************************************************
+ * Procedure Dynamic_Open_Module
+ *
+ * Parameters:
+ *      module  The input stream that supplies the module image
+ *      syms    Host-side symbol table and malloc/free functions
+ *      alloc   Target-side memory allocation
+ *      init    Target-side memory initialization
+ *      options Option flags DLOAD_*
+ *      mhandle A module handle for use with Dynamic_Unload
+ *
+ * Effect:
+ *      The module image is read using *module.  Target storage for the new
+ *      image is
+ * 	obtained from *alloc.  Symbols defined and referenced by the module are
+ * 	managed using *syms.  The image is then relocated and references
+ *      resolved as necessary, and the resulting executable bits are placed
+ *      into target memory using *init.
+ *
+ * Returns:
+ *      On a successful load, a module handle is placed in *mhandle,
+ *      and zero is returned.  On error, the number of errors detected is
+ *      returned.  Individual errors are reported during the load process
+ *      using syms->Error_Report().
+ ***********************************************************************/
+int
+Dynamic_Open_Module(struct Dynamic_Loader_Stream *module,
+		    struct Dynamic_Loader_Sym *syms,
+		    struct Dynamic_Loader_Allocate *alloc,
+		    struct Dynamic_Loader_Initialize *init,
+		    unsigned options, DLOAD_mhandle *mhandle)
+{
+	register unsigned *dp, sz;
+	struct dload_state dl_state;   /* internal state for this call */
+
+	/* blast our internal state */
+	dp = (unsigned *)&dl_state;
+	for (sz = sizeof(dl_state) / sizeof(unsigned); sz > 0; sz -= 1)
+		*dp++ = 0;
+
+	/* Enable _only_ BSS initialization if enabled by user */
+	if ((options & DLOAD_INITBSS) == DLOAD_INITBSS)
+		dl_state.myoptions = DLOAD_INITBSS;
+
+	/* Check that mandatory arguments are present */
+	if (!module || !syms) {
+		dload_error(&dl_state, "Required parameter is NULL");
+	} else {
+		dl_state.strm = module;
+		dl_state.mysym = syms;
+		dload_headers(&dl_state);
+		if (!dl_state.dload_errcount)
+			dload_strings(&dl_state, false);
+		if (!dl_state.dload_errcount)
+			dload_sections(&dl_state);
+
+		if (init && !dl_state.dload_errcount) {
+			if (init->connect(init)) {
+				dl_state.myio = init;
+				dl_state.myalloc = alloc;
+				/* do now, before reducing symbols */
+				allocate_sections(&dl_state);
+			} else
+				dload_error(&dl_state, E_ICONNECT);
+		}
+
+		if (!dl_state.dload_errcount) {
+			/* fix up entry point address */
+			unsigned sref = dl_state.dfile_hdr.df_entry_secn - 1;
+			if (sref < dl_state.allocated_secn_count)
+				dl_state.dfile_hdr.df_entrypt +=
+				    dl_state.ldr_sections[sref].run_addr;
+
+			dload_symbols(&dl_state);
+		}
+
+		init_module_handle(&dl_state);
+
+		/* dl_state.myio is either 0 or init at this point. */
+		if (dl_state.myio) {
+			if ((!dl_state.dload_errcount) &&
+			    (dl_state.dfile_hdr.df_entry_secn != DN_UNDEF) &&
+			    (!init->execute(init,
+					    dl_state.dfile_hdr.df_entrypt)))
+				dload_error(&dl_state,
+					    "Init->Execute Failed");
+			init->release(init);
+		}
+
+		symbol_table_free(&dl_state);
+		section_table_free(&dl_state);
+		string_table_free(&dl_state);
+
+		if (dl_state.dload_errcount) {
+			Dynamic_Unload_Module(dl_state.myhandle, syms, alloc,
+					      init);
+			dl_state.myhandle = NULL;
+		}
+	}
+
+	if (mhandle)
+		*mhandle = dl_state.myhandle;   /* give back the handle */
+
+	return dl_state.dload_errcount;
+}			       /* DLOAD_File */
+
+/*************************************************************************
+ * Procedure dload_headers
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Loads the DOFF header and verify record.  Deals with any byte-order
+ * issues and checks them for validity.
+ ************************************************************************/
+#define COMBINED_HEADER_SIZE (sizeof(struct doff_filehdr_t)+ \
+			     sizeof(struct doff_verify_rec_t))
+
+void dload_headers(struct dload_state *dlthis)
+{
+	u32 map;
+
+	/* Read the header and the verify record as one.  If we don't get it
+	   all, we're done */
+	if (dlthis->strm->read_buffer(dlthis->strm, &dlthis->dfile_hdr,
+	    COMBINED_HEADER_SIZE) != COMBINED_HEADER_SIZE) {
+		DL_ERROR(E_READSTRM, "File Headers");
+		return;
+	}
+	/*
+	 * Verify that we have the byte order of the file correct.
+	 * If not, must fix it before we can continue
+	 */
+	map = REORDER_MAP(dlthis->dfile_hdr.df_byte_reshuffle);
+	if (map != REORDER_MAP(BYTE_RESHUFFLE_VALUE)) {
+		/* input is either byte-shuffled or bad */
+		if ((map & 0xFCFCFCFC) == 0) {	/* no obviously bogus bits */
+			dload_reorder(&dlthis->dfile_hdr, COMBINED_HEADER_SIZE,
+				      map);
+		}
+		if (dlthis->dfile_hdr.df_byte_reshuffle !=
+		    BYTE_RESHUFFLE_VALUE) {
+			/* didn't fix the problem, the byte swap map is bad */
+			dload_error(dlthis,
+				    "Bad byte swap map " FMT_UI32 " in header",
+				    dlthis->dfile_hdr.df_byte_reshuffle);
+			return;
+		}
+		dlthis->reorder_map = map;	/* keep map for future use */
+	}
+
+	/*
+	 * Verify checksum of header and verify record
+	 */
+	if (~dload_checksum(&dlthis->dfile_hdr,
+	    sizeof(struct doff_filehdr_t)) ||
+	    ~dload_checksum(&dlthis->verify,
+	    sizeof(struct doff_verify_rec_t))) {
+		DL_ERROR(E_CHECKSUM, "header or verify record");
+		return;
+	}
+#if HOST_ENDIANNESS
+	dlthis->dfile_hdr.df_byte_reshuffle = map;	/* put back for later */
+#endif
+
+	/* Check for valid target ID */
+	if ((dlthis->dfile_hdr.df_target_id != TARGET_ID) &&
+	  -(dlthis->dfile_hdr.df_target_id != TMS470_ID)) {
+		dload_error(dlthis, "Bad target ID 0x%x and TARGET_ID 0x%x",
+			    dlthis->dfile_hdr.df_target_id, TARGET_ID);
+		return;
+	}
+	/* Check for valid file format */
+	if ((dlthis->dfile_hdr.df_doff_version != DOFF0)) {
+		dload_error(dlthis, "Bad DOFF version 0x%x",
+			    dlthis->dfile_hdr.df_doff_version);
+		return;
+	}
+
+	/*
+	 * Apply reasonableness checks to count fields
+	 */
+	if (dlthis->dfile_hdr.df_strtab_size > MAX_REASONABLE_STRINGTAB) {
+		dload_error(dlthis, "Excessive string table size " FMT_UI32,
+			    dlthis->dfile_hdr.df_strtab_size);
+		return;
+	}
+	if (dlthis->dfile_hdr.df_no_scns > MAX_REASONABLE_SECTIONS) {
+		dload_error(dlthis, "Excessive section count 0x%x",
+			    dlthis->dfile_hdr.df_no_scns);
+		return;
+	}
+#ifndef TARGET_ENDIANNESS
+	/*
+	 * Check that endianness does not disagree with explicit specification
+	 */
+	if ((dlthis->dfile_hdr.df_flags >> ALIGN_COFF_ENDIANNESS) &
+	    dlthis->myoptions & ENDIANNESS_MASK) {
+		dload_error(dlthis,
+			    "Input endianness disagrees with specified option");
+		return;
+	}
+	dlthis->big_e_target = dlthis->dfile_hdr.df_flags & DF_BIG;
+#endif
+
+}				/* dload_headers */
+
+/*	COFF Section Processing
+ *
+ *	COFF sections are read in and retained intact.  Each record is embedded
+ * 	in a new structure that records the updated load and
+ * 	run addresses of the section  */
+
+static const char SECN_ERRID[] = { "section" };
+
+/*************************************************************************
+ * Procedure dload_sections
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Loads the section records into an internal table.
+ ************************************************************************/
+void
+dload_sections(struct dload_state *dlthis)
+{
+	s16 siz;
+	struct doff_scnhdr_t *shp;
+	unsigned nsecs = dlthis->dfile_hdr.df_no_scns;
+
+	/* allocate space for the DOFF section records */
+	siz = nsecs * sizeof(struct doff_scnhdr_t);
+	shp = (struct doff_scnhdr_t *)dlthis->mysym->Allocate(dlthis->mysym,
+	       siz);
+	if (!shp) {		/* not enough storage */
+		DL_ERROR(E_ALLOC, siz);
+		return;
+	}
+	dlthis->sect_hdrs = shp;
+
+	/* read in the section records */
+	if (dlthis->strm->read_buffer(dlthis->strm, shp, siz) != siz) {
+		DL_ERROR(E_READSTRM, SECN_ERRID);
+		return;
+	}
+
+	/* if we need to fix up byte order, do it now */
+	if (dlthis->reorder_map)
+		dload_reorder(shp, siz, dlthis->reorder_map);
+
+	/* check for validity */
+	if (~dload_checksum(dlthis->sect_hdrs, siz) !=
+	    dlthis->verify.dv_scn_rec_checksum) {
+		DL_ERROR(E_CHECKSUM, SECN_ERRID);
+		return;
+	}
+
+}				/* dload_sections */
+
+/*****************************************************************************
+ * Procedure allocate_sections
+ *
+ * Parameters:
+ *	alloc	target memory allocator class
+ *
+ * Effect:
+ *	Assigns new (target) addresses for sections
+ *****************************************************************************/
+static void allocate_sections(struct dload_state *dlthis)
+{
+	u16 curr_sect, nsecs, siz;
+	struct doff_scnhdr_t *shp;
+	struct LDR_SECTION_INFO *asecs;
+	struct my_handle *hndl;
+	nsecs = dlthis->dfile_hdr.df_no_scns;
+	if (!nsecs)
+		return;
+	if ((dlthis->myalloc == NULL) &&
+	   (dlthis->dfile_hdr.df_target_scns > 0)) {
+		DL_ERROR("Arg 3 (alloc) required but NULL", 0);
+		return;
+	}
+	/*
+	 * allocate space for the module handle, which we will keep for unload
+	 * purposes include an additional section store for an auto-generated
+	 * trampoline section in case we need it.
+	 */
+	siz = (dlthis->dfile_hdr.df_target_scns + 1) *
+		sizeof(struct LDR_SECTION_INFO) + MY_HANDLE_SIZE;
+
+	hndl = (struct my_handle *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	if (!hndl) {		/* not enough storage */
+		DL_ERROR(E_ALLOC, siz);
+		return;
+	}
+	/* initialize the handle header */
+	hndl->dm.hnext = hndl->dm.hprev = hndl;	/* circular list */
+	hndl->dm.hroot = NULL;
+	hndl->dm.dbthis = 0;
+	dlthis->myhandle = hndl;	/* save away for return */
+	/* pointer to the section list of allocated sections */
+	dlthis->ldr_sections = asecs = hndl->secns;
+	/* * Insert names into all sections, make copies of
+	   the sections we allocate */
+	shp = dlthis->sect_hdrs;
+	for (curr_sect = 0; curr_sect < nsecs; curr_sect++) {
+		u32 soffset = shp->ds_offset;
+#if BITS_PER_AU <= BITS_PER_BYTE
+		/* attempt to insert the name of this section */
+		if (soffset < dlthis->dfile_hdr.df_strtab_size)
+			DOFFSEC_IS_LDRSEC(shp)->name = dlthis->str_head +
+							       soffset;
+		else {
+			dload_error(dlthis, "Bad name offset in section %d",
+				    curr_sect);
+			DOFFSEC_IS_LDRSEC(shp)->name = NULL;
+		}
+#endif
+		/* allocate target storage for sections that require it */
+		if (DS_NEEDS_ALLOCATION(shp)) {
+			*asecs = *DOFFSEC_IS_LDRSEC(shp);
+			asecs->context = 0;	/* zero the context field */
+#if BITS_PER_AU > BITS_PER_BYTE
+			asecs->name = unpack_name(dlthis, soffset);
+			dlthis->debug_string_size = soffset + dlthis->temp_len;
+#else
+			dlthis->debug_string_size = soffset;
+#endif
+		if (dlthis->myalloc != NULL) {
+			if (!dlthis->myalloc->Allocate(dlthis->myalloc, asecs,
+				     DS_ALIGNMENT(asecs->type))) {
+				dload_error(dlthis, E_TGTALLOC, asecs->name,
+					    asecs->size);
+				return;
+			}
+			}
+			/* keep address deltas in original section table */
+			shp->ds_vaddr = asecs->load_addr - shp->ds_vaddr;
+			shp->ds_paddr = asecs->run_addr - shp->ds_paddr;
+			dlthis->allocated_secn_count += 1;
+		}		/* allocate target storage */
+		shp += 1;
+		asecs += 1;
+	}
+#if BITS_PER_AU <= BITS_PER_BYTE
+	dlthis->debug_string_size +=
+	    strlen(dlthis->str_head + dlthis->debug_string_size) + 1;
+#endif
+}				/* allocate sections */
+
+/*************************************************************************
+ * Procedure section_table_free
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Frees any state used by the symbol table.
+ *
+ * WARNING:
+ *	This routine is not allowed to declare errors!
+ ************************************************************************/
+static void section_table_free(struct dload_state *dlthis)
+{
+	struct doff_scnhdr_t *shp;
+
+	shp = dlthis->sect_hdrs;
+	if (shp)
+		dlthis->mysym->Deallocate(dlthis->mysym, shp);
+
+}				/* section_table_free */
+
+/*************************************************************************
+ * Procedure dload_strings
+ *
+ * Parameters:
+ *  sec_names_only   If true only read in the "section names"
+ *		     portion of the string table
+ *
+ * Effect:
+ *	Loads the DOFF string table into memory. DOFF keeps all strings in a
+ * big unsorted array.  We just read that array into memory in bulk.
+ ************************************************************************/
+static const char S_STRINGTBL[] = { "string table" };
+void dload_strings(struct dload_state *dlthis, bool sec_names_only)
+{
+	u32 ssiz;
+	char *strbuf;
+
+	if (sec_names_only) {
+		ssiz = BYTE_TO_HOST(DOFF_ALIGN
+				   (dlthis->dfile_hdr.df_scn_name_size));
+	} else {
+		ssiz = BYTE_TO_HOST(DOFF_ALIGN
+				   (dlthis->dfile_hdr.df_strtab_size));
+	}
+	if (ssiz == 0)
+		return;
+
+	/* get some memory for the string table */
+#if BITS_PER_AU > BITS_PER_BYTE
+	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz +
+					     dlthis->dfile_hdr.df_max_str_len);
+#else
+	strbuf = (char *)dlthis->mysym->Allocate(dlthis->mysym, ssiz);
+#endif
+	if (strbuf == NULL) {
+		DL_ERROR(E_ALLOC, ssiz);
+		return;
+	}
+	dlthis->str_head = strbuf;
+#if BITS_PER_AU > BITS_PER_BYTE
+	dlthis->str_temp = strbuf + ssiz;
+#endif
+	/* read in the strings and verify them */
+	if ((unsigned)(dlthis->strm->read_buffer(dlthis->strm, strbuf,
+	    ssiz)) != ssiz) {
+		DL_ERROR(E_READSTRM, S_STRINGTBL);
+	}
+	/* if we need to fix up byte order, do it now */
+#ifndef _BIG_ENDIAN
+	if (dlthis->reorder_map)
+		dload_reorder(strbuf, ssiz, dlthis->reorder_map);
+
+	if ((!sec_names_only) && (~dload_checksum(strbuf, ssiz) !=
+	     dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+	}
+#else
+	if (dlthis->dfile_hdr.df_byte_reshuffle !=
+	    HOST_BYTE_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
+		/* put strings in big-endian order, not in PC order */
+		dload_reorder(strbuf, ssiz, HOST_BYTE_ORDER(dlthis->dfile_hdr.
+					      df_byte_reshuffle));
+	}
+	if ((!sec_names_only) && (~dload_reverse_checksum(strbuf, ssiz) !=
+	     dlthis->verify.dv_str_tab_checksum)) {
+		DL_ERROR(E_CHECKSUM, S_STRINGTBL);
+	}
+#endif
+}				/* dload_strings */
+
+/*************************************************************************
+ * Procedure string_table_free
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Frees any state used by the string table.
+ *
+ * WARNING:
+ *	This routine is not allowed to declare errors!
+ *************************************************************************/
+static void string_table_free(struct dload_state *dlthis)
+{
+	if (dlthis->str_head)
+		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+
+}				/* string_table_free */
+
+/*
+ * Symbol Table Maintenance Functions
+ *
+ * COFF symbols are read by dload_symbols(), which is called after
+ * sections have been allocated.  Symbols which might be used in
+ * relocation (ie, not debug info) are retained in an internal temporary
+ * compressed table (type Local_Symbol). A particular symbol is recovered
+ * by index by calling dload_find_symbol().  dload_find_symbol
+ * reconstructs a more explicit representation (type SLOTVEC) which is
+ * used by reloc.c
+ */
+/* real size of debug header */
+#define DBG_HDR_SIZE (sizeof(struct dll_module) - sizeof(struct dll_sect))
+
+static const char SYM_ERRID[] = { "symbol" };
+
+/**************************************************************************
+ * Procedure dload_symbols
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Reads in symbols and retains ones that might be needed for relocation
+ * purposes.
+ ************************************************************************/
+/* size of symbol buffer no bigger than target data buffer, to limit stack
+ * usage*/
+#define MY_SYM_BUF_SIZ (BYTE_TO_HOST(IMAGE_PACKET_SIZE)/\
+			sizeof(struct doff_syment_t))
+
+static void dload_symbols(struct dload_state *dlthis)
+{
+	u32 s_count, siz, dsiz, symbols_left;
+	u32 checks;
+	struct Local_Symbol *sp;
+	struct dynload_symbol *symp;
+	struct dynload_symbol *newsym;
+
+	s_count = dlthis->dfile_hdr.df_no_syms;
+	if (s_count == 0)
+		return;
+
+	/*
+	 * We keep a local symbol table for all of the symbols in the input.
+	 * This table contains only section & value info, as we do not have
+	 * to do any name processing for locals.  We reuse this storage
+	 * as a temporary for .dllview record construction.
+	 * Allocate storage for the whole table.  Add 1 to the section count
+	 * in case a trampoline section is auto-generated as well as the
+	 * size of the trampoline section name so DLLView doens't get lost.
+	 */
+
+	siz = s_count * sizeof(struct Local_Symbol);
+	dsiz = DBG_HDR_SIZE +
+		(sizeof(struct dll_sect) * dlthis->allocated_secn_count) +
+	    BYTE_TO_HOST_ROUND(dlthis->debug_string_size + 1);
+	if (dsiz > siz)
+		siz = dsiz;	/* larger of symbols and .dllview temp */
+	sp = (struct Local_Symbol *)dlthis->mysym->Allocate(dlthis->mysym, siz);
+	if (!sp) {
+		DL_ERROR(E_ALLOC, siz);
+		return;
+	}
+	dlthis->local_symtab = sp;
+	/* Read the symbols in the input, store them in the table, and post any
+	 * globals to the global symbol table.  In the process, externals
+	   become defined from the global symbol table */
+	checks = dlthis->verify.dv_sym_tab_checksum;
+	symbols_left = s_count;
+	do {			/* read all symbols */
+		char *sname;
+		u32 val;
+		s32 delta;
+		struct doff_syment_t *input_sym;
+		unsigned syms_in_buf;
+		struct doff_syment_t my_sym_buf[MY_SYM_BUF_SIZ];
+		input_sym = my_sym_buf;
+		syms_in_buf = symbols_left > MY_SYM_BUF_SIZ ?
+					     MY_SYM_BUF_SIZ : symbols_left;
+		siz = syms_in_buf * sizeof(struct doff_syment_t);
+		if (dlthis->strm->read_buffer(dlthis->strm, input_sym, siz) !=
+					      siz) {
+			DL_ERROR(E_READSTRM, SYM_ERRID);
+			return;
+		}
+		if (dlthis->reorder_map)
+			dload_reorder(input_sym, siz, dlthis->reorder_map);
+
+		checks += dload_checksum(input_sym, siz);
+		do {		/* process symbols in buffer */
+			symbols_left -= 1;
+			/* attempt to derive the name of this symbol */
+			sname = NULL;
+			if (input_sym->dn_offset > 0) {
+#if BITS_PER_AU <= BITS_PER_BYTE
+				if ((u32) input_sym->dn_offset <
+				    dlthis->dfile_hdr.df_strtab_size)
+					sname = dlthis->str_head +
+					     BYTE_TO_HOST(input_sym->dn_offset);
+				else
+					dload_error(dlthis,
+						 "Bad name offset in symbol %d",
+						 symbols_left);
+#else
+				sname = unpack_name(dlthis,
+						   input_sym->dn_offset);
+#endif
+			}
+			val = input_sym->dn_value;
+			delta = 0;
+			sp->sclass = input_sym->dn_sclass;
+			sp->secnn = input_sym->dn_scnum;
+			/* if this is an undefined symbol,
+			 * define it (or fail) now	  */
+			if (sp->secnn == DN_UNDEF) {
+					/* pointless for static undefined */
+				if (input_sym->dn_sclass != DN_EXT)
+					goto loop_cont;
+
+				/* try to define symbol from previously
+				 * loaded images			  */
+				symp = dlthis->mysym->Find_Matching_Symbol
+						      (dlthis->mysym, sname);
+				if (!symp) {
+					DL_ERROR
+						("Undefined external symbol %s",
+						 sname);
+					goto loop_cont;
+				}
+				val = delta = symp->value;
+#ifdef ENABLE_TRAMP_DEBUG
+				dload_syms_error(dlthis->mysym,
+						"===> ext sym [%s] at %x",
+						sname, val);
+#endif
+
+				goto loop_cont;
+			}
+			/* symbol defined by this module */
+			if (sp->secnn > 0) {   /* symbol references a section */
+				if ((unsigned)sp->secnn <=
+				    dlthis->allocated_secn_count) {
+					/* section was allocated */
+					struct doff_scnhdr_t *srefp =
+							     &dlthis->sect_hdrs
+							     [sp->secnn - 1];
+
+					if (input_sym->dn_sclass ==
+					    DN_STATLAB ||
+					    input_sym->dn_sclass == DN_EXTLAB){
+						/* load */
+						delta = srefp->ds_vaddr;
+					} else {
+						/* run */
+						delta = srefp->ds_paddr;
+					}
+					val += delta;
+				}
+				goto loop_itr;
+			}
+			/* This symbol is an absolute symbol */
+			if (sp->secnn == DN_ABS && ((sp->sclass == DN_EXT) ||
+						   (sp->sclass == DN_EXTLAB))) {
+				symp = dlthis->mysym->Find_Matching_Symbol
+						      (dlthis->mysym, sname);
+				if (!symp)
+					goto loop_itr;
+				/* This absolute symbol is already defined.  */
+				if (symp->value == input_sym->dn_value) {
+					/* If symbol values are equal, continue
+					 * but don't add to the global symbol
+					 * table			     */
+					sp->value = val;
+					sp->delta = delta;
+					sp += 1;
+					input_sym += 1;
+					continue;
+				} else {
+					/* If symbol values are not equal,
+					 * return with redefinition error */
+					DL_ERROR("Absolute symbol %s is "
+					   "defined multiple times with "
+					   "different values", sname);
+					return;
+				}
+			}
+loop_itr:
+			/* if this is a global symbol, post it to the
+			 * global table			       */
+			if (input_sym->dn_sclass == DN_EXT ||
+			    input_sym->dn_sclass == DN_EXTLAB) {
+				/* Keep this global symbol for subsequent
+				 * modules. Don't complain on error, to allow
+				 * symbol API to suppress global symbols */
+				if (!sname)
+					goto loop_cont;
+
+				newsym = dlthis->mysym->Add_To_Symbol_Table
+						    (dlthis->mysym, sname,
+						    (unsigned)dlthis->myhandle);
+				if (newsym)
+					newsym->value = val;
+
+			}	/* global */
+loop_cont:
+			sp->value = val;
+			sp->delta = delta;
+			sp += 1;
+			input_sym += 1;
+		} while ((syms_in_buf -= 1) > 0); /* process sym in buffer */
+	} while (symbols_left > 0);	/* read all symbols */
+	if (~checks)
+		dload_error(dlthis, "Checksum of symbols failed");
+
+}				/* dload_symbols */
+
+/*****************************************************************************
+ * Procedure symbol_table_free
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Frees any state used by the symbol table.
+ *
+ * WARNING:
+ *	This routine is not allowed to declare errors!
+ *****************************************************************************/
+static void symbol_table_free(struct dload_state *dlthis)
+{
+	if (dlthis->local_symtab) {
+		if (dlthis->dload_errcount) {	/* blow off our symbols */
+			dlthis->mysym->Purge_Symbol_Table(dlthis->mysym,
+						   (unsigned)dlthis->myhandle);
+		}
+		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->local_symtab);
+	}
+}				/* symbol_table_free */
+
+/* .cinit Processing
+ *
+ * The dynamic loader does .cinit interpretation.  cload_cinit()
+ * acts as a special write-to-target function, in that it takes relocated
+ * data from the normal data flow, and interprets it as .cinit actions.
+ * Because the normal data flow does not  necessarily process the whole
+ * .cinit section in one buffer, cload_cinit() must be prepared to
+ * interpret the data piecemeal.  A state machine is used for this
+ * purpose.
+ */
+
+/* The following are only for use by reloc.c and things it calls */
+static const struct LDR_SECTION_INFO CINIT_INFO_INIT = { CINITNAME, 0, 0,
+					(LDR_ADDR) -1, 0, DLOAD_BSS, 0 };
+
+/*************************************************************************
+ * Procedure cload_cinit
+ *
+ * Parameters:
+ *	ipacket		Pointer to data packet to be loaded
+ *
+ * Effect:
+ *	Interprets the data in the buffer as .cinit data, and performs the
+ * appropriate initializations.
+ ************************************************************************/
+static void cload_cinit(struct dload_state *dlthis,
+			struct image_packet_t *ipacket)
+{
+#if TDATA_TO_HOST(CINIT_COUNT)*BITS_PER_AU > 16
+	s32 init_count, left;
+#else
+	s16 init_count, left;
+#endif
+	unsigned char *pktp = ipacket->i_bits;
+	unsigned char *pktend =	pktp +
+				BYTE_TO_HOST_ROUND(ipacket->i_packet_size);
+	int temp;
+	LDR_ADDR atmp;
+	struct LDR_SECTION_INFO cinit_info;
+
+	/*  PROCESS ALL THE INITIALIZATION RECORDS IN THE BUFFER.  */
+	while (true) {
+		left = pktend - pktp;
+		switch (dlthis->cinit_state) {
+		case CI_count:	/* count field */
+			if (left < TDATA_TO_HOST(CINIT_COUNT))
+				goto loopexit;
+			temp = dload_unpack(dlthis, (TgtAU_t *)pktp,
+					CINIT_COUNT * TDATA_AU_BITS, 0,
+					ROP_SGN);
+			pktp += TDATA_TO_HOST(CINIT_COUNT);
+			/* negative signifies BSS table, zero means done */
+			if (temp <= 0) {
+				dlthis->cinit_state = CI_done;
+				break;
+			}
+			dlthis->cinit_count = temp;
+			dlthis->cinit_state = CI_address;
+			break;
+#if CINIT_ALIGN < CINIT_ADDRESS
+		case CI_partaddress:
+			pktp -= TDATA_TO_HOST(CINIT_ALIGN);
+			/* back up pointer into space courtesy of caller */
+			*(uint16_t *)pktp = dlthis->cinit_addr;
+			/* stuff in saved bits  !! FALL THRU !! */
+#endif
+		case CI_address:	/* Address field for a copy packet */
+			if (left < TDATA_TO_HOST(CINIT_ADDRESS)) {
+#if CINIT_ALIGN < CINIT_ADDRESS
+				if (left == TDATA_TO_HOST(CINIT_ALIGN)) {
+					/* address broken into halves */
+					dlthis->cinit_addr = *(uint16_t *)pktp;
+					/* remember 1st half */
+					dlthis->cinit_state = CI_partaddress;
+					left = 0;
+				}
+#endif
+				goto loopexit;
+			}
+			atmp = dload_unpack(dlthis, (TgtAU_t *)pktp,
+					CINIT_ADDRESS * TDATA_AU_BITS, 0,
+					ROP_UNS);
+			pktp += TDATA_TO_HOST(CINIT_ADDRESS);
+#if CINIT_PAGE_BITS > 0
+			dlthis->cinit_page = atmp &
+					     ((1 << CINIT_PAGE_BITS) - 1);
+			atmp >>= CINIT_PAGE_BITS;
+#else
+			dlthis->cinit_page = CINIT_DEFAULT_PAGE;
+#endif
+			dlthis->cinit_addr = atmp;
+			dlthis->cinit_state = CI_copy;
+			break;
+		case CI_copy:	/* copy bits to the target */
+			init_count = HOST_TO_TDATA(left);
+			if (init_count > dlthis->cinit_count)
+				init_count = dlthis->cinit_count;
+			if (init_count == 0)
+				goto loopexit;	/* get more bits */
+			cinit_info = CINIT_INFO_INIT;
+			cinit_info.page = dlthis->cinit_page;
+			if (!dlthis->myio->writemem(dlthis->myio, pktp,
+					TDATA_TO_TADDR(dlthis->cinit_addr),
+					&cinit_info,
+					TDATA_TO_HOST(init_count))) {
+				dload_error(dlthis, E_INITFAIL, "write",
+					    dlthis->cinit_addr);
+			}
+			dlthis->cinit_count -= init_count;
+			if (dlthis->cinit_count  <= 0) {
+				dlthis->cinit_state = CI_count;
+				init_count = (init_count + CINIT_ALIGN - 1) &
+					     -CINIT_ALIGN;
+				/* align to next init */
+			}
+			pktp += TDATA_TO_HOST(init_count);
+			dlthis->cinit_addr += init_count;
+			break;
+		case CI_done:	/* no more .cinit to do */
+			return;
+		}		/* switch (cinit_state) */
+	}			/* while */
+
+loopexit:
+	if (left > 0) {
+		dload_error(dlthis, "%d bytes left over in cinit packet", left);
+		dlthis->cinit_state = CI_done;	/* left over bytes are bad */
+	}
+}				/* cload_cinit */
+
+/*	Functions to interface to reloc.c
+ *
+ * reloc.c is the relocation module borrowed from the linker, with
+ * minimal (we hope) changes for our purposes.  cload_sect_data() invokes
+ * this module on a section to relocate and load the image data for that
+ * section.  The actual read and write actions are supplied by the global
+ * routines below.
+ */
+
+/************************************************************************
+ * Procedure relocate_packet
+ *
+ * Parameters:
+ *	ipacket		Pointer to an image packet to relocate
+ *
+ * Effect:
+ *	Performs the required relocations on the packet.  Returns a checksum
+ * of the relocation operations.
+ ************************************************************************/
+#define MY_RELOC_BUF_SIZ 8
+/* careful! exists at the same time as the image buffer*/
+static int relocate_packet(struct dload_state *dlthis,
+				struct image_packet_t *ipacket,
+				u32 *checks, bool *tramps_generated)
+{
+	u32 rnum;
+	*tramps_generated = false;
+
+	rnum = ipacket->i_num_relocs;
+	do {			/* all relocs */
+		unsigned rinbuf;
+		int siz;
+		struct reloc_record_t *rp, rrec[MY_RELOC_BUF_SIZ];
+		rp = rrec;
+		rinbuf = rnum > MY_RELOC_BUF_SIZ ? MY_RELOC_BUF_SIZ : rnum;
+		siz = rinbuf * sizeof(struct reloc_record_t);
+		if (dlthis->strm->read_buffer(dlthis->strm, rp, siz) != siz) {
+			DL_ERROR(E_READSTRM, "relocation");
+			return 0;
+		}
+		/* reorder the bytes if need be */
+		if (dlthis->reorder_map)
+			dload_reorder(rp, siz, dlthis->reorder_map);
+
+		*checks += dload_checksum(rp, siz);
+		do {
+			/* perform the relocation operation */
+			dload_relocate(dlthis, (TgtAU_t *) ipacket->i_bits, rp,
+					tramps_generated, false);
+			rp += 1;
+			rnum -= 1;
+		} while ((rinbuf -= 1) > 0);
+	} while (rnum > 0);	/* all relocs */
+	/* If trampoline(s) were generated, we need to do an update of the
+	 * trampoline copy of the packet since a 2nd phase relo will be done
+	 * later.  */
+	if (*tramps_generated == true) {
+		dload_tramp_pkt_udpate(dlthis,
+				(dlthis->image_secn - dlthis->ldr_sections),
+				dlthis->image_offset, ipacket);
+	}
+
+	return 1;
+}				/* dload_read_reloc */
+
+#define IPH_SIZE (sizeof(struct image_packet_t) - sizeof(u32))
+
+/* VERY dangerous */
+static const char IMAGEPAK[] = { "image packet" };
+
+/*************************************************************************
+ * Procedure dload_data
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Read image data from input file, relocate it, and download it to the
+ *	target.
+ ************************************************************************/
+static void dload_data(struct dload_state *dlthis)
+{
+	u16 curr_sect;
+	struct doff_scnhdr_t *sptr = dlthis->sect_hdrs;
+	struct LDR_SECTION_INFO *lptr = dlthis->ldr_sections;
+#ifdef OPT_ZERO_COPY_LOADER
+	bool bZeroCopy = false;
+#endif
+	u8 *pDest;
+
+	struct {
+		struct image_packet_t ipacket;
+		u8 bufr[BYTE_TO_HOST(IMAGE_PACKET_SIZE)];
+	} ibuf;
+
+	/* Indicates whether CINIT processing has occurred */
+	bool cinit_processed = false;
+
+	/* Loop through the sections and load them one at a time.
+	 */
+	for (curr_sect = 0; curr_sect < dlthis->dfile_hdr.df_no_scns;
+	     curr_sect += 1) {
+		if (DS_NEEDS_DOWNLOAD(sptr)) {
+			s32 nip;
+			LDR_ADDR image_offset = 0;
+			/* set relocation info for this section */
+			if (curr_sect < dlthis->allocated_secn_count)
+				dlthis->delta_runaddr = sptr->ds_paddr;
+			else {
+				lptr = DOFFSEC_IS_LDRSEC(sptr);
+				dlthis->delta_runaddr = 0;
+			}
+			dlthis->image_secn = lptr;
+#if BITS_PER_AU > BITS_PER_BYTE
+			lptr->name = unpack_name(dlthis, sptr->ds_offset);
+#endif
+			nip = sptr->ds_nipacks;
+			while ((nip -= 1) >= 0) {	/* process packets */
+
+				s32 ipsize;
+				u32 checks;
+				bool  tramp_generated = false;
+
+				/* get the fixed header bits */
+				if (dlthis->strm->read_buffer(dlthis->strm,
+				    &ibuf.ipacket, IPH_SIZE) != IPH_SIZE) {
+					DL_ERROR(E_READSTRM, IMAGEPAK);
+					return;
+				}
+				/* reorder the header if need be */
+				if (dlthis->reorder_map) {
+					dload_reorder(&ibuf.ipacket, IPH_SIZE,
+						      dlthis->reorder_map);
+				}
+				/* now read the rest of the packet */
+				ipsize =
+				    BYTE_TO_HOST(DOFF_ALIGN
+						(ibuf.ipacket.i_packet_size));
+				if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
+					DL_ERROR("Bad image packet size %d",
+						ipsize);
+					return;
+				}
+				pDest = ibuf.bufr;
+#ifdef OPT_ZERO_COPY_LOADER
+				bZeroCopy = false;
+				if (DLOAD_SECT_TYPE(sptr) != DLOAD_CINIT) {
+					dlthis->myio->writemem(dlthis->myio,
+						&pDest, lptr->load_addr +
+						image_offset, lptr, 0);
+				bZeroCopy = (pDest != ibuf.bufr);
+				}
+#endif
+		/* End of determination */
+
+				if (dlthis->strm->read_buffer(dlthis->strm,
+				    ibuf.bufr, ipsize) != ipsize) {
+					DL_ERROR(E_READSTRM, IMAGEPAK);
+					return;
+				}
+				ibuf.ipacket.i_bits = pDest;
+
+				/* reorder the bytes if need be */
+#if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)
+				if (dlthis->reorder_map) {
+					dload_reorder(pDest, ipsize,
+						     dlthis->reorder_map);
+				}
+				checks = dload_checksum(pDest, ipsize);
+#else
+				if (dlthis->dfile_hdr.df_byte_reshuffle !=
+				    TARGET_ORDER(REORDER_MAP
+				    (BYTE_RESHUFFLE_VALUE))) {
+					/* put image bytes in big-endian order,
+					 * not PC order */
+					dload_reorder(pDest, ipsize,
+					TARGET_ORDER
+					(dlthis->dfile_hdr.df_byte_reshuffle));
+				}
+#if TARGET_AU_BITS > 8
+				checks = dload_reverse_checksum_16(pDest,
+								   ipsize);
+#else
+				checks = dload_reverse_checksum(pDest,
+								ipsize);
+#endif
+#endif
+
+				checks += dload_checksum(&ibuf.ipacket,
+							IPH_SIZE);
+				/* relocate the image bits as needed */
+				if (ibuf.ipacket.i_num_relocs) {
+					dlthis->image_offset = image_offset;
+					if (!relocate_packet(dlthis,
+					    &ibuf.ipacket, &checks,
+					    &tramp_generated))
+						return;	/* serious error */
+				}
+				if (~checks)
+					DL_ERROR(E_CHECKSUM, IMAGEPAK);
+				/* Only write the result to the target if no
+				  * trampoline was generated.  Otherwise it
+				  *will be done during trampoline finalize.  */
+
+				if (tramp_generated == false) {
+
+					/* stuff the result into target
+					 * memory */
+					if (DLOAD_SECT_TYPE(sptr) ==
+					    DLOAD_CINIT) {
+						cload_cinit(dlthis,
+							&ibuf.ipacket);
+						cinit_processed = true;
+					} else {
+#ifdef OPT_ZERO_COPY_LOADER
+						if (!bZeroCopy) {
+#endif
+						if (!dlthis->myio->writemem
+						(dlthis->myio, ibuf.bufr,
+						lptr->load_addr + image_offset,
+						lptr, BYTE_TO_HOST
+						(ibuf.ipacket.i_packet_size))) {
+							DL_ERROR(
+							"Write to " FMT_UI32
+							" failed",
+							lptr->load_addr +
+							image_offset);
+						}
+#ifdef OPT_ZERO_COPY_LOADER
+					}
+#endif
+					}
+				}
+				image_offset +=
+				      BYTE_TO_TADDR(ibuf.ipacket.i_packet_size);
+			}	/* process packets */
+			/* if this is a BSS section, we may want to fill it */
+			if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
+				goto loop_cont;
+
+			if (!(dlthis->myoptions & DLOAD_INITBSS))
+				goto loop_cont;
+
+			if (cinit_processed) {
+				/* Don't clear BSS after load-time
+				 * initialization */
+				DL_ERROR
+				  ("Zero-initialization at " FMT_UI32 " after "
+				  "load-time initialization!", lptr->load_addr);
+				goto loop_cont;
+			}
+			/* fill the .bss area */
+			dlthis->myio->fillmem(dlthis->myio,
+					      TADDR_TO_HOST(lptr->load_addr),
+					      lptr, TADDR_TO_HOST(lptr->size),
+					      dload_fill_bss);
+			goto loop_cont;
+		} /* if DS_DOWNLOAD_MASK */
+		/* If not loading, but BSS, zero initialize */
+		if (DLOAD_SECT_TYPE(sptr) != DLOAD_BSS)
+			goto loop_cont;
+
+		if (!(dlthis->myoptions & DLOAD_INITBSS))
+			goto loop_cont;
+
+		if (curr_sect >= dlthis->allocated_secn_count)
+			lptr = DOFFSEC_IS_LDRSEC(sptr);
+
+		if (cinit_processed) {
+			/*Don't clear BSS after load-time initialization */
+			DL_ERROR(
+			 "Zero-initialization at " FMT_UI32 " attempted after "
+			 "load-time initialization!", lptr->load_addr);
+			goto loop_cont;
+		}
+		/* fill the .bss area */
+		dlthis->myio->fillmem(dlthis->myio,
+				     TADDR_TO_HOST(lptr->load_addr), lptr,
+				     TADDR_TO_HOST(lptr->size), dload_fill_bss);
+loop_cont:
+		sptr += 1;
+		lptr += 1;
+	}			/* load sections */
+
+	/*  Finalize any trampolines that were created during the load  */
+	if (dload_tramp_finalize(dlthis) == 0) {
+		DL_ERROR("Finalization of auto-trampolines (size = " FMT_UI32
+			") failed", dlthis->tramp.tramp_sect_next_addr);
+    }
+}				/* dload_data */
+
+/*************************************************************************
+ * Procedure dload_reorder
+ *
+ * Parameters:
+ *	data	32-bit aligned pointer to data to be byte-swapped
+ *	dsiz	size of the data to be reordered in sizeof() units.
+ *	map		32-bit map defining how to reorder the data.  Value
+ *			must be REORDER_MAP() of some permutation
+ *			of 0x00 01 02 03
+ *
+ * Effect:
+ *	Re-arranges the bytes in each word according to the map specified.
+ *
+ ************************************************************************/
+/* mask for byte shift count */
+#define SHIFT_COUNT_MASK (3 << LOG_BITS_PER_BYTE)
+
+void dload_reorder(void *data, int dsiz, unsigned int map)
+{
+	register u32 tmp, tmap, datv;
+	u32 *dp = (u32 *)data;
+
+	map <<= LOG_BITS_PER_BYTE;	/* align map with SHIFT_COUNT_MASK */
+	do {
+		tmp = 0;
+		datv = *dp;
+		tmap = map;
+		do {
+			tmp |= (datv & BYTE_MASK) << (tmap & SHIFT_COUNT_MASK);
+			tmap >>= BITS_PER_BYTE;
+		} while (datv >>= BITS_PER_BYTE);
+		*dp++ = tmp;
+	} while ((dsiz -= sizeof(u32)) > 0);
+}				/* dload_reorder */
+
+/*************************************************************************
+ * Procedure dload_checksum
+ *
+ * Parameters:
+ *	data	32-bit aligned pointer to data to be checksummed
+ *	siz		size of the data to be checksummed in sizeof() units.
+ *
+ * Effect:
+ *	Returns a checksum of the specified block
+ *
+ ************************************************************************/
+u32 dload_checksum(void *data, unsigned siz)
+{
+	u32 sum;
+	u32 *dp;
+	int left;
+
+	sum = 0;
+	dp = (u32 *)data;
+	for (left = siz; left > 0; left -= sizeof(u32))
+		sum += *dp++;
+	return sum;
+}				/* dload_checksum */
+
+#if HOST_ENDIANNESS
+/*************************************************************************
+ * Procedure dload_reverse_checksum
+ *
+ * Parameters:
+ *	data	32-bit aligned pointer to data to be checksummed
+ *	siz		size of the data to be checksummed in sizeof() units.
+ *
+ * Effect:
+ *	Returns a checksum of the specified block, which is assumed to be bytes
+ * in big-endian order.
+ *
+ * Notes:
+ *	In a big-endian host, things like the string table are stored as bytes
+ * in host order. But dllcreate always checksums in little-endian order.
+ * It is most efficient to just handle the difference a word at a time.
+ *
+ ***********************************************************************/
+u32 dload_reverse_checksum(void *data, unsigned siz)
+{
+	u32 sum, temp;
+	u32 *dp;
+	int left;
+
+	sum = 0;
+	dp = (u32 *)data;
+
+	for (left = siz; left > 0; left -= sizeof(u32)) {
+		temp = *dp++;
+		sum += temp << BITS_PER_BYTE * 3;
+		sum += temp >> BITS_PER_BYTE * 3;
+		sum += (temp >> BITS_PER_BYTE) & (BYTE_MASK << BITS_PER_BYTE);
+		sum += (temp & (BYTE_MASK << BITS_PER_BYTE)) << BITS_PER_BYTE;
+	}
+
+	return sum;
+}				/* dload_reverse_checksum */
+
+#if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
+u32 dload_reverse_checksum_16(void *data, unsigned siz)
+{
+	uint_fast32_t sum, temp;
+	u32 *dp;
+	int left;
+
+	sum = 0;
+	dp = (u32 *)data;
+
+	for (left = siz; left > 0; left -= sizeof(u32)) {
+		temp = *dp++;
+		sum += temp << BITS_PER_BYTE * 2;
+		sum += temp >> BITS_PER_BYTE * 2;
+	}
+
+	return sum;
+}				/* dload_reverse_checksum_16 */
+#endif
+#endif
+
+/*************************************************************************
+ * Procedure swap_words
+ *
+ * Parameters:
+ *	data	32-bit aligned pointer to data to be swapped
+ *	siz	size of the data to be swapped.
+ *	bitmap	Bit map of how to swap each 32-bit word; 1 => 2 shorts,
+ *		0 => 1 long
+ *
+ * Effect:
+ *	Swaps the specified data according to the specified map
+ *
+ ************************************************************************/
+static void swap_words(void *data, unsigned siz, unsigned bitmap)
+{
+	register int i;
+#if TARGET_AU_BITS < 16
+	register u16 *sp;
+#endif
+	register u32 *lp;
+
+	siz /= sizeof(u16);
+
+#if TARGET_AU_BITS < 16
+	/* pass 1: do all the bytes */
+	i = siz;
+	sp = (u16 *) data;
+	do {
+		register u16 tmp;
+		tmp = *sp;
+		*sp++ = SWAP16BY8(tmp);
+	} while ((i -= 1) > 0);
+#endif
+
+#if TARGET_AU_BITS < 32
+	/* pass 2: fixup the 32-bit words */
+	i = siz >> 1;
+	lp = (u32 *) data;
+	do {
+		if ((bitmap & 1) == 0) {
+			register u32 tmp;
+			tmp = *lp;
+			*lp = SWAP32BY16(tmp);
+		}
+		lp += 1;
+		bitmap >>= 1;
+	} while ((i -= 1) > 0);
+#endif
+}				/* swap_words */
+
+/*************************************************************************
+ * Procedure copy_tgt_strings
+ *
+ * Parameters:
+ *	dstp		Destination address.  Assumed to be 32-bit aligned
+ *	srcp		Source address.  Assumed to be 32-bit aligned
+ *	charcount	Number of characters to copy.
+ *
+ * Effect:
+ *	Copies strings from the source (which is in usual .dof file order on
+ * the loading processor) to the destination buffer (which should be in proper
+ * target addressable unit order).  Makes sure the last string in the
+ * buffer is NULL terminated (for safety).
+ * Returns the first unused destination address.
+ ************************************************************************/
+static char *copy_tgt_strings(void *dstp, void *srcp, unsigned charcount)
+{
+	register TgtAU_t *src = (TgtAU_t *)srcp;
+	register TgtAU_t *dst = (TgtAU_t *)dstp;
+	register int cnt = charcount;
+	do {
+#if TARGET_AU_BITS <= BITS_PER_AU
+		/* byte-swapping issues may exist for strings on target */
+		*dst++ = *src++;
+#else
+		*dst++ = *src++;
+#endif
+	} while ((cnt -= (sizeof(TgtAU_t) * BITS_PER_AU / BITS_PER_BYTE)) > 0);
+	/*apply force to make sure that the string table has null terminator */
+#if (BITS_PER_AU == BITS_PER_BYTE) && (TARGET_AU_BITS == BITS_PER_BYTE)
+	dst[-1] = 0;
+#else
+	dst[-1] &= (1 << (BITS_PER_AU - BITS_PER_BYTE)) - 1; /* little endian */
+#endif
+	return (char *)dst;
+}				/* copy_tgt_strings */
+
+/*************************************************************************
+ * Procedure init_module_handle
+ *
+ * Parameters:
+ *	none
+ *
+ * Effect:
+ *	Initializes the module handle we use to enable unloading, and installs
+ * the debug information required by the target.
+ *
+ * Notes:
+ * The handle returned from Dynamic_Load_Module needs to encapsulate all the
+ * allocations done for the module, and enable them plus the modules symbols to
+ * be deallocated.
+ *
+ ************************************************************************/
+#ifndef _BIG_ENDIAN
+static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
+				(LDR_ADDR) -1, DBG_LIST_PAGE, DLOAD_DATA, 0 };
+#else
+static const struct LDR_SECTION_INFO DLLVIEW_INFO_INIT = { ".dllview", 0, 0,
+				(LDR_ADDR) -1, DLOAD_DATA, DBG_LIST_PAGE, 0 };
+#endif
+static void init_module_handle(struct dload_state *dlthis)
+{
+	struct my_handle *hndl;
+	u16 curr_sect;
+	struct LDR_SECTION_INFO *asecs;
+	struct dll_module *dbmod;
+	struct dll_sect *dbsec;
+	struct dbg_mirror_root *mlist;
+	register char *cp;
+	struct modules_header mhdr;
+	struct LDR_SECTION_INFO dllview_info;
+	struct dynload_symbol *debug_mirror_sym;
+	hndl = dlthis->myhandle;
+	if (!hndl)
+		return;		/* must be errors detected, so forget it */
+
+	/*  Store the section count  */
+	hndl->secn_count = dlthis->allocated_secn_count;
+
+	/*  If a trampoline section was created, add it in  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0)
+		hndl->secn_count += 1;
+
+	hndl->secn_count = hndl->secn_count << 1;
+
+	hndl->secn_count = dlthis->allocated_secn_count << 1;
+#ifndef TARGET_ENDIANNESS
+	if (dlthis->big_e_target)
+		hndl->secn_count += 1;	/* flag for big-endian */
+#endif
+	if (dlthis->dload_errcount)
+		return;		/* abandon if errors detected */
+	 /* Locate the symbol that names the header for the CCS debug list
+	 of modules. If not found, we just don't generate the debug record.
+	 If found, we create our modules list.  We make sure to create the
+	 LOADER_DLLVIEW_ROOT even if there is no relocation info to record,
+	 just to try to put both symbols in the same symbol table and
+	 module.*/
+	debug_mirror_sym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
+						LOADER_DLLVIEW_ROOT);
+	if (!debug_mirror_sym) {
+		struct dynload_symbol *dlmodsym;
+		struct dbg_mirror_root *mlst;
+
+		/* our root symbol is not yet present;
+		   check if we have DLModules defined */
+		dlmodsym = dlthis->mysym->Find_Matching_Symbol(dlthis->mysym,
+							LINKER_MODULES_HEADER);
+		if (!dlmodsym)
+			return;	/* no DLModules list so no debug info */
+		/* if we have DLModules defined, construct our header */
+		mlst = (struct dbg_mirror_root *)
+			dlthis->mysym->Allocate(dlthis->mysym,
+			sizeof(struct dbg_mirror_root));
+		if (!mlst) {
+			DL_ERROR(E_ALLOC, sizeof(struct dbg_mirror_root));
+			return;
+		}
+		mlst->hnext = NULL;
+		mlst->changes = 0;
+		mlst->refcount = 0;
+		mlst->dbthis = TDATA_TO_TADDR(dlmodsym->value);
+		/* add our root symbol */
+		debug_mirror_sym = dlthis->mysym->Add_To_Symbol_Table
+			(dlthis->mysym, LOADER_DLLVIEW_ROOT,
+			(unsigned)dlthis->myhandle);
+		if (!debug_mirror_sym) {
+			/* failed, recover memory */
+			dlthis->mysym->Deallocate(dlthis->mysym, mlst);
+			return;
+		}
+		debug_mirror_sym->value = (u32)mlst;
+	}
+	 /* First create the DLLview record and stuff it into the buffer.
+	 Then write it to the DSP.  Record pertinent locations in our hndl,
+	  and add it to the per-processor list of handles with debug info.*/
+#ifndef DEBUG_HEADER_IN_LOADER
+	mlist = (struct dbg_mirror_root *)debug_mirror_sym->value;
+	if (!mlist)
+		return;
+#else
+	mlist = (struct dbg_mirror_root *)&debug_list_header;
+#endif
+	hndl->dm.hroot = mlist;	/* set pointer to root into our handle */
+	if (!dlthis->allocated_secn_count)
+		return;		/* no load addresses to be recorded */
+	/* reuse temporary symbol storage */
+	dbmod = (struct dll_module *) dlthis->local_symtab;
+	 /* Create the DLLview record in the memory we retain for our handle*/
+	dbmod->num_sects = dlthis->allocated_secn_count;
+	dbmod->timestamp = dlthis->verify.dv_timdat;
+	dbmod->version = INIT_VERSION;
+	dbmod->verification = VERIFICATION;
+	asecs = dlthis->ldr_sections;
+	dbsec = dbmod->sects;
+	for (curr_sect = dlthis->allocated_secn_count;
+	     curr_sect > 0; curr_sect -= 1) {
+		dbsec->sect_load_adr = asecs->load_addr;
+		dbsec->sect_run_adr = asecs->run_addr;
+		dbsec += 1;
+		asecs += 1;
+	}
+
+	/*  If a trampoline section was created go ahead and add its info  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		dbmod->num_sects++;
+		dbsec->sect_load_adr = asecs->load_addr;
+		dbsec->sect_run_adr = asecs->run_addr;
+		dbsec++;
+		asecs++;
+	}
+
+	/* now cram in the names */
+	cp = copy_tgt_strings(dbsec, dlthis->str_head,
+			      dlthis->debug_string_size);
+
+
+	/* If a trampoline section was created, add its name so DLLView
+	 * can show the user the section info.  */
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		cp = copy_tgt_strings(cp,
+			dlthis->tramp.final_string_table,
+			strlen(dlthis->tramp.final_string_table) + 1);
+	}
+
+
+	/* round off the size of the debug record, and remember same */
+	hndl->dm.dbsiz = HOST_TO_TDATA_ROUND(cp - (char *)dbmod);
+	*cp = 0;		/* strictly to make our test harness happy */
+	dllview_info = DLLVIEW_INFO_INIT;
+	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
+	/* Initialize memory context to default heap */
+	dllview_info.context = 0;
+	hndl->dm.context = 0;
+	/* fill in next pointer and size */
+	if (mlist->hnext) {
+		dbmod->next_module = TADDR_TO_TDATA(mlist->hnext->dm.dbthis);
+		dbmod->next_module_size = mlist->hnext->dm.dbsiz;
+	} else {
+		dbmod->next_module_size = 0;
+		dbmod->next_module = 0;
+	}
+	/* allocate memory for on-DSP DLLview debug record */
+	if (!dlthis->myalloc)
+		return;
+	if (!dlthis->myalloc->Allocate(dlthis->myalloc, &dllview_info,
+		     HOST_TO_TADDR(sizeof(u32)))) {
+		return;
+	}
+	/* Store load address of .dllview section */
+	hndl->dm.dbthis = dllview_info.load_addr;
+	/* Store memory context (segid) in which .dllview section
+	 * was  allocated */
+	hndl->dm.context = dllview_info.context;
+	mlist->refcount += 1;
+	/* swap bytes in the entire debug record, but not the string table */
+	if (TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)) {
+		swap_words(dbmod, (char *)dbsec - (char *)dbmod,
+			   DLL_MODULE_BITMAP);
+	}
+	 /* Update the DLLview list on the DSP write new record */
+	if (!dlthis->myio->writemem(dlthis->myio, dbmod,
+		dllview_info.load_addr, &dllview_info,
+		TADDR_TO_HOST(dllview_info.size))) {
+		return;
+	}
+	/* write new header */
+	mhdr.first_module_size = hndl->dm.dbsiz;
+	mhdr.first_module = TADDR_TO_TDATA(dllview_info.load_addr);
+	/* swap bytes in the module header, if needed */
+	if (TARGET_ENDIANNESS_DIFFERS(TARGET_BIG_ENDIAN)) {
+		swap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),
+			   MODULES_HEADER_BITMAP);
+	}
+	dllview_info = DLLVIEW_INFO_INIT;
+	if (!dlthis->myio->writemem(dlthis->myio, &mhdr, mlist->dbthis,
+			&dllview_info, sizeof(struct modules_header) -
+				       sizeof(u16))) {
+		return;
+	}
+	 /* Add the module handle to this processor's list
+		of handles with debug info */
+	hndl->dm.hnext = mlist->hnext;
+	if (hndl->dm.hnext)
+		hndl->dm.hnext->dm.hprev = hndl;
+	hndl->dm.hprev = (struct my_handle *) mlist;
+	mlist->hnext = hndl;	/* insert after root*/
+}				/* init_module_handle */
+
+/*************************************************************************
+ * Procedure Dynamic_Unload_Module
+ *
+ * Parameters:
+ *	mhandle	A module handle from Dynamic_Load_Module
+ *	syms	Host-side symbol table and malloc/free functions
+ *	alloc	Target-side memory allocation
+ *
+ * Effect:
+ *	The module specified by mhandle is unloaded.  Unloading causes all
+ * target memory to be deallocated, all symbols defined by the module to
+ * be purged, and any host-side storage used by the dynamic loader for
+ * this module to be released.
+ *
+ * Returns:
+ *	Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report().
+ ************************************************************************/
+int Dynamic_Unload_Module(DLOAD_mhandle mhandle,
+		struct Dynamic_Loader_Sym *syms,
+		struct Dynamic_Loader_Allocate *alloc,
+		struct Dynamic_Loader_Initialize *init)
+{
+	s16 curr_sect;
+	struct LDR_SECTION_INFO *asecs;
+	struct my_handle *hndl;
+	struct dbg_mirror_root *root;
+	unsigned errcount = 0;
+	struct LDR_SECTION_INFO dllview_info = DLLVIEW_INFO_INIT;
+	struct modules_header mhdr;
+
+	hndl = (struct my_handle *)mhandle;
+	if (!hndl)
+		return 0;	/* if handle is null, nothing to do */
+	 /* Clear out the module symbols
+	 * Note that if this is the module that defined MODULES_HEADER
+	  (the head of the target debug list)
+	 * then this operation will blow away that symbol.
+	 It will therefore be impossible for subsequent
+	 * operations to add entries to this un-referenceable list.*/
+	if (!syms)
+		return 1;
+	syms->Purge_Symbol_Table(syms, (unsigned) hndl);
+	 /* Deallocate target memory for sections
+	  * NOTE: The trampoline section, if created, gets deleted here, too */
+
+	asecs = hndl->secns;
+	if (alloc)
+		for (curr_sect = (hndl->secn_count >> 1); curr_sect > 0;
+		     curr_sect -= 1) {
+			asecs->name = NULL;
+			alloc->Deallocate(alloc, asecs++);
+		}
+	root = hndl->dm.hroot;
+	if (!root) {
+		/* there is a debug list containing this module */
+		goto func_end;
+	}
+	if (!hndl->dm.dbthis) {	/* target-side dllview record exists */
+		goto loop_end;
+	}
+	/* Retrieve memory context in which .dllview was allocated */
+	dllview_info.context = hndl->dm.context;
+	if (hndl->dm.hprev == hndl)
+		goto exitunltgt;
+
+	/* target-side dllview record is in list */
+	/* dequeue this record from our GPP-side mirror list */
+	hndl->dm.hprev->dm.hnext = hndl->dm.hnext;
+	if (hndl->dm.hnext)
+		hndl->dm.hnext->dm.hprev = hndl->dm.hprev;
+	 /* Update next_module of previous entry in target list
+	 * We are using mhdr here as a surrogate for either a
+	 struct modules_header or a dll_module	 */
+	if (hndl->dm.hnext) {
+		mhdr.first_module = TADDR_TO_TDATA(hndl->dm.hnext->dm.dbthis);
+		mhdr.first_module_size = hndl->dm.hnext->dm.dbsiz;
+	} else {
+		mhdr.first_module = 0;
+		mhdr.first_module_size = 0;
+	}
+	if (!init)
+		goto exitunltgt;
+
+	if (!init->connect(init)) {
+		dload_syms_error(syms, E_ICONNECT);
+		errcount += 1;
+		goto exitunltgt;
+	}
+	/* swap bytes in the module header, if needed */
+	if (TARGET_ENDIANNESS_DIFFERS(hndl->secn_count & 0x1)) {
+		swap_words(&mhdr, sizeof(struct modules_header) - sizeof(u16),
+			   MODULES_HEADER_BITMAP);
+	}
+	if (!init->writemem(init, &mhdr, hndl->dm.hprev->dm.dbthis,
+			    &dllview_info, sizeof(struct modules_header) -
+			    sizeof(mhdr.update_flag))) {
+		dload_syms_error(syms, E_DLVWRITE);
+		errcount += 1;
+	}
+	/* update change counter */
+	root->changes += 1;
+	if (!init->writemem(init, &(root->changes),
+				root->dbthis + HOST_TO_TADDR
+				      (sizeof(mhdr.first_module) +
+				      sizeof(mhdr.first_module_size)),
+				      &dllview_info,
+				      sizeof(mhdr.update_flag))) {
+		dload_syms_error(syms, E_DLVWRITE);
+		errcount += 1;
+	}
+	init->release(init);
+exitunltgt:
+	/* release target storage */
+	dllview_info.size = TDATA_TO_TADDR(hndl->dm.dbsiz);
+	dllview_info.load_addr = hndl->dm.dbthis;
+	if (alloc)
+		alloc->Deallocate(alloc, &dllview_info);
+	root->refcount -= 1;
+	/* target-side dllview record exists */
+loop_end:
+#ifndef DEBUG_HEADER_IN_LOADER
+	if (root->refcount <= 0) {
+		/* if all references gone, blow off the header */
+		/* our root symbol may be gone due to the Purge above,
+		   but if not, do not destroy the root */
+		if (syms->Find_Matching_Symbol
+			(syms, LOADER_DLLVIEW_ROOT) == NULL)
+			syms->Deallocate(syms, root);
+	}
+#endif
+func_end:
+	/* there is a debug list containing this module */
+	syms->Deallocate(syms, mhandle);	/* release our storage */
+	return errcount;
+}				/* Dynamic_Unload_Module */
+
+#if BITS_PER_AU > BITS_PER_BYTE
+/*************************************************************************
+ * Procedure unpack_name
+ *
+ * Parameters:
+ *	soffset	Byte offset into the string table
+ *
+ * Effect:
+ *	Returns a pointer to the string specified by the offset supplied, or
+ * NULL for error.
+ *
+ ************************************************************************/
+static char *unpack_name(struct dload_state *dlthis, u32 soffset)
+{
+	u8 tmp, *src;
+	char *dst;
+
+	if (soffset >= dlthis->dfile_hdr.df_strtab_size) {
+		dload_error(dlthis, "Bad string table offset " FMT_UI32,
+			    soffset);
+		return NULL;
+	}
+	src = (uint_least8_t *)dlthis->str_head +
+	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
+	dst = dlthis->str_temp;
+	if (soffset & 1)
+		*dst++ = *src++;	/* only 1 character in first word */
+	do {
+		tmp = *src++;
+		*dst = (tmp >> BITS_PER_BYTE);
+		if (!(*dst++))
+			break;
+	} while ((*dst++ = tmp & BYTE_MASK));
+	dlthis->temp_len = dst - dlthis->str_temp;
+	/* squirrel away length including terminating null */
+	return dlthis->str_temp;
+}				/* unpack_name */
+#endif
diff --git a/drivers/dsp/bridge/dynload/dload_internal.h b/drivers/dsp/bridge/dynload/dload_internal.h
new file mode 100644
index 0000000..65d1f47
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/dload_internal.h
@@ -0,0 +1,356 @@
+/*
+ * dload_internal.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef __DLOAD_INTERNAL__
+#define __DLOAD_INTERNAL__
+
+#include <linux/types.h>
+
+/*
+ * Internal state definitions for the dynamic loader
+ */
+
+#define TRUE 1
+#define FALSE 0
+typedef int boolean;
+
+
+/* type used for relocation intermediate results */
+typedef s32 RVALUE;
+
+/* unsigned version of same; must have at least as many bits */
+typedef u32 URVALUE;
+
+/*
+ * Dynamic loader configuration constants
+ */
+/* error issued if input has more sections than this limit */
+#define REASONABLE_SECTION_LIMIT 100
+
+/* (Addressable unit) value used to clear BSS section */
+#define dload_fill_bss 0
+
+/*
+ * Reorder maps explained (?)
+ *
+ * The doff file format defines a 32-bit pattern used to determine the
+ * byte order of an image being read.  That value is
+ * BYTE_RESHUFFLE_VALUE == 0x00010203
+ * For purposes of the reorder routine, we would rather have the all-is-OK
+ * for 32-bits pattern be 0x03020100.  This first macro makes the
+ * translation from doff file header value to MAP value: */
+#define REORDER_MAP(rawmap) ((rawmap) ^ 0x3030303)
+/* This translation is made in dload_headers.  Thereafter, the all-is-OK
+ * value for the maps stored in dlthis is REORDER_MAP(BYTE_RESHUFFLE_VALUE).
+ * But sadly, not all bits of the doff file are 32-bit integers.
+ * The notable exceptions are strings and image bits.
+ * Strings obey host byte order: */
+#if defined(_BIG_ENDIAN)
+#define HOST_BYTE_ORDER(cookedmap) ((cookedmap) ^ 0x3030303)
+#else
+#define HOST_BYTE_ORDER(cookedmap) (cookedmap)
+#endif
+/* Target bits consist of target AUs (could be bytes, or 16-bits,
+ * or 32-bits) stored as an array in host order.  A target order
+ * map is defined by: */
+#if !defined(_BIG_ENDIAN) || TARGET_AU_BITS > 16
+#define TARGET_ORDER(cookedmap) (cookedmap)
+#elif TARGET_AU_BITS > 8
+#define TARGET_ORDER(cookedmap) ((cookedmap) ^ 0x2020202)
+#else
+#define TARGET_ORDER(cookedmap) ((cookedmap) ^ 0x3030303)
+#endif
+
+/* forward declaration for handle returned by dynamic loader */
+struct my_handle;
+
+/*
+ * a list of module handles, which mirrors the debug list on the target
+ */
+struct dbg_mirror_root {
+	/* must be same as dbg_mirror_list; __DLModules address on target */
+	u32 dbthis;
+	struct my_handle *hnext;	/* must be same as dbg_mirror_list */
+	u16 changes;	/* change counter */
+	u16 refcount;	/* number of modules referencing this root */
+} ;
+
+struct dbg_mirror_list {
+	u32 dbthis;
+	struct my_handle *hnext, *hprev;
+	struct dbg_mirror_root *hroot;
+	u16 dbsiz;
+	u32 context;	/* Save context for .dllview memory allocation */
+} ;
+
+#define VARIABLE_SIZE 1
+/*
+ * the structure we actually return as an opaque module handle
+ */
+struct my_handle {
+	struct dbg_mirror_list dm;	/* !!! must be first !!! */
+	/* sections following << 1, LSB is set for big-endian target */
+	u16 secn_count;
+	struct LDR_SECTION_INFO secns[VARIABLE_SIZE];
+} ;
+#define MY_HANDLE_SIZE (sizeof(struct my_handle) -\
+			sizeof(struct LDR_SECTION_INFO))
+/* real size of my_handle */
+
+/*
+ * reduced symbol structure used for symbols during relocation
+ */
+struct Local_Symbol {
+	s32 value;	/* Relocated symbol value */
+	s32 delta;	/* Original value in input file */
+	s16 secnn;		/* section number */
+	s16 sclass;		/* symbol class */
+};
+
+
+/*
+ * Trampoline data structures
+ */
+#define TRAMP_NO_GEN_AVAIL              65535
+#define TRAMP_SYM_PREFIX                "__$dbTR__"
+#define TRAMP_SECT_NAME                 ".dbTR"
+#define TRAMP_SYM_PREFIX_LEN            9  /*  MUST MATCH THE LENGTH ABOVE!! */
+#define TRAMP_SYM_HEX_ASCII_LEN         9  /*  Includes NULL termination  */
+
+#define GET_CONTAINER(ptr, type, field) ((type *)((unsigned long)ptr -\
+				(unsigned long)(&((type *)0)->field)))
+#ifndef FIELD_OFFSET
+#define FIELD_OFFSET(type, field)       ((unsigned long)(&((type *)0)->field))
+#endif
+
+
+/*
+    The trampoline code for the target is located in a table called
+    "tramp_gen_info" with is indexed by looking up the index in the table
+    "tramp_map".  The tramp_map index is acquired using the target
+    HASH_FUNC on the relocation type that caused the trampoline.  Each
+    trampoline code table entry MUST follow this format:
+
+    |----------------------------------------------|
+    |  tramp_gen_code_hdr                          |
+    |----------------------------------------------|
+    |  Trampoline image code                       |
+    |  (the raw instruction code for the target)   |
+    |----------------------------------------------|
+    |  Relocation entries for the image code       |
+    |----------------------------------------------|
+
+    This is very similar to how image data is laid out in the DOFF file
+    itself.
+*/
+struct tramp_gen_code_hdr {
+	u32		tramp_code_size;    /*  in BYTES  */
+	u32		num_relos;
+	u32		relo_offset;   /*  in BYTES  */
+};
+
+struct tramp_img_pkt {
+	struct tramp_img_pkt	*next;    /*  MUST BE FIRST  */
+	u32		base;
+	struct tramp_gen_code_hdr	hdr;
+	u8		payload[VARIABLE_SIZE];
+};
+
+struct tramp_img_dup_relo {
+	struct tramp_img_dup_relo	*next;
+	struct reloc_record_t	relo;
+};
+
+struct tramp_img_dup_pkt {
+	struct tramp_img_dup_pkt  *next;    /*  MUST BE FIRST  */
+	s16		secnn;
+	u32		offset;
+	struct image_packet_t                img_pkt;
+	struct tramp_img_dup_relo            *relo_chain;
+
+	/*  PAYLOAD OF IMG PKT FOLLOWS  */
+};
+
+struct tramp_sym {
+	struct tramp_sym	*next;    /*  MUST BE FIRST  */
+	u32		index;
+	u32		str_index;
+	struct Local_Symbol sym_info;
+};
+
+struct tramp_string {
+	struct tramp_string	*next;    /*  MUST BE FIRST  */
+	u32	index;
+	char    str[VARIABLE_SIZE];    /*  NULL terminated  */
+};
+
+struct tramp_info {
+	u32		tramp_sect_next_addr;
+	struct LDR_SECTION_INFO	sect_info;
+
+	struct tramp_sym		*symbol_head;
+	struct tramp_sym		*symbol_tail;
+	u32		tramp_sym_next_index;
+	struct	Local_Symbol		*final_sym_table;
+
+	struct tramp_string                *string_head;
+	struct tramp_string                *string_tail;
+	u32		tramp_string_next_index;
+	u32		tramp_string_size;
+	char		*final_string_table;
+
+	struct tramp_img_pkt		*tramp_pkts;
+	struct tramp_img_dup_pkt	*dup_pkts;
+};
+
+/*
+ * States of the .cinit state machine
+ */
+enum cinit_mode {
+	CI_count = 0,		/* expecting a count */
+	CI_address,		/* expecting an address */
+#if CINIT_ALIGN < CINIT_ADDRESS	/* handle case of partial address field */
+	CI_partaddress,		/* have only part of the address */
+#endif
+	CI_copy,		/* in the middle of copying data */
+	CI_done			/* end of .cinit table */
+};
+
+/*
+ * The internal state of the dynamic loader, which is passed around as
+ * an object
+ */
+struct dload_state {
+	struct Dynamic_Loader_Stream *strm;	/* The module input stream */
+	struct Dynamic_Loader_Sym *mysym;	/* Symbols for this session */
+	struct Dynamic_Loader_Allocate *myalloc; /* target memory allocator */
+	struct Dynamic_Loader_Initialize *myio;	/* target memory initializer */
+	unsigned myoptions;	/* Options parameter Dynamic_Load_Module */
+
+	char *str_head;		/* Pointer to string table */
+#if BITS_PER_AU > BITS_PER_BYTE
+	char *str_temp;		/* Pointer to temporary buffer for strings */
+	/* big enough to hold longest string */
+	unsigned temp_len;	/* length of last temporary string */
+	char *xstrings;		/* Pointer to buffer for expanded */
+	/* strings for sec names */
+#endif
+	/* Total size of strings for DLLView section names */
+	unsigned debug_string_size;
+	/* Pointer to parallel section info for allocated sections only */
+	struct doff_scnhdr_t *sect_hdrs;	/* Pointer to section table */
+	struct LDR_SECTION_INFO *ldr_sections;
+#if TMS32060
+	/* The address of the start of the .bss section */
+	LDR_ADDR bss_run_base;
+#endif
+	struct Local_Symbol *local_symtab;	/* Relocation symbol table */
+
+	/* pointer to DL section info for the section being relocated */
+	struct LDR_SECTION_INFO *image_secn;
+	/* change in run address for current section during relocation */
+	LDR_ADDR delta_runaddr;
+	LDR_ADDR image_offset;	/* offset of current packet in section */
+	enum cinit_mode cinit_state;	/* current state of cload_cinit() */
+	int cinit_count;	/* the current count */
+	LDR_ADDR cinit_addr;	/* the current address */
+	s16 cinit_page;	/* the current page */
+	/* Handle to be returned by Dynamic_Load_Module */
+	struct my_handle *myhandle;
+	unsigned dload_errcount;	/* Total # of errors reported so far */
+	/* Number of target sections that require allocation and relocation */
+	unsigned allocated_secn_count;
+#ifndef TARGET_ENDIANNESS
+	boolean big_e_target;	/* Target data in big-endian format */
+#endif
+	/* map for reordering bytes, 0 if not needed */
+	u32 reorder_map;
+	struct doff_filehdr_t dfile_hdr;	/* DOFF file header structure */
+	struct doff_verify_rec_t verify;	/* Verify record */
+
+	struct tramp_info tramp;	/* Trampoline data, if needed  */
+
+	int relstkidx;		/* index into relocation value stack */
+	/* relocation value stack used in relexp.c */
+	RVALUE relstk[STATIC_EXPR_STK_SIZE];
+
+} ;
+
+#ifdef TARGET_ENDIANNESS
+#define TARGET_BIG_ENDIAN TARGET_ENDIANNESS
+#else
+#define TARGET_BIG_ENDIAN (dlthis->big_e_target)
+#endif
+
+/*
+ * Exports from cload.c to rest of the world
+ */
+extern void dload_error(struct dload_state *dlthis, const char *errtxt, ...);
+extern void dload_syms_error(struct Dynamic_Loader_Sym *syms,
+			     const char *errtxt, ...);
+extern void dload_headers(struct dload_state *dlthis);
+extern void dload_strings(struct dload_state *dlthis, bool sec_names_only);
+extern void dload_sections(struct dload_state *dlthis);
+extern void dload_reorder(void *data, int dsiz, u32 map);
+extern u32 dload_checksum(void *data, unsigned siz);
+
+#if HOST_ENDIANNESS
+extern uint32_t dload_reverse_checksum(void *data, unsigned siz);
+#if (TARGET_AU_BITS > 8) && (TARGET_AU_BITS < 32)
+extern uint32_t dload_reverse_checksum_16(void *data, unsigned siz);
+#endif
+#endif
+
+#define is_data_scn(zzz) (DLOAD_SECTION_TYPE((zzz)->type) != DLOAD_TEXT)
+#define is_data_scn_num(zzz) \
+		(DLOAD_SECT_TYPE(&dlthis->sect_hdrs[(zzz)-1]) != DLOAD_TEXT)
+
+/*
+ * exported by reloc.c
+ */
+extern void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
+			struct reloc_record_t *rp, bool *tramps_generated,
+			bool second_pass);
+
+extern RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data,
+			   int fieldsz, int offset, unsigned sgn);
+
+extern int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+			int fieldsz, int offset, unsigned sgn);
+
+
+/*
+ * exported by tramp.c
+ */
+extern bool dload_tramp_avail(struct dload_state *dlthis,
+			struct reloc_record_t *rp);
+
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+			u32 image_offset, struct image_packet_t *ipacket,
+			struct reloc_record_t *rp);
+
+extern int dload_tramp_pkt_udpate(struct dload_state *dlthis,
+			s16 secnn, u32 image_offset,
+			struct image_packet_t *ipacket);
+
+extern int dload_tramp_finalize(struct dload_state *dlthis);
+
+extern void dload_tramp_cleanup(struct dload_state *dlthis);
+
+
+#endif				/* __DLOAD_INTERNAL__ */
diff --git a/drivers/dsp/bridge/dynload/doff.h b/drivers/dsp/bridge/dynload/doff.h
new file mode 100644
index 0000000..916bd72
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/doff.h
@@ -0,0 +1,344 @@
+/*
+ * doff.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Structures & definitions used for dynamically loaded modules file format.
+ * This format is a reformatted version of COFF. It optimizes the layout for
+ * the dynamic loader.
+ *
+ * .dof files, when viewed as a sequence of 32-bit integers, look the same
+ * on big-endian and little-endian machines.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _DOFF_H
+#define _DOFF_H
+
+#ifndef UINT32_C
+#define UINT32_C(zzz) ((u32)zzz)
+#endif
+
+#define BYTE_RESHUFFLE_VALUE UINT32_C(0x00010203)
+
+/* DOFF file header containing fields categorizing the remainder of the file */
+struct doff_filehdr_t {
+
+	/* string table size, including filename, in bytes   */
+	u32 df_strtab_size;
+
+	/* entry point if one exists */
+	u32 df_entrypt;
+
+	/* identifies byte ordering of file;
+	 * always set to BYTE_RESHUFFLE_VALUE  */
+	u32 df_byte_reshuffle;
+
+	/* Size of the string table up to and including the last section name */
+	/* Size includes the name of the COFF file also     */
+	u32 df_scn_name_size;
+
+#ifndef _BIG_ENDIAN
+	/* number of symbols */
+	u16 df_no_syms;
+
+	/* length in bytes of the longest string, including terminating NULL */
+	/* excludes the name of the file     */
+	u16 df_max_str_len;
+
+	/* total number of sections including no-load ones   */
+	u16 df_no_scns;
+
+	/* number of sections containing target code allocated or downloaded */
+	u16 df_target_scns;
+
+	/* unique id for dll file format & version   */
+	u16 df_doff_version;
+
+	/* identifies ISA */
+	u16 df_target_id;
+
+	/* useful file flags */
+	u16 df_flags;
+
+	/* section reference for entry point, N_UNDEF for none,   */
+	/* N_ABS for absolute address */
+	s16 df_entry_secn;
+#else
+	/* length of the longest string, including terminating NULL  */
+	u16 df_max_str_len;
+
+	/* number of symbols */
+	u16 df_no_syms;
+
+	/* number of sections containing target code allocated or downloaded */
+	u16 df_target_scns;
+
+	/* total number of sections including no-load ones */
+	u16 df_no_scns;
+
+	/* identifies ISA */
+	u16 df_target_id;
+
+	/* unique id for dll file format & version */
+	u16 df_doff_version;
+
+	/* section reference for entry point, N_UNDEF for none,  */
+	/* N_ABS for absolute address */
+	s16 df_entry_secn;
+
+	/* useful file flags */
+	u16 df_flags;
+#endif
+	/* checksum for file header record */
+	u32 df_checksum;
+
+} ;
+
+/* flags in the df_flags field */
+#define  DF_LITTLE   0x100
+#define  DF_BIG      0x200
+#define  DF_BYTE_ORDER (DF_LITTLE | DF_BIG)
+
+/* Supported processors */
+#define TMS470_ID   0x97
+#define LEAD_ID     0x98
+#define TMS32060_ID 0x99
+#define LEAD3_ID    0x9c
+
+/* Primary processor for loading */
+#if TMS32060
+#define TARGET_ID   TMS32060_ID
+#endif
+
+/* Verification record containing values used to test integrity of the bits */
+struct doff_verify_rec_t {
+
+	/* time and date stamp */
+	u32 dv_timdat;
+
+	/* checksum for all section records */
+	u32 dv_scn_rec_checksum;
+
+	/* checksum for string table */
+	u32 dv_str_tab_checksum;
+
+	/* checksum for symbol table */
+	u32 dv_sym_tab_checksum;
+
+	/* checksum for verification record */
+	u32 dv_verify_rec_checksum;
+
+} ;
+
+/* String table is an array of null-terminated strings.  The first entry is
+ * the filename, which is added by DLLcreate.  No new structure definitions
+ * are required.
+ */
+
+/* Section Records including information on the corresponding image packets */
+/*
+ *      !!WARNING!!
+ *
+ * This structure is expected to match in form LDR_SECTION_INFO in
+ * dynamic_loader.h
+ */
+
+struct doff_scnhdr_t {
+
+	s32 ds_offset;	/* offset into string table of name    */
+	s32 ds_paddr;	/* RUN address, in target AU           */
+	s32 ds_vaddr;	/* LOAD address, in target AU          */
+	s32 ds_size;	/* section size, in target AU          */
+#ifndef _BIG_ENDIAN
+	u16 ds_page;	/* memory page id                      */
+	u16 ds_flags;	/* section flags                       */
+#else
+	u16 ds_flags;	/* section flags                       */
+	u16 ds_page;	/* memory page id                      */
+#endif
+	u32 ds_first_pkt_offset;
+	/* Absolute byte offset into the file  */
+	/* where the first image record resides */
+
+	s32 ds_nipacks;	/* number of image packets             */
+
+};
+
+/* Symbol table entry */
+struct doff_syment_t {
+
+	s32 dn_offset;	/* offset into string table of name    */
+	s32 dn_value;	/* value of symbol                     */
+#ifndef _BIG_ENDIAN
+	s16 dn_scnum;	/* section number                      */
+	s16 dn_sclass;	/* storage class                       */
+#else
+	s16 dn_sclass;	/* storage class                       */
+	s16 dn_scnum;	/* section number, 1-based             */
+#endif
+
+} ;
+
+/* special values for dn_scnum */
+#define  DN_UNDEF  0		/* undefined symbol               */
+#define  DN_ABS    (-1)		/* value of symbol is absolute    */
+/* special values for dn_sclass */
+#define DN_EXT     2
+#define DN_STATLAB 20
+#define DN_EXTLAB  21
+
+/* Default value of image bits in packet */
+/* Configurable by user on the command line */
+#define IMAGE_PACKET_SIZE 1024
+
+/* An image packet contains a chunk of data from a section along with */
+/* information necessary for its processing.                          */
+struct image_packet_t {
+
+	s32 i_num_relocs;	/* number of relocations for   */
+	/* this packet                 */
+
+	s32 i_packet_size;	/* number of bytes in array    */
+	/* "bits" occupied  by         */
+	/* valid data.  Could be       */
+	/* < IMAGE_PACKET_SIZE to      */
+	/* prevent splitting a         */
+	/* relocation across packets.  */
+	/* Last packet of a section    */
+	/* will most likely contain    */
+	/* < IMAGE_PACKET_SIZE bytes   */
+	/* of valid data               */
+
+	s32 i_checksum;	/* Checksum for image packet   */
+	/* and the corresponding       */
+	/* relocation records          */
+
+	u8 *i_bits;	/* Actual data in section      */
+
+};
+
+/* The relocation structure definition matches the COFF version.  Offsets  */
+/* however are relative to the image packet base not the section base.     */
+struct reloc_record_t {
+
+	s32 r_vaddr;
+
+	/* expressed in target AUs          */
+
+	union {
+		struct {
+#ifndef _BIG_ENDIAN
+			u8 _offset;	/* bit offset of rel fld      */
+			u8 _fieldsz;	/* size of rel fld            */
+			u8 _wordsz;	/* # bytes containing rel fld */
+			u8 _dum1;
+			u16 _dum2;
+			u16 _type;
+#else
+			unsigned _dum1:8;
+			unsigned _wordsz:8;	/* # bytes containing rel fld */
+			unsigned _fieldsz:8;	/* size of rel fld            */
+			unsigned _offset:8;	/* bit offset of rel fld      */
+			u16 _type;
+			u16 _dum2;
+#endif
+		} _r_field;
+
+		struct {
+			u32 _spc;	/* image packet relative PC   */
+#ifndef _BIG_ENDIAN
+			u16 _dum;
+			u16 _type;	/* relocation type            */
+#else
+			u16 _type;	/* relocation type            */
+			u16 _dum;
+#endif
+		} _r_spc;
+
+		struct {
+			u32 _uval;	/* constant value             */
+#ifndef _BIG_ENDIAN
+			u16 _dum;
+			u16 _type;	/* relocation type            */
+#else
+			u16 _type;	/* relocation type            */
+			u16 _dum;
+#endif
+		} _r_uval;
+
+		struct {
+			s32 _symndx;	/* 32-bit sym tbl index       */
+#ifndef _BIG_ENDIAN
+			u16 _disp;	/* extra addr encode data     */
+			u16 _type;	/* relocation type            */
+#else
+			u16 _type;	/* relocation type            */
+			u16 _disp;	/* extra addr encode data     */
+#endif
+		} _r_sym;
+	} _u_reloc;
+
+} ;
+
+/* abbreviations for convenience */
+#ifndef r_type
+#define r_type      _u_reloc._r_sym._type
+#define r_uval      _u_reloc._r_uval._uval
+#define r_symndx    _u_reloc._r_sym._symndx
+#define r_offset    _u_reloc._r_field._offset
+#define r_fieldsz   _u_reloc._r_field._fieldsz
+#define r_wordsz    _u_reloc._r_field._wordsz
+#define r_disp      _u_reloc._r_sym._disp
+#endif
+
+/*****************************************************************************/
+/*                                                                           */
+/* Important DOFF macros used for file processing                            */
+/*                                                                           */
+/*****************************************************************************/
+
+/* DOFF Versions */
+#define         DOFF0                       0
+
+/* Return the address/size >= to addr that is at a 32-bit boundary           */
+/* This assumes that a byte is 8 bits                                        */
+#define         DOFF_ALIGN(addr)            (((addr) + 3) & ~UINT32_C(3))
+
+/*****************************************************************************/
+/*                                                                           */
+/* The DOFF section header flags field is laid out as follows:               */
+/*                                                                           */
+/*  Bits 0-3 : Section Type                                                  */
+/*  Bit    4 : Set when section requires target memory to be allocated by DL */
+/*  Bit    5 : Set when section requires downloading                         */
+/*  Bits 8-11: Alignment, same as COFF                                       */
+/*                                                                           */
+/*****************************************************************************/
+
+/* Enum for DOFF section types (bits 0-3 of flag): See dynamic_loader.h      */
+
+/* Macros to help processing of sections                                     */
+#define DLOAD_SECT_TYPE(s_hdr)      ((s_hdr)->ds_flags & 0xF)
+
+/* DS_ALLOCATE indicates whether a section needs space on the target         */
+#define DS_ALLOCATE_MASK            0x10
+#define DS_NEEDS_ALLOCATION(s_hdr)  ((s_hdr)->ds_flags & DS_ALLOCATE_MASK)
+
+/* DS_DOWNLOAD indicates that the loader needs to copy bits                  */
+#define DS_DOWNLOAD_MASK            0x20
+#define DS_NEEDS_DOWNLOAD(s_hdr)    ((s_hdr)->ds_flags & DS_DOWNLOAD_MASK)
+
+/* Section alignment requirement in AUs */
+#define DS_ALIGNMENT(ds_flags) (1 << (((ds_flags) >> 8) & 0xF))
+
+#endif				/* _DOFF_H */
diff --git a/drivers/dsp/bridge/dynload/getsection.c b/drivers/dsp/bridge/dynload/getsection.c
new file mode 100644
index 0000000..78a301a
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/getsection.c
@@ -0,0 +1,412 @@
+/*
+ * getsection.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#include <dspbridge/getsection.h>
+#include "header.h"
+
+/*
+ * Error strings
+ */
+static const char E_READSTRM[] = { "Error reading %s from input stream" };
+static const char E_SEEK[] = { "Set file position to %d failed" };
+static const char E_ISIZ[] = { "Bad image packet size %d" };
+static const char E_CHECKSUM[] = { "Checksum failed on %s" };
+static const char E_RELOC[] = { "DLOAD_GetSection unable to read"
+	"sections containing relocation entries"};
+#if BITS_PER_AU > BITS_PER_BYTE
+static const char E_ALLOC[] = { "Syms->Allocate( %d ) failed" };
+static const char E_STBL[] = { "Bad string table offset " FMT_UI32 };
+#endif
+
+/*
+ * we use the fact that DOFF section records are shaped just like
+ * LDR_SECTION_INFO to reduce our section storage usage.  These macros
+ * marks the places where that assumption is made
+ */
+#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct LDR_SECTION_INFO *)(pdoffsec))
+#define LDRSEC_IS_DOFFSEC(ldrsec) ((struct doff_scnhdr_t *)(ldrsec))
+
+/***************************************************************/
+/********************* SUPPORT FUNCTIONS ***********************/
+/***************************************************************/
+
+#if BITS_PER_AU > BITS_PER_BYTE
+/**************************************************************************
+ * Procedure unpack_sec_name
+ *
+ * Parameters:
+ *  dlthis		Handle from DLOAD_module_open for this module
+ *	soffset	    Byte offset into the string table
+ *  dst         Place to store the expanded string
+ *
+ * Effect:
+ *	Stores a string from the string table into the destination, expanding
+ * it in the process.  Returns a pointer just past the end of the stored
+ * string on success, or NULL on failure.
+ *
+ *************************************************************************/
+static char *unpack_sec_name(struct dload_state *dlthis,
+			     u32 soffset, char *dst)
+{
+	u8 tmp, *src;
+
+	if (soffset >= dlthis->dfile_hdr.df_scn_name_size) {
+		dload_error(dlthis, E_STBL, soffset);
+		return NULL;
+	}
+	src = (u8 *)dlthis->str_head +
+	    (soffset >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE));
+	if (soffset & 1)
+		*dst++ = *src++;	/* only 1 character in first word */
+	do {
+		tmp = *src++;
+		*dst = (tmp >> BITS_PER_BYTE)
+		if (!(*dst++))
+			break;
+	} while ((*dst++ = tmp & BYTE_MASK));
+
+	return dst;
+}
+
+/**************************************************************************
+ * Procedure expand_sec_names
+ *
+ * Parameters:
+ *  dlthis		Handle from DLOAD_module_open for this module
+ *
+ * Effect:
+ *    Allocates a buffer, unpacks and copies strings from string table into it.
+ * Stores a pointer to the buffer into a state variable.
+ **************************************************************************/
+static void expand_sec_names(struct dload_state *dlthis)
+{
+	char *xstrings, *curr, *next;
+	u32 xsize;
+	u16 sec;
+	struct LDR_SECTION_INFO *shp;
+	/* assume worst-case size requirement */
+	xsize = dlthis->dfile_hdr.df_max_str_len * dlthis->dfile_hdr.df_no_scns;
+	xstrings = (char *)dlthis->mysym->Allocate(dlthis->mysym, xsize);
+	if (xstrings == NULL) {
+		dload_error(dlthis, E_ALLOC, xsize);
+		return;
+	}
+	dlthis->xstrings = xstrings;
+	/* For each sec, copy and expand its name */
+	curr = xstrings;
+	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
+		shp = DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		next = unpack_sec_name(dlthis, *(u32 *) &shp->name, curr);
+		if (next == NULL)
+			break;	/* error */
+		shp->name = curr;
+		curr = next;
+	}
+}
+
+#endif
+
+/***************************************************************/
+/********************* EXPORTED FUNCTIONS **********************/
+/***************************************************************/
+
+/**************************************************************************
+ * Procedure DLOAD_module_open
+ *
+ * Parameters:
+ *	module	The input stream that supplies the module image
+ *	syms	Host-side malloc/free and error reporting functions.
+ *			Other methods are unused.
+ *
+ * Effect:
+ *	Reads header information from a dynamic loader module using the
+    specified
+ * stream object, and returns a handle for the module information.  This
+ * handle may be used in subsequent query calls to obtain information
+ * contained in the module.
+ *
+ * Returns:
+ *	NULL if an error is encountered, otherwise a module handle for use
+ * in subsequent operations.
+ **************************************************************************/
+DLOAD_module_info DLOAD_module_open(struct Dynamic_Loader_Stream *module,
+				    struct Dynamic_Loader_Sym *syms)
+{
+	struct dload_state *dlthis;	/* internal state for this call */
+	unsigned *dp, sz;
+	u32 sec_start;
+#if BITS_PER_AU <= BITS_PER_BYTE
+	u16 sec;
+#endif
+
+	/* Check that mandatory arguments are present */
+	if (!module || !syms) {
+		if (syms != NULL)
+			dload_syms_error(syms, "Required parameter is NULL");
+
+		return NULL;
+	}
+
+	dlthis = (struct dload_state *)
+		 syms->Allocate(syms, sizeof(struct dload_state));
+	if (!dlthis) {
+		/* not enough storage */
+		dload_syms_error(syms, "Can't allocate module info");
+		return NULL;
+	}
+
+	/* clear our internal state */
+	dp = (unsigned *)dlthis;
+	for (sz = sizeof(struct dload_state) / sizeof(unsigned);
+	     sz > 0; sz -= 1)
+		*dp++ = 0;
+
+	dlthis->strm = module;
+	dlthis->mysym = syms;
+
+	/* read in the doff image and store in our state variable */
+	dload_headers(dlthis);
+
+	if (!dlthis->dload_errcount)
+		dload_strings(dlthis, true);
+
+	/* skip ahead past the unread portion of the string table */
+	sec_start = sizeof(struct doff_filehdr_t) +
+		    sizeof(struct doff_verify_rec_t) +
+		    BYTE_TO_HOST(DOFF_ALIGN(dlthis->dfile_hdr.df_strtab_size));
+
+	if (dlthis->strm->set_file_posn(dlthis->strm, sec_start) != 0) {
+		dload_error(dlthis, E_SEEK, sec_start);
+		return NULL;
+	}
+
+	if (!dlthis->dload_errcount)
+		dload_sections(dlthis);
+
+	if (dlthis->dload_errcount) {
+		DLOAD_module_close(dlthis);	/* errors, blow off our state */
+		dlthis = NULL;
+		return NULL;
+	}
+#if BITS_PER_AU > BITS_PER_BYTE
+	/* Expand all section names from the string table into the   */
+	/* state variable, and convert section names from a relative */
+	/* string table offset to a pointers to the expanded string. */
+	expand_sec_names(dlthis);
+#else
+	/* Convert section names from a relative string table offset */
+	/* to a pointer into the string table.                       */
+	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
+		struct LDR_SECTION_INFO *shp =
+		    DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		shp->name = dlthis->str_head + *(u32 *)&shp->name;
+	}
+#endif
+
+	return dlthis;
+}
+
+/***************************************************************************
+ * Procedure DLOAD_GetSectionInfo
+ *
+ * Parameters:
+ *  minfo		Handle from DLOAD_module_open for this module
+ *	sectionName	Pointer to the string name of the section desired
+ *	sectionInfo	Address of a section info structure pointer to be
+ *			initialized
+ *
+ * Effect:
+ *	Finds the specified section in the module information, and initializes
+ * the provided struct LDR_SECTION_INFO pointer.
+ *
+ * Returns:
+ *	true for success, false for section not found
+ **************************************************************************/
+int DLOAD_GetSectionInfo(DLOAD_module_info minfo, const char *sectionName,
+		     const struct LDR_SECTION_INFO **const sectionInfo)
+{
+	struct dload_state *dlthis;
+	struct LDR_SECTION_INFO *shp;
+	u16 sec;
+
+	dlthis = (struct dload_state *)minfo;
+	if (!dlthis)
+		return false;
+
+	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
+		shp = DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		if (strcmp(sectionName, shp->name) == 0) {
+			*sectionInfo = shp;
+			return true;
+		}
+	}
+
+	return false;
+}
+
+#define IPH_SIZE (sizeof(struct image_packet_t) - sizeof(u32))
+#define REVERSE_REORDER_MAP(rawmap) ((rawmap) ^ 0x3030303)
+
+/**************************************************************************
+ * Procedure DLOAD_GetSection
+ *
+ * Parameters:
+ *  minfo		Handle from DLOAD_module_open for this module
+ *	sectionInfo	Pointer to a section info structure for the desired
+ *			section
+ *	sectionData	Buffer to contain the section initialized data
+ *
+ * Effect:
+ *	Copies the initialized data for the specified section into the
+ * supplied buffer.
+ *
+ * Returns:
+ *	true for success, false for section not found
+ **************************************************************************/
+int DLOAD_GetSection(DLOAD_module_info minfo,
+		 const struct LDR_SECTION_INFO *sectionInfo, void *sectionData)
+{
+	struct dload_state *dlthis;
+	u32 pos;
+	struct doff_scnhdr_t *sptr = NULL;
+	s32 nip;
+	struct image_packet_t ipacket;
+	s32 ipsize;
+	u32 checks;
+	s8 *dest = (s8 *)sectionData;
+
+	dlthis = (struct dload_state *)minfo;
+	if (!dlthis)
+		return false;
+	sptr = LDRSEC_IS_DOFFSEC(sectionInfo);
+	if (sptr == NULL)
+		return false;
+
+	/* skip ahead to the start of the first packet */
+	pos = BYTE_TO_HOST(DOFF_ALIGN((u32) sptr->ds_first_pkt_offset));
+	if (dlthis->strm->set_file_posn(dlthis->strm, pos) != 0) {
+		dload_error(dlthis, E_SEEK, pos);
+		return false;
+	}
+
+	nip = sptr->ds_nipacks;
+	while ((nip -= 1) >= 0) {	/* for each packet */
+		/* get the fixed header bits */
+		if (dlthis->strm->
+		    read_buffer(dlthis->strm, &ipacket, IPH_SIZE) != IPH_SIZE) {
+			dload_error(dlthis, E_READSTRM, "image packet");
+			return false;
+		}
+		/* reorder the header if need be */
+		if (dlthis->reorder_map)
+			dload_reorder(&ipacket, IPH_SIZE, dlthis->reorder_map);
+
+		/* Now read the packet image bits. Note: round the size up to
+		 * the next multiple of 4 bytes; this is what checksum
+		 * routines want. */
+		ipsize = BYTE_TO_HOST(DOFF_ALIGN(ipacket.i_packet_size));
+		if (ipsize > BYTE_TO_HOST(IMAGE_PACKET_SIZE)) {
+			dload_error(dlthis, E_ISIZ, ipsize);
+			return false;
+		}
+		if (dlthis->strm->read_buffer
+		    (dlthis->strm, dest, ipsize) != ipsize) {
+			dload_error(dlthis, E_READSTRM, "image packet");
+			return false;
+		}
+		/* reorder the bytes if need be */
+#if !defined(_BIG_ENDIAN) || (TARGET_AU_BITS > 16)
+		if (dlthis->reorder_map)
+			dload_reorder(dest, ipsize, dlthis->reorder_map);
+
+		checks = dload_checksum(dest, ipsize);
+#else
+		if (dlthis->dfile_hdr.df_byte_reshuffle !=
+		    TARGET_ORDER(REORDER_MAP(BYTE_RESHUFFLE_VALUE))) {
+			/* put image bytes in big-endian order, not PC order */
+			dload_reorder(dest, ipsize,
+				      TARGET_ORDER(dlthis->dfile_hdr.
+				      df_byte_reshuffle));
+		}
+#if TARGET_AU_BITS > 8
+		checks = dload_reverse_checksum_16(dest, ipsize);
+#else
+		checks = dload_reverse_checksum(dest, ipsize);
+#endif
+#endif
+		checks += dload_checksum(&ipacket, IPH_SIZE);
+
+		/* NYI: unable to handle relocation entries here.  Reloc
+		 * entries referring to fields that span the packet boundaries
+		 * may result in packets of sizes that are not multiple of
+		 * 4 bytes. Our checksum implementation works on 32-bit words
+		 * only.     */
+		if (ipacket.i_num_relocs != 0) {
+			dload_error(dlthis, E_RELOC, ipsize);
+			return false;
+		}
+
+		if (~checks) {
+			dload_error(dlthis, E_CHECKSUM, "image packet");
+			return false;
+		}
+
+		/*Advance destination ptr by the size of the just-read packet*/
+		dest += ipsize;
+	}
+
+	return true;
+}
+
+/***************************************************************************
+ * Procedure DLOAD_module_close
+ *
+ * Parameters:
+ *  minfo		Handle from DLOAD_module_open for this module
+ *
+ * Effect:
+ *	Releases any storage associated with the module handle.  On return,
+ * the module handle is invalid.
+ *
+ * Returns:
+ *	Zero for success. On error, the number of errors detected is returned.
+ * Individual errors are reported using syms->Error_Report(), where syms was
+ * an argument to DLOAD_module_open
+ **************************************************************************/
+void DLOAD_module_close(DLOAD_module_info minfo)
+{
+	struct dload_state *dlthis;
+
+	dlthis = (struct dload_state *)minfo;
+	if (!dlthis)
+		return;
+
+	if (dlthis->str_head)
+		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->str_head);
+
+	if (dlthis->sect_hdrs)
+		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->sect_hdrs);
+
+#if BITS_PER_AU > BITS_PER_BYTE
+	if (dlthis->xstrings)
+		dlthis->mysym->Deallocate(dlthis->mysym, dlthis->xstrings);
+
+#endif
+
+	dlthis->mysym->Deallocate(dlthis->mysym, dlthis);
+}
diff --git a/drivers/dsp/bridge/dynload/header.h b/drivers/dsp/bridge/dynload/header.h
new file mode 100644
index 0000000..0de744b
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/header.h
@@ -0,0 +1,59 @@
+/*
+ * header.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#define TRUE 1
+#define FALSE 0
+#ifndef NULL
+#define NULL 0
+#endif
+
+#include <linux/string.h>
+#define DL_STRCMP  strcmp
+
+/* maximum parenthesis nesting in relocation stack expressions */
+#define STATIC_EXPR_STK_SIZE 10
+
+#include <linux/types.h>
+typedef unsigned int            uint_least32_t;
+typedef unsigned short int	uint_least16_t;
+
+#include "doff.h"
+#include <dspbridge/dynamic_loader.h>
+#include "params.h"
+#include "dload_internal.h"
+#include "reloc_table.h"
+
+/*
+ * Plausibility limits
+ *
+ * These limits are imposed upon the input DOFF file as a check for validity.
+ * They are hard limits, in that the load will fail if they are exceeded.
+ * The numbers selected are arbitrary, in that the loader implementation does
+ * not require these limits.
+ */
+
+/* maximum number of bytes in string table */
+#define MAX_REASONABLE_STRINGTAB (0x100000)
+/* maximum number of code,data,etc. sections */
+#define MAX_REASONABLE_SECTIONS (200)
+/* maximum number of linker symbols */
+#define MAX_REASONABLE_SYMBOLS (100000)
+
+/* shift count to align F_BIG with DLOAD_LITTLE */
+#define ALIGN_COFF_ENDIANNESS 7
+#define ENDIANNESS_MASK (DF_BYTE_ORDER >> ALIGN_COFF_ENDIANNESS)
diff --git a/drivers/dsp/bridge/dynload/module_list.h b/drivers/dsp/bridge/dynload/module_list.h
new file mode 100644
index 0000000..2a3e475
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/module_list.h
@@ -0,0 +1,155 @@
+/*
+ * dspbridge/mpu_driver/src/dynload/module_list.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ * This C header file gives the layout of the data structure created by the
+ * dynamic loader to describe the set of modules loaded into the DSP.
+ *
+ * Linked List Structure:
+ * ----------------------
+ * The data structure defined here is a singly-linked list.  The list
+ * represents the set of modules which are currently loaded in the DSP memory.
+ * The first entry in the list is a header record which contains a flag
+ * representing the state of the list.  The rest of the entries in the list
+ * are module records.
+ *
+ * Global symbol  _DLModules designates the first record in the list (i.e. the
+ * header record).  This symbol must be defined in any program that wishes to
+ * use DLLview plug-in.
+ *
+ * String Representation:
+ * ----------------------
+ * The string names of the module and its sections are stored in a block of
+ * memory which follows the module record itself.  The strings are ordered:
+ * module name first, followed by section names in order from the first
+ * section to the last.  String names are tightly packed arrays of 8-bit
+ * characters (two characters per 16-bit word on the C55x).  Strings are
+ * zero-byte-terminated.
+ *
+ * Creating and updating the list:
+ * -------------------------------
+ * Upon loading a new module into the DSP memory the dynamic loader inserts a
+ * new module record as the first module record in the list.  The fields of
+ * this module record are initialized to reflect the properties of the module.
+ * The dynamic loader does NOT increment the flag/counter in the list's header
+ * record.
+ *
+ * Upon unloading a module from the DSP memory the dynamic loader removes the
+ * module's record from this list.  The dynamic loader also increments the
+ * flag/counter in the list's header record to indicate that the list has been
+ * changed.
+ */
+
+#ifndef _MODULE_LIST_H_
+#define _MODULE_LIST_H_
+
+#include <linux/types.h>
+
+/* Global pointer to the modules_header structure*/
+#define MODULES_HEADER "_DLModules"
+#define MODULES_HEADER_NO_UNDERSCORE "DLModules"
+
+/* Initial version number*/
+#define INIT_VERSION 1
+
+/* Verification number -- to be recorded in each module record */
+#define VERIFICATION 0x79
+
+/* forward declarations */
+struct dll_module;
+struct dll_sect;
+
+/* the first entry in the list is the modules_header record;
+ * its address is contained in the global _DLModules pointer */
+struct modules_header {
+
+	/* Address of the first dll_module record in the list or NULL.
+	 Note: for C55x this is a word address (C55x data is word-addressable)*/
+	u32 first_module;
+
+	/* Combined storage size (in target addressable units) of the
+	 * dll_module record which follows this header record, or zero
+	 * if the list is empty.  This size includes the module's string table.
+	 * Note: for C55x the unit is a 16-bit word */
+	u16 first_module_size;
+
+	/* Counter is incremented whenever a module record is removed from
+	 * the list */
+	u16 update_flag;
+
+} ;
+
+/* for each 32-bits in above structure, a bitmap, LSB first, whose bits are:
+ * 0 => a 32-bit value, 1 => 2 16-bit values */
+#define MODULES_HEADER_BITMAP 0x2 /* swapping bitmap for type modules_header */
+
+/* information recorded about each section in a module */
+struct dll_sect {
+
+	/* Load-time address of the section.
+	 * Note: for C55x this is a byte address for program sections, and
+	 * a word address for data sections.  C55x program memory is
+	 * byte-addressable, while data memory is word-addressable. */
+	u32 sect_load_adr;
+
+	/* Run-time address of the section.
+	 * Note 1: for C55x this is a byte address for program sections, and
+	 * a word address for data sections.
+	 * Note 2: for C55x two most significant bits of this field indicate
+	 * the section type: '00' for a code section, '11' for a data section
+	 * (C55 addresses are really only 24-bits wide). */
+	u32 sect_run_adr;
+
+} ;
+
+/* the rest of the entries in the list are module records */
+struct dll_module {
+
+	/* Address of the next dll_module record in the list, or 0 if this is
+	 * the last record in the list.
+	 * Note: for C55x this is a word address (C55x data is
+	 * word-addressable) */
+	u32 next_module;
+
+	/* Combined storage size (in target addressable units) of the
+	 * dll_module record which follows this one, or zero if this is the
+	 * last record in the list.  This size includes the module's string
+	 * table.
+	 * Note: for C55x the unit is a 16-bit word. */
+	u16 next_module_size;
+
+	/* version number of the tooling; set to INIT_VERSION for Phase 1 */
+	u16 version;
+
+	/* the verification word; set to VERIFICATION */
+	u16 verification;
+
+	/* Number of sections in the sects array */
+	u16 num_sects;
+
+	/* Module's "unique" id; copy of the timestamp from the host
+	 * COFF file */
+	u32 timestamp;
+
+	/* Array of num_sects elements of the module's section records */
+	struct dll_sect sects[1];
+} ;
+
+/* for each 32 bits in above structure, a bitmap, LSB first, whose bits are:
+ * 0 => a 32-bit value, 1 => 2 16-bit values */
+#define DLL_MODULE_BITMAP 0x6	/* swapping bitmap for type dll_module */
+
+#endif				/* _MODULE_LIST_H_ */
diff --git a/drivers/dsp/bridge/dynload/params.h b/drivers/dsp/bridge/dynload/params.h
new file mode 100644
index 0000000..92a2049
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/params.h
@@ -0,0 +1,226 @@
+/*
+ * params.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This file defines host and target properties for all machines
+ * supported by the dynamic loader.  To be tedious...
+ *
+ * host: the machine on which the dynamic loader runs
+ * target: the machine that the dynamic loader is loading
+ *
+ * Host and target may or may not be the same, depending upon the particular
+ * use.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/******************************************************************************
+ *
+ *							Host Properties
+ *
+ *****************************************************************************/
+
+#define BITS_PER_BYTE 8		/* bits in the standard PC/SUN byte */
+#define LOG_BITS_PER_BYTE 3	/* log base 2 of same */
+#define BYTE_MASK ((1U<<BITS_PER_BYTE)-1)
+
+#if defined(__TMS320C55X__) || defined(_TMS320C5XX)
+#define BITS_PER_AU 16
+#define LOG_BITS_PER_AU 4
+ /* use this print string in error messages for uint32_t */
+#define FMT_UI32 "0x%lx"
+#define FMT8_UI32 "%08lx"	/* same but no 0x, fixed width field */
+#else
+#define BITS_PER_AU 8	/* bits in the smallest addressable data storage unit */
+#define LOG_BITS_PER_AU 3  /* log base 2 of the same; useful for shift counts */
+#define FMT_UI32 "0x%x"
+#define FMT8_UI32 "%08x"
+#endif
+
+/* generic fastest method for swapping bytes and shorts */
+#define SWAP32BY16(zz) (((zz) << 16) | ((zz) >> 16))
+#define SWAP16BY8(zz) (((zz) << 8) | ((zz) >> 8))
+
+/* !! don't be tempted to insert type definitions here; use <stdint.h> !! */
+
+/******************************************************************************
+ *
+ *							Target Properties
+ *
+ *****************************************************************************/
+
+
+/*--------------------------------------------------------------------------*/
+/* TMS320C6x Target Specific Parameters (byte-addressable)                  */
+/*--------------------------------------------------------------------------*/
+#if TMS32060
+#define MEMORG          0x0L	/* Size of configured memory  */
+#define MEMSIZE         0x0L	/* (full address space)  */
+
+#define CINIT_ALIGN     8	/* alignment of cinit record in TDATA AUs */
+#define CINIT_COUNT	4	/* width of count field in TDATA AUs */
+#define CINIT_ADDRESS	4	/* width of address field in TDATA AUs */
+#define CINIT_PAGE_BITS	0	/* Number of LSBs of address that
+				 * are page number */
+
+#define LENIENT_SIGNED_RELEXPS 0	/* DOES SIGNED ALLOW MAX UNSIGNED   */
+
+#undef TARGET_ENDIANNESS	/* may be big or little endian */
+
+/* align a target address to a word boundary */
+#define TARGET_WORD_ALIGN(zz) (((zz) + 0x3) & -0x4)
+#endif
+
+
+/*--------------------------------------------------------------------------
+ *
+ *			DEFAULT SETTINGS and DERIVED PROPERTIES
+ *
+ * This section establishes defaults for values not specified above
+ *--------------------------------------------------------------------------*/
+#ifndef TARGET_AU_BITS
+#define TARGET_AU_BITS 8	/* width of the target addressable unit */
+#define LOG_TARGET_AU_BITS 3	/* log2 of same */
+#endif
+
+#ifndef CINIT_DEFAULT_PAGE
+#define CINIT_DEFAULT_PAGE 0	/* default .cinit page number */
+#endif
+
+#ifndef DATA_RUN2LOAD
+#define DATA_RUN2LOAD(zz) (zz)	/* translate data run address to load address */
+#endif
+
+#ifndef DBG_LIST_PAGE
+#define DBG_LIST_PAGE 0		/* page number for .dllview section */
+#endif
+
+#ifndef TARGET_WORD_ALIGN
+/* align a target address to a word boundary */
+#define TARGET_WORD_ALIGN(zz) (zz)
+#endif
+
+#ifndef TDATA_TO_TADDR
+#define TDATA_TO_TADDR(zz) (zz)	/* target data address to target AU address */
+#define TADDR_TO_TDATA(zz) (zz)	/* target AU address to target data address */
+#define TDATA_AU_BITS	TARGET_AU_BITS	/* bits per data AU */
+#define LOG_TDATA_AU_BITS	LOG_TARGET_AU_BITS
+#endif
+
+/*
+ *
+ * Useful properties and conversions derived from the above
+ *
+ */
+
+/*
+ * Conversions between host and target addresses
+ */
+#if LOG_BITS_PER_AU == LOG_TARGET_AU_BITS
+/* translate target addressable unit to host address */
+#define TADDR_TO_HOST(x) (x)
+/* translate host address to target addressable unit */
+#define HOST_TO_TADDR(x) (x)
+#elif LOG_BITS_PER_AU > LOG_TARGET_AU_BITS
+#define TADDR_TO_HOST(x) ((x) >> (LOG_BITS_PER_AU-LOG_TARGET_AU_BITS))
+#define HOST_TO_TADDR(x) ((x) << (LOG_BITS_PER_AU-LOG_TARGET_AU_BITS))
+#else
+#define TADDR_TO_HOST(x) ((x) << (LOG_TARGET_AU_BITS-LOG_BITS_PER_AU))
+#define HOST_TO_TADDR(x) ((x) >> (LOG_TARGET_AU_BITS-LOG_BITS_PER_AU))
+#endif
+
+#if LOG_BITS_PER_AU == LOG_TDATA_AU_BITS
+/* translate target addressable unit to host address */
+#define TDATA_TO_HOST(x) (x)
+/* translate host address to target addressable unit */
+#define HOST_TO_TDATA(x) (x)
+/* translate host address to target addressable unit, round up */
+#define HOST_TO_TDATA_ROUND(x) (x)
+/* byte offset to host offset, rounded up for TDATA size */
+#define BYTE_TO_HOST_TDATA_ROUND(x) BYTE_TO_HOST_ROUND(x)
+#elif LOG_BITS_PER_AU > LOG_TDATA_AU_BITS
+#define TDATA_TO_HOST(x) ((x) >> (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))
+#define HOST_TO_TDATA(x) ((x) << (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))
+#define HOST_TO_TDATA_ROUND(x) ((x) << (LOG_BITS_PER_AU-LOG_TDATA_AU_BITS))
+#define BYTE_TO_HOST_TDATA_ROUND(x) BYTE_TO_HOST_ROUND(x)
+#else
+#define TDATA_TO_HOST(x) ((x) << (LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))
+#define HOST_TO_TDATA(x) ((x) >> (LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))
+#define HOST_TO_TDATA_ROUND(x) (((x) +\
+				(1<<(LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))-1) >>\
+				(LOG_TDATA_AU_BITS-LOG_BITS_PER_AU))
+#define BYTE_TO_HOST_TDATA_ROUND(x) (BYTE_TO_HOST((x) +\
+	(1<<(LOG_TDATA_AU_BITS-LOG_BITS_PER_BYTE))-1) &\
+	-(TDATA_AU_BITS/BITS_PER_AU))
+#endif
+
+/*
+ * Input in DOFF format is always expresed in bytes, regardless of loading host
+ * so we wind up converting from bytes to target and host units even when the
+ * host is not a byte machine.
+ */
+#if LOG_BITS_PER_AU == LOG_BITS_PER_BYTE
+#define BYTE_TO_HOST(x) (x)
+#define BYTE_TO_HOST_ROUND(x) (x)
+#define HOST_TO_BYTE(x) (x)
+#elif LOG_BITS_PER_AU >= LOG_BITS_PER_BYTE
+#define BYTE_TO_HOST(x) ((x) >> (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))
+#define BYTE_TO_HOST_ROUND(x) ((x + (BITS_PER_AU/BITS_PER_BYTE-1)) >>\
+			      (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))
+#define HOST_TO_BYTE(x) ((x) << (LOG_BITS_PER_AU - LOG_BITS_PER_BYTE))
+#else
+/* lets not try to deal with sub-8-bit byte machines */
+#endif
+
+#if LOG_TARGET_AU_BITS == LOG_BITS_PER_BYTE
+/* translate target addressable unit to byte address */
+#define TADDR_TO_BYTE(x) (x)
+/* translate byte address to target addressable unit */
+#define BYTE_TO_TADDR(x) (x)
+#elif LOG_TARGET_AU_BITS > LOG_BITS_PER_BYTE
+#define TADDR_TO_BYTE(x) ((x) << (LOG_TARGET_AU_BITS-LOG_BITS_PER_BYTE))
+#define BYTE_TO_TADDR(x) ((x) >> (LOG_TARGET_AU_BITS-LOG_BITS_PER_BYTE))
+#else
+/* lets not try to deal with sub-8-bit byte machines */
+#endif
+
+#ifdef _BIG_ENDIAN
+#define HOST_ENDIANNESS 1
+#else
+#define HOST_ENDIANNESS 0
+#endif
+
+#ifdef TARGET_ENDIANNESS
+#define TARGET_ENDIANNESS_DIFFERS(rtend) (HOST_ENDIANNESS^TARGET_ENDIANNESS)
+#elif HOST_ENDIANNESS
+#define TARGET_ENDIANNESS_DIFFERS(rtend) (!(rtend))
+#else
+#define TARGET_ENDIANNESS_DIFFERS(rtend) (rtend)
+#endif
+
+/* the unit in which we process target image data */
+#if TARGET_AU_BITS <= 8
+typedef u8 TgtAU_t;
+#elif TARGET_AU_BITS <= 16
+typedef u16 TgtAU_t;
+#else
+typedef u32 TgtAU_t;
+#endif
+
+/* size of that unit */
+#if TARGET_AU_BITS < BITS_PER_AU
+#define TGTAU_BITS BITS_PER_AU
+#define LOG_TGTAU_BITS LOG_BITS_PER_AU
+#else
+#define TGTAU_BITS TARGET_AU_BITS
+#define LOG_TGTAU_BITS LOG_TARGET_AU_BITS
+#endif
diff --git a/drivers/dsp/bridge/dynload/reloc.c b/drivers/dsp/bridge/dynload/reloc.c
new file mode 100644
index 0000000..b9e2a9b
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/reloc.c
@@ -0,0 +1,477 @@
+/*
+ * reloc.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "header.h"
+
+#if TMS32060
+/* the magic symbol for the start of BSS */
+static const char BSSSYMBOL[] = {".bss"};
+#endif
+
+#if TMS32060
+#include "reloc_table_c6000.c"
+#endif
+
+#if TMS32060
+/* From coff.h - ignore these relocation operations */
+#define R_C60ALIGN     0x76       /* C60: Alignment info for compressor   */
+#define R_C60FPHEAD    0x77       /* C60: Explicit assembly directive     */
+#define R_C60NOCMP    0x100       /* C60: Don't compress this code scn    */
+#endif
+
+/**************************************************************************
+ * Procedure dload_unpack
+ *
+ * Parameters:
+ *	data	pointer to storage unit containing lowest host address of
+ *		image data
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
+ *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
+ *
+ * Effect:
+ *	Extracts the specified field and returns it.
+ **************************************************************************/
+RVALUE dload_unpack(struct dload_state *dlthis, TgtAU_t *data, int fieldsz,
+		    int offset, unsigned sgn)
+{
+	register RVALUE objval;
+	register int shift, direction;
+	register TgtAU_t *dp = data;
+
+	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value*/
+	/* * collect up enough bits to contain the desired field */
+	if (TARGET_BIG_ENDIAN) {
+		dp += (fieldsz + offset) >> LOG_TGTAU_BITS;
+		direction = -1;
+	} else
+		direction = 1;
+	objval = *dp >> offset;
+	shift = TGTAU_BITS - offset;
+	while (shift <= fieldsz) {
+		dp += direction;
+		objval += (RVALUE)*dp << shift;
+		shift += TGTAU_BITS;
+	}
+
+	/* * sign or zero extend the value appropriately */
+	if (sgn == ROP_UNS)
+		objval &= (2 << fieldsz) - 1;
+	else {
+		shift = sizeof(RVALUE) * BITS_PER_AU-1 - fieldsz;
+		objval = (objval << shift) >> shift;
+	}
+
+	return objval;
+
+} /* dload_unpack */
+
+
+/**************************************************************************
+ * Procedure dload_repack
+ *
+ * Parameters:
+ *	val		Value to insert
+ *	data	Pointer to storage unit containing lowest host address of
+ * 		image data
+ *	fieldsz	Size of bit field, 0 < fieldsz <= sizeof(RVALUE)*BITS_PER_AU
+ *	offset	Offset from LSB, 0 <= offset < BITS_PER_AU
+ *	sgn	Signedness of the field (ROP_SGN, ROP_UNS, ROP_MAX, ROP_ANY)
+ *
+ * Effect:
+ *	Stuffs the specified value in the specified field.  Returns 0 for
+ *	success
+ * or 1 if the value will not fit in the specified field according to the
+ * specified signedness rule.
+ **************************************************************************/
+static const unsigned char ovf_limit[] = {1, 2, 2};
+int dload_repack(struct dload_state *dlthis, RVALUE val, TgtAU_t *data,
+		 int fieldsz, int offset, unsigned sgn)
+{
+	register URVALUE objval, mask;
+	register int shift, direction;
+	register TgtAU_t *dp = data;
+
+
+	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
+	/* clip the bits */
+	mask = ((UINT32_C(2) << fieldsz) - 1);
+	objval = (val & mask);
+	/* * store the bits through the specified mask */
+	if (TARGET_BIG_ENDIAN) {
+		dp += (fieldsz + offset) >> LOG_TGTAU_BITS;
+		direction = -1;
+	} else
+		direction = 1;
+
+	/* insert LSBs */
+	*dp = (*dp & ~(mask << offset)) + (objval << offset);
+	shift = TGTAU_BITS-offset;
+	/* align mask and objval with AU boundary */
+	objval >>= shift;
+	mask >>= shift;
+
+	while (mask) {
+		dp += direction;
+		*dp = (*dp & ~mask) + objval;
+		objval >>= TGTAU_BITS;
+		mask >>= TGTAU_BITS;
+	}
+
+	/*
+	 * check for overflow
+	 */
+	if (sgn) {
+		unsigned tmp = (val >> fieldsz) + (sgn & 0x1);
+		if (tmp > ovf_limit[sgn-1])
+			return 1;
+	}
+	return 0;
+
+} /* dload_repack */
+
+/* lookup table for the scaling amount in a C6x instruction */
+#if TMS32060
+#define SCALE_BITS 4		/* there are 4 bits in the scale field */
+#define SCALE_MASK 0x7		/* we really only use the bottom 3 bits */
+static const u8 C60_Scale[SCALE_MASK+1] = {
+	1, 0, 0, 0, 1, 1, 2, 2
+};
+#endif
+
+/**************************************************************************
+ * Procedure dload_relocate
+ *
+ * Parameters:
+ *	data	Pointer to base of image data
+ *	rp		Pointer to relocation operation
+ *
+ * Effect:
+ *	Performs the specified relocation operation
+ **************************************************************************/
+void dload_relocate(struct dload_state *dlthis, TgtAU_t *data,
+			struct reloc_record_t *rp, bool *tramps_genereted,
+			bool second_pass)
+{
+	RVALUE val, reloc_amt, orig_val = 0;
+	unsigned int fieldsz = 0;
+	unsigned int offset = 0;
+	unsigned int reloc_info = 0;
+	unsigned int reloc_action = 0;
+	register int rx = 0;
+	RVALUE    *stackp = NULL;
+	int top;
+	struct Local_Symbol *svp = NULL;
+#ifdef RFV_SCALE
+	unsigned int scale = 0;
+#endif
+	struct image_packet_t *img_pkt = NULL;
+
+	/* The image packet data struct is only used during first pass
+	  * relocation in the event that a trampoline is needed.  2nd pass
+	  * relocation doesn't guarantee that data is coming from an
+	  * image_packet_t structure. See cload.c, dload_data for how i_bits is
+	  * set. If that changes this needs to be updated!!!  */
+	if (second_pass == false)
+		img_pkt = (struct image_packet_t *)((u8 *)data -
+				sizeof(struct image_packet_t));
+
+
+	rx = HASH_FUNC(rp->r_type);
+	while (rop_map1[rx] != rp->r_type) {
+		rx = HASH_L(rop_map2[rx]);
+		if (rx < 0) {
+#if TMS32060
+			switch (rp->r_type) {
+			case R_C60ALIGN:
+			case R_C60NOCMP:
+			case R_C60FPHEAD:
+				/* Ignore these reloc types and return */
+				break;
+			default:
+				/* Unknown reloc type, print error and return */
+				dload_error(dlthis, "Bad coff operator 0x%x",
+						rp->r_type);
+			}
+#else
+			dload_error(dlthis, "Bad coff operator 0x%x",
+					rp->r_type);
+#endif
+			return;
+		}
+	}
+	rx = HASH_I(rop_map2[rx]);
+	if ((rx < (sizeof(rop_action)/sizeof(uint_least16_t)))
+	   && (rx < (sizeof(rop_info)/sizeof(uint_least16_t))) && (rx > 0)) {
+		reloc_action = rop_action[rx]; reloc_info = rop_info[rx];
+	} else {
+		dload_error(dlthis, "Buffer Overflow - Array Index Out "
+				"of Bounds");
+	}
+
+	/* Compute the relocation amount for the referenced symbol, if any */
+	reloc_amt = rp->r_uval;
+	if (RFV_SYM(reloc_info)) {	/* relocation uses a symbol reference */
+		/* If this is first pass, use the module local symbol table,
+		  * else use the trampoline symbol table.  */
+	       if (second_pass == false) {
+			if ((u32)rp->r_symndx < dlthis->dfile_hdr.df_no_syms) {
+				/* real symbol reference */
+				svp = &dlthis->local_symtab[rp->r_symndx];
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+					    svp->delta : svp->value;
+			}
+			/* reloc references current section */
+			else if (rp->r_symndx == -1) {
+				reloc_amt = (RFV_SYM(reloc_info) == ROP_SYMD) ?
+				dlthis->delta_runaddr :
+				dlthis->image_secn->run_addr;
+			}
+		}
+	}	/* relocation uses a symbol reference */
+	/* Handle stack adjustment */
+	val = 0;
+	top = RFV_STK(reloc_info);
+	if (top) {
+		top += dlthis->relstkidx - RSTK_UOP;
+		if (top >= STATIC_EXPR_STK_SIZE) {
+			dload_error(dlthis,
+			"Expression stack overflow in %s at offset "
+			FMT_UI32, dlthis->image_secn->name,
+			rp->r_vaddr + dlthis->image_offset);
+			return;
+		}
+		val = dlthis->relstk[dlthis->relstkidx];
+		dlthis->relstkidx = top;
+		stackp = &dlthis->relstk[top];
+	}
+	/* Derive field position and size, if we need them */
+	if (reloc_info & ROP_RW) {	/* read or write action in our future */
+		fieldsz = RFV_WIDTH(reloc_action);
+		if (fieldsz) {	/* field info from table */
+			offset = RFV_POSN(reloc_action);
+			if (TARGET_BIG_ENDIAN)
+				/* make sure r_vaddr is the lowest target
+				 * address containing bits */
+				rp->r_vaddr += RFV_BIGOFF(reloc_info);
+		} else {	/* field info from relocation op */
+			fieldsz = rp->r_fieldsz; offset = rp->r_offset;
+			if (TARGET_BIG_ENDIAN)
+				/* make sure r_vaddr is the lowest target
+				   address containing bits */
+				rp->r_vaddr += (rp->r_wordsz - offset - fieldsz)
+						>> LOG_TARGET_AU_BITS;
+		}
+		data = (TgtAU_t *)((char *)data + TADDR_TO_HOST(rp->r_vaddr));
+		/* compute lowest host location of referenced data */
+#if BITS_PER_AU > TARGET_AU_BITS
+		/* conversion from target address to host address may lose
+		   address bits; add loss to offset */
+		if (TARGET_BIG_ENDIAN) {
+			offset += -((rp->r_vaddr << LOG_TARGET_AU_BITS) +
+				  offset + fieldsz) &
+				  (BITS_PER_AU-TARGET_AU_BITS);
+		} else {
+			offset += (rp->r_vaddr << LOG_TARGET_AU_BITS) &
+				  (BITS_PER_AU-1);
+		}
+#endif
+#ifdef RFV_SCALE
+		scale = RFV_SCALE(reloc_info);
+#endif
+	}
+	/* read the object value from the current image, if so ordered */
+	if (reloc_info & ROP_R) {    /* relocation reads current image value */
+		val = dload_unpack(dlthis, data, fieldsz, offset,
+		      RFV_SIGN(reloc_info));
+	/* Save off the original value in case the relo overflows and
+	  * we can trampoline it.  */
+	orig_val = val;
+
+#ifdef RFV_SCALE
+		val <<= scale;
+#endif
+	}
+	/* perform the necessary arithmetic */
+	switch (RFV_ACTION(reloc_action)) {	/* relocation actions */
+	case RACT_VAL:
+		break;
+	case RACT_ASGN:
+		val = reloc_amt;
+		break;
+	case RACT_ADD:
+		val += reloc_amt;
+		break;
+	case RACT_PCR:
+		/*-----------------------------------------------------------
+		 * Handle special cases of jumping from absolute sections
+		 * (special reloc type) or to absolute destination
+		 * (symndx == -1).  In either case, set the appropriate
+		 * relocation amount to 0.
+		 *-----------------------------------------------------------*/
+		if (rp->r_symndx == -1)
+			reloc_amt = 0;
+		val += reloc_amt - dlthis->delta_runaddr;
+		break;
+	case RACT_ADDISP:
+		val += rp->r_disp + reloc_amt;
+		break;
+	case RACT_ASGPC:
+		val = dlthis->image_secn->run_addr + reloc_amt;
+		break;
+	case RACT_PLUS:
+		if (stackp != NULL)
+			val += *stackp;
+		break;
+	case RACT_SUB:
+		if (stackp != NULL)
+			val = *stackp - val;
+		break;
+	case RACT_NEG:
+		val = -val;
+		break;
+	case RACT_MPY:
+		if (stackp != NULL)
+			val *= *stackp;
+		break;
+	case RACT_DIV:
+		if (stackp != NULL)
+			val = *stackp / val;
+		break;
+	case RACT_MOD:
+		if (stackp != NULL)
+			val = *stackp % val;
+		break;
+	case RACT_SR:
+		if (val >= sizeof(RVALUE) * BITS_PER_AU)
+			val = 0;
+		else if (stackp != NULL)
+			val = (URVALUE)*stackp >> val;
+		break;
+	case RACT_ASR:
+		if (val >= sizeof(RVALUE)*BITS_PER_AU)
+			val = sizeof(RVALUE)*BITS_PER_AU - 1;
+		else if (stackp != NULL)
+			val = *stackp >> val;
+		break;
+	case RACT_SL:
+		if (val >= sizeof(RVALUE)*BITS_PER_AU)
+			val = 0;
+		else if (stackp != NULL)
+			val = *stackp << val;
+		break;
+	case RACT_AND:
+		if (stackp != NULL)
+			val &= *stackp;
+		break;
+	case RACT_OR:
+		if (stackp != NULL)
+			val |= *stackp;
+		break;
+	case RACT_XOR:
+		if (stackp != NULL)
+			val ^= *stackp;
+		break;
+	case RACT_NOT:
+		val = ~val;
+		break;
+#if TMS32060
+	case RACT_C6SECT:
+		/* actually needed address of secn containing symbol */
+		if (svp != NULL) {
+			if (rp->r_symndx >= 0)
+				if (svp->secnn > 0)
+					reloc_amt = dlthis->ldr_sections
+						[svp->secnn-1].run_addr;
+		}
+	/* !!! FALL THRU !!! */
+	case RACT_C6BASE:
+		if (dlthis->bss_run_base == 0) {
+			struct dynload_symbol *symp;
+			symp = dlthis->mysym->Find_Matching_Symbol
+				(dlthis->mysym, BSSSYMBOL);
+			/* lookup value of global BSS base */
+			if (symp)
+				dlthis->bss_run_base = symp->value;
+			else
+				dload_error(dlthis,
+				     "Global BSS base referenced in %s offset"\
+				     FMT_UI32 " but not defined",
+				     dlthis->image_secn->name,
+				     rp->r_vaddr + dlthis->image_offset);
+		}
+		reloc_amt -= dlthis->bss_run_base;
+		/* !!! FALL THRU !!! */
+	case RACT_C6DSPL:
+		/* scale factor determined by 3 LSBs of field */
+		scale = C60_Scale[val & SCALE_MASK];
+		offset += SCALE_BITS;
+		fieldsz -= SCALE_BITS;
+		val >>= SCALE_BITS;	/* ignore the scale field hereafter */
+		val <<= scale;
+		val += reloc_amt;		/* do the usual relocation */
+		if (((1 << scale)-1) & val)
+			dload_error(dlthis,
+				"Unaligned reference in %s offset " FMT_UI32,
+				dlthis->image_secn->name,
+				rp->r_vaddr + dlthis->image_offset);
+		break;
+#endif
+	}	/* relocation actions */
+	/* * Put back result as required */
+	if (reloc_info & ROP_W) {	/* relocation writes image value */
+#ifdef RFV_SCALE
+		val >>= scale;
+#endif
+		if (dload_repack(dlthis, val, data, fieldsz, offset,
+		   RFV_SIGN(reloc_info))) {
+			/* Check to see if this relo can be trampolined,
+			  * but only in first phase relocation.  2nd phase
+			  * relocation cannot trampoline.  */
+			if ((second_pass == false) &&
+				(dload_tramp_avail(dlthis, rp) == true)) {
+
+				/* Before generating the trampoline, restore
+				  * the value to its original so the 2nd pass
+				  *  relo will work.  */
+				dload_repack(dlthis, orig_val, data, fieldsz,
+					offset, RFV_SIGN(reloc_info));
+				if (!dload_tramp_generate(dlthis,
+					(dlthis->image_secn - dlthis->
+					ldr_sections), dlthis->image_offset,
+					img_pkt, rp)) {
+					dload_error(dlthis, "Failed to "
+					     "generate trampoline for bit "
+					     "overflow");
+					dload_error(dlthis, "Relocation value "
+					   FMT_UI32 " overflows %d bits in %s "
+					   "offset " FMT_UI32, val, fieldsz,
+					   dlthis->image_secn->name,
+					   dlthis->image_offset + rp->r_vaddr);
+				} else
+					*tramps_genereted = true;
+			} else {
+				dload_error(dlthis, "Relocation value "
+					FMT_UI32 " overflows %d bits in %s"
+					" offset " FMT_UI32, val, fieldsz,
+					dlthis->image_secn->name,
+					dlthis->image_offset + rp->r_vaddr);
+			}
+		}
+	} else if (top)
+		*stackp = val;
+} /* reloc_value */
+
diff --git a/drivers/dsp/bridge/dynload/reloc_table.h b/drivers/dsp/bridge/dynload/reloc_table.h
new file mode 100644
index 0000000..6326146
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/reloc_table.h
@@ -0,0 +1,102 @@
+/*
+ * reloc_table.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef __RELOC_TABLE_H__
+#define __RELOC_TABLE_H__
+/*
+ * Table of relocation operator properties
+ */
+#include <linux/types.h>
+
+/* How does this relocation operation access the program image? */
+#define ROP_N	0		/* does not access image */
+#define ROP_R	1		/* read from image */
+#define ROP_W	2		/* write to image */
+#define ROP_RW	3		/* read from and write to image */
+
+/* For program image access, what are the overflow rules for the bit field? */
+/* Beware! Procedure repack depends on this encoding */
+#define ROP_ANY	0		/* no overflow ever, just truncate the value */
+#define ROP_SGN	1		/* signed field */
+#define ROP_UNS	2		/* unsigned field */
+#define ROP_MAX 3	  /* allow maximum range of either signed or unsigned */
+
+/* How does the relocation operation use the symbol reference */
+#define ROP_IGN	0		/* no symbol is referenced */
+#define ROP_LIT 0		/* use rp->r_uval literal field */
+#define ROP_SYM	1		/* symbol value is used in relocation */
+#define ROP_SYMD 2		/* delta value vs last link is used */
+
+/* How does the reloc op use the stack? */
+#define RSTK_N 0		/* Does not use */
+#define RSTK_POP 1		/* Does a POP */
+#define RSTK_UOP 2		/* Unary op, stack position unaffected */
+#define RSTK_PSH 3		/* Does a push */
+
+/*
+ * Computational actions performed by the dynamic loader
+ */
+enum Dload_Actions {
+	RACT_VAL,    /* don't alter the current val (from stack or mem fetch) */
+	RACT_ASGN,   /* set value to reference amount (from symbol reference) */
+	RACT_ADD,		/* add reference to value */
+	RACT_PCR,		/* add reference minus PC delta to value */
+	RACT_ADDISP,		/* add reference plus r_disp */
+	RACT_ASGPC,	/* set value to section address plus reference */
+
+	RACT_PLUS,		/* stack + */
+	RACT_SUB,		/* stack - */
+	RACT_NEG,		/* stack unary - */
+
+	RACT_MPY,		/* stack * */
+	RACT_DIV,		/* stack / */
+	RACT_MOD,		/* stack % */
+
+	RACT_SR,		/* stack unsigned >> */
+	RACT_ASR,		/* stack signed >> */
+	RACT_SL,		/* stack << */
+	RACT_AND,		/* stack & */
+	RACT_OR,		/* stack | */
+	RACT_XOR,		/* stack ^ */
+	RACT_NOT,		/* stack ~ */
+	RACT_C6SECT,		/* for C60 R_SECT op */
+	RACT_C6BASE,		/* for C60 R_BASE op */
+	RACT_C6DSPL,		/* for C60 scaled 15-bit displacement */
+	RACT_PCR23T		/* for ARM Thumb long branch */
+};
+
+/*
+ * macros used to extract values
+ */
+#define RFV_POSN(aaa) ((aaa) & 0xF)
+#define RFV_WIDTH(aaa) (((aaa) >> 4) & 0x3F)
+#define RFV_ACTION(aaa) ((aaa) >> 10)
+
+#define RFV_SIGN(iii) (((iii) >> 2) & 0x3)
+#define RFV_SYM(iii) (((iii) >> 4) & 0x3)
+#define RFV_STK(iii) (((iii) >> 6) & 0x3)
+#define RFV_ACCS(iii) ((iii) & 0x3)
+
+#if (TMS32060)
+#define RFV_SCALE(iii) ((iii) >> 11)
+#define RFV_BIGOFF(iii) (((iii) >> 8) & 0x7)
+#else
+#define RFV_BIGOFF(iii) ((iii) >> 8)
+#endif
+
+#endif				/* __RELOC_TABLE_H__ */
diff --git a/drivers/dsp/bridge/dynload/reloc_table_c6000.c b/drivers/dsp/bridge/dynload/reloc_table_c6000.c
new file mode 100644
index 0000000..978834c
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/reloc_table_c6000.c
@@ -0,0 +1,258 @@
+/*
+ * reloc_table_c6000.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+/* Tables generated for c6000 */
+
+#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+#define HASH_L(zz) ((zz) >> 8)
+#define HASH_I(zz) ((zz) & 0xFF)
+
+static const u16 rop_map1[] = {
+	0,
+	1,
+	2,
+	20,
+	4,
+	5,
+	6,
+	15,
+	80,
+	81,
+	82,
+	83,
+	84,
+	85,
+	86,
+	87,
+	17,
+	18,
+	19,
+	21,
+	16,
+	16394,
+	16404,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	32,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	40,
+	112,
+	113,
+	65535,
+	16384,
+	16385,
+	16386,
+	16387,
+	16388,
+	16389,
+	16390,
+	16391,
+	16392,
+	16393,
+	16395,
+	16396,
+	16397,
+	16398,
+	16399,
+	16400,
+	16401,
+	16402,
+	16403,
+	16405,
+	16406,
+	65535,
+	65535,
+	65535
+};
+
+static const s16 rop_map2[] = {
+	-256,
+	-255,
+	-254,
+	-245,
+	-253,
+	-252,
+	-251,
+	-250,
+	-241,
+	-240,
+	-239,
+	-238,
+	-237,
+	-236,
+	1813,
+	5142,
+	-248,
+	-247,
+	778,
+	-244,
+	-249,
+	-221,
+	-211,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-243,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-1,
+	-242,
+	-233,
+	-232,
+	-1,
+	-231,
+	-230,
+	-229,
+	-228,
+	-227,
+	-226,
+	-225,
+	-224,
+	-223,
+	5410,
+	-220,
+	-219,
+	-218,
+	-217,
+	-216,
+	-215,
+	-214,
+	-213,
+	5676,
+	-210,
+	-209,
+	-1,
+	-1,
+	-1
+};
+
+static const u16 rop_action[] = {
+	2560,
+	2304,
+	2304,
+	2432,
+	2432,
+	2560,
+	2176,
+	2304,
+	2560,
+	3200,
+	3328,
+	3584,
+	3456,
+	2304,
+	4208,
+	20788,
+	21812,
+	3415,
+	3245,
+	2311,
+	4359,
+	19764,
+	2311,
+	3191,
+	3280,
+	6656,
+	7680,
+	8704,
+	9728,
+	10752,
+	11776,
+	12800,
+	13824,
+	14848,
+	15872,
+	16896,
+	17920,
+	18944,
+	0,
+	0,
+	0,
+	0,
+	1536,
+	1536,
+	1536,
+	5632,
+	512,
+	0
+};
+
+static const u16 rop_info[] = {
+	0,
+	35,
+	35,
+	35,
+	35,
+	35,
+	35,
+	35,
+	35,
+	39,
+	39,
+	39,
+	39,
+	35,
+	34,
+	283,
+	299,
+	4135,
+	4391,
+	291,
+	33059,
+	283,
+	295,
+	4647,
+	4135,
+	64,
+	64,
+	128,
+	64,
+	64,
+	64,
+	64,
+	64,
+	64,
+	64,
+	64,
+	64,
+	128,
+	201,
+	197,
+	74,
+	70,
+	208,
+	196,
+	200,
+	192,
+	192,
+	66
+};
diff --git a/drivers/dsp/bridge/dynload/tramp.c b/drivers/dsp/bridge/dynload/tramp.c
new file mode 100644
index 0000000..c2fe02d
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/tramp.c
@@ -0,0 +1,1118 @@
+/*
+ * tramp.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2009 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "header.h"
+
+#if TMS32060
+#include "tramp_table_c6000.c"
+#endif
+
+#define MAX_RELOS_PER_PASS	4
+
+/*
+ * Function:	priv_tramp_sect_tgt_alloc
+ * Description: Allocate target memory for the trampoline section.  The
+ *	  target mem size is easily obtained as the next available address.
+ */
+static int priv_tramp_sect_tgt_alloc(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct LDR_SECTION_INFO	*sect_info;
+
+	/*  Populate the trampoline loader section and allocate it on the
+	 * target.  The section name is ALWAYS the first string in the final
+	 * string table for trampolines.  The trampoline section is always
+	 * 1 beyond the total number of allocated sections.  */
+	sect_info = &dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	sect_info->name = dlthis->tramp.final_string_table;
+	sect_info->size = dlthis->tramp.tramp_sect_next_addr;
+	sect_info->context = 0;
+	sect_info->type =
+		(4 << 8) | DLOAD_TEXT | DS_ALLOCATE_MASK | DS_DOWNLOAD_MASK;
+	sect_info->page = 0;
+	sect_info->run_addr = 0;
+	sect_info->load_addr = 0;
+	ret_val = dlthis->myalloc->Allocate(dlthis->myalloc,
+			sect_info, DS_ALIGNMENT(sect_info->type));
+
+	if (ret_val == 0)
+		dload_error(dlthis, "Failed to allocate target memory for"
+							" trampoline");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_h2a
+ * Description: Helper function to convert a hex value to its ASCII
+ *	  representation.  Used for trampoline symbol name generation.
+ */
+static u8 priv_h2a(u8 value)
+{
+	if (value > 0xF)
+		return 0xFF;
+
+	if (value <= 9)
+		value += 0x30;
+	else
+		value += 0x37;
+
+	return value;
+}
+
+/*
+ * Function:	priv_tramp_sym_gen_name
+ * Description: Generate a trampoline symbol name (ASCII) using the value
+ *	  of the symbol.  This places the new name into the user buffer.
+ *	  The name is fixed in length and of the form: __$dbTR__xxxxxxxx
+ *	  (where "xxxxxxxx" is the hex value.
+ */
+static void priv_tramp_sym_gen_name(u32 value, char *dst)
+{
+	u32 i;
+	volatile char *prefix = TRAMP_SYM_PREFIX;
+	volatile char *dst_local = dst;
+	u8 tmp;
+
+	/*  Clear out the destination, including the ending NULL  */
+	for (i = 0; i < (TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN); i++)
+		*(dst_local + i) = 0;
+
+	/*  Copy the prefix to start  */
+	for (i = 0; i < strlen(TRAMP_SYM_PREFIX); i++) {
+		*dst_local = *(prefix + i);
+		dst_local++;
+	}
+
+	/*  Now convert the value passed in to a string equiv of the hex  */
+	for (i = 0; i < sizeof(value); i++) {
+#ifndef _BIG_ENDIAN
+		tmp = *(((u8 *)&value) + (sizeof(value) - 1) - i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#else
+		tmp = *(((u8 *)&value) + i);
+		*dst_local = priv_h2a((tmp & 0xF0) >> 4);
+		dst_local++;
+		*dst_local = priv_h2a(tmp & 0x0F);
+		dst_local++;
+#endif
+	}
+
+	/*  NULL terminate  */
+	*dst_local = 0;
+}
+
+/*
+ * Function:	priv_tramp_string_create
+ * Description: Create a new string specific to the trampoline loading and add
+ *	  it to the trampoline string list.  This list contains the
+ *	  trampoline section name and trampoline point symbols.
+ */
+static struct tramp_string *priv_tramp_string_create(struct dload_state *dlthis,
+	  u32 str_len, char *str)
+{
+	struct tramp_string *new_string = NULL;
+	u32 i;
+
+	/*  Create a new string object with the specified size.  */
+	new_string = (struct tramp_string *)dlthis->mysym->Allocate(
+		dlthis->mysym, (sizeof(struct tramp_string) + str_len + 1));
+	if (new_string != NULL) {
+		/*  Clear the string first.  This ensures the ending NULL is
+		 * present and the optimizer won't touch it.  */
+		for (i = 0; i < (sizeof(struct tramp_string) + str_len + 1);
+				i++)
+			*((u8 *)new_string + i) = 0;
+
+		/*  Add this string to our virtual table by assigning it the
+		 * next index and pushing it to the tail of the list.  */
+		new_string->index = dlthis->tramp.tramp_string_next_index;
+		dlthis->tramp.tramp_string_next_index++;
+		dlthis->tramp.tramp_string_size += str_len + 1;
+
+		new_string->next = NULL;
+		if (dlthis->tramp.string_head == NULL)
+			dlthis->tramp.string_head = new_string;
+		else
+			dlthis->tramp.string_tail->next = new_string;
+
+		dlthis->tramp.string_tail = new_string;
+
+		/*  Copy the string over to the new object  */
+		for (i = 0; i < str_len; i++)
+			new_string->str[i] = str[i];
+	}
+
+	return new_string;
+}
+
+/*
+ * Function:	priv_tramp_string_find
+ * Description: Walk the trampoline string list and find a match for the
+ *	  provided string.  If not match is found, NULL is returned.
+ */
+static struct tramp_string *priv_tramp_string_find(struct dload_state *dlthis,
+								char *str)
+{
+	struct tramp_string *cur_str = NULL;
+	struct tramp_string *ret_val = NULL;
+	u32 i;
+	u32 str_len = strlen(str);
+
+	for (cur_str = dlthis->tramp.string_head;
+		 (ret_val == NULL) && (cur_str != NULL);
+		 cur_str = cur_str->next) {
+		/*  If the string lengths aren't equal, don't bother
+		 * comparing  */
+		if (str_len != strlen(cur_str->str))
+			continue;
+
+		/*  Walk the strings until one of them ends  */
+		for (i = 0; i < str_len; i++) {
+			/*  If they don't match in the current position then
+			 * break out now, no sense in continuing to look at
+			 * this string.  */
+			if (str[i] != cur_str->str[i])
+				break;
+		}
+
+		if (i == str_len)
+			ret_val = cur_str;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_string_tbl_finalize
+ * Description: Flatten the trampoline string list into a table of NULL
+ *	  terminated strings.  This is the same format of string table
+ *	  as used by the COFF/DOFF file.
+ */
+static int priv_string_tbl_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_string *cur_string;
+	char *cur_loc;
+	char *tmp;
+
+	/*  Allocate enough space for all strings that have been created.  The
+	 * table is simply all strings concatenated together will NULL
+	 * endings.  */
+	dlthis->tramp.final_string_table =
+		(char *)dlthis->mysym->Allocate(dlthis->mysym,
+					dlthis->tramp.tramp_string_size);
+	if (dlthis->tramp.final_string_table != NULL) {
+		/*  We got our buffer, walk the list and release the nodes as*
+		 * we go  */
+		cur_loc = dlthis->tramp.final_string_table;
+		cur_string = dlthis->tramp.string_head;
+		while (cur_string != NULL) {
+			/*  Move the head/tail pointers  */
+			dlthis->tramp.string_head = cur_string->next;
+			if (dlthis->tramp.string_tail == cur_string)
+				dlthis->tramp.string_tail = NULL;
+
+			/*  Copy the string contents  */
+			for (tmp = cur_string->str;
+				 *tmp != '\0';
+				 tmp++, cur_loc++)
+				*cur_loc = *tmp;
+
+			/*  Pick up the NULL termination since it was missed by
+			 * breaking using it to end the above loop.  */
+			*cur_loc = '\0';
+			cur_loc++;
+
+			/*  Free the string node, we don't need it any more. */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+
+			/*  Move our pointer to the next one  */
+			cur_string = dlthis->tramp.string_head;
+		}
+
+		/*  Update our return value to success  */
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to allocate trampoline "
+						"string table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sect_alloc
+ * Description: Virtually allocate space from the trampoline section.  This
+ *	  function returns the next offset within the trampoline section
+ *	  that is available and moved the next available offset by the
+ *	  requested size.  NO TARGET ALLOCATION IS DONE AT THIS TIME.
+ */
+static u32 priv_tramp_sect_alloc(struct dload_state *dlthis, u32 tramp_size)
+{
+	u32 ret_val;
+
+	/*  If the next available address is 0, this is our first allocation.
+	 * Create a section name string to go into the string table .  */
+	if (dlthis->tramp.tramp_sect_next_addr == 0) {
+		dload_syms_error(dlthis->mysym, "*** WARNING ***  created "
+			"dynamic TRAMPOLINE section for module %s",
+			dlthis->str_head);
+	}
+
+	/*  Reserve space for the new trampoline  */
+	ret_val = dlthis->tramp.tramp_sect_next_addr;
+	dlthis->tramp.tramp_sect_next_addr += tramp_size;
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_sym_create
+ * Description: Allocate and create a new trampoline specific symbol and add
+ *	  it to the trampoline symbol list.  These symbols will include
+ *	  trampoline points as well as the external symbols they
+ *	  reference.
+ */
+static struct tramp_sym *priv_tramp_sym_create(struct dload_state *dlthis,
+			u32 str_index, struct Local_Symbol *tmp_sym)
+{
+	struct tramp_sym	*new_sym = NULL;
+	u32 i;
+
+	/*  Allocate new space for the symbol in the symbol table.  */
+	new_sym = (struct tramp_sym *)dlthis->mysym->Allocate(dlthis->mysym,
+						   sizeof(struct tramp_sym));
+	if (new_sym != NULL) {
+		for (i = 0; i != sizeof(struct tramp_sym); i++)
+			*((char *)new_sym + i) = 0;
+
+		/*  Assign this symbol the next symbol index for easier
+		 * reference later during relocation.  */
+		new_sym->index = dlthis->tramp.tramp_sym_next_index;
+		dlthis->tramp.tramp_sym_next_index++;
+
+		/*  Populate the symbol information.  At this point any
+		 * trampoline symbols will be the offset location, not the
+		 * final.  Copy over the symbol info to start, then be sure to
+		 * get the string index from the trampoline string table.  */
+		new_sym->sym_info = *tmp_sym;
+		new_sym->str_index = str_index;
+
+		/*  Push the new symbol to the tail of the symbol table list  */
+		new_sym->next = NULL;
+		if (dlthis->tramp.symbol_head == NULL)
+			dlthis->tramp.symbol_head = new_sym;
+		else
+			dlthis->tramp.symbol_tail->next = new_sym;
+
+		dlthis->tramp.symbol_tail = new_sym;
+	}
+
+	return new_sym;
+}
+
+/*
+ * Function:	priv_tramp_sym_get
+ * Description: Search for the symbol with the matching string index (from
+ *	  the trampoline string table) and return the trampoline
+ *	  symbol object, if found.  Otherwise return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_get(struct dload_state *dlthis,
+						 u32 string_index)
+{
+	struct tramp_sym *sym_found = NULL;
+
+	/*  Walk the symbol table list and search vs. the string index  */
+	for (sym_found = dlthis->tramp.symbol_head;
+		 sym_found != NULL;
+		 sym_found = sym_found->next) {
+		if (sym_found->str_index == string_index)
+			break;
+	}
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_find
+ * Description: Search for a trampoline symbol based on the string name of
+ *	  the symbol.  Return the symbol object, if found, otherwise
+ *	  return NULL.
+ */
+static struct tramp_sym *priv_tramp_sym_find(struct dload_state *dlthis,
+							char *string)
+{
+	struct tramp_sym *sym_found = NULL;
+	struct tramp_string *str_found = NULL;
+
+	/*  First, search for the string, then search for the sym based on the
+		string index.  */
+	str_found = priv_tramp_string_find(dlthis, string);
+	if (str_found != NULL)
+		sym_found = priv_tramp_sym_get(dlthis, str_found->index);
+
+	return sym_found;
+}
+
+/*
+ * Function:	priv_tramp_sym_finalize
+ * Description: Allocate a flat symbol table for the trampoline section,
+ *	  put each trampoline symbol into the table, adjust the
+ *	  symbol value based on the section address on the target and
+ *	  free the trampoline symbol list nodes.
+ */
+static int priv_tramp_sym_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 0;
+	struct tramp_sym *cur_sym;
+	struct LDR_SECTION_INFO *tramp_sect =
+		&dlthis->ldr_sections[dlthis->allocated_secn_count];
+	struct Local_Symbol *new_sym;
+
+	/*  Allocate a table to hold a flattened version of all symbols
+	 * created.  */
+	dlthis->tramp.final_sym_table =
+		(struct Local_Symbol *)dlthis->mysym->Allocate(
+			dlthis->mysym, (sizeof(struct Local_Symbol) *
+			dlthis->tramp.tramp_sym_next_index));
+	if (dlthis->tramp.final_sym_table != NULL) {
+		/*  Walk the list of all symbols, copy it over to the flattened
+		 * table. After it has been copied, the node can be freed as
+		 * it is no longer needed.  */
+		new_sym = dlthis->tramp.final_sym_table;
+		cur_sym = dlthis->tramp.symbol_head;
+		while (cur_sym != NULL) {
+			/*  Pop it off the list  */
+			dlthis->tramp.symbol_head = cur_sym->next;
+			if (cur_sym == dlthis->tramp.symbol_tail)
+				dlthis->tramp.symbol_tail = NULL;
+
+			/*  Copy the symbol contents into the flat table  */
+			*new_sym = cur_sym->sym_info;
+
+			/*  Now finaize the symbol.  If it is in the tramp
+			 * section, we need to adjust for the section start.
+			 * If it is external then we don't need to adjust at
+			 * all.
+			 * NOTE: THIS CODE ASSUMES THAT THE TRAMPOLINE IS
+			 * REFERENCED LIKE A CALL TO AN EXTERNAL SO VALUE AND
+			 * DELTA ARE THE SAME.  SEE THE FUNCTION dload_symbols
+			 * WHERE DN_UNDEF IS HANDLED FOR MORE REFERENCE.  */
+			if (new_sym->secnn < 0) {
+				new_sym->value += tramp_sect->load_addr;
+				new_sym->delta = new_sym->value;
+			}
+
+			/*  Let go of the symbol node  */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+
+			/*  Move to the next node  */
+			cur_sym = dlthis->tramp.symbol_head;
+			new_sym++;
+		}
+
+		ret_val = 1;
+	} else
+		dload_error(dlthis, "Failed to alloc trampoline sym table");
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tgt_img_gen
+ * Description: Allocate storage for and copy the target specific image data
+ *	and fix up its relocations for the new external symbol.  If
+ *	a trampoline image packet was successfully created it is added
+ *	to the trampoline list.
+ */
+static int priv_tgt_img_gen(struct dload_state *dlthis, u32 base,
+		u32 gen_index, struct tramp_sym *new_ext_sym)
+{
+	struct tramp_img_pkt *new_img_pkt = NULL;
+	u32 i;
+	u32 pkt_size = tramp_img_pkt_size_get();
+	u8 *gen_tbl_entry;
+	u8 *pkt_data;
+	struct reloc_record_t *cur_relo;
+	int ret_val = 0;
+
+	/*  Allocate a new image packet and set it up.  */
+	new_img_pkt =
+		(struct tramp_img_pkt *)dlthis->mysym->Allocate(dlthis->mysym,
+								 pkt_size);
+	if (new_img_pkt != NULL) {
+		/*  Save the base, this is where it goes in the section  */
+		new_img_pkt->base = base;
+
+		/*  Copy over the image data and relos from the target table */
+		pkt_data = (u8 *)&new_img_pkt->hdr;
+		gen_tbl_entry = (u8 *)&tramp_gen_info[gen_index];
+		for (i = 0; i < pkt_size; i++) {
+			*pkt_data = *gen_tbl_entry;
+			pkt_data++;
+			gen_tbl_entry++;
+		}
+
+		/*  Update the relocations to point to the external symbol  */
+		cur_relo =
+			(struct reloc_record_t *)((u8 *)&new_img_pkt->hdr +
+					   new_img_pkt->hdr.relo_offset);
+		for (i = 0; i < new_img_pkt->hdr.num_relos; i++)
+			cur_relo[i].r_symndx = new_ext_sym->index;
+
+		/*  Add it to the trampoline list.  */
+		new_img_pkt->next = dlthis->tramp.tramp_pkts;
+		dlthis->tramp.tramp_pkts = new_img_pkt;
+
+		ret_val = 1;
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_pkt_relo
+ * Description: Take the provided image data and the collection of relocations
+ *	  for it and perform the relocations.  Note that all relocations
+ *	  at this stage are considered SECOND PASS since the original
+ *	  image has already been processed in the first pass.  This means
+ *	  TRAMPOLINES ARE TREATED AS 2ND PASS even though this is really
+ *	  the first (and only) relocation that will be performed on them.
+ */
+static int priv_pkt_relo(struct dload_state *dlthis, TgtAU_t *data,
+			 struct reloc_record_t *rp[], u32 relo_count)
+{
+	int ret_val = 1;
+	u32 i;
+	bool tmp;
+
+	/*  Walk through all of the relos and process them.  This function is
+	 * the equivalent of relocate_packet() from cload.c, but specialized
+	 * for trampolines and 2nd phase relocations.  */
+	for (i = 0; i < relo_count; i++)
+		dload_relocate(dlthis, data, rp[i], &tmp, true);
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_tramp_pkt_finalize
+ * Description: Walk the list of all trampoline packets and finalize them.
+ *	  Each trampoline image packet will be relocated now that the
+ *	  trampoline section has been allocated on the target.  Once
+ *	  all of the relocations are done the trampoline image data
+ *	  is written into target memory and the trampoline packet
+ *	  is freed: it is no longer needed after this point.
+ */
+static int priv_tramp_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_pkt *cur_pkt = NULL;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	u32 relos_done;
+	u32 i;
+	struct reloc_record_t *cur_relo;
+	struct LDR_SECTION_INFO *sect_info =
+		&dlthis->ldr_sections[dlthis->allocated_secn_count];
+
+	/*  Walk the list of trampoline packets and relocate each packet.  This
+	 * function is the trampoline equivalent of dload_data() from
+	 * cload.c.  */
+	cur_pkt = dlthis->tramp.tramp_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the pkt from the list  */
+		dlthis->tramp.tramp_pkts = cur_pkt->next;
+
+		/*  Setup section and image offset information for the relo  */
+		dlthis->image_secn = sect_info;
+		dlthis->image_offset = cur_pkt->base;
+		dlthis->delta_runaddr = sect_info->run_addr;
+
+		/*  Walk through all relos for the packet  */
+		relos_done = 0;
+		cur_relo = (struct reloc_record_t *)((u8 *)&cur_pkt->hdr +
+						  cur_pkt->hdr.relo_offset);
+		while (relos_done < cur_pkt->hdr.num_relos) {
+#ifdef ENABLE_TRAMP_DEBUG
+			dload_syms_error(dlthis->mysym,
+				 "===> Trampoline %x branches to %x",
+				 sect_info->run_addr + dlthis->image_offset,
+				 dlthis->tramp.
+				 final_sym_table[cur_relo->r_symndx].value);
+#endif
+
+			for (i = 0;
+				 ((i < MAX_RELOS_PER_PASS) &&
+				  ((i + relos_done) < cur_pkt->hdr.num_relos));
+				 i++)
+				relos[i] = cur_relo + i;
+
+			/*  Do the actual relo  */
+			ret_val = priv_pkt_relo(dlthis,
+						(TgtAU_t *)&cur_pkt->payload,
+						relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+				"Relocation of trampoline pkt at %x failed",
+				cur_pkt->base + sect_info->run_addr);
+				break;
+			}
+
+			relos_done += i;
+			cur_relo += i;
+		}
+
+		/*  Make sure we didn't hit a problem  */
+		if (ret_val != 0) {
+			/*  Relos are done for the packet, write it to the
+			 * target  */
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+					   &cur_pkt->payload,
+					   sect_info->load_addr + cur_pkt->base
+					   , sect_info, BYTE_TO_HOST(
+					   cur_pkt->hdr.tramp_code_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Write to " FMT_UI32 " failed",
+					sect_info->load_addr + cur_pkt->base);
+			}
+
+			/*  Done with the pkt, let it go  */
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Get the next packet to process  */
+			cur_pkt = dlthis->tramp.tramp_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_pkt_finalize
+ * Description: Walk the list of duplicate image packets and finalize them.
+ *	  Each duplicate packet will be relocated again for the
+ *	  relocations that previously failed and have been adjusted
+ *	  to point at a trampoline.  Once all relocations for a packet
+ *	  have been done, write the packet into target memory.  The
+ *	  duplicate packet and its relocation chain are all freed
+ *	  after use here as they are no longer needed after this.
+ */
+static int priv_dup_pkt_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+	struct tramp_img_dup_pkt *cur_pkt;
+	struct tramp_img_dup_relo *cur_relo;
+	struct reloc_record_t *relos[MAX_RELOS_PER_PASS];
+	struct doff_scnhdr_t *sect_hdr = NULL;
+	s32 i;
+
+	/* Similar to the trampoline pkt finalize, this function walks each dup
+	 * pkt that was generated and performs all relocations that were
+	 * deferred to a 2nd pass.  This is the equivalent of dload_data() from
+	 * cload.c, but does not need the additional reorder and checksum
+	 * processing as it has already been done.  */
+	cur_pkt = dlthis->tramp.dup_pkts;
+	while ((ret_val != 0) && (cur_pkt != NULL)) {
+		/*  Remove the node from the list, we'll be freeing it
+		 * shortly  */
+		dlthis->tramp.dup_pkts = cur_pkt->next;
+
+		/*  Setup the section and image offset for relocation  */
+		dlthis->image_secn = &dlthis->ldr_sections[cur_pkt->secnn];
+		dlthis->image_offset = cur_pkt->offset;
+
+		/*  In order to get the delta run address, we need to reference
+		 * the original section header.  It's a bit ugly, but needed
+		 * for relo.  */
+		i = (s32)(dlthis->image_secn - dlthis->ldr_sections);
+		sect_hdr = dlthis->sect_hdrs + i;
+		dlthis->delta_runaddr = sect_hdr->ds_paddr;
+
+		/*  Walk all relos in the chain and process each.  */
+		cur_relo = cur_pkt->relo_chain;
+		while (cur_relo != NULL) {
+			/*  Process them a chunk at a time to be efficient  */
+			for (i = 0; (i < MAX_RELOS_PER_PASS)
+				 && (cur_relo != NULL);
+				 i++, cur_relo = cur_relo->next) {
+				relos[i] = &cur_relo->relo;
+				cur_pkt->relo_chain = cur_relo->next;
+			}
+
+			/*  Do the actual relo  */
+			ret_val = priv_pkt_relo(dlthis,
+				cur_pkt->img_pkt.i_bits,
+				relos, i);
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Relocation of dup pkt at %x failed",
+					cur_pkt->offset + dlthis->image_secn->
+					run_addr);
+				break;
+			}
+
+			/*  Release all of these relos, we're done with them */
+			while (i > 0) {
+				dlthis->mysym->Deallocate(dlthis->mysym,
+					  GET_CONTAINER(relos[i - 1],
+					struct tramp_img_dup_relo, relo));
+				i--;
+			}
+
+			/*  DO NOT ADVANCE cur_relo, IT IS ALREADY READY TO
+			 * GO!  */
+		}
+
+		/* Done with all relos.  Make sure we didn't have a problem and
+		 * write it out to the target  */
+		if (ret_val != 0) {
+			ret_val = dlthis->myio->writemem(dlthis->myio,
+				   cur_pkt->img_pkt.i_bits,
+				   dlthis->image_secn->load_addr +
+				   cur_pkt->offset, dlthis->image_secn,
+				   BYTE_TO_HOST(cur_pkt->
+				   img_pkt.i_packet_size));
+			if (ret_val == 0) {
+				dload_error(dlthis,
+					"Write to " FMT_UI32 " failed",
+					dlthis->image_secn->load_addr +
+					cur_pkt->offset);
+			}
+
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_pkt);
+
+			/*  Advance to the next packet  */
+			cur_pkt = dlthis->tramp.dup_pkts;
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	priv_dup_find
+ * Description: Walk the list of existing duplicate packets and find a
+ *	  match based on the section number and image offset.  Return
+ *	  the duplicate packet if found, otherwise NULL.
+ */
+static struct tramp_img_dup_pkt *priv_dup_find(struct dload_state *dlthis,
+					s16 secnn, u32 image_offset)
+{
+	struct tramp_img_dup_pkt *cur_pkt = NULL;
+
+	for (cur_pkt = dlthis->tramp.dup_pkts;
+		 cur_pkt != NULL;
+		 cur_pkt = cur_pkt->next) {
+		if ((cur_pkt->secnn == secnn) &&
+			(cur_pkt->offset == image_offset)) {
+			/*  Found a match, break out  */
+			break;
+		}
+	}
+
+	return cur_pkt;
+}
+
+/*
+ * Function:	priv_img_pkt_dup
+ * Description: Duplicate the original image packet.  If this is the first
+ *	  time this image packet has been seen (based on section number
+ *	  and image offset), create a new duplicate packet and add it
+ *	  to the dup packet list.  If not, just get the existing one and
+ *	  update it with the current packet contents (since relocation
+ *	  on the packet is still ongoing in first pass.)  Create a
+ *	  duplicate of the provided relocation, but update it to point
+ *	  to the new trampoline symbol.  Add the new relocation dup to
+ *	  the dup packet's relo chain for 2nd pass relocation later.
+ */
+static int priv_img_pkt_dup(struct dload_state *dlthis,
+	s16 secnn, u32 image_offset, struct image_packet_t *ipacket,
+	struct reloc_record_t *rp, struct tramp_sym *new_tramp_sym)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	u32 new_dup_size;
+	s32 i;
+	int ret_val = 0;
+	struct tramp_img_dup_relo *dup_relo = NULL;
+
+	/*  Determinne if this image packet is already being tracked in the
+		dup list for other trampolines.  */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+
+	if (dup_pkt == NULL) {
+		/*  This image packet does not exist in our tracking, so create
+		 * a new one and add it to the head of the list.  */
+		new_dup_size = sizeof(struct tramp_img_dup_pkt) +
+						ipacket->i_packet_size;
+
+		dup_pkt = (struct tramp_img_dup_pkt *)
+			dlthis->mysym->Allocate(dlthis->mysym, new_dup_size);
+		if (dup_pkt != NULL) {
+			/*  Save off the section and offset information  */
+			dup_pkt->secnn = secnn;
+			dup_pkt->offset = image_offset;
+			dup_pkt->relo_chain = NULL;
+
+			/*  Copy the original packet content  */
+			dup_pkt->img_pkt = *ipacket;
+			dup_pkt->img_pkt.i_bits = (u8 *)(dup_pkt + 1);
+			for (i = 0; i < ipacket->i_packet_size; i++)
+				*(dup_pkt->img_pkt.i_bits + i) =
+					*(ipacket->i_bits + i);
+
+			/*  Add the packet to the dup list  */
+			dup_pkt->next = dlthis->tramp.dup_pkts;
+			dlthis->tramp.dup_pkts = dup_pkt;
+		} else
+			dload_error(dlthis, "Failed to create dup packet!");
+	} else {
+		/*  The image packet contents could have changed since
+		 * trampoline detection happens during relocation of the image
+		 * packets.  So, we need to update the image packet contents
+		 * before adding relo information.  */
+		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
+			*(dup_pkt->img_pkt.i_bits + i) =
+				*(ipacket->i_bits + i);
+	}
+
+	/*  Since the previous code may have allocated a new dup packet for us,
+		double check that we actually have one.  */
+	if (dup_pkt != NULL) {
+		/*  Allocate a new node for the relo chain.  Each image packet
+		 * can potentially have multiple relocations that cause a
+		 * trampoline to be generated.  So, we keep them in a chain,
+		 * order is not important.  */
+		dup_relo = dlthis->mysym->Allocate(dlthis->mysym,
+					   sizeof(struct tramp_img_dup_relo));
+		if (dup_relo != NULL) {
+			/*  Copy the relo contents, adjust for the new
+			 * trampoline and add it to the list.  */
+			dup_relo->relo = *rp;
+			dup_relo->relo.r_symndx = new_tramp_sym->index;
+
+			dup_relo->next = dup_pkt->relo_chain;
+			dup_pkt->relo_chain = dup_relo;
+
+			/*  That's it, we're done.  Make sure we update our
+			 * return value to be success since everything finished
+			 * ok  */
+			ret_val = 1;
+		} else
+			dload_error(dlthis, "Unable to alloc dup relo");
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_avail
+ * Description: Check to see if the target supports a trampoline for this type
+ *	  of relocation.  Return true if it does, otherwise false.
+ */
+bool dload_tramp_avail(struct dload_state *dlthis, struct reloc_record_t *rp)
+{
+	bool ret_val = false;
+	u16 map_index;
+	u16 gen_index;
+
+	/*  Check type hash vs. target tramp table  */
+	map_index = HASH_FUNC(rp->r_type);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL)
+		ret_val = true;
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_generate
+ * Description: Create a new trampoline for the provided image packet and
+ *	  relocation causing problems.  This will create the trampoline
+ *	  as well as duplicate/update the image packet and relocation
+ *	  causing the problem, which will be relo'd again during
+ *	  finalization.
+ */
+int dload_tramp_generate(struct dload_state *dlthis, s16 secnn,
+	u32 image_offset, struct image_packet_t *ipacket,
+	struct reloc_record_t *rp)
+{
+	u16 map_index;
+	u16 gen_index;
+	int ret_val = 1;
+	char tramp_sym_str[TRAMP_SYM_PREFIX_LEN + TRAMP_SYM_HEX_ASCII_LEN];
+	struct Local_Symbol *ref_sym;
+	struct tramp_sym	*new_tramp_sym;
+	struct tramp_sym	*new_ext_sym;
+	struct tramp_string *new_tramp_str;
+	u32 new_tramp_base;
+	struct Local_Symbol tmp_sym;
+	struct Local_Symbol ext_tmp_sym;
+
+	/*  Hash the relo type to get our generator information  */
+	map_index = HASH_FUNC(rp->r_type);
+	gen_index = tramp_map[map_index];
+	if (gen_index != TRAMP_NO_GEN_AVAIL) {
+		/*  If this is the first trampoline, create the section name in
+		 * our string table for debug help later.  */
+		if (dlthis->tramp.string_head == NULL) {
+			priv_tramp_string_create(dlthis,
+				 strlen(TRAMP_SECT_NAME), TRAMP_SECT_NAME);
+		}
+
+#ifdef ENABLE_TRAMP_DEBUG
+		dload_syms_error(dlthis->mysym,
+			 "Trampoline at img loc %x, references %x",
+			 dlthis->ldr_sections[secnn].run_addr + image_offset +
+			 rp->r_vaddr,
+			 dlthis->local_symtab[rp->r_symndx].value);
+#endif
+
+		/*  Generate the trampoline string, check if already defined.
+		 * If the relo symbol index is -1, it means we need the section
+		 * info for relo later.  To do this we'll dummy up a symbol
+		 * with the section delta and run addresses.  */
+		if (rp->r_symndx == -1) {
+			ext_tmp_sym.value =
+				dlthis->ldr_sections[secnn].run_addr;
+			ext_tmp_sym.delta = dlthis->sect_hdrs[secnn].ds_paddr;
+			ref_sym = &ext_tmp_sym;
+		} else
+			ref_sym = &(dlthis->local_symtab[rp->r_symndx]);
+
+		priv_tramp_sym_gen_name(ref_sym->value, tramp_sym_str);
+		new_tramp_sym = priv_tramp_sym_find(dlthis, tramp_sym_str);
+		if (new_tramp_sym == NULL) {
+			/*  If tramp string not defined, create it and a new
+			 * string, and symbol for it as well as the original
+			 * symbol which caused the trampoline.  */
+			new_tramp_str = priv_tramp_string_create(dlthis,
+				 strlen(tramp_sym_str), tramp_sym_str);
+			if (new_tramp_str == NULL) {
+				dload_error(dlthis, "Failed to create new "
+					"trampoline string\n");
+				ret_val = 0;
+			} else {
+				/*  Allocate tramp section space for the new
+				 * tramp from the target  */
+				new_tramp_base = priv_tramp_sect_alloc(dlthis,
+							   tramp_size_get());
+
+				/*  We have a string, create the new symbol and
+				 * duplicate the external.  */
+				tmp_sym.value = new_tramp_base;
+				tmp_sym.delta = 0;
+				tmp_sym.secnn = -1;
+				tmp_sym.sclass = 0;
+				new_tramp_sym = priv_tramp_sym_create(dlthis,
+					  new_tramp_str->index, &tmp_sym);
+
+				new_ext_sym = priv_tramp_sym_create(dlthis,
+								-1, ref_sym);
+
+				if ((new_tramp_sym != NULL) &&
+					(new_ext_sym != NULL)) {
+					/*  Call the image generator to get the
+					 * new image data and fix up its
+					 * relocations for the external
+					 * symbol.  */
+					ret_val = priv_tgt_img_gen(dlthis,
+					   new_tramp_base, gen_index,
+					   new_ext_sym);
+
+					/*  Add generated image data to tramp
+					 * image list  */
+					if (ret_val != 1) {
+						dload_error(dlthis, "Failed to"
+						   " create image packet for "
+						   "trampoline\n");
+					}
+				} else {
+					dload_error(dlthis, "Failed to create "
+					   "new tramp syms (%8.8X, %8.8X)\n",
+					   new_tramp_sym, new_ext_sym);
+					ret_val = 0;
+				}
+			}
+		}
+
+		/*  Duplicate the image data and relo record that caused the
+		 * tramp, including update the relo data to point to the tramp
+		 * symbol.  */
+		if (ret_val == 1) {
+			ret_val = priv_img_pkt_dup(dlthis, secnn, image_offset,
+				   ipacket, rp, new_tramp_sym);
+			if (ret_val != 1) {
+				dload_error(dlthis, "Failed to create dup of "
+					"original img pkt\n");
+			}
+		}
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_pkt_update
+ * Description: Update the duplicate copy of this image packet, which the
+ *	  trampoline layer is already tracking.  This is call is critical
+ *	  to make if trampolines were generated anywhere within the
+ *	  packet and first pass relo continued on the remainder.  The
+ *	  trampoline layer needs the updates image data so when 2nd
+ *	  pass relo is done during finalize the image packet can be
+ *	  written to the target since all relo is done.
+ */
+int dload_tramp_pkt_udpate(struct dload_state *dlthis, s16 secnn,
+	   u32 image_offset, struct image_packet_t *ipacket)
+{
+	struct tramp_img_dup_pkt *dup_pkt = NULL;
+	s32 i;
+	int ret_val = 0;
+
+	/*  Find the image packet in question, the caller needs us to update it
+		since a trampoline was previously generated.  */
+	dup_pkt = priv_dup_find(dlthis, secnn, image_offset);
+	if (dup_pkt != NULL) {
+		for (i = 0; i < dup_pkt->img_pkt.i_packet_size; i++)
+			*(dup_pkt->img_pkt.i_bits + i) = *(ipacket->i_bits + i);
+
+		ret_val = 1;
+	} else {
+		dload_error(dlthis,
+			"Unable to find existing DUP pkt for %x, offset %x",
+			secnn, image_offset);
+
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_finalize
+ * Description: If any trampolines were created, finalize everything on the
+ *	  target by allocating the trampoline section on the target,
+ *	  finalizing the trampoline symbols, finalizing the trampoline
+ *	  packets (write the new section to target memory) and finalize
+ *	  the duplicate packets by doing 2nd pass relo over them.
+ */
+int dload_tramp_finalize(struct dload_state *dlthis)
+{
+	int ret_val = 1;
+
+	if (dlthis->tramp.tramp_sect_next_addr != 0) {
+		/*  Finalize strings into a flat table.  This is needed so it
+		 * can be added to the debug string table later.  */
+		ret_val = priv_string_tbl_finalize(dlthis);
+
+		/*  Do target allocation for section BEFORE finalizing
+		 * symbols.  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sect_tgt_alloc(dlthis);
+
+		/*  Finalize symbols with their correct target information and
+		 * flatten  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_sym_finalize(dlthis);
+
+		/*  Finalize all trampoline packets.  This performs the
+		 * relocation on the packets as well as writing them to target
+		 * memory.  */
+		if (ret_val != 0)
+			ret_val = priv_tramp_pkt_finalize(dlthis);
+
+		/*  Perform a 2nd pass relocation on the dup list.  */
+		if (ret_val != 0)
+			ret_val = priv_dup_pkt_finalize(dlthis);
+	}
+
+	return ret_val;
+}
+
+/*
+ * Function:	dload_tramp_cleanup
+ * Description: Release all temporary resources used in the trampoline layer.
+ *	  Note that the target memory which may have been allocated and
+ *	  written to store the trampolines is NOT RELEASED HERE since it
+ *	  is potentially still in use.  It is automatically released
+ *	  when the module is unloaded.
+ */
+void dload_tramp_cleanup(struct dload_state *dlthis)
+{
+	struct tramp_info *tramp = &dlthis->tramp;
+	struct tramp_sym *cur_sym;
+	struct tramp_string *cur_string;
+	struct tramp_img_pkt *cur_tramp_pkt;
+	struct tramp_img_dup_pkt *cur_dup_pkt;
+	struct tramp_img_dup_relo *cur_dup_relo;
+
+	/*  If there were no tramps generated, just return  */
+	if (tramp->tramp_sect_next_addr == 0)
+		return;
+
+	/*  Destroy all tramp information  */
+	for (cur_sym = tramp->symbol_head;
+		 cur_sym != NULL;
+		 cur_sym = tramp->symbol_head) {
+		tramp->symbol_head = cur_sym->next;
+		if (tramp->symbol_tail == cur_sym)
+			tramp->symbol_tail = NULL;
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_sym);
+	}
+
+	if (tramp->final_sym_table != NULL)
+		dlthis->mysym->Deallocate(dlthis->mysym,
+			tramp->final_sym_table);
+
+	for (cur_string = tramp->string_head;
+		 cur_string != NULL;
+		 cur_string = tramp->string_head) {
+		tramp->string_head = cur_string->next;
+		if (tramp->string_tail == cur_string)
+			tramp->string_tail = NULL;
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_string);
+	}
+
+	if (tramp->final_string_table != NULL)
+		dlthis->mysym->Deallocate(dlthis->mysym,
+			tramp->final_string_table);
+
+	for (cur_tramp_pkt = tramp->tramp_pkts;
+		 cur_tramp_pkt != NULL;
+		 cur_tramp_pkt = tramp->tramp_pkts) {
+		tramp->tramp_pkts = cur_tramp_pkt->next;
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_tramp_pkt);
+	}
+
+	for (cur_dup_pkt = tramp->dup_pkts;
+		 cur_dup_pkt != NULL;
+		 cur_dup_pkt = tramp->dup_pkts) {
+		tramp->dup_pkts = cur_dup_pkt->next;
+
+		for (cur_dup_relo = cur_dup_pkt->relo_chain;
+			 cur_dup_relo != NULL;
+			 cur_dup_relo = cur_dup_pkt->relo_chain) {
+			cur_dup_pkt->relo_chain = cur_dup_relo->next;
+			dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_relo);
+		}
+
+		dlthis->mysym->Deallocate(dlthis->mysym, cur_dup_pkt);
+	}
+}
diff --git a/drivers/dsp/bridge/dynload/tramp_table_c6000.c b/drivers/dsp/bridge/dynload/tramp_table_c6000.c
new file mode 100644
index 0000000..acda513
--- /dev/null
+++ b/drivers/dsp/bridge/dynload/tramp_table_c6000.c
@@ -0,0 +1,172 @@
+/*
+ * tramp_table_c6000.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include "dload_internal.h"
+
+/*  These are defined in coff.h, but may not be available on all platforms
+	so we'll go ahead and define them here.  */
+#ifndef R_C60LO16
+#define R_C60LO16	  0x54	   /* C60: MVK Low Half Register	  */
+#define R_C60HI16	  0x55	   /* C60: MVKH/MVKLH High Half Register  */
+#endif
+
+#define C6X_TRAMP_WORD_COUNT			8
+#define C6X_TRAMP_MAX_RELOS			 8
+
+/*  THIS HASH FUNCTION MUST MATCH THE ONE IN reloc_table_c6000.c  */
+#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+
+
+/*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO  */
+struct c6000_relo_record {
+	s32 r_vaddr;
+	s32 symndx;
+#ifndef _BIG_ENDIAN
+	u16 disp;
+	u16 type;
+#else
+	u16 type;
+	u16 disp;
+#endif
+};
+
+struct c6000_gen_code {
+	struct tramp_gen_code_hdr	hdr;
+	u32 tramp_instrs[C6X_TRAMP_WORD_COUNT];
+	struct c6000_relo_record relos[C6X_TRAMP_MAX_RELOS];
+};
+
+
+/*  Hash mapping for relos that can cause trampolines.  */
+static const u16 tramp_map[] =
+{
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	0,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535,
+	65535
+};
+
+
+static const struct c6000_gen_code   tramp_gen_info[] =
+{
+	/*  Tramp caused by R_C60PCR21  */
+	{
+		/*  Header - 8 instructions, 2 relos  */
+		{
+			sizeof(u32) * C6X_TRAMP_WORD_COUNT,
+			2,
+			FIELD_OFFSET(struct c6000_gen_code, relos)
+		},
+
+		/*  Trampoline instructions  */
+		{
+			0x053C54F7,	/*	 STW.D2T2  B10, *sp--[2]  */
+			0x0500002A,	/*  || MVK.S2	<blank>, B10   */
+			0x0500006A,	/*	 MVKH.S2   <blank>, B10   */
+			0x00280362,	/*	 B.S2	  B10		*/
+			0x053C52E6,	/*	 LDW.D2T2  *++sp[2], B10  */
+			0x00006000,	/*	 NOP	   4		*/
+			0x00000000,	/*	 NOP			*/
+			0x00000000	/*	 NOP			*/
+		},
+
+		/*  Relocations  */
+		{
+			{ 4, 0, 0, R_C60LO16 },
+			{ 8, 0, 0, R_C60HI16 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 },
+			{ 0, 0, 0, 0x0000 }
+		}
+	}
+};
+
+
+
+/*  TARGET SPECIFIC FUNCTIONS THAT MUST BE DEFINED  */
+static u32 tramp_size_get(void)
+{
+	return sizeof(u32) * C6X_TRAMP_WORD_COUNT;
+}
+
+
+static u32 tramp_img_pkt_size_get(void)
+{
+	return sizeof(struct c6000_gen_code);
+}
diff --git a/drivers/dsp/bridge/gen/gb.c b/drivers/dsp/bridge/gen/gb.c
new file mode 100644
index 0000000..1b11c15
--- /dev/null
+++ b/drivers/dsp/bridge/gen/gb.c
@@ -0,0 +1,169 @@
+/*
+ * gb.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Generic bitmap operations.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <linux/types.h>
+/*  ----------------------------------- This */
+#include <dspbridge/gs.h>
+#include <dspbridge/gb.h>
+
+typedef GB_BitNum GB_WordNum;
+
+struct GB_TMap {
+	GB_BitNum len;
+	GB_WordNum wcnt;
+	u32 *words;
+};
+
+/*
+ *  ======== GB_clear ========
+ *  purpose:
+ *      Clears a bit in the bit map.
+ */
+
+void GB_clear(struct GB_TMap *map, GB_BitNum bitn)
+{
+	u32 mask;
+
+	mask = 1L << (bitn % BITS_PER_LONG);
+	map->words[bitn / BITS_PER_LONG] &= ~mask;
+}
+
+/*
+ *  ======== GB_create ========
+ *  purpose:
+ *      Creates a bit map.
+ */
+
+struct GB_TMap *GB_create(GB_BitNum len)
+{
+	struct GB_TMap *map;
+	GB_WordNum i;
+	map = (struct GB_TMap *)GS_alloc(sizeof(struct GB_TMap));
+	if (map != NULL) {
+		map->len = len;
+		map->wcnt = len / BITS_PER_LONG + 1;
+		map->words = (u32 *)GS_alloc(map->wcnt * sizeof(u32));
+		if (map->words != NULL) {
+			for (i = 0; i < map->wcnt; i++)
+				map->words[i] = 0L;
+
+		} else {
+			GS_frees(map, sizeof(struct GB_TMap));
+			map = NULL;
+		}
+	}
+
+	return map;
+}
+
+/*
+ *  ======== GB_delete ========
+ *  purpose:
+ *      Frees a bit map.
+ */
+
+void GB_delete(struct GB_TMap *map)
+{
+	GS_frees(map->words, map->wcnt * sizeof(u32));
+	GS_frees(map, sizeof(struct GB_TMap));
+}
+
+/*
+ *  ======== GB_findandset ========
+ *  purpose:
+ *      Finds a free bit and sets it.
+ */
+GB_BitNum GB_findandset(struct GB_TMap *map)
+{
+	GB_BitNum bitn;
+
+	bitn = GB_minclear(map);
+
+	if (bitn != GB_NOBITS)
+		GB_set(map, bitn);
+
+	return bitn;
+}
+
+/*
+ *  ======== GB_minclear ========
+ *  purpose:
+ *      returns the location of the first unset bit in the bit map.
+ */
+GB_BitNum GB_minclear(struct GB_TMap *map)
+{
+	GB_BitNum bit_location = 0;
+	GB_BitNum bitAcc = 0;
+	GB_WordNum i;
+	GB_BitNum bit;
+	u32 *word;
+
+	for (word = map->words, i = 0; i < map->wcnt; word++, i++) {
+		if (~*word) {
+			for (bit = 0; bit < BITS_PER_LONG; bit++, bitAcc++) {
+				if (bitAcc == map->len)
+					return GB_NOBITS;
+
+				if (~*word & (1L << bit)) {
+					bit_location = i * BITS_PER_LONG + bit;
+					return bit_location;
+				}
+
+			}
+		} else {
+			bitAcc += BITS_PER_LONG;
+		}
+	}
+
+	return GB_NOBITS;
+}
+
+/*
+ *  ======== GB_set ========
+ *  purpose:
+ *      Sets a bit in the bit map.
+ */
+
+void GB_set(struct GB_TMap *map, GB_BitNum bitn)
+{
+	u32 mask;
+
+	mask = 1L << (bitn % BITS_PER_LONG);
+	map->words[bitn / BITS_PER_LONG] |= mask;
+}
+
+/*
+ *  ======== GB_test ========
+ *  purpose:
+ *      Returns true if the bit is set in the specified location.
+ */
+
+bool GB_test(struct GB_TMap *map, GB_BitNum bitn)
+{
+	bool state;
+	u32 mask;
+	u32 word;
+
+	mask = 1L << (bitn % BITS_PER_LONG);
+	word = map->words[bitn / BITS_PER_LONG];
+	state = word & mask ? TRUE : FALSE;
+
+	return state;
+}
diff --git a/drivers/dsp/bridge/gen/gh.c b/drivers/dsp/bridge/gen/gh.c
new file mode 100644
index 0000000..252efaf
--- /dev/null
+++ b/drivers/dsp/bridge/gen/gh.c
@@ -0,0 +1,186 @@
+/*
+ * gh.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/std.h>
+
+#include <dspbridge/host_os.h>
+
+#include <dspbridge/gs.h>
+
+#include <dspbridge/gh.h>
+
+struct Elem {
+	struct Elem *next;
+	u8 data[1];
+};
+
+struct GH_THashTab {
+	u16 maxBucket;
+	u16 valSize;
+	struct Elem **buckets;
+	 u16(*hash) (void *, u16);
+	 bool(*match) (void *, void *);
+	 void(*delete) (void *);
+};
+
+static void Nop(void *p);
+static s32 curInit;
+static void myfree(void *ptr, s32 size);
+
+/*
+ *  ======== GH_create ========
+ */
+
+struct GH_THashTab *GH_create(u16 maxBucket, u16 valSize,
+		u16(*hash)(void *, u16), bool(*match)(void *, void *),
+		void(*delete)(void *))
+{
+	struct GH_THashTab *hashTab;
+	u16 i;
+	hashTab = (struct GH_THashTab *)GS_alloc(sizeof(struct GH_THashTab));
+	if (hashTab == NULL)
+		return NULL;
+	hashTab->maxBucket = maxBucket;
+	hashTab->valSize = valSize;
+	hashTab->hash = hash;
+	hashTab->match = match;
+	hashTab->delete = delete == NULL ? Nop : delete;
+
+	hashTab->buckets = (struct Elem **)
+			   GS_alloc(sizeof(struct Elem *) * maxBucket);
+	if (hashTab->buckets == NULL) {
+		GH_delete(hashTab);
+		return NULL;
+	}
+
+	for (i = 0; i < maxBucket; i++)
+		hashTab->buckets[i] = NULL;
+
+	return hashTab;
+}
+
+/*
+ *  ======== GH_delete ========
+ */
+void GH_delete(struct GH_THashTab *hashTab)
+{
+	struct Elem *elem, *next;
+	u16 i;
+
+	if (hashTab != NULL) {
+		if (hashTab->buckets != NULL) {
+			for (i = 0; i < hashTab->maxBucket; i++) {
+				for (elem = hashTab->buckets[i]; elem != NULL;
+				    elem = next) {
+					next = elem->next;
+					(*hashTab->delete) (elem->data);
+					myfree(elem, sizeof(struct Elem) - 1 +
+					      hashTab->valSize);
+				}
+			}
+
+			myfree(hashTab->buckets, sizeof(struct Elem *)
+			      * hashTab->maxBucket);
+		}
+
+		myfree(hashTab, sizeof(struct GH_THashTab));
+	}
+}
+
+/*
+ *  ======== GH_exit ========
+ */
+
+void GH_exit(void)
+{
+	if (curInit-- == 1)
+		GS_exit();
+
+}
+
+/*
+ *  ======== GH_find ========
+ */
+
+void *GH_find(struct GH_THashTab *hashTab, void *key)
+{
+	struct Elem *elem;
+
+	elem = hashTab->buckets[(*hashTab->hash)(key, hashTab->maxBucket)];
+
+	for (; elem; elem = elem->next) {
+		if ((*hashTab->match)(key, elem->data))
+			return elem->data;
+	}
+
+	return NULL;
+}
+
+/*
+ *  ======== GH_init ========
+ */
+
+void GH_init(void)
+{
+	if (curInit++ == 0)
+		GS_init();
+}
+
+/*
+ *  ======== GH_insert ========
+ */
+
+void *GH_insert(struct GH_THashTab *hashTab, void *key, void *value)
+{
+	struct Elem *elem;
+	u16 i;
+	char *src, *dst;
+
+	elem = (struct Elem *)GS_alloc(sizeof(struct Elem) - 1 +
+		hashTab->valSize);
+	if (elem != NULL) {
+
+		dst = (char *)elem->data;
+		src = (char *)value;
+		for (i = 0; i < hashTab->valSize; i++)
+			*dst++ = *src++;
+
+		i = (*hashTab->hash)(key, hashTab->maxBucket);
+		elem->next = hashTab->buckets[i];
+		hashTab->buckets[i] = elem;
+
+		return elem->data;
+	}
+
+	return NULL;
+}
+
+/*
+ *  ======== Nop ========
+ */
+/* ARGSUSED */
+static void Nop(void *p)
+{
+	p = p;			/* stifle compiler warning */
+}
+
+/*
+ *  ======== myfree ========
+ */
+static void myfree(void *ptr, s32 size)
+{
+	GS_free(ptr);
+}
diff --git a/drivers/dsp/bridge/gen/gs.c b/drivers/dsp/bridge/gen/gs.c
new file mode 100644
index 0000000..05b2e56
--- /dev/null
+++ b/drivers/dsp/bridge/gen/gs.c
@@ -0,0 +1,89 @@
+/*
+ * gs.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * General storage memory allocator services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <linux/types.h>
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/gs.h>
+
+/*  ----------------------------------- Globals */
+static u32 cumsize;
+
+/*
+ *  ======== GS_alloc ========
+ *  purpose:
+ *      Allocates memory of the specified size.
+ */
+void *GS_alloc(u32 size)
+{
+	void *p;
+
+	p = MEM_Calloc(size, MEM_PAGED);
+	if (p == NULL)
+		return NULL;
+	cumsize += size;
+	return p;
+}
+
+/*
+ *  ======== GS_exit ========
+ *  purpose:
+ *      Discontinue the usage of the GS module.
+ */
+void GS_exit(void)
+{
+	/* Do nothing */
+}
+
+/*
+ *  ======== GS_free ========
+ *  purpose:
+ *      Frees the memory.
+ */
+void GS_free(void *ptr)
+{
+	kfree(ptr);
+	/* ack! no size info */
+	/* cumsize -= size; */
+}
+
+/*
+ *  ======== GS_frees ========
+ *  purpose:
+ *      Frees the memory.
+ */
+void GS_frees(void *ptr, u32 size)
+{
+	kfree(ptr);
+	cumsize -= size;
+}
+
+/*
+ *  ======== GS_init ========
+ *  purpose:
+ *      Initializes the GS module.
+ */
+void GS_init(void)
+{
+	/* Do nothing */
+}
diff --git a/drivers/dsp/bridge/gen/uuidutil.c b/drivers/dsp/bridge/gen/uuidutil.c
new file mode 100644
index 0000000..165ca86
--- /dev/null
+++ b/drivers/dsp/bridge/gen/uuidutil.c
@@ -0,0 +1,222 @@
+/*
+ * uuidutil.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This file contains the implementation of UUID helper functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS  */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/uuidutil.h>
+
+/*
+ *  ======== UUID_UuidToString ========
+ *  Purpose:
+ *      Converts a struct DSP_UUID to a string.
+ *      Note: snprintf format specifier is:
+ *      %[flags] [width] [.precision] [{h | l | I64 | L}]type
+ */
+void UUID_UuidToString(IN struct DSP_UUID *pUuid, OUT char *pszUuid,
+		       IN s32 size)
+{
+	s32 i;			/* return result from snprintf. */
+
+	DBC_Require(pUuid && pszUuid);
+
+	i = snprintf(pszUuid, size,
+		     "%.8X_%.4X_%.4X_%.2X%.2X_%.2X%.2X%.2X%.2X%.2X%.2X",
+		     pUuid->ulData1, pUuid->usData2, pUuid->usData3,
+		     pUuid->ucData4, pUuid->ucData5, pUuid->ucData6[0],
+		     pUuid->ucData6[1], pUuid->ucData6[2], pUuid->ucData6[3],
+		     pUuid->ucData6[4], pUuid->ucData6[5]);
+
+	DBC_Ensure(i != -1);
+}
+
+/*
+ *  ======== htoi ========
+ *  Purpose:
+ *      Converts a hex value to a decimal integer.
+ */
+
+static int htoi(char c)
+{
+	switch (c) {
+	case '0':
+		return 0;
+	case '1':
+		return 1;
+	case '2':
+		return 2;
+	case '3':
+		return 3;
+	case '4':
+		return 4;
+	case '5':
+		return 5;
+	case '6':
+		return 6;
+	case '7':
+		return 7;
+	case '8':
+		return 8;
+	case '9':
+		return 9;
+	case 'A':
+		return 10;
+	case 'B':
+		return 11;
+	case 'C':
+		return 12;
+	case 'D':
+		return 13;
+	case 'E':
+		return 14;
+	case 'F':
+		return 15;
+	case 'a':
+		return 10;
+	case 'b':
+		return 11;
+	case 'c':
+		return 12;
+	case 'd':
+		return 13;
+	case 'e':
+		return 14;
+	case 'f':
+		return 15;
+	}
+	return 0;
+}
+
+/*
+ *  ======== UUID_UuidFromString ========
+ *  Purpose:
+ *      Converts a string to a struct DSP_UUID.
+ */
+void UUID_UuidFromString(IN char *pszUuid, OUT struct DSP_UUID *pUuid)
+{
+	char c;
+	s32 i, j;
+	s32 result;
+	char *temp = pszUuid;
+
+	result = 0;
+	for (i = 0; i < 8; i++) {
+		/* Get first character in string */
+		c = *temp;
+
+		/* Increase the results by new value */
+		result *= 16;
+		result += htoi(c);
+
+		/* Go to next character in string */
+		temp++;
+	}
+	pUuid->ulData1 = result;
+
+	/* Step over underscore */
+	temp++;
+
+	result = 0;
+	for (i = 0; i < 4; i++) {
+		/* Get first character in string */
+		c = *temp;
+
+		/* Increase the results by new value */
+		result *= 16;
+		result += htoi(c);
+
+		/* Go to next character in string */
+		temp++;
+	}
+	pUuid->usData2 = (u16)result;
+
+	/* Step over underscore */
+	temp++;
+
+	result = 0;
+	for (i = 0; i < 4; i++) {
+		/* Get first character in string */
+		c = *temp;
+
+		/* Increase the results by new value */
+		result *= 16;
+		result += htoi(c);
+
+		/* Go to next character in string */
+		temp++;
+	}
+	pUuid->usData3 = (u16)result;
+
+	/* Step over underscore */
+	temp++;
+
+	result = 0;
+	for (i = 0; i < 2; i++) {
+		/* Get first character in string */
+		c = *temp;
+
+		/* Increase the results by new value */
+		result *= 16;
+		result += htoi(c);
+
+		/* Go to next character in string */
+		temp++;
+	}
+	pUuid->ucData4 = (u8)result;
+
+	result = 0;
+	for (i = 0; i < 2; i++) {
+		/* Get first character in string */
+		c = *temp;
+
+		/* Increase the results by new value */
+		result *= 16;
+		result += htoi(c);
+
+		/* Go to next character in string */
+		temp++;
+	}
+	pUuid->ucData5 = (u8)result;
+
+	/* Step over underscore */
+	temp++;
+
+	for (j = 0; j < 6; j++) {
+		result = 0;
+		for (i = 0; i < 2; i++) {
+			/* Get first character in string */
+			c = *temp;
+
+			/* Increase the results by new value */
+			result *= 16;
+			result += htoi(c);
+
+			/* Go to next character in string */
+			temp++;
+		}
+		pUuid->ucData6[j] = (u8)result;
+	}
+}
diff --git a/drivers/dsp/bridge/hw/EasiGlobal.h b/drivers/dsp/bridge/hw/EasiGlobal.h
new file mode 100644
index 0000000..b023826
--- /dev/null
+++ b/drivers/dsp/bridge/hw/EasiGlobal.h
@@ -0,0 +1,42 @@
+/*
+ * EasiGlobal.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __EASIGLOBAL_H
+#define __EASIGLOBAL_H
+#include <linux/types.h>
+
+/*
+ * DEFINE:        READ_ONLY, WRITE_ONLY &  READ_WRITE
+ *
+ * DESCRIPTION: Defines used to describe register types for EASI-checker tests.
+ */
+
+#define READ_ONLY    1
+#define WRITE_ONLY   2
+#define READ_WRITE   3
+
+/*
+ * MACRO:        _DEBUG_LEVEL_1_EASI
+ *
+ * DESCRIPTION:  A MACRO which can be used to indicate that a particular beach
+ *               register access function was called.
+ *
+ * NOTE:         We currently dont use this functionality.
+ */
+#define _DEBUG_LEVEL_1_EASI(easiNum)     ((void)0)
+
+#endif	/* __EASIGLOBAL_H */
+
diff --git a/drivers/dsp/bridge/hw/GlobalTypes.h b/drivers/dsp/bridge/hw/GlobalTypes.h
new file mode 100644
index 0000000..73a2d93
--- /dev/null
+++ b/drivers/dsp/bridge/hw/GlobalTypes.h
@@ -0,0 +1,317 @@
+/*
+ * GlobalTypes.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global HW definitions
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __GLOBALTYPES_H
+#define __GLOBALTYPES_H
+
+/*
+ * Definition: TRUE, FALSE
+ *
+ * DESCRIPTION:  Boolean Definitions
+ */
+#ifndef TRUE
+#define FALSE	0
+#define TRUE	(!(FALSE))
+#endif
+
+/*
+ * Definition: NULL
+ *
+ * DESCRIPTION:  Invalid pointer
+ */
+#ifndef NULL
+#define NULL	(void *)0
+#endif
+
+/*
+ * Definition: RET_CODE_BASE
+ *
+ * DESCRIPTION:  Base value for return code offsets
+ */
+#define RET_CODE_BASE	0
+
+/*
+ * Definition: *BIT_OFFSET
+ *
+ * DESCRIPTION:  offset in bytes from start of 32-bit word.
+ */
+#define LOWER_16BIT_OFFSET	  0
+#define UPPER_16BIT_OFFSET	  2
+
+#define LOWER_8BIT_OFFSET	   0
+#define LOWER_MIDDLE_8BIT_OFFSET    1
+#define UPPER_MIDDLE_8BIT_OFFSET    2
+#define UPPER_8BIT_OFFSET	   3
+
+#define LOWER_8BIT_OF16_OFFSET      0
+#define UPPER_8BIT_OF16_OFFSET      1
+
+/*
+ * Definition: *BIT_SHIFT
+ *
+ * DESCRIPTION:  offset in bits from start of 32-bit word.
+ */
+#define LOWER_16BIT_SHIFT	  0
+#define UPPER_16BIT_SHIFT	  16
+
+#define LOWER_8BIT_SHIFT	   0
+#define LOWER_MIDDLE_8BIT_SHIFT    8
+#define UPPER_MIDDLE_8BIT_SHIFT    16
+#define UPPER_8BIT_SHIFT	   24
+
+#define LOWER_8BIT_OF16_SHIFT      0
+#define UPPER_8BIT_OF16_SHIFT      8
+
+
+/*
+ * Definition: LOWER_16BIT_MASK
+ *
+ * DESCRIPTION: 16 bit mask used for inclusion of lower 16 bits i.e. mask out
+ *		the upper 16 bits
+ */
+#define LOWER_16BIT_MASK	0x0000FFFF
+
+
+/*
+ * Definition: LOWER_8BIT_MASK
+ *
+ * DESCRIPTION: 8 bit masks used for inclusion of 8 bits i.e. mask out
+ *		the upper 16 bits
+ */
+#define LOWER_8BIT_MASK	   0x000000FF
+
+/*
+ * Definition: RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)
+ *
+ * DESCRIPTION: Returns a 32 bit value given a 16 bit lower value and a 16
+ *		bit upper value
+ */
+#define RETURN_32BITS_FROM_16LOWER_AND_16UPPER(lower16Bits, upper16Bits)\
+    (((((u32)lower16Bits)  & LOWER_16BIT_MASK)) | \
+     (((((u32)upper16Bits) & LOWER_16BIT_MASK) << UPPER_16BIT_SHIFT)))
+
+/*
+ * Definition: RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower16Bits, upper16Bits)
+ *
+ * DESCRIPTION:  Returns a 16 bit value given a 8 bit lower value and a 8
+ *	       bit upper value
+ */
+#define RETURN_16BITS_FROM_8LOWER_AND_8UPPER(lower8Bits, upper8Bits)\
+    (((((u32)lower8Bits)  & LOWER_8BIT_MASK)) | \
+     (((((u32)upper8Bits) & LOWER_8BIT_MASK) << UPPER_8BIT_OF16_SHIFT)))
+
+/*
+ * Definition: RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,
+ * 					lowerUpper8Bits, upper8Bits)
+ *
+ * DESCRIPTION:  Returns a 32 bit value given four 8 bit values
+ */
+#define RETURN_32BITS_FROM_4_8BIT_VALUES(lower8Bits, lowerMiddle8Bits,\
+	lowerUpper8Bits, upper8Bits)\
+	(((((u32)lower8Bits) & LOWER_8BIT_MASK)) | \
+	(((((u32)lowerMiddle8Bits) & LOWER_8BIT_MASK) <<\
+		LOWER_MIDDLE_8BIT_SHIFT)) | \
+	(((((u32)lowerUpper8Bits) & LOWER_8BIT_MASK) <<\
+		UPPER_MIDDLE_8BIT_SHIFT)) | \
+	(((((u32)upper8Bits) & LOWER_8BIT_MASK) <<\
+		UPPER_8BIT_SHIFT)))
+
+/*
+ * Definition: READ_LOWER_16BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 16 lower bits of 32bit value
+ */
+#define READ_LOWER_16BITS_OF_32(value32bits)\
+    ((u16)((u32)(value32bits) & LOWER_16BIT_MASK))
+
+/*
+ * Definition: READ_UPPER_16BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 16 lower bits of 32bit value
+ */
+#define READ_UPPER_16BITS_OF_32(value32bits)\
+	(((u16)((u32)(value32bits) >> UPPER_16BIT_SHIFT)) &\
+	LOWER_16BIT_MASK)
+
+
+/*
+ * Definition: READ_LOWER_8BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 8 lower bits of 32bit value
+ */
+#define READ_LOWER_8BITS_OF_32(value32bits)\
+    ((u8)((u32)(value32bits) & LOWER_8BIT_MASK))
+
+/*
+ * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
+ */
+#define READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
+	LOWER_8BIT_MASK)
+
+/*
+ * Definition: READ_LOWER_MIDDLE_8BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 8 lower middle bits of 32bit value
+ */
+#define READ_UPPER_MIDDLE_8BITS_OF_32(value32bits)\
+	(((u8)((u32)(value32bits) >> LOWER_MIDDLE_8BIT_SHIFT)) &\
+	LOWER_8BIT_MASK)
+
+/*
+ * Definition: READ_UPPER_8BITS_OF_32(value32bits)
+ *
+ * DESCRIPTION:  Returns a 8 upper bits of 32bit value
+ */
+#define READ_UPPER_8BITS_OF_32(value32bits)\
+    (((u8)((u32)(value32bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
+
+
+/*
+ * Definition: READ_LOWER_8BITS_OF_16(value16bits)
+ *
+ * DESCRIPTION:  Returns a 8 lower bits of 16bit value
+ */
+#define READ_LOWER_8BITS_OF_16(value16bits)\
+    ((u8)((u16)(value16bits) & LOWER_8BIT_MASK))
+
+/*
+ * Definition: READ_UPPER_8BITS_OF_16(value32bits)
+ *
+ * DESCRIPTION:  Returns a 8 upper bits of 16bit value
+ */
+#define READ_UPPER_8BITS_OF_16(value16bits)\
+    (((u8)((u32)(value16bits) >> UPPER_8BIT_SHIFT)) & LOWER_8BIT_MASK)
+
+
+
+/* UWORD16:  16 bit tpyes */
+
+
+/* REG_UWORD8, REG_WORD8: 8 bit register types */
+typedef volatile unsigned char  REG_UWORD8;
+typedef volatile signed   char  REG_WORD8;
+
+/* REG_UWORD16, REG_WORD16: 16 bit register types */
+#ifndef OMAPBRIDGE_TYPES
+typedef volatile unsigned short REG_UWORD16;
+#endif
+typedef volatile	  short REG_WORD16;
+
+/* REG_UWORD32, REG_WORD32: 32 bit register types */
+typedef volatile unsigned long  REG_UWORD32;
+
+/* FLOAT
+ *
+ * Type to be used for floating point calculation. Note that floating point
+ * calculation is very CPU expensive, and you should only  use if you
+ * absolutely need this. */
+
+
+/* boolean_t:  Boolean Type True, False */
+/* ReturnCode_t:  Return codes to be returned by all library functions */
+typedef enum ReturnCode_label {
+    RET_OK = 0,
+    RET_FAIL = -1,
+    RET_BAD_NULL_PARAM = -2,
+    RET_PARAM_OUT_OF_RANGE = -3,
+    RET_INVALID_ID = -4,
+    RET_EMPTY = -5,
+    RET_FULL = -6,
+    RET_TIMEOUT = -7,
+    RET_INVALID_OPERATION = -8,
+
+    /* Add new error codes at end of above list */
+
+    RET_NUM_RET_CODES     /* this should ALWAYS be LAST entry */
+} ReturnCode_t, *pReturnCode_t;
+
+/* MACRO: RD_MEM_8, WR_MEM_8
+ *
+ * DESCRIPTION:  32 bit memory access macros
+ */
+#define RD_MEM_8(addr)	((u8)(*((u8 *)(addr))))
+#define WR_MEM_8(addr, data)	(*((u8 *)(addr)) = (u8)(data))
+
+/* MACRO: RD_MEM_8_VOLATILE, WR_MEM_8_VOLATILE
+ *
+ * DESCRIPTION:  8 bit register access macros
+ */
+#define RD_MEM_8_VOLATILE(addr)	((u8)(*((REG_UWORD8 *)(addr))))
+#define WR_MEM_8_VOLATILE(addr, data) (*((REG_UWORD8 *)(addr)) = (u8)(data))
+
+
+/*
+ * MACRO: RD_MEM_16, WR_MEM_16
+ *
+ * DESCRIPTION:  16 bit memory access macros
+ */
+#define RD_MEM_16(addr)	((u16)(*((u16 *)(addr))))
+#define WR_MEM_16(addr, data)	(*((u16 *)(addr)) = (u16)(data))
+
+/*
+ * MACRO: RD_MEM_16_VOLATILE, WR_MEM_16_VOLATILE
+ *
+ * DESCRIPTION:  16 bit register access macros
+ */
+#define RD_MEM_16_VOLATILE(addr)	((u16)(*((REG_UWORD16 *)(addr))))
+#define WR_MEM_16_VOLATILE(addr, data)	(*((REG_UWORD16 *)(addr)) =\
+					(u16)(data))
+
+/*
+ * MACRO: RD_MEM_32, WR_MEM_32
+ *
+ * DESCRIPTION:  32 bit memory access macros
+ */
+#define RD_MEM_32(addr)	((u32)(*((u32 *)(addr))))
+#define WR_MEM_32(addr, data)	(*((u32 *)(addr)) = (u32)(data))
+
+/*
+ * MACRO: RD_MEM_32_VOLATILE, WR_MEM_32_VOLATILE
+ *
+ * DESCRIPTION:  32 bit register access macros
+ */
+#define RD_MEM_32_VOLATILE(addr)	((u32)(*((REG_UWORD32 *)(addr))))
+#define WR_MEM_32_VOLATILE(addr, data)	(*((REG_UWORD32 *)(addr)) =\
+					(u32)(data))
+
+/* Not sure if this all belongs here */
+
+#define CHECK_RETURN_VALUE(actualValue, expectedValue,  returnCodeIfMismatch,\
+	spyCodeIfMisMatch)
+#define CHECK_RETURN_VALUE_RET(actualValue, expectedValue, returnCodeIfMismatch)
+#define CHECK_RETURN_VALUE_RES(actualValue, expectedValue, spyCodeIfMisMatch)
+#define CHECK_RETURN_VALUE_RET_VOID(actualValue, expectedValue,\
+	spyCodeIfMisMatch)
+
+#define CHECK_INPUT_PARAM(actualValue, invalidValue, returnCodeIfMismatch,\
+	spyCodeIfMisMatch)
+#define CHECK_INPUT_PARAM_NO_SPY(actualValue, invalidValue,\
+	returnCodeIfMismatch)
+#define CHECK_INPUT_RANGE(actualValue, minValidValue, maxValidValue,\
+	returnCodeIfMismatch, spyCodeIfMisMatch)
+#define CHECK_INPUT_RANGE_NO_SPY(actualValue, minValidValue, maxValidValue,\
+	returnCodeIfMismatch)
+#define CHECK_INPUT_RANGE_MIN0(actualValue, maxValidValue,\
+	returnCodeIfMismatch, spyCodeIfMisMatch)
+#define CHECK_INPUT_RANGE_NO_SPY_MIN0(actualValue, maxValidValue,\
+	returnCodeIfMismatch)
+
+#endif	/* __GLOBALTYPES_H */
diff --git a/drivers/dsp/bridge/hw/IPIAccInt.h b/drivers/dsp/bridge/hw/IPIAccInt.h
new file mode 100644
index 0000000..dde0ef0
--- /dev/null
+++ b/drivers/dsp/bridge/hw/IPIAccInt.h
@@ -0,0 +1,26 @@
+/*
+ * IPIAccInt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _IPI_ACC_INT_H
+#define _IPI_ACC_INT_H
+
+/* Bitfield mask and offset declarations */
+#define SYSC_IVA2BOOTMOD_OFFSET                   0x404
+#define SYSC_IVA2BOOTADDR_OFFSET                0x400
+#define SYSC_IVA2BOOTADDR_MASK                 0xfffffc00
+
+#endif				/* _IPI_ACC_INT_H */
+/* EOF */
diff --git a/drivers/dsp/bridge/hw/IVA2RegAcM.h b/drivers/dsp/bridge/hw/IVA2RegAcM.h
new file mode 100644
index 0000000..6c1e300
--- /dev/null
+++ b/drivers/dsp/bridge/hw/IVA2RegAcM.h
@@ -0,0 +1,28 @@
+/*
+ * IVA1RegAcM.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+
+#ifndef _IVA2_REG_ACM_H
+#define _IVA2_REG_ACM_H
+
+#include <GlobalTypes.h>
+#include <EasiGlobal.h>
+
+#define SYSC_IVA2BOOTMOD_OFFSET	    0x404
+#define SYSC_IVA2BOOTADDR_OFFSET	    0x400
+
+#endif
diff --git a/drivers/dsp/bridge/hw/MLBAccInt.h b/drivers/dsp/bridge/hw/MLBAccInt.h
new file mode 100644
index 0000000..7a03c6a
--- /dev/null
+++ b/drivers/dsp/bridge/hw/MLBAccInt.h
@@ -0,0 +1,132 @@
+/*
+ * MLBAccInt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+#ifndef _MLB_ACC_INT_H
+#define _MLB_ACC_INT_H
+
+/* Mappings of level 1 EASI function numbers to function names */
+
+#define EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32   (MLB_BASE_EASIL1 + 3)
+#define EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32  (MLB_BASE_EASIL1 + 4)
+#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32   (MLB_BASE_EASIL1 + 7)
+#define EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32  (MLB_BASE_EASIL1 + 17)
+#define EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32 (MLB_BASE_EASIL1 + 29)
+#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32 \
+						(MLB_BASE_EASIL1 + 33)
+#define EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32   (MLB_BASE_EASIL1 + 39)
+#define EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32  (MLB_BASE_EASIL1 + 44)
+#define EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32 \
+						(MLB_BASE_EASIL1 + 50)
+#define EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32  \
+						(MLB_BASE_EASIL1 + 51)
+#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32  \
+						(MLB_BASE_EASIL1 + 56)
+#define EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32 \
+						(MLB_BASE_EASIL1 + 57)
+#define EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32  \
+						(MLB_BASE_EASIL1 + 60)
+#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32  \
+						(MLB_BASE_EASIL1 + 62)
+#define EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32 \
+						(MLB_BASE_EASIL1 + 63)
+#define EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32    \
+						(MLB_BASE_EASIL1 + 192)
+#define EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32   \
+						(MLB_BASE_EASIL1 + 193)
+
+/* Register set MAILBOX_MESSAGE___REGSET_0_15 address offset, bank address
+ * increment and number of banks */
+
+#define MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET    (u32)(0x0040)
+#define MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP   (u32)(0x0004)
+
+/* Register offset address definitions relative to register set
+ * MAILBOX_MESSAGE___REGSET_0_15 */
+
+#define MLB_MAILBOX_MESSAGE___0_15_OFFSET   (u32)(0x0)
+
+
+/* Register set MAILBOX_FIFOSTATUS___REGSET_0_15 address offset, bank address
+ * increment and number of banks */
+
+#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET  (u32)(0x0080)
+#define MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP   (u32)(0x0004)
+
+/* Register offset address definitions relative to register set
+ * MAILBOX_FIFOSTATUS___REGSET_0_15 */
+
+#define MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET    (u32)(0x0)
+
+
+/* Register set MAILBOX_MSGSTATUS___REGSET_0_15 address offset, bank address
+ * increment and number of banks */
+
+#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET  (u32)(0x00c0)
+#define MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP    (u32)(0x0004)
+
+/* Register offset address definitions relative to register set
+ * MAILBOX_MSGSTATUS___REGSET_0_15 */
+
+#define MLB_MAILBOX_MSGSTATUS___0_15_OFFSET    (u32)(0x0)
+
+
+/* Register set MAILBOX_IRQSTATUS___REGSET_0_3 address offset, bank address
+ * increment and number of banks */
+
+#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET        (u32)(0x0100)
+#define MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP          (u32)(0x0008)
+
+/* Register offset address definitions relative to register set
+ * MAILBOX_IRQSTATUS___REGSET_0_3 */
+
+#define MLB_MAILBOX_IRQSTATUS___0_3_OFFSET        (u32)(0x0)
+
+
+/* Register set MAILBOX_IRQENABLE___REGSET_0_3 address offset, bank address
+ * increment and number of banks */
+
+#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET     (u32)(0x0104)
+#define MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP     (u32)(0x0008)
+
+/* Register offset address definitions relative to register set
+ * MAILBOX_IRQENABLE___REGSET_0_3 */
+
+#define MLB_MAILBOX_IRQENABLE___0_3_OFFSET          (u32)(0x0)
+
+
+/* Register offset address definitions */
+
+#define MLB_MAILBOX_SYSCONFIG_OFFSET            (u32)(0x10)
+#define MLB_MAILBOX_SYSSTATUS_OFFSET            (u32)(0x14)
+
+
+/* Bitfield mask and offset declarations */
+
+#define MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK        (u32)(0x18)
+#define MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET      (u32)(3)
+#define MLB_MAILBOX_SYSCONFIG_SoftReset_MASK        (u32)(0x2)
+#define MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET      (u32)(1)
+#define MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK          (u32)(0x1)
+#define MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET        (u32)(0)
+#define MLB_MAILBOX_SYSSTATUS_ResetDone_MASK         (u32)(0x1)
+#define MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET         (u32)(0)
+#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK   (u32)(0x1)
+#define MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET  (u32)(0)
+#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK    (u32)(0x7f)
+#define MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET    (u32)(0)
+
+#endif /* _MLB_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/MLBRegAcM.h b/drivers/dsp/bridge/hw/MLBRegAcM.h
new file mode 100644
index 0000000..29f6de3
--- /dev/null
+++ b/drivers/dsp/bridge/hw/MLBRegAcM.h
@@ -0,0 +1,201 @@
+/*
+ * MLBRegAcM.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _MLB_REG_ACM_H
+#define _MLB_REG_ACM_H
+
+#include <GlobalTypes.h>
+#include <linux/io.h>
+#include <EasiGlobal.h>
+#include "MLBAccInt.h"
+
+#if defined(USE_LEVEL_1_MACROS)
+
+#define MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGReadRegister32),\
+      __raw_readl(((baseAddress))+ \
+      MLB_MAILBOX_SYSCONFIG_OFFSET))
+
+
+#define MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGWriteRegister32);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
+}
+
+
+#define MLBMAILBOX_SYSCONFIGSIdleModeRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
+      MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK) >>\
+      MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET))
+
+
+#define MLBMAILBOX_SYSCONFIGSIdleModeWrite32(baseAddress, value)\
+{\
+    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
+    register u32 data = __raw_readl(((u32)(baseAddress)) +\
+			    offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSIdleModeWrite32);\
+    data &= ~(MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK);\
+    newValue <<= MLB_MAILBOX_SYSCONFIG_SIdleMode_OFFSET;\
+    newValue &= MLB_MAILBOX_SYSCONFIG_SIdleMode_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define MLBMAILBOX_SYSCONFIGSoftResetWrite32(baseAddress, value)\
+{\
+    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
+    register u32 data =\
+    __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGSoftResetWrite32);\
+    data &= ~(MLB_MAILBOX_SYSCONFIG_SoftReset_MASK);\
+    newValue <<= MLB_MAILBOX_SYSCONFIG_SoftReset_OFFSET;\
+    newValue &= MLB_MAILBOX_SYSCONFIG_SoftReset_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define MLBMAILBOX_SYSCONFIGAutoIdleRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+      (MLB_MAILBOX_SYSCONFIG_OFFSET)))) &\
+      MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK) >>\
+      MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET))
+
+
+#define MLBMAILBOX_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
+{\
+    const u32 offset = MLB_MAILBOX_SYSCONFIG_OFFSET;\
+    register u32 data =\
+    __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSCONFIGAutoIdleWrite32);\
+    data &= ~(MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK);\
+    newValue <<= MLB_MAILBOX_SYSCONFIG_AutoIdle_OFFSET;\
+    newValue &= MLB_MAILBOX_SYSCONFIG_AutoIdle_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define MLBMAILBOX_SYSSTATUSResetDoneRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_SYSSTATUSResetDoneRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+      (MLB_MAILBOX_SYSSTATUS_OFFSET)))) &\
+      MLB_MAILBOX_SYSSTATUS_ResetDone_MASK) >>\
+      MLB_MAILBOX_SYSSTATUS_ResetDone_OFFSET))
+
+
+#define MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15ReadRegister32),\
+      __raw_readl(((baseAddress))+\
+      (MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
+      MLB_MAILBOX_MESSAGE___0_15_OFFSET+(\
+      (bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP))))
+
+
+#define MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, bank, value)\
+{\
+    const u32 offset = MLB_MAILBOX_MESSAGE___REGSET_0_15_OFFSET +\
+    MLB_MAILBOX_MESSAGE___0_15_OFFSET +\
+    ((bank)*MLB_MAILBOX_MESSAGE___REGSET_0_15_STEP);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_MESSAGE___0_15WriteRegister32);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
+}
+
+
+#define MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(\
+      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15ReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+\
+      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
+      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
+      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP))))
+
+
+#define MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(\
+      EASIL1_MLBMAILBOX_FIFOSTATUS___0_15FifoFullMBmRead32),\
+      (((__raw_readl(((baseAddress))+\
+      (MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_OFFSET +\
+      MLB_MAILBOX_FIFOSTATUS___0_15_OFFSET+\
+      ((bank)*MLB_MAILBOX_FIFOSTATUS___REGSET_0_15_STEP)))) &\
+      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_MASK) >>\
+      MLB_MAILBOX_FIFOSTATUS___0_15_FifoFullMBm_OFFSET))
+
+
+#define MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(\
+      EASIL1_MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32),\
+      (((__raw_readl(((baseAddress))+\
+      (MLB_MAILBOX_MSGSTATUS___REGSET_0_15_OFFSET +\
+      MLB_MAILBOX_MSGSTATUS___0_15_OFFSET+\
+      ((bank)*MLB_MAILBOX_MSGSTATUS___REGSET_0_15_STEP)))) &\
+      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_MASK) >>\
+      MLB_MAILBOX_MSGSTATUS___0_15_NbOfMsgMBm_OFFSET))
+
+
+#define MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3ReadRegister32),\
+      __raw_readl(((baseAddress))+\
+      (MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
+      MLB_MAILBOX_IRQSTATUS___0_3_OFFSET+\
+      ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP))))
+
+
+#define MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, bank, value)\
+{\
+    const u32 offset = MLB_MAILBOX_IRQSTATUS___REGSET_0_3_OFFSET +\
+    MLB_MAILBOX_IRQSTATUS___0_3_OFFSET +\
+    ((bank)*MLB_MAILBOX_IRQSTATUS___REGSET_0_3_STEP);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQSTATUS___0_3WriteRegister32);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
+}
+
+
+#define MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress, bank)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3ReadRegister32),\
+      __raw_readl(((baseAddress))+\
+      (MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
+      MLB_MAILBOX_IRQENABLE___0_3_OFFSET+\
+       ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP))))
+
+
+#define MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, bank, value)\
+{\
+    const u32 offset = MLB_MAILBOX_IRQENABLE___REGSET_0_3_OFFSET +\
+      MLB_MAILBOX_IRQENABLE___0_3_OFFSET +\
+      ((bank)*MLB_MAILBOX_IRQENABLE___REGSET_0_3_STEP);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MLBMAILBOX_IRQENABLE___0_3WriteRegister32);\
+    __raw_writel(newValue, ((baseAddress))+offset);\
+}
+
+
+#endif	/* USE_LEVEL_1_MACROS */
+
+#endif /* _MLB_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/MMUAccInt.h b/drivers/dsp/bridge/hw/MMUAccInt.h
new file mode 100644
index 0000000..6ca1573
--- /dev/null
+++ b/drivers/dsp/bridge/hw/MMUAccInt.h
@@ -0,0 +1,76 @@
+/*
+ * MMUAccInt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _MMU_ACC_INT_H
+#define _MMU_ACC_INT_H
+
+/* Mappings of level 1 EASI function numbers to function names */
+
+#define EASIL1_MMUMMU_SYSCONFIGReadRegister32 (MMU_BASE_EASIL1 + 3)
+#define EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32  (MMU_BASE_EASIL1 + 17)
+#define EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32    (MMU_BASE_EASIL1 + 39)
+#define EASIL1_MMUMMU_IRQSTATUSWriteRegister32   (MMU_BASE_EASIL1 + 51)
+#define EASIL1_MMUMMU_IRQENABLEReadRegister32 (MMU_BASE_EASIL1 + 102)
+#define EASIL1_MMUMMU_IRQENABLEWriteRegister32 (MMU_BASE_EASIL1 + 103)
+#define EASIL1_MMUMMU_WALKING_STTWLRunningRead32 (MMU_BASE_EASIL1 + 156)
+#define EASIL1_MMUMMU_CNTLTWLEnableRead32 (MMU_BASE_EASIL1 + 174)
+#define EASIL1_MMUMMU_CNTLTWLEnableWrite32   (MMU_BASE_EASIL1 + 180)
+#define EASIL1_MMUMMU_CNTLMMUEnableWrite32     (MMU_BASE_EASIL1 + 190)
+#define EASIL1_MMUMMU_FAULT_ADReadRegister32   (MMU_BASE_EASIL1 + 194)
+#define EASIL1_MMUMMU_TTBWriteRegister32  (MMU_BASE_EASIL1 + 198)
+#define EASIL1_MMUMMU_LOCKReadRegister32   (MMU_BASE_EASIL1 + 203)
+#define EASIL1_MMUMMU_LOCKWriteRegister32  (MMU_BASE_EASIL1 + 204)
+#define EASIL1_MMUMMU_LOCKBaseValueRead32  (MMU_BASE_EASIL1 + 205)
+#define EASIL1_MMUMMU_LOCKCurrentVictimRead32 (MMU_BASE_EASIL1 + 209)
+#define EASIL1_MMUMMU_LOCKCurrentVictimWrite32 (MMU_BASE_EASIL1 + 211)
+#define EASIL1_MMUMMU_LOCKCurrentVictimSet32  (MMU_BASE_EASIL1 + 212)
+#define EASIL1_MMUMMU_LD_TLBReadRegister32    (MMU_BASE_EASIL1 + 213)
+#define EASIL1_MMUMMU_LD_TLBWriteRegister32   (MMU_BASE_EASIL1 + 214)
+#define EASIL1_MMUMMU_CAMWriteRegister32   (MMU_BASE_EASIL1 + 226)
+#define EASIL1_MMUMMU_RAMWriteRegister32 (MMU_BASE_EASIL1 + 268)
+#define EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32  (MMU_BASE_EASIL1 + 322)
+
+/* Register offset address definitions */
+#define MMU_MMU_SYSCONFIG_OFFSET   0x10
+#define MMU_MMU_IRQSTATUS_OFFSET  0x18
+#define MMU_MMU_IRQENABLE_OFFSET    0x1c
+#define MMU_MMU_WALKING_ST_OFFSET 0x40
+#define MMU_MMU_CNTL_OFFSET   0x44
+#define MMU_MMU_FAULT_AD_OFFSET  0x48
+#define MMU_MMU_TTB_OFFSET  0x4c
+#define MMU_MMU_LOCK_OFFSET   0x50
+#define MMU_MMU_LD_TLB_OFFSET  0x54
+#define MMU_MMU_CAM_OFFSET   0x58
+#define MMU_MMU_RAM_OFFSET   0x5c
+#define MMU_MMU_GFLUSH_OFFSET  0x60
+#define MMU_MMU_FLUSH_ENTRY_OFFSET  0x64
+/* Bitfield mask and offset declarations */
+#define MMU_MMU_SYSCONFIG_IdleMode_MASK  0x18
+#define MMU_MMU_SYSCONFIG_IdleMode_OFFSET  3
+#define MMU_MMU_SYSCONFIG_AutoIdle_MASK  0x1
+#define MMU_MMU_SYSCONFIG_AutoIdle_OFFSET   0
+#define MMU_MMU_WALKING_ST_TWLRunning_MASK 0x1
+#define MMU_MMU_WALKING_ST_TWLRunning_OFFSET  0
+#define MMU_MMU_CNTL_TWLEnable_MASK 0x4
+#define MMU_MMU_CNTL_TWLEnable_OFFSET 2
+#define MMU_MMU_CNTL_MMUEnable_MASK    0x2
+#define MMU_MMU_CNTL_MMUEnable_OFFSET   1
+#define MMU_MMU_LOCK_BaseValue_MASK 0xfc00
+#define MMU_MMU_LOCK_BaseValue_OFFSET   10
+#define MMU_MMU_LOCK_CurrentVictim_MASK   0x3f0
+#define MMU_MMU_LOCK_CurrentVictim_OFFSET    4
+
+#endif /* _MMU_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/MMURegAcM.h b/drivers/dsp/bridge/hw/MMURegAcM.h
new file mode 100644
index 0000000..6ef5915
--- /dev/null
+++ b/drivers/dsp/bridge/hw/MMURegAcM.h
@@ -0,0 +1,253 @@
+/*
+ * MMURegAcM.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+
+#ifndef _MMU_REG_ACM_H
+#define _MMU_REG_ACM_H
+
+#include <GlobalTypes.h>
+#include <linux/io.h>
+#include <EasiGlobal.h>
+
+#include "MMUAccInt.h"
+
+#if defined(USE_LEVEL_1_MACROS)
+
+
+#define MMUMMU_SYSCONFIGReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_SYSCONFIG_OFFSET))
+
+
+#define MMUMMU_SYSCONFIGIdleModeWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGIdleModeWrite32);\
+    data &= ~(MMU_MMU_SYSCONFIG_IdleMode_MASK);\
+    newValue <<= MMU_MMU_SYSCONFIG_IdleMode_OFFSET;\
+    newValue &= MMU_MMU_SYSCONFIG_IdleMode_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_SYSCONFIGAutoIdleWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_SYSCONFIG_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_SYSCONFIGAutoIdleWrite32);\
+    data &= ~(MMU_MMU_SYSCONFIG_AutoIdle_MASK);\
+    newValue <<= MMU_MMU_SYSCONFIG_AutoIdle_OFFSET;\
+    newValue &= MMU_MMU_SYSCONFIG_AutoIdle_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_IRQSTATUSReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_IRQSTATUS_OFFSET))
+
+
+#define MMUMMU_IRQSTATUSWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_IRQSTATUS_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQSTATUSWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_IRQENABLEReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_IRQENABLE_OFFSET))
+
+
+#define MMUMMU_IRQENABLEWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_IRQENABLE_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_IRQENABLEWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_WALKING_STTWLRunningRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_WALKING_STTWLRunningRead32),\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_WALKING_ST_OFFSET))))\
+      & MMU_MMU_WALKING_ST_TWLRunning_MASK) >>\
+      MMU_MMU_WALKING_ST_TWLRunning_OFFSET))
+
+
+#define MMUMMU_CNTLTWLEnableRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableRead32),\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_CNTL_OFFSET)))) &\
+      MMU_MMU_CNTL_TWLEnable_MASK) >>\
+      MMU_MMU_CNTL_TWLEnable_OFFSET))
+
+
+#define MMUMMU_CNTLTWLEnableWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_CNTL_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLTWLEnableWrite32);\
+    data &= ~(MMU_MMU_CNTL_TWLEnable_MASK);\
+    newValue <<= MMU_MMU_CNTL_TWLEnable_OFFSET;\
+    newValue &= MMU_MMU_CNTL_TWLEnable_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_CNTLMMUEnableWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_CNTL_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CNTLMMUEnableWrite32);\
+    data &= ~(MMU_MMU_CNTL_MMUEnable_MASK);\
+    newValue <<= MMU_MMU_CNTL_MMUEnable_OFFSET;\
+    newValue &= MMU_MMU_CNTL_MMUEnable_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_FAULT_ADReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FAULT_ADReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_FAULT_AD_OFFSET))
+
+
+#define MMUMMU_TTBWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_TTB_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_TTBWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_LOCKReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_LOCK_OFFSET))
+
+
+#define MMUMMU_LOCKWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_LOCK_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_LOCKBaseValueRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueRead32),\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
+      MMU_MMU_LOCK_BaseValue_MASK) >>\
+      MMU_MMU_LOCK_BaseValue_OFFSET))
+
+
+#define MMUMMU_LOCKBaseValueWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_LOCK_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKBaseValueWrite32);\
+    data &= ~(MMU_MMU_LOCK_BaseValue_MASK);\
+    newValue <<= MMU_MMU_LOCK_BaseValue_OFFSET;\
+    newValue &= MMU_MMU_LOCK_BaseValue_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_LOCKCurrentVictimRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimRead32),\
+      (((__raw_readl(((baseAddress)+(MMU_MMU_LOCK_OFFSET)))) &\
+      MMU_MMU_LOCK_CurrentVictim_MASK) >>\
+      MMU_MMU_LOCK_CurrentVictim_OFFSET))
+
+
+#define MMUMMU_LOCKCurrentVictimWrite32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_LOCK_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimWrite32);\
+    data &= ~(MMU_MMU_LOCK_CurrentVictim_MASK);\
+    newValue <<= MMU_MMU_LOCK_CurrentVictim_OFFSET;\
+    newValue &= MMU_MMU_LOCK_CurrentVictim_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, baseAddress+offset);\
+}
+
+
+#define MMUMMU_LOCKCurrentVictimSet32(var, value)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LOCKCurrentVictimSet32),\
+      (((var) & ~(MMU_MMU_LOCK_CurrentVictim_MASK)) |\
+      (((value) << MMU_MMU_LOCK_CurrentVictim_OFFSET) &\
+      MMU_MMU_LOCK_CurrentVictim_MASK)))
+
+
+#define MMUMMU_LD_TLBReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBReadRegister32),\
+      __raw_readl((baseAddress)+MMU_MMU_LD_TLB_OFFSET))
+
+
+#define MMUMMU_LD_TLBWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_LD_TLB_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_LD_TLBWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_CAMWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_CAM_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_CAMWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_RAMWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_RAM_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_RAMWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = MMU_MMU_FLUSH_ENTRY_OFFSET;\
+    register u32 newValue = (value);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_MMUMMU_FLUSH_ENTRYWriteRegister32);\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#endif	/* USE_LEVEL_1_MACROS */
+
+#endif /* _MMU_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/PRCMAccInt.h b/drivers/dsp/bridge/hw/PRCMAccInt.h
new file mode 100644
index 0000000..5a11f01
--- /dev/null
+++ b/drivers/dsp/bridge/hw/PRCMAccInt.h
@@ -0,0 +1,300 @@
+/*
+ * PRCMAccInt.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _PRCM_ACC_INT_H
+#define _PRCM_ACC_INT_H
+
+/* Mappings of level 1 EASI function numbers to function names */
+
+#define EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32  \
+						(PRCM_BASE_EASIL1 + 349)
+#define EASIL1_PRCMCM_FCLKEN1_COREReadRegister32	(PRCM_BASE_EASIL1 + 743)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32	(PRCM_BASE_EASIL1 + 951)
+#define EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32	(PRCM_BASE_EASIL1 + 961)
+#define EASIL1_PRCMCM_ICLKEN1_COREReadRegister32	\
+						(PRCM_BASE_EASIL1 + 1087)
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32	\
+						(PRCM_BASE_EASIL1 + 1105)
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32	\
+						(PRCM_BASE_EASIL1 + 1305)
+#define EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32	\
+						(PRCM_BASE_EASIL1 + 1315)
+#define EASIL1_PRCMCM_CLKSEL1_CORECLKSEL_L3ReadIssel132	\
+						(PRCM_BASE_EASIL1 + 2261)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32	\
+						(PRCM_BASE_EASIL1 + 2364)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32	\
+						(PRCM_BASE_EASIL1 + 2365)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32	\
+						(PRCM_BASE_EASIL1 + 2366)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32	\
+						(PRCM_BASE_EASIL1 + 2380)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32	\
+						(PRCM_BASE_EASIL1 + 2381)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32	\
+						(PRCM_BASE_EASIL1 + 2382)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32	\
+						(PRCM_BASE_EASIL1 + 2397)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32	\
+						(PRCM_BASE_EASIL1 + 2398)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32	\
+						(PRCM_BASE_EASIL1 + 2413)
+#define EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32	\
+						(PRCM_BASE_EASIL1 + 2414)
+#define EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32	\
+						(PRCM_BASE_EASIL1 + 3747)
+#define EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32	(PRCM_BASE_EASIL1 + 3834)
+#define EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32	\
+						(PRCM_BASE_EASIL1 + 3846)
+#define EASIL1_PRCMCM_IDLEST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3850)
+#define EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32	(PRCM_BASE_EASIL1 + 3857)
+#define EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32	(PRCM_BASE_EASIL1 + 3863)
+#define EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32	\
+						(PRCM_BASE_EASIL1 + 3877)
+#define EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32	(PRCM_BASE_EASIL1 + 3927)
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32	\
+						(PRCM_BASE_EASIL1 + 3941)
+#define EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32	\
+						(PRCM_BASE_EASIL1 + 3965)
+#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32	\
+						(PRCM_BASE_EASIL1 + 3987)
+#define EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32	\
+						(PRCM_BASE_EASIL1 + 3993)
+#define EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32	(PRCM_BASE_EASIL1 + 3997)
+#define EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32	\
+						(PRCM_BASE_EASIL1 + 4025)
+#define EASIL1_PRCMRM_RSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4029)
+#define EASIL1_PRCMRM_RSTST_DSPWriteRegister32	(PRCM_BASE_EASIL1 + 4030)
+#define EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32	\
+						(PRCM_BASE_EASIL1 + 4165)
+#define EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32	\
+						(PRCM_BASE_EASIL1 + 4193)
+#define EASIL1_PRCMPM_PWSTST_DSPReadRegister32	(PRCM_BASE_EASIL1 + 4197)
+#define EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32	\
+						(PRCM_BASE_EASIL1 + 4198)
+#define EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32	\
+						(PRCM_BASE_EASIL1 + 4235)
+#define EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32	\
+						(PRCM_BASE_EASIL1 + 4368)
+#define EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32	\
+						(PRCM_BASE_EASIL1 + 4370)
+#define EASIL1_CM_CLKSEL_PER_GPT5Write32k32	(PRCM_BASE_EASIL1 + 4372)
+#define EASIL1_CM_CLKSEL_PER_GPT6Write32k32	(PRCM_BASE_EASIL1 + 4373)
+#define EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32	\
+						(PRCM_BASE_EASIL1 + 4374)
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32	\
+						(PRCM_BASE_EASIL1 + 4375)
+#define EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32	\
+						(PRCM_BASE_EASIL1 + 4376)
+#define EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32	\
+						(PRCM_BASE_EASIL1 + 4377)
+#define EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32	\
+						(PRCM_BASE_EASIL1 + 4378)
+#define EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32	(PRCM_BASE_EASIL1 + 4379)
+
+/* Register offset address definitions */
+
+#define PRCM_PRCM_CLKCFG_CTRL_OFFSET        (u32)(0x80)
+#define PRCM_CM_FCLKEN1_CORE_OFFSET          (u32)(0x200)
+#define PRCM_CM_ICLKEN1_CORE_OFFSET          (u32)(0x210)
+#define PRCM_CM_CLKSEL2_CORE_OFFSET          (u32)(0x244)
+#define PRCM_CM_CLKSEL1_PLL_OFFSET           (u32)(0x540)
+#define PRCM_CM_ICLKEN_DSP_OFFSET            (u32)(0x810)
+#define PRCM_CM_IDLEST_DSP_OFFSET            (u32)(0x820)
+#define PRCM_CM_AUTOIDLE_DSP_OFFSET          (u32)(0x830)
+#define PRCM_CM_CLKSEL_DSP_OFFSET            (u32)(0x840)
+#define PRCM_CM_CLKSTCTRL_DSP_OFFSET         (u32)(0x848)
+#define PRCM_RM_RSTCTRL_DSP_OFFSET           (u32)(0x050)
+#define PRCM_RM_RSTST_DSP_OFFSET             (u32)(0x058)
+#define PRCM_PM_PWSTCTRL_DSP_OFFSET          (u32)(0x8e0)
+#define PRCM_PM_PWSTST_DSP_OFFSET            (u32)(0x8e4)
+#define PRCM_PM_PWSTST_IVA2_OFFSET            (u32)(0xE4)
+#define PRCM_PM_PWSTCTRL_IVA2_OFFSET          (u32)(0xE0)
+#define PRCM_CM_CLKSTCTRL_IVA2_OFFSET         (u32)(0x48)
+#define CM_CLKSEL_PER_OFFSET                            (u32)(0x40)
+
+/* Bitfield mask and offset declarations */
+
+#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK         (u32)(0x1)
+#define PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET       (u32)(0)
+
+#define PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
+#define PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
+
+#define PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK               (u32)(0x200)
+#define PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET             (u32)(9)
+
+#define PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK               (u32)(0x400)
+#define PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET             (u32)(10)
+
+#define PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK               (u32)(0x200)
+#define PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET             (u32)(9)
+
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK           (u32)(0xc000)
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET         (u32)(14)
+
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK           (u32)(0x3000)
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET         (u32)(12)
+
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK           (u32)(0xc00)
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET         (u32)(10)
+
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK           (u32)(0x300)
+#define PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET         (u32)(8)
+
+#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK            (u32)(0x3800000)
+#define PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET          (u32)(23)
+
+#define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK              (u32)(0x2)
+#define PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET            (u32)(1)
+
+#define PRCM_CM_IDLEST_DSP_ST_IPI_MASK                  (u32)(0x2)
+#define PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET                (u32)(1)
+
+#define PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK          (u32)(0x2)
+#define PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET        (u32)(1)
+
+#define PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK                (u32)(0x80)
+#define PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET              (u32)(7)
+
+#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK           (u32)(0x60)
+#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET         (u32)(5)
+
+#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK              (u32)(0x1f)
+#define PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET            (u32)(0)
+
+#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK        (u32)(0x1)
+#define PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET      (u32)(0)
+
+#define PRCM_PM_PWSTCTRL_DSP_ForceState_MASK            (u32)(0x40000)
+#define PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET          (u32)(18)
+
+#define PRCM_PM_PWSTCTRL_DSP_PowerState_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET          (u32)(0)
+
+#define PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET          (u32)(0)
+
+#define PRCM_PM_PWSTST_DSP_InTransition_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_DSP_InTransition_OFFSET          (u32)(20)
+
+#define PRCM_PM_PWSTST_IVA2_InTransition_MASK            (u32)(0x100000)
+#define PRCM_PM_PWSTST_IVA2_InTransition_OFFSET          (u32)(20)
+
+#define PRCM_PM_PWSTST_DSP_PowerStateSt_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET          (u32)(0)
+
+#define PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK            (u32)(0x3)
+#define PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET          (u32)(0)
+
+#define CM_FCLKEN_PER_OFFSET		(u32)(0x0)
+#define CM_FCLKEN_PER_GPT5_OFFSET         (u32)(6)
+#define CM_FCLKEN_PER_GPT5_MASK     (u32)(0x40)
+
+#define CM_FCLKEN_PER_GPT6_OFFSET   (u32)(7)
+#define CM_FCLKEN_PER_GPT6_MASK      (u32)(0x80)
+
+#define CM_ICLKEN_PER_OFFSET		(u32)(0x10)
+#define CM_ICLKEN_PER_GPT5_OFFSET  (u32)(6)
+#define CM_ICLKEN_PER_GPT5_MASK     (u32)(0x40)
+
+#define CM_ICLKEN_PER_GPT6_OFFSET  (u32)(7)
+#define CM_ICLKEN_PER_GPT6_MASK     (u32)(0x80)
+
+#define CM_CLKSEL_PER_GPT5_OFFSET   (u32)(3)
+#define CM_CLKSEL_PER_GPT5_MASK      (u32)(0x8)
+
+#define CM_CLKSEL_PER_GPT6_OFFSET   (u32)(4)
+#define CM_CLKSEL_PER_GPT6_MASK       (u32)(0x10)
+
+
+#define CM_FCLKEN_IVA2_OFFSET		(u32)(0x0)
+#define CM_FCLKEN_IVA2_EN_MASK	(u32)(0x1)
+#define CM_FCLKEN_IVA2_EN_OFFSET	(u32)(0x0)
+
+#define CM_IDLEST_IVA2_OFFSET 		(u32)(0x20)
+#define CM_IDLEST_IVA2_ST_IVA2_MASK (u32) (0x01)
+#define CM_IDLEST_IVA2_ST_IVA2_OFFSET (u32) (0x00)
+
+#define CM_FCLKEN1_CORE_OFFSET 	(u32)(0xA00)
+
+#define CM_ICLKEN1_CORE_OFFSET  	(u32)(0xA10)
+#define CM_ICLKEN1_CORE_EN_MAILBOXES_MASK  (u32)(0x00000080)   /* bit 7 */
+#define CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET	(u32)(7)
+
+#define CM_CLKSTCTRL_IVA2_OFFSET (u32)(0x0)
+#define CM_CLKSTCTRL_IVA2_MASK    (u32)(0x3)
+
+
+#define PRM_RSTCTRL_IVA2_OFFSET  	(u32)(0x50)
+#define PRM_RSTCTRL_IVA2_RST1_MASK	(u32)(0x1)
+#define PRM_RSTCTRL_IVA2_RST1_OFFSET	(u32)(0x0)
+#define PRM_RSTCTRL_IVA2_RST2_MASK	(u32)(0x2)
+#define PRM_RSTCTRL_IVA2_RST2_OFFSET	(u32)(0x1)
+#define PRM_RSTCTRL_IVA2_RST3_MASK	(u32)(0x4)
+#define PRM_RSTCTRL_IVA2_RST3_OFFSET	(u32)(0x2)
+
+
+/* The following represent the enumerated values for each bitfield */
+
+enum PRCMPRCM_CLKCFG_CTRLValid_configE {
+    PRCMPRCM_CLKCFG_CTRLValid_configUpdated = 0x0000,
+    PRCMPRCM_CLKCFG_CTRLValid_configClk_valid = 0x0001
+} ;
+
+enum PRCMCM_CLKSEL2_CORECLKSEL_GPT8E {
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT832k = 0x0000,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys = 0x0001,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext = 0x0002,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT8Reserved = 0x0003
+} ;
+
+enum PRCMCM_CLKSEL2_CORECLKSEL_GPT7E {
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT732k = 0x0000,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys = 0x0001,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext = 0x0002,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT7Reserved = 0x0003
+} ;
+
+enum PRCMCM_CLKSEL2_CORECLKSEL_GPT6E {
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT632k = 0x0000,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys = 0x0001,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext = 0x0002,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT6Reserved = 0x0003
+} ;
+
+enum PRCMCM_CLKSEL2_CORECLKSEL_GPT5E {
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT532k = 0x0000,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys = 0x0001,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext = 0x0002,
+    PRCMCM_CLKSEL2_CORECLKSEL_GPT5Reserved = 0x0003
+} ;
+
+enum PRCMPM_PWSTCTRL_DSPPowerStateE {
+    PRCMPM_PWSTCTRL_DSPPowerStateON = 0x0000,
+    PRCMPM_PWSTCTRL_DSPPowerStateRET = 0x0001,
+    PRCMPM_PWSTCTRL_DSPPowerStateReserved = 0x0002,
+    PRCMPM_PWSTCTRL_DSPPowerStateOFF = 0x0003
+} ;
+
+enum PRCMPM_PWSTCTRL_IVA2PowerStateE {
+    PRCMPM_PWSTCTRL_IVA2PowerStateON = 0x0003,
+    PRCMPM_PWSTCTRL_IVA2PowerStateRET = 0x0001,
+    PRCMPM_PWSTCTRL_IVA2PowerStateReserved = 0x0002,
+    PRCMPM_PWSTCTRL_IVA2PowerStateOFF = 0x0000
+} ;
+
+#endif /* _PRCM_ACC_INT_H */
diff --git a/drivers/dsp/bridge/hw/PRCMRegAcM.h b/drivers/dsp/bridge/hw/PRCMRegAcM.h
new file mode 100644
index 0000000..4c9d732
--- /dev/null
+++ b/drivers/dsp/bridge/hw/PRCMRegAcM.h
@@ -0,0 +1,670 @@
+/*
+ * PRCMRegAcM.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _PRCM_REG_ACM_H
+#define _PRCM_REG_ACM_H
+
+#include <GlobalTypes.h>
+#include <linux/io.h>
+
+#include <EasiGlobal.h>
+
+#include "PRCMAccInt.h"
+
+#if defined(USE_LEVEL_1_MACROS)
+
+#define PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32(baseAddress)\
+{\
+    const u32 offset = PRCM_PRCM_CLKCFG_CTRL_OFFSET;\
+    const u32 newValue = \
+	(u32)PRCMPRCM_CLKCFG_CTRLValid_configClk_valid <<\
+      PRCM_PRCM_CLKCFG_CTRL_Valid_config_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(\
+      EASIL1_PRCMPRCM_CLKCFG_CTRLValid_configWriteClk_valid32);\
+    data &= ~(PRCM_PRCM_CLKCFG_CTRL_Valid_config_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define CM_FCLKEN_PERReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+CM_FCLKEN_PER_OFFSET))
+
+
+#define CM_ICLKEN_PERReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+CM_ICLKEN_PER_OFFSET))
+
+
+#define CM_FCLKEN_PER_GPT5WriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = CM_FCLKEN_PER_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
+   data &= ~(CM_FCLKEN_PER_GPT5_MASK);\
+   newValue <<= CM_FCLKEN_PER_GPT5_OFFSET;\
+   newValue &= CM_FCLKEN_PER_GPT5_MASK;\
+   newValue |= data;\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
+}
+
+
+#define CM_FCLKEN_PER_GPT6WriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = CM_FCLKEN_PER_OFFSET;\
+    register u32 data =\
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_FCLKEN_PER_GPT5WriteRegister32);\
+   data &= ~(CM_FCLKEN_PER_GPT6_MASK);\
+   newValue <<= CM_FCLKEN_PER_GPT6_OFFSET;\
+   newValue &= CM_FCLKEN_PER_GPT6_MASK;\
+   newValue |= data;\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
+}
+
+
+#define CM_ICLKEN_PER_GPT5WriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = CM_ICLKEN_PER_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
+   data &= ~(CM_ICLKEN_PER_GPT5_MASK);\
+   newValue <<= CM_ICLKEN_PER_GPT5_OFFSET;\
+   newValue &= CM_ICLKEN_PER_GPT5_MASK;\
+   newValue |= data;\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
+}
+
+
+#define CM_ICLKEN_PER_GPT6WriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = CM_ICLKEN_PER_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_ICLKEN_PER_GPT5WriteRegister32);\
+   data &= ~(CM_ICLKEN_PER_GPT6_MASK);\
+   newValue <<= CM_ICLKEN_PER_GPT6_OFFSET;\
+   newValue &= CM_ICLKEN_PER_GPT6_MASK;\
+   newValue |= data;\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
+}
+
+
+#define CM_FCLKEN1_COREReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+CM_FCLKEN1_CORE_OFFSET))
+
+
+#define PRCMCM_FCLKEN1_COREEN_GPT8Write32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT8Write32);\
+    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK);\
+    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT8_OFFSET;\
+    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT8_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_FCLKEN1_COREEN_GPT7Write32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_FCLKEN1_CORE_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN1_COREEN_GPT7Write32);\
+    data &= ~(PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK);\
+    newValue <<= PRCM_CM_FCLKEN1_CORE_EN_GPT7_OFFSET;\
+    newValue &= PRCM_CM_FCLKEN1_CORE_EN_GPT7_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define CM_ICLKEN1_COREReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+CM_ICLKEN1_CORE_OFFSET))
+
+
+#define  CM_ICLKEN1_COREEN_MAILBOXESWrite32(baseAddress, value)\
+{\
+    const u32 offset = CM_ICLKEN1_CORE_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_MAILBOXESWrite32);\
+    data &= ~(CM_ICLKEN1_CORE_EN_MAILBOXES_MASK);\
+    newValue <<= CM_ICLKEN1_CORE_EN_MAILBOXES_OFFSET;\
+    newValue &= CM_ICLKEN1_CORE_EN_MAILBOXES_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_ICLKEN1_COREEN_GPT8Write32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT8Write32);\
+    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK);\
+    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT8_OFFSET;\
+    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT8_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_ICLKEN1_COREEN_GPT7Write32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_ICLKEN1_CORE_OFFSET;\
+    register u32 data =\
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN1_COREEN_GPT7Write32);\
+    data &= ~(PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK);\
+    newValue <<= PRCM_CM_ICLKEN1_CORE_EN_GPT7_OFFSET;\
+    newValue &= PRCM_CM_ICLKEN1_CORE_EN_GPT7_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT832k <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8Write32k32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Sys <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteSys32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT8Ext <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT8WriteExt32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT8_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT732k <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7Write32k32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Sys <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteSys32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT7Ext <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT7WriteExt32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT7_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Sys <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteSys32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT6Ext <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT6WriteExt32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT6_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define CM_CLKSEL_PER_GPT5Write32k32(baseAddress)\
+{\
+    const u32 offset = CM_CLKSEL_PER_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
+      CM_CLKSEL_PER_GPT5_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT5Write32k32);\
+    data &= ~(CM_CLKSEL_PER_GPT5_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define CM_CLKSEL_PER_GPT6Write32k32(baseAddress)\
+{\
+    const u32 offset = CM_CLKSEL_PER_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT532k <<\
+      CM_CLKSEL_PER_GPT6_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_CM_CLKSEL_PER_GPT6Write32k32);\
+    data &= ~(CM_CLKSEL_PER_GPT6_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Sys <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteSys32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32(baseAddress)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL2_CORE_OFFSET;\
+    const u32 newValue = (u32)PRCMCM_CLKSEL2_CORECLKSEL_GPT5Ext <<\
+      PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_OFFSET;\
+    register u32 data = __raw_readl((u32)(baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL2_CORECLKSEL_GPT5WriteExt32);\
+    data &= ~(PRCM_CM_CLKSEL2_CORE_CLKSEL_GPT5_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL1_PLLAPLLs_ClkinRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+	(PRCM_CM_CLKSEL1_PLL_OFFSET)))) &\
+      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_MASK) >>\
+      PRCM_CM_CLKSEL1_PLL_APLLs_Clkin_OFFSET))
+
+
+#define CM_FCLKEN_IVA2EN_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = CM_FCLKEN_IVA2_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_FCLKEN_DSPEN_DSPWrite32);\
+    data &= ~(CM_FCLKEN_IVA2_EN_MASK);\
+    newValue <<= CM_FCLKEN_IVA2_EN_OFFSET;\
+    newValue &= CM_FCLKEN_IVA2_EN_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_ICLKEN_DSP_OFFSET;\
+    register u32 data = \
+      __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_ICLKEN_DSPEN_DSP_IPIWrite32);\
+    data &= ~(PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK);\
+    newValue <<= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_OFFSET;\
+    newValue &= PRCM_CM_ICLKEN_DSP_EN_DSP_IPI_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_IDLEST_DSPReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+PRCM_CM_IDLEST_DSP_OFFSET))
+
+
+#define PRCMCM_IDLEST_DSPST_IPIRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_IPIRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+	(PRCM_CM_IDLEST_DSP_OFFSET)))) &\
+      PRCM_CM_IDLEST_DSP_ST_IPI_MASK) >>\
+      PRCM_CM_IDLEST_DSP_ST_IPI_OFFSET))
+
+
+#define PRM_IDLEST_IVA2ST_IVA2Read32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_IDLEST_DSPST_DSPRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+	  (CM_IDLEST_IVA2_OFFSET)))) &\
+      CM_IDLEST_IVA2_ST_IVA2_MASK) >>\
+      CM_IDLEST_IVA2_ST_IVA2_OFFSET))
+
+
+#define PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_AUTOIDLE_DSP_OFFSET;\
+    register u32 data =\
+      __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_AUTOIDLE_DSPAUTO_DSP_IPIWrite32);\
+    data &= ~(PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK);\
+    newValue <<= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_OFFSET;\
+    newValue &= PRCM_CM_AUTOIDLE_DSP_AUTO_DSP_IPI_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL_DSPSYNC_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPSYNC_DSPWrite32);\
+    data &= ~(PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK);\
+    newValue <<= PRCM_CM_CLKSEL_DSP_SYNC_DSP_OFFSET;\
+    newValue &= PRCM_CM_CLKSEL_DSP_SYNC_DSP_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
+    register u32 data = \
+      __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSP_IFWrite32);\
+    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK);\
+    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_OFFSET;\
+    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_IF_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_CLKSEL_DSP_OFFSET;\
+    register u32 data = \
+      __raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSEL_DSPCLKSEL_DSPWrite32);\
+    data &= ~(PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK);\
+    newValue <<= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_OFFSET;\
+    newValue &= PRCM_CM_CLKSEL_DSP_CLKSEL_DSP_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_CLKSTCTRL_IVA2_OFFSET;\
+    register u32 data = \
+      __raw_readl(((baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_IVA2WriteRegister32);\
+    data &= ~(CM_CLKSTCTRL_IVA2_MASK);\
+    newValue <<= CM_CLKSTCTRL_IVA2_OFFSET;\
+    newValue &= CM_CLKSTCTRL_IVA2_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+	(PRCM_CM_CLKSTCTRL_DSP_OFFSET)))) &\
+      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK) >>\
+      PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET))
+
+
+#define PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_CM_CLKSTCTRL_DSP_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMCM_CLKSTCTRL_DSPAutostate_DSPWrite32);\
+    data &= ~(PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK);\
+    newValue <<= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_OFFSET;\
+    newValue &= PRCM_CM_CLKSTCTRL_DSP_Autostate_DSP_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPReadRegister32),\
+      __raw_readl(((baseAddress))+PRCM_RM_RSTCTRL_DSP_OFFSET))
+
+
+#define PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
+    register u32 data =\
+    __raw_readl(((baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    data &= ~(PRM_RSTCTRL_IVA2_RST1_MASK);\
+    newValue <<= PRM_RSTCTRL_IVA2_RST1_OFFSET;\
+    newValue &= PRM_RSTCTRL_IVA2_RST1_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
+    register u32 data =\
+	__raw_readl(((baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    data &= ~(PRM_RSTCTRL_IVA2_RST2_MASK);\
+    newValue <<= PRM_RSTCTRL_IVA2_RST2_OFFSET;\
+    newValue &= PRM_RSTCTRL_IVA2_RST2_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRM_RSTCTRL_IVA2_OFFSET;\
+    register u32 data =\
+      __raw_readl(((baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTCTRL_DSPRST1_DSPWrite32);\
+    data &= ~(PRM_RSTCTRL_IVA2_RST3_MASK);\
+    newValue <<= PRM_RSTCTRL_IVA2_RST3_OFFSET;\
+    newValue &= PRM_RSTCTRL_IVA2_RST3_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (baseAddress)+offset);\
+}
+
+
+#define PRCMRM_RSTST_DSPReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPReadRegister32),\
+      __raw_readl(((baseAddress))+PRCM_RM_RSTST_DSP_OFFSET))
+
+
+#define PRCMRM_RSTST_DSPWriteRegister32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_RM_RSTST_DSP_OFFSET;\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMRM_RSTST_DSPWriteRegister32);\
+    __raw_writel(newValue, ((u32)(baseAddress))+offset);\
+}
+
+
+#define PRCMPM_PWSTCTRL_DSPForceStateWrite32(baseAddress, value)\
+{\
+    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
+    register u32 data = \
+	__raw_readl(((u32)(baseAddress))+offset);\
+    register u32 newValue = ((u32)(value));\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPForceStateWrite32);\
+    data &= ~(PRCM_PM_PWSTCTRL_DSP_ForceState_MASK);\
+    newValue <<= PRCM_PM_PWSTCTRL_DSP_ForceState_OFFSET;\
+    newValue &= PRCM_PM_PWSTCTRL_DSP_ForceState_MASK;\
+    newValue |= data;\
+    __raw_writel(newValue, (u32)(baseAddress)+offset);\
+}
+
+
+#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress)\
+{\
+    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateON <<\
+      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32);\
+    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (baseAddress)+offset);\
+}
+
+
+#define PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress)\
+{\
+    const u32 offset = PRCM_PM_PWSTCTRL_IVA2_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_IVA2PowerStateOFF <<\
+      PRCM_PM_PWSTCTRL_IVA2_PowerState_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32);\
+    data &= ~(PRCM_PM_PWSTCTRL_IVA2_PowerState_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (baseAddress)+offset);\
+}
+
+
+#define PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress)\
+{\
+    const u32 offset = PRCM_PM_PWSTCTRL_DSP_OFFSET;\
+    const u32 newValue = (u32)PRCMPM_PWSTCTRL_DSPPowerStateRET <<\
+      PRCM_PM_PWSTCTRL_DSP_PowerState_OFFSET;\
+    register u32 data = __raw_readl((baseAddress)+offset);\
+    _DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32);\
+    data &= ~(PRCM_PM_PWSTCTRL_DSP_PowerState_MASK);\
+    data |= newValue;\
+    __raw_writel(data, (baseAddress)+offset);\
+}
+
+
+#define PRCMPM_PWSTST_DSPReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPReadRegister32),\
+      __raw_readl(((u32)(baseAddress))+PRCM_PM_PWSTST_DSP_OFFSET))
+
+
+#define PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2ReadRegister32),\
+      __raw_readl((baseAddress) + PRCM_PM_PWSTST_IVA2_OFFSET))
+
+
+#define PRCMPM_PWSTST_DSPInTransitionRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPInTransitionRead32),\
+      (((__raw_readl((((u32)(baseAddress))+\
+	(PRCM_PM_PWSTST_DSP_OFFSET)))) &\
+      PRCM_PM_PWSTST_DSP_InTransition_MASK) >>\
+      PRCM_PM_PWSTST_DSP_InTransition_OFFSET))
+
+
+#define PRCMPM_PWSTST_IVA2InTransitionRead32(baseAddress)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2InTransitionRead32),\
+      (((__raw_readl((((baseAddress))+\
+	(PRCM_PM_PWSTST_IVA2_OFFSET)))) &\
+      PRCM_PM_PWSTST_IVA2_InTransition_MASK) >>\
+      PRCM_PM_PWSTST_IVA2_InTransition_OFFSET))
+
+
+#define PRCMPM_PWSTST_DSPPowerStateStGet32(var)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_DSPPowerStateStGet32),\
+      (u32)((((u32)(var)) & PRCM_PM_PWSTST_DSP_PowerStateSt_MASK) >>\
+	PRCM_PM_PWSTST_DSP_PowerStateSt_OFFSET))
+
+
+#define PRCMPM_PWSTST_IVA2PowerStateStGet32(var)\
+    (_DEBUG_LEVEL_1_EASI(EASIL1_PRCMPM_PWSTST_IVA2PowerStateStGet32),\
+      (u32)((((u32)(var)) & PRCM_PM_PWSTST_IVA2_PowerStateSt_MASK) >>\
+      PRCM_PM_PWSTST_IVA2_PowerStateSt_OFFSET))
+
+
+#endif  /* USE_LEVEL_1_MACROS */
+
+#endif /* _PRCM_REG_ACM_H */
diff --git a/drivers/dsp/bridge/hw/hw_defs.h b/drivers/dsp/bridge/hw/hw_defs.h
new file mode 100644
index 0000000..827fff3
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_defs.h
@@ -0,0 +1,62 @@
+/*
+ * hw_defs.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Global HW definitions
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __HW_DEFS_H
+#define __HW_DEFS_H
+
+#include <GlobalTypes.h>
+
+/* Page size */
+#define HW_PAGE_SIZE_4KB   0x1000
+#define HW_PAGE_SIZE_64KB  0x10000
+#define HW_PAGE_SIZE_1MB   0x100000
+#define HW_PAGE_SIZE_16MB  0x1000000
+
+/* HW_STATUS:  return type for HW API */
+typedef long HW_STATUS;
+
+/*  Macro used to set and clear any bit */
+#define HW_CLEAR	0
+#define HW_SET		1
+
+/* HW_Endianism_t:  Enumerated Type used to specify the endianism
+ *		Do NOT change these values. They are used as bit fields. */
+enum HW_Endianism_t {
+    HW_LITTLE_ENDIAN,
+    HW_BIG_ENDIAN
+
+} ;
+
+/* HW_ElementSize_t:  Enumerated Type used to specify the element size
+ *		Do NOT change these values. They are used as bit fields. */
+enum HW_ElementSize_t {
+    HW_ELEM_SIZE_8BIT,
+    HW_ELEM_SIZE_16BIT,
+    HW_ELEM_SIZE_32BIT,
+    HW_ELEM_SIZE_64BIT
+
+} ;
+
+/* HW_IdleMode_t:  Enumerated Type used to specify Idle modes */
+	enum HW_IdleMode_t {
+		HW_FORCE_IDLE,
+		HW_NO_IDLE,
+		HW_SMART_IDLE
+	} ;
+
+#endif  /* __HW_DEFS_H */
diff --git a/drivers/dsp/bridge/hw/hw_dspssC64P.c b/drivers/dsp/bridge/hw/hw_dspssC64P.c
new file mode 100644
index 0000000..c1124fd
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_dspssC64P.c
@@ -0,0 +1,47 @@
+/*
+ * hw_dspss64P.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * API definitions to configure DSP Subsystem modules like IPI
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* PROJECT SPECIFIC INCLUDE FILES */
+#include <GlobalTypes.h>
+#include <linux/io.h>
+#include <hw_defs.h>
+#include <hw_dspssC64P.h>
+#include <IVA2RegAcM.h>
+#include <IPIAccInt.h>
+
+/* HW FUNCTIONS */
+HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
+		      enum HW_DSPSYSC_BootMode_t bootMode,
+		      const u32 bootAddress)
+{
+	HW_STATUS status = RET_OK;
+	u32 offset = SYSC_IVA2BOOTMOD_OFFSET;
+	u32 alignedBootAddr;
+
+	/* if Boot mode it DIRECT BOOT, check that the bootAddress is
+	 * aligned to atleast 1K :: TODO */
+	__raw_writel(bootMode, (baseAddress) + offset);
+
+	offset = SYSC_IVA2BOOTADDR_OFFSET;
+
+	alignedBootAddr = bootAddress & SYSC_IVA2BOOTADDR_MASK;
+
+	__raw_writel(alignedBootAddr, (baseAddress) + offset);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/hw/hw_dspssC64P.h b/drivers/dsp/bridge/hw/hw_dspssC64P.h
new file mode 100644
index 0000000..2af5415
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_dspssC64P.h
@@ -0,0 +1,37 @@
+/*
+ * hw_dspssC64P.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP Subsystem API declarations
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __HW_DSPSS_H
+#define __HW_DSPSS_H
+#include <linux/types.h>
+
+	enum HW_DSPSYSC_BootMode_t {
+		HW_DSPSYSC_DIRECTBOOT = 0x0,
+		HW_DSPSYSC_IDLEBOOT = 0x1,
+		HW_DSPSYSC_SELFLOOPBOOT = 0x2,
+		HW_DSPSYSC_USRBOOTSTRAP = 0x3,
+		HW_DSPSYSC_DEFAULTRESTORE = 0x4
+	} ;
+
+#define HW_DSP_IDLEBOOT_ADDR   0x007E0000
+
+	extern HW_STATUS HW_DSPSS_BootModeSet(const void __iomem *baseAddress,
+					enum HW_DSPSYSC_BootMode_t bootMode,
+					const u32 bootAddress);
+
+#endif				/* __HW_DSPSS_H */
diff --git a/drivers/dsp/bridge/hw/hw_mbox.c b/drivers/dsp/bridge/hw/hw_mbox.c
new file mode 100644
index 0000000..5268b58
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_mbox.c
@@ -0,0 +1,248 @@
+/*
+ * hw_mbox.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Mailbox messaging & configuration API definitions
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <GlobalTypes.h>
+#include "MLBRegAcM.h"
+#include <hw_defs.h>
+#include <hw_mbox.h>
+
+/* width in bits of MBOX Id */
+#define HW_MBOX_ID_WIDTH	   2
+
+/* SYSCONFIG: register bit definition */
+#define AUTOIDLE	(1 << 0)
+#define SMARTIDLE	(2 << 3)
+
+struct MAILBOX_CONTEXT mboxsetting = {
+	.sysconfig = SMARTIDLE | AUTOIDLE,
+};
+
+HW_STATUS HW_MBOX_initSettings(void __iomem *baseAddress)
+{
+	MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, SMARTIDLE | AUTOIDLE);
+	return RET_OK;
+}
+
+/* Saves the mailbox context */
+HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddress)
+{
+	HW_STATUS status = RET_OK;
+
+	mboxsetting.sysconfig = MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress);
+	/* Get current enable status */
+	mboxsetting.irqEnable0 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
+				 (baseAddress, HW_MBOX_U0_ARM);
+	mboxsetting.irqEnable1 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
+				 (baseAddress, HW_MBOX_U1_DSP1);
+	return status;
+}
+
+/* Restores the mailbox context */
+HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddress)
+{
+	 HW_STATUS status = RET_OK;
+	/* Restor IRQ enable status */
+	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, HW_MBOX_U0_ARM,
+						 mboxsetting.irqEnable0);
+	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, HW_MBOX_U1_DSP1,
+						 mboxsetting.irqEnable1);
+	/* Restore Sysconfig register */
+	MLBMAILBOX_SYSCONFIGWriteRegister32(baseAddress, mboxsetting.sysconfig);
+	return status;
+}
+
+/* Reads a u32 from the sub module message box Specified. if there are no
+ * messages in the mailbox then and error is returned. */
+HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, u32 *const pReadValue)
+{
+	HW_STATUS status = RET_OK;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_PARAM(pReadValue, NULL, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+			   RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* Read 32-bit message in mail box */
+	*pReadValue = MLBMAILBOX_MESSAGE___0_15ReadRegister32(baseAddress,
+							 (u32)mailBoxId);
+
+	return status;
+}
+
+/* Writes a u32 from the sub module message box Specified. */
+HW_STATUS HW_MBOX_MsgWrite(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, const u32 writeValue)
+{
+	HW_STATUS status = RET_OK;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+			RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+			RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* Write 32-bit value to mailbox */
+	MLBMAILBOX_MESSAGE___0_15WriteRegister32(baseAddress, (u32)mailBoxId,
+					    (u32)writeValue);
+
+	return status;
+}
+
+/* Gets number of messages in a specified mailbox. */
+HW_STATUS HW_MBOX_NumMsgGet(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, u32 *const pNumMsg)
+{
+	HW_STATUS status = RET_OK;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_PARAM(pNumMsg,  NULL, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+			   RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* Get number of messages available for MailBox */
+	*pNumMsg = MLBMAILBOX_MSGSTATUS___0_15NbOfMsgMBmRead32(baseAddress,
+							  (u32)mailBoxId);
+
+	return status;
+}
+
+/* Enables the specified IRQ. */
+HW_STATUS HW_MBOX_EventEnable(const void __iomem *baseAddress,
+				const HW_MBOX_Id_t mailBoxId,
+				const HW_MBOX_UserId_t userId,
+				const u32 events)
+{
+	HW_STATUS status = RET_OK;
+	u32 irqEnableReg;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+			  RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(enableIrq, HW_MBOX_INT_MAX, RET_INVALID_ID,
+			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
+			 RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* Get current enable status */
+	irqEnableReg = MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress,
+							     (u32)userId);
+
+	/* update enable value */
+	irqEnableReg |= ((u32)(events)) << (((u32)(mailBoxId)) *
+			HW_MBOX_ID_WIDTH);
+
+	/* write new enable status */
+	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, (u32)userId,
+						 (u32)irqEnableReg);
+
+	mboxsetting.sysconfig = MLBMAILBOX_SYSCONFIGReadRegister32(baseAddress);
+	/* Get current enable status */
+	mboxsetting.irqEnable0 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
+				(baseAddress, HW_MBOX_U0_ARM);
+	mboxsetting.irqEnable1 = MLBMAILBOX_IRQENABLE___0_3ReadRegister32
+				(baseAddress, HW_MBOX_U1_DSP1);
+	return status;
+}
+
+/* Disables the specified IRQ. */
+HW_STATUS HW_MBOX_EventDisable(const void __iomem *baseAddress,
+				const HW_MBOX_Id_t mailBoxId,
+				const HW_MBOX_UserId_t userId,
+				const u32 events)
+{
+	HW_STATUS status = RET_OK;
+	u32 irqDisableReg;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(disableIrq, HW_MBOX_INT_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* Get current enable status */
+	irqDisableReg = MLBMAILBOX_IRQENABLE___0_3ReadRegister32(baseAddress,
+		    (u32)userId);
+
+	/* update enable value */
+	irqDisableReg &= ~(((u32)(events)) << (((u32)(mailBoxId)) *
+		     HW_MBOX_ID_WIDTH));
+
+	/* write new enable status */
+	MLBMAILBOX_IRQENABLE___0_3WriteRegister32(baseAddress, (u32)userId,
+					     (u32)irqDisableReg);
+
+	return status;
+}
+
+/* Sets the status of the specified IRQ. */
+HW_STATUS HW_MBOX_EventAck(const void __iomem *baseAddress,
+	const HW_MBOX_Id_t mailBoxId, const HW_MBOX_UserId_t userId,
+	const u32 event)
+{
+	HW_STATUS status = RET_OK;
+	u32 irqStatusReg;
+
+	/* Check input parameters */
+	CHECK_INPUT_PARAM(baseAddress,   0, RET_BAD_NULL_PARAM, RES_MBOX_BASE +
+		      RES_INVALID_INPUT_PARAM);
+
+	CHECK_INPUT_RANGE_MIN0(irqStatus, HW_MBOX_INT_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(mailBoxId, HW_MBOX_ID_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+	CHECK_INPUT_RANGE_MIN0(userId, HW_MBOX_USER_MAX, RET_INVALID_ID,
+		     RES_MBOX_BASE + RES_INVALID_INPUT_PARAM);
+
+	/* calculate status to write */
+	irqStatusReg = ((u32)event) << (((u32)(mailBoxId)) *
+		   HW_MBOX_ID_WIDTH);
+
+	/* clear Irq Status for specified mailbox/User Id */
+	MLBMAILBOX_IRQSTATUS___0_3WriteRegister32(baseAddress, (u32)userId,
+					     (u32)irqStatusReg);
+
+	/*
+	 * FIXME: Replace all this custom register access with standard
+	 * __raw_read/write().
+	 *
+	 * FIXME: Replace all interrupt handlers with standard linux style
+	 * interrupt handlers.
+	 *
+	 * FIXME: Replace direct access to PRCM registers with omap standard
+	 * PRCM register access.
+	 *
+	 * Flush posted write for the irq status to avoid spurious interrupts.
+	 */
+	MLBMAILBOX_IRQSTATUS___0_3ReadRegister32(baseAddress, (u32)userId);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/hw/hw_mbox.h b/drivers/dsp/bridge/hw/hw_mbox.h
new file mode 100644
index 0000000..a561fb5
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_mbox.h
@@ -0,0 +1,326 @@
+/*
+ * hw_mbox.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * HW Mailbox API and types definitions
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __MBOX_H
+#define __MBOX_H
+
+/* Bitmasks for Mailbox interrupt sources */
+#define HW_MBOX_INT_NEW_MSG    0x1
+#define HW_MBOX_INT_NOT_FULL   0x2
+#define HW_MBOX_INT_ALL	0x3
+
+/* Maximum number of messages that mailbox can hald at a time. */
+#define HW_MBOX_MAX_NUM_MESSAGES   4
+
+/* HW_MBOX_Id_t: Enumerated Type used to specify Mailbox Sub Module Id Number */
+typedef enum HW_MBOX_Id_label {
+    HW_MBOX_ID_0,
+    HW_MBOX_ID_1,
+    HW_MBOX_ID_2,
+    HW_MBOX_ID_3,
+    HW_MBOX_ID_4,
+    HW_MBOX_ID_5
+
+} HW_MBOX_Id_t, *pHW_MBOX_Id_t;
+
+/* HW_MBOX_UserId_t:  Enumerated Type used to specify Mail box User Id */
+typedef enum HW_MBOX_UserId_label {
+    HW_MBOX_U0_ARM,
+    HW_MBOX_U1_DSP1,
+    HW_MBOX_U2_DSP2,
+    HW_MBOX_U3_ARM
+
+} HW_MBOX_UserId_t, *pHW_MBOX_UserId_t;
+
+/* Mailbox context settings */
+struct MAILBOX_CONTEXT {
+	u32 sysconfig;
+	u32 irqEnable0;
+	u32 irqEnable1;
+};
+
+/*
+* FUNCTION      : HW_MBOX_MsgRead
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to read
+*
+* OUTPUTS:
+*
+*   Identifier  : pReadValue
+*   Type	: u32 *const
+*   Description : Value read from MailBox
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/ptr Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*		 RET_EMPTY	   Mailbox empty
+*
+* PURPOSE:      : this function reads a u32 from the sub module message
+*		 box Specified. if there are no messages in the mailbox
+*		 then and error is returned.
+*/
+extern HW_STATUS HW_MBOX_MsgRead(const void __iomem *baseAddress,
+				const HW_MBOX_Id_t mailBoxId,
+				u32 *const pReadValue);
+
+/*
+* FUNCTION      : HW_MBOX_MsgWrite
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to write
+*
+*   Identifier  : writeValue
+*   Type	: const u32
+*   Description : Value to write to MailBox
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*
+* PURPOSE:      : this function writes a u32 from the sub module message
+*		 box Specified.
+*/
+extern HW_STATUS HW_MBOX_MsgWrite(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId, const u32 writeValue);
+
+/*
+* FUNCTION      : HW_MBOX_NumMsgGet
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to get num messages
+*
+* OUTPUTS:
+*
+*   Identifier  : pNumMsg
+*   Type	: u32 *const
+*   Description : Number of messages in mailbox
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Inavlid ID input at parameter
+*
+* PURPOSE:      : this function gets number of messages in a specified mailbox.
+*/
+extern HW_STATUS HW_MBOX_NumMsgGet(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId, u32 *const pNumMsg);
+
+/*
+* FUNCTION      : HW_MBOX_EventEnable
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to enable
+*
+*   Identifier  : userId
+*   Type	: const HW_MBOX_UserId_t
+*   Description : Mail box User Id to enable
+*
+*   Identifier  : enableIrq
+*   Type	: const u32
+*   Description : Irq value to enable
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  A Pointer Paramater was set to NULL
+*		 RET_INVALID_ID      Invalid Id used
+*
+* PURPOSE:      : this function enables the specified IRQ.
+*/
+extern HW_STATUS HW_MBOX_EventEnable(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId,
+			const HW_MBOX_UserId_t userId,
+			const u32 events);
+
+/*
+* FUNCTION      : HW_MBOX_EventDisable
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to disable
+*
+*   Identifier  : userId
+*   Type	: const HW_MBOX_UserId_t
+*   Description : Mail box User Id to disable
+*
+*   Identifier  : enableIrq
+*   Type	: const u32
+*   Description : Irq value to disable
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  A Pointer Paramater was set to NULL
+*		 RET_INVALID_ID      Invalid Id used
+*
+* PURPOSE:      : this function disables the specified IRQ.
+*/
+extern HW_STATUS HW_MBOX_EventDisable(const void __iomem *baseAddress,
+		const HW_MBOX_Id_t mailBoxId,
+		const HW_MBOX_UserId_t userId,
+		const u32 events);
+
+/*
+* FUNCTION      : HW_MBOX_EventAck
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*   Identifier  : mailBoxId
+*   Type	: const HW_MBOX_Id_t
+*   Description : Mail Box Sub module Id to set
+*
+*   Identifier  : userId
+*   Type	: const HW_MBOX_UserId_t
+*   Description : Mail box User Id to set
+*
+*   Identifier  : irqStatus
+*   Type	: const u32
+*   Description : The value to write IRQ status
+*
+* OUTPUTS:
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address Paramater was set to 0
+*		 RET_INVALID_ID      Invalid Id used
+*
+* PURPOSE:      : this function sets the status of the specified IRQ.
+*/
+extern HW_STATUS HW_MBOX_EventAck(const void __iomem *baseAddress,
+			const HW_MBOX_Id_t mailBoxId,
+			const HW_MBOX_UserId_t userId,
+			const u32 event);
+
+/*
+* FUNCTION      : HW_MBOX_initSettings
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*		 RET_EMPTY	   Mailbox empty
+*
+* PURPOSE:      : This function initialize the mailbox configuration.
+*/
+extern HW_STATUS HW_MBOX_initSettings(void __iomem *baseAddres);
+
+/*
+* FUNCTION      : HW_MBOX_saveSettings
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*		 RET_EMPTY	   Mailbox empty
+*
+* PURPOSE:      : this function saves the context of mailbox
+*/
+extern HW_STATUS HW_MBOX_saveSettings(void __iomem *baseAddres);
+
+/*
+* FUNCTION      : HW_MBOX_restoreSettings
+*
+* INPUTS:
+*
+*   Identifier  : baseAddress
+*   Type	: const u32
+*   Description : Base Address of instance of Mailbox module
+*
+*
+* RETURNS:
+*
+*   Type	: ReturnCode_t
+*   Description : RET_OK	      No errors occured
+*		 RET_BAD_NULL_PARAM  Address/pointer Paramater was set to 0/NULL
+*		 RET_INVALID_ID      Invalid Id used
+*		 RET_EMPTY	   Mailbox empty
+*
+* PURPOSE:      : this function restores the context of mailbox
+*/
+extern HW_STATUS HW_MBOX_restoreSettings(void __iomem *baseAddres);
+
+#endif  /* __MBOX_H */
diff --git a/drivers/dsp/bridge/hw/hw_mmu.c b/drivers/dsp/bridge/hw/hw_mmu.c
new file mode 100644
index 0000000..abaf0f6
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_mmu.c
@@ -0,0 +1,585 @@
+/*
+ * hw_mmu.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * API definitions to setup MMU TLB and PTE
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <GlobalTypes.h>
+#include <linux/io.h>
+#include "MMURegAcM.h"
+#include <hw_defs.h>
+#include <hw_mmu.h>
+#include <linux/types.h>
+
+#define MMU_BASE_VAL_MASK	0xFC00
+#define MMU_PAGE_MAX	     3
+#define MMU_ELEMENTSIZE_MAX      3
+#define MMU_ADDR_MASK	    0xFFFFF000
+#define MMU_TTB_MASK	     0xFFFFC000
+#define MMU_SECTION_ADDR_MASK    0xFFF00000
+#define MMU_SSECTION_ADDR_MASK   0xFF000000
+#define MMU_PAGE_TABLE_MASK      0xFFFFFC00
+#define MMU_LARGE_PAGE_MASK      0xFFFF0000
+#define MMU_SMALL_PAGE_MASK      0xFFFFF000
+
+#define MMU_LOAD_TLB	0x00000001
+
+/* HW_MMUPageSize_t:  Enumerated Type used to specify the MMU Page Size(SLSS) */
+enum HW_MMUPageSize_t {
+    HW_MMU_SECTION,
+    HW_MMU_LARGE_PAGE,
+    HW_MMU_SMALL_PAGE,
+    HW_MMU_SUPERSECTION
+} ;
+
+/*
+* FUNCTION	      : MMU_FlushEntry
+*
+* INPUTS:
+*
+*       Identifier      : baseAddress
+*       Type		: const u32
+*       Description     : Base Address of instance of MMU module
+*
+* RETURNS:
+*
+*       Type		: HW_STATUS
+*       Description     : RET_OK		 -- No errors occured
+*			 RET_BAD_NULL_PARAM     -- A Pointer
+*						Paramater was set to NULL
+*
+* PURPOSE:	      : Flush the TLB entry pointed by the
+*			lock counter register
+*			even if this entry is set protected
+*
+* METHOD:	       : Check the Input parameter and Flush a
+*			 single entry in the TLB.
+*/
+static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress);
+
+/*
+* FUNCTION	      : MMU_SetCAMEntry
+*
+* INPUTS:
+*
+*       Identifier      : baseAddress
+*       TypE		: const u32
+*       Description     : Base Address of instance of MMU module
+*
+*       Identifier      : pageSize
+*       TypE		: const u32
+*       Description     : It indicates the page size
+*
+*       Identifier      : preservedBit
+*       Type		: const u32
+*       Description     : It indicates the TLB entry is preserved entry
+*							or not
+*
+*       Identifier      : validBit
+*       Type		: const u32
+*       Description     : It indicates the TLB entry is valid entry or not
+*
+*
+*       Identifier      : virtualAddrTag
+*       Type	    	: const u32
+*       Description     : virtual Address
+*
+* RETURNS:
+*
+*       Type	    	: HW_STATUS
+*       Description     : RET_OK		 -- No errors occured
+*			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
+*						   was set to NULL
+*			 RET_PARAM_OUT_OF_RANGE -- Input Parameter out
+*						   of Range
+*
+* PURPOSE:	      	: Set MMU_CAM reg
+*
+* METHOD:	       	: Check the Input parameters and set the CAM entry.
+*/
+static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
+				   const u32    pageSize,
+				   const u32    preservedBit,
+				   const u32    validBit,
+				   const u32    virtualAddrTag);
+
+/*
+* FUNCTION	      : MMU_SetRAMEntry
+*
+* INPUTS:
+*
+*       Identifier      : baseAddress
+*       Type	    	: const u32
+*       Description     : Base Address of instance of MMU module
+*
+*       Identifier      : physicalAddr
+*       Type	    	: const u32
+*       Description     : Physical Address to which the corresponding
+*			 virtual   Address shouldpoint
+*
+*       Identifier      : endianism
+*       Type	    	: HW_Endianism_t
+*       Description     : endianism for the given page
+*
+*       Identifier      : elementSize
+*       Type	    	: HW_ElementSize_t
+*       Description     : The element size ( 8,16, 32 or 64 bit)
+*
+*       Identifier      : mixedSize
+*       Type	    	: HW_MMUMixedSize_t
+*       Description     : Element Size to follow CPU or TLB
+*
+* RETURNS:
+*
+*       Type	    	: HW_STATUS
+*       Description     : RET_OK		 -- No errors occured
+*			 RET_BAD_NULL_PARAM     -- A Pointer Paramater
+*							was set to NULL
+*			 RET_PARAM_OUT_OF_RANGE -- Input Parameter
+*							out of Range
+*
+* PURPOSE:	      : Set MMU_CAM reg
+*
+* METHOD:	       : Check the Input parameters and set the RAM entry.
+*/
+static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
+				   const u32	physicalAddr,
+				   enum HW_Endianism_t      endianism,
+				   enum HW_ElementSize_t    elementSize,
+				   enum HW_MMUMixedSize_t   mixedSize);
+
+/* HW FUNCTIONS */
+
+HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_SET);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_CNTLMMUEnableWrite32(baseAddress, HW_CLEAR);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
+				u32 numLockedEntries)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_LOCKBaseValueWrite32(baseAddress, numLockedEntries);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
+				u32 victimEntryNum)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, victimEntryNum);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress, u32 irqMask)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_IRQSTATUSWriteRegister32(baseAddress, irqMask);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
+				u32 irqMask)
+{
+    HW_STATUS status = RET_OK;
+    u32 irqReg;
+
+    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+
+    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg & ~irqMask);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress, u32 irqMask)
+{
+    HW_STATUS status = RET_OK;
+    u32 irqReg;
+
+    irqReg = MMUMMU_IRQENABLEReadRegister32(baseAddress);
+
+    MMUMMU_IRQENABLEWriteRegister32(baseAddress, irqReg | irqMask);
+
+    return status;
+}
+
+
+HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress, u32 *irqMask)
+{
+    HW_STATUS status = RET_OK;
+
+    *irqMask = MMUMMU_IRQSTATUSReadRegister32(baseAddress);
+
+    return status;
+}
+
+
+HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress, u32 *addr)
+{
+    HW_STATUS status = RET_OK;
+
+    /*Check the input Parameters*/
+    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+    /* read values from register */
+    *addr = MMUMMU_FAULT_ADReadRegister32(baseAddress);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress, u32 TTBPhysAddr)
+{
+    HW_STATUS status = RET_OK;
+    u32 loadTTB;
+
+   /*Check the input Parameters*/
+   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+   loadTTB = TTBPhysAddr & ~0x7FUL;
+   /* write values to register */
+   MMUMMU_TTBWriteRegister32(baseAddress, loadTTB);
+
+   return status;
+}
+
+HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_SET);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress)
+{
+    HW_STATUS status = RET_OK;
+
+    MMUMMU_CNTLTWLEnableWrite32(baseAddress, HW_CLEAR);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress, u32 virtualAddr,
+			     u32 pageSize)
+{
+    HW_STATUS status = RET_OK;
+    u32 virtualAddrTag;
+    enum HW_MMUPageSize_t pgSizeBits;
+
+    switch (pageSize) {
+    case HW_PAGE_SIZE_4KB:
+	pgSizeBits = HW_MMU_SMALL_PAGE;
+	break;
+
+    case HW_PAGE_SIZE_64KB:
+	pgSizeBits = HW_MMU_LARGE_PAGE;
+	break;
+
+    case HW_PAGE_SIZE_1MB:
+	pgSizeBits = HW_MMU_SECTION;
+	break;
+
+    case HW_PAGE_SIZE_16MB:
+	pgSizeBits = HW_MMU_SUPERSECTION;
+	break;
+
+    default:
+	return RET_FAIL;
+    }
+
+    /* Generate the 20-bit tag from virtual address */
+    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+
+    MMU_SetCAMEntry(baseAddress, pgSizeBits, 0, 0, virtualAddrTag);
+
+    MMU_FlushEntry(baseAddress);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
+			   u32	      physicalAddr,
+			   u32	      virtualAddr,
+			   u32	      pageSize,
+			   u32	      entryNum,
+			   struct HW_MMUMapAttrs_t    *mapAttrs,
+			   s8 preservedBit, s8 validBit)
+{
+    HW_STATUS  status = RET_OK;
+    u32 lockReg;
+    u32 virtualAddrTag;
+    enum HW_MMUPageSize_t mmuPgSize;
+
+    /*Check the input Parameters*/
+    CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		      RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+    CHECK_INPUT_RANGE_MIN0(pageSize, MMU_PAGE_MAX, RET_PARAM_OUT_OF_RANGE,
+			   RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+    CHECK_INPUT_RANGE_MIN0(mapAttrs->elementSize, MMU_ELEMENTSIZE_MAX,
+			RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+			RES_INVALID_INPUT_PARAM);
+
+    switch (pageSize) {
+    case HW_PAGE_SIZE_4KB:
+	mmuPgSize = HW_MMU_SMALL_PAGE;
+	break;
+
+    case HW_PAGE_SIZE_64KB:
+	mmuPgSize = HW_MMU_LARGE_PAGE;
+	break;
+
+    case HW_PAGE_SIZE_1MB:
+	mmuPgSize = HW_MMU_SECTION;
+	break;
+
+    case HW_PAGE_SIZE_16MB:
+	mmuPgSize = HW_MMU_SUPERSECTION;
+	break;
+
+    default:
+	return RET_FAIL;
+    }
+
+    lockReg = MMUMMU_LOCKReadRegister32(baseAddress);
+
+    /* Generate the 20-bit tag from virtual address */
+    virtualAddrTag = ((virtualAddr & MMU_ADDR_MASK) >> 12);
+
+    /* Write the fields in the CAM Entry Register */
+    MMU_SetCAMEntry(baseAddress,  mmuPgSize, preservedBit, validBit,
+		    virtualAddrTag);
+
+    /* Write the different fields of the RAM Entry Register */
+    /* endianism of the page,Element Size of the page (8, 16, 32, 64 bit)*/
+    MMU_SetRAMEntry(baseAddress, physicalAddr, mapAttrs->endianism,
+		    mapAttrs->elementSize, mapAttrs->mixedSize);
+
+    /* Update the MMU Lock Register */
+    /* currentVictim between lockedBaseValue and (MMU_Entries_Number - 1)*/
+    MMUMMU_LOCKCurrentVictimWrite32(baseAddress, entryNum);
+
+    /* Enable loading of an entry in TLB by writing 1
+	   into LD_TLB_REG register */
+    MMUMMU_LD_TLBWriteRegister32(baseAddress, MMU_LOAD_TLB);
+
+
+    MMUMMU_LOCKWriteRegister32(baseAddress, lockReg);
+
+    return status;
+}
+
+HW_STATUS HW_MMU_PteSet(const u32	pgTblVa,
+			   u32	      physicalAddr,
+			   u32	      virtualAddr,
+			   u32	      pageSize,
+			   struct HW_MMUMapAttrs_t    *mapAttrs)
+{
+    HW_STATUS status = RET_OK;
+    u32 pteAddr, pteVal;
+    s32 numEntries = 1;
+
+    switch (pageSize) {
+    case HW_PAGE_SIZE_4KB:
+	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
+				    virtualAddr & MMU_SMALL_PAGE_MASK);
+	pteVal = ((physicalAddr & MMU_SMALL_PAGE_MASK) |
+		    (mapAttrs->endianism << 9) |
+		    (mapAttrs->elementSize << 4) |
+		    (mapAttrs->mixedSize << 11) | 2
+		  );
+	break;
+
+    case HW_PAGE_SIZE_64KB:
+	numEntries = 16;
+	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
+				    virtualAddr & MMU_LARGE_PAGE_MASK);
+	pteVal = ((physicalAddr & MMU_LARGE_PAGE_MASK) |
+		    (mapAttrs->endianism << 9) |
+		    (mapAttrs->elementSize << 4) |
+		    (mapAttrs->mixedSize << 11) | 1
+		  );
+	break;
+
+    case HW_PAGE_SIZE_1MB:
+	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
+				    virtualAddr & MMU_SECTION_ADDR_MASK);
+	pteVal = ((((physicalAddr & MMU_SECTION_ADDR_MASK) |
+		     (mapAttrs->endianism << 15) |
+		     (mapAttrs->elementSize << 10) |
+		     (mapAttrs->mixedSize << 17)) &
+		     ~0x40000) | 0x2
+		 );
+	break;
+
+    case HW_PAGE_SIZE_16MB:
+	numEntries = 16;
+	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
+				    virtualAddr & MMU_SSECTION_ADDR_MASK);
+	pteVal = (((physicalAddr & MMU_SSECTION_ADDR_MASK) |
+		      (mapAttrs->endianism << 15) |
+		      (mapAttrs->elementSize << 10) |
+		      (mapAttrs->mixedSize << 17)
+		    ) | 0x40000 | 0x2
+		  );
+	break;
+
+    case HW_MMU_COARSE_PAGE_SIZE:
+	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
+				    virtualAddr & MMU_SECTION_ADDR_MASK);
+	pteVal = (physicalAddr & MMU_PAGE_TABLE_MASK) | 1;
+	break;
+
+    default:
+	return RET_FAIL;
+    }
+
+    while (--numEntries >= 0)
+	((u32 *)pteAddr)[numEntries] = pteVal;
+
+    return status;
+}
+
+HW_STATUS HW_MMU_PteClear(const u32  pgTblVa,
+			     u32	virtualAddr,
+			     u32	pgSize)
+{
+    HW_STATUS status = RET_OK;
+    u32 pteAddr;
+    s32 numEntries = 1;
+
+    switch (pgSize) {
+    case HW_PAGE_SIZE_4KB:
+	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
+				    virtualAddr & MMU_SMALL_PAGE_MASK);
+	break;
+
+    case HW_PAGE_SIZE_64KB:
+	numEntries = 16;
+	pteAddr = HW_MMU_PteAddrL2(pgTblVa,
+				    virtualAddr & MMU_LARGE_PAGE_MASK);
+	break;
+
+    case HW_PAGE_SIZE_1MB:
+    case HW_MMU_COARSE_PAGE_SIZE:
+	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
+				    virtualAddr & MMU_SECTION_ADDR_MASK);
+	break;
+
+    case HW_PAGE_SIZE_16MB:
+	numEntries = 16;
+	pteAddr = HW_MMU_PteAddrL1(pgTblVa,
+				    virtualAddr & MMU_SSECTION_ADDR_MASK);
+	break;
+
+    default:
+	return RET_FAIL;
+    }
+
+    while (--numEntries >= 0)
+	((u32 *)pteAddr)[numEntries] = 0;
+
+    return status;
+}
+
+/* MMU_FlushEntry */
+static HW_STATUS MMU_FlushEntry(const void __iomem *baseAddress)
+{
+   HW_STATUS status = RET_OK;
+   u32 flushEntryData = 0x1;
+
+   /*Check the input Parameters*/
+   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+   /* write values to register */
+   MMUMMU_FLUSH_ENTRYWriteRegister32(baseAddress, flushEntryData);
+
+   return status;
+}
+
+/* MMU_SetCAMEntry */
+static HW_STATUS MMU_SetCAMEntry(const void __iomem *baseAddress,
+				   const u32    pageSize,
+				   const u32    preservedBit,
+				   const u32    validBit,
+				   const u32    virtualAddrTag)
+{
+   HW_STATUS status = RET_OK;
+   u32 mmuCamReg;
+
+   /*Check the input Parameters*/
+   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+
+   mmuCamReg = (virtualAddrTag << 12);
+   mmuCamReg = (mmuCamReg) | (pageSize) |  (validBit << 2) |
+	       (preservedBit << 3) ;
+
+   /* write values to register */
+   MMUMMU_CAMWriteRegister32(baseAddress, mmuCamReg);
+
+   return status;
+}
+
+/* MMU_SetRAMEntry */
+static HW_STATUS MMU_SetRAMEntry(const void __iomem *baseAddress,
+				   const u32       physicalAddr,
+				   enum HW_Endianism_t     endianism,
+				   enum HW_ElementSize_t   elementSize,
+				   enum HW_MMUMixedSize_t  mixedSize)
+{
+   HW_STATUS status = RET_OK;
+   u32 mmuRamReg;
+
+   /*Check the input Parameters*/
+   CHECK_INPUT_PARAM(baseAddress, 0, RET_BAD_NULL_PARAM,
+		     RES_MMU_BASE + RES_INVALID_INPUT_PARAM);
+   CHECK_INPUT_RANGE_MIN0(elementSize, MMU_ELEMENTSIZE_MAX,
+		   RET_PARAM_OUT_OF_RANGE, RES_MMU_BASE +
+		   RES_INVALID_INPUT_PARAM);
+
+
+   mmuRamReg = (physicalAddr & MMU_ADDR_MASK);
+   mmuRamReg = (mmuRamReg) | ((endianism << 9) |  (elementSize << 7) |
+	       (mixedSize << 6));
+
+   /* write values to register */
+   MMUMMU_RAMWriteRegister32(baseAddress, mmuRamReg);
+
+   return status;
+
+}
diff --git a/drivers/dsp/bridge/hw/hw_mmu.h b/drivers/dsp/bridge/hw/hw_mmu.h
new file mode 100644
index 0000000..ddb0843
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_mmu.h
@@ -0,0 +1,165 @@
+/*
+ * hw_mmu.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * MMU types and API declarations
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __HW_MMU_H
+#define __HW_MMU_H
+
+#include <linux/types.h>
+
+/* Bitmasks for interrupt sources */
+#define HW_MMU_TRANSLATION_FAULT   0x2
+#define HW_MMU_ALL_INTERRUPTS      0x1F
+
+#define HW_MMU_COARSE_PAGE_SIZE 0x400
+
+/* HW_MMUMixedSize_t:  Enumerated Type used to specify whether to follow
+			CPU/TLB Element size */
+enum HW_MMUMixedSize_t {
+	HW_MMU_TLBES,
+	HW_MMU_CPUES
+
+} ;
+
+/* HW_MMUMapAttrs_t:  Struct containing MMU mapping attributes */
+struct HW_MMUMapAttrs_t {
+	enum HW_Endianism_t     endianism;
+	enum HW_ElementSize_t   elementSize;
+	enum HW_MMUMixedSize_t  mixedSize;
+	bool donotlockmpupage;
+} ;
+
+extern HW_STATUS HW_MMU_Enable(const void __iomem *baseAddress);
+
+extern HW_STATUS HW_MMU_Disable(const void __iomem *baseAddress);
+
+extern HW_STATUS HW_MMU_NumLockedSet(const void __iomem *baseAddress,
+					u32 numLockedEntries);
+
+extern HW_STATUS HW_MMU_VictimNumSet(const void __iomem *baseAddress,
+					u32 victimEntryNum);
+
+/* For MMU faults */
+extern HW_STATUS HW_MMU_EventAck(const void __iomem *baseAddress,
+				    u32 irqMask);
+
+extern HW_STATUS HW_MMU_EventDisable(const void __iomem *baseAddress,
+					u32 irqMask);
+
+extern HW_STATUS HW_MMU_EventEnable(const void __iomem *baseAddress,
+				       u32 irqMask);
+
+extern HW_STATUS HW_MMU_EventStatus(const void __iomem *baseAddress,
+				       u32 *irqMask);
+
+extern HW_STATUS HW_MMU_FaultAddrRead(const void __iomem *baseAddress,
+					 u32 *addr);
+
+/* Set the TT base address */
+extern HW_STATUS HW_MMU_TTBSet(const void __iomem *baseAddress,
+				  u32 TTBPhysAddr);
+
+extern HW_STATUS HW_MMU_TWLEnable(const void __iomem *baseAddress);
+
+extern HW_STATUS HW_MMU_TWLDisable(const void __iomem *baseAddress);
+
+extern HW_STATUS HW_MMU_TLBFlush(const void __iomem *baseAddress,
+				    u32 virtualAddr,
+				    u32 pageSize);
+
+extern HW_STATUS HW_MMU_TLBAdd(const void __iomem *baseAddress,
+				  u32	   physicalAddr,
+				  u32	   virtualAddr,
+				  u32	   pageSize,
+				  u32	    entryNum,
+				  struct HW_MMUMapAttrs_t *mapAttrs,
+				  s8 preservedBit, s8 validBit);
+
+
+/* For PTEs */
+extern HW_STATUS HW_MMU_PteSet(const u32     pgTblVa,
+				  u32	   physicalAddr,
+				  u32	   virtualAddr,
+				  u32	   pageSize,
+				  struct HW_MMUMapAttrs_t *mapAttrs);
+
+extern HW_STATUS HW_MMU_PteClear(const u32   pgTblVa,
+				    u32	 pgSize,
+				    u32	 virtualAddr);
+
+static inline u32 HW_MMU_PteAddrL1(u32 L1_base, u32 va)
+{
+	u32 pteAddr;
+	u32 VA_31_to_20;
+
+	VA_31_to_20  = va >> (20 - 2); /* Left-shift by 2 here itself */
+	VA_31_to_20 &= 0xFFFFFFFCUL;
+	pteAddr = L1_base + VA_31_to_20;
+
+	return pteAddr;
+}
+
+static inline u32 HW_MMU_PteAddrL2(u32 L2_base, u32 va)
+{
+	u32 pteAddr;
+
+	pteAddr = (L2_base & 0xFFFFFC00) | ((va >> 10) & 0x3FC);
+
+	return pteAddr;
+}
+
+static inline u32 HW_MMU_PteCoarseL1(u32 pteVal)
+{
+	u32 pteCoarse;
+
+	pteCoarse = pteVal & 0xFFFFFC00;
+
+	return pteCoarse;
+}
+
+static inline u32 HW_MMU_PteSizeL1(u32 pteVal)
+{
+	u32 pteSize = 0;
+
+	if ((pteVal & 0x3) == 0x1) {
+		/* Points to L2 PT */
+		pteSize = HW_MMU_COARSE_PAGE_SIZE;
+	}
+
+	if ((pteVal & 0x3) == 0x2) {
+		if (pteVal & (1 << 18))
+			pteSize = HW_PAGE_SIZE_16MB;
+		else
+			pteSize = HW_PAGE_SIZE_1MB;
+	}
+
+	return pteSize;
+}
+
+static inline u32 HW_MMU_PteSizeL2(u32 pteVal)
+{
+    u32 pteSize = 0;
+
+    if (pteVal & 0x2)
+	pteSize = HW_PAGE_SIZE_4KB;
+    else if (pteVal & 0x1)
+	pteSize = HW_PAGE_SIZE_64KB;
+
+    return pteSize;
+}
+
+#endif  /* __HW_MMU_H */
diff --git a/drivers/dsp/bridge/hw/hw_prcm.c b/drivers/dsp/bridge/hw/hw_prcm.c
new file mode 100644
index 0000000..703ca67
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_prcm.c
@@ -0,0 +1,157 @@
+/*
+ * hw_prcm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * API definitions to configure PRCM (Power, Reset & Clocks Manager)
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <GlobalTypes.h>
+#include "PRCMRegAcM.h"
+#include <hw_defs.h>
+#include <hw_prcm.h>
+
+static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
+				    enum HW_RstModule_t r, s8 val);
+
+HW_STATUS HW_RST_Reset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+{
+	return HW_RST_WriteVal(baseAddress, r, HW_SET);
+}
+
+HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress, enum HW_RstModule_t r)
+{
+	return HW_RST_WriteVal(baseAddress, r, HW_CLEAR);
+}
+
+static HW_STATUS HW_RST_WriteVal(const void __iomem *baseAddress,
+				    enum HW_RstModule_t r, s8 val)
+{
+	HW_STATUS status = RET_OK;
+
+	switch (r) {
+	case HW_RST1_IVA2:
+	    PRM_RSTCTRL_IVA2RST1_DSPWrite32(baseAddress, val);
+	    break;
+	case HW_RST2_IVA2:
+	    PRM_RSTCTRL_IVA2RST2_DSPWrite32(baseAddress, val);
+	    break;
+	case HW_RST3_IVA2:
+	    PRM_RSTCTRL_IVA2RST3_DSPWrite32(baseAddress, val);
+	    break;
+	default:
+	    status = RET_FAIL;
+	    break;
+	}
+	return status;
+}
+
+HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
+		enum HW_PwrModule_t p, enum HW_PwrState_t *value)
+{
+	HW_STATUS status = RET_OK;
+	u32 temp;
+
+	switch (p) {
+	case HW_PWR_DOMAIN_DSP:
+		/* wait until Transition is complete */
+		do {
+			/* mdelay(1); */
+			temp = PRCMPM_PWSTST_IVA2InTransitionRead32
+				(baseAddress);
+
+		} while (temp);
+
+		temp = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
+		*value = PRCMPM_PWSTST_IVA2PowerStateStGet32(temp);
+		break;
+
+	default:
+		status = RET_FAIL;
+		break;
+	}
+	return status;
+}
+
+HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress, u32 *value)
+{
+	HW_STATUS status = RET_OK;
+
+	*value = PRCMPM_PWSTST_IVA2ReadRegister32(baseAddress);
+
+	return status;
+}
+
+
+HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
+				     enum HW_PwrModule_t p,
+				     enum HW_PwrState_t value)
+{
+	HW_STATUS status = RET_OK;
+
+	switch (p) {
+	case HW_PWR_DOMAIN_DSP:
+		switch (value) {
+		case HW_PWR_STATE_ON:
+			PRCMPM_PWSTCTRL_IVA2PowerStateWriteON32(baseAddress);
+			break;
+		case HW_PWR_STATE_RET:
+			PRCMPM_PWSTCTRL_DSPPowerStateWriteRET32(baseAddress);
+			break;
+		case HW_PWR_STATE_OFF:
+			PRCMPM_PWSTCTRL_IVA2PowerStateWriteOFF32(baseAddress);
+			break;
+		default:
+			status = RET_FAIL;
+			break;
+		}
+		break;
+
+	default:
+		status = RET_FAIL;
+		break;
+	}
+
+	return status;
+}
+
+HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
+				      enum HW_TransitionState_t val)
+{
+	HW_STATUS status = RET_OK;
+
+	PRCMCM_CLKSTCTRL_IVA2WriteRegister32(baseAddress, val);
+
+	return status;
+
+}
+
+HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
+		enum HW_RstModule_t m, u32 *value)
+{
+	HW_STATUS status = RET_OK;
+
+	*value = PRCMRM_RSTST_DSPReadRegister32(baseAddress);
+
+	return status;
+}
+
+HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
+		enum HW_RstModule_t m, u32 *value)
+{
+	HW_STATUS status = RET_OK;
+
+	*value = PRCMRM_RSTCTRL_DSPReadRegister32(baseAddress);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/hw/hw_prcm.h b/drivers/dsp/bridge/hw/hw_prcm.h
new file mode 100644
index 0000000..07f16ff
--- /dev/null
+++ b/drivers/dsp/bridge/hw/hw_prcm.h
@@ -0,0 +1,161 @@
+/*
+ * hw_prcm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * PRCM types and API declarations
+ *
+ * Copyright (C) 2007 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef __HW_PRCM_H
+#define __HW_PRCM_H
+
+/* HW_ClkModule:  Enumerated Type used to specify the clock domain */
+
+enum HW_ClkModule_t {
+/* DSP Domain */
+    HW_CLK_DSP_CPU,
+    HW_CLK_DSP_IPI_MMU,
+    HW_CLK_IVA_ARM,
+    HW_CLK_IVA_COP,	/* IVA Coprocessor */
+
+/* Core Domain */
+    HW_CLK_FN_WDT4,	/* Functional Clock */
+    HW_CLK_FN_WDT3,
+    HW_CLK_FN_UART2,
+    HW_CLK_FN_UART1,
+    HW_CLK_GPT5,
+    HW_CLK_GPT6,
+    HW_CLK_GPT7,
+    HW_CLK_GPT8,
+
+    HW_CLK_IF_WDT4,	/* Interface Clock */
+    HW_CLK_IF_WDT3,
+    HW_CLK_IF_UART2,
+    HW_CLK_IF_UART1,
+    HW_CLK_IF_MBOX
+
+} ;
+
+enum HW_ClkSubsys_t {
+    HW_CLK_DSPSS,
+    HW_CLK_IVASS
+} ;
+
+/* HW_GPtimers:  General purpose timers */
+enum HW_GPtimer_t {
+    HW_GPT5 = 5,
+    HW_GPT6 = 6,
+    HW_GPT7 = 7,
+    HW_GPT8 = 8
+} ;
+
+
+/* GP timers Input clock type:  General purpose timers */
+enum HW_Clocktype_t {
+    HW_CLK_32KHz = 0,
+    HW_CLK_SYS   = 1,
+    HW_CLK_EXT   = 2
+} ;
+
+/* HW_ClkDiv:  Clock divisors */
+enum HW_ClkDiv_t {
+    HW_CLK_DIV_1 = 0x1,
+    HW_CLK_DIV_2 = 0x2,
+    HW_CLK_DIV_3 = 0x3,
+    HW_CLK_DIV_4 = 0x4,
+    HW_CLK_DIV_6 = 0x6,
+    HW_CLK_DIV_8 = 0x8,
+    HW_CLK_DIV_12 = 0xC
+} ;
+
+/* HW_RstModule:  Enumerated Type used to specify the module to be reset */
+enum HW_RstModule_t {
+    HW_RST1_IVA2,  /* Reset the DSP */
+    HW_RST2_IVA2,  /* Reset MMU and LEON HWa */
+    HW_RST3_IVA2   /* Reset LEON sequencer */
+} ;
+
+/* HW_PwrModule:  Enumerated Type used to specify the power domain */
+enum HW_PwrModule_t {
+/* Domains */
+    HW_PWR_DOMAIN_CORE,
+    HW_PWR_DOMAIN_MPU,
+    HW_PWR_DOMAIN_WAKEUP,
+    HW_PWR_DOMAIN_DSP,
+
+/* Sub-domains */
+    HW_PWR_DSP_IPI,	/* IPI = Intrusive Port Interface */
+    HW_PWR_IVA_ISP	 /* ISP = Intrusive Slave Port */
+} ;
+
+enum HW_PwrState_t {
+    HW_PWR_STATE_OFF,
+    HW_PWR_STATE_RET,
+    HW_PWR_STATE_INACT,
+    HW_PWR_STATE_ON = 3
+} ;
+
+enum HW_ForceState_t {
+    HW_FORCE_OFF,
+    HW_FORCE_ON
+} ;
+
+enum HW_IdleState_t {
+    HW_ACTIVE,
+    HW_STANDBY
+
+} ;
+
+enum HW_TransitionState_t {
+    HW_AUTOTRANS_DIS,
+    HW_SW_SUP_SLEEP,
+    HW_SW_SUP_WAKEUP,
+    HW_AUTOTRANS_EN
+} ;
+
+
+extern HW_STATUS HW_RST_Reset(const void __iomem *baseAddress,
+				 enum HW_RstModule_t r);
+
+extern HW_STATUS HW_RST_UnReset(const void __iomem *baseAddress,
+				   enum HW_RstModule_t r);
+
+extern HW_STATUS HW_RSTCTRL_RegGet(const void __iomem *baseAddress,
+					     enum HW_RstModule_t p,
+					     u32 *value);
+extern HW_STATUS HW_RSTST_RegGet(const void __iomem *baseAddress,
+					   enum HW_RstModule_t p, u32 *value);
+
+extern HW_STATUS HW_PWR_PowerStateSet(const u32 baseAddress,
+						enum HW_PwrModule_t p,
+						enum HW_PwrState_t value);
+
+extern HW_STATUS HW_CLK_SetInputClock(const u32 baseAddress,
+					enum HW_GPtimer_t gpt,
+					enum HW_Clocktype_t c);
+
+extern HW_STATUS HW_PWR_IVA2StateGet(const void __iomem *baseAddress,
+					enum HW_PwrModule_t p,
+					enum HW_PwrState_t *value);
+
+extern HW_STATUS HW_PWRST_IVA2RegGet(const void __iomem *baseAddress,
+						u32 *value);
+
+extern HW_STATUS HW_PWR_IVA2PowerStateSet(const void __iomem *baseAddress,
+					    enum HW_PwrModule_t p,
+					    enum HW_PwrState_t value);
+
+extern HW_STATUS HW_PWR_CLKCTRL_IVA2RegSet(const void __iomem *baseAddress,
+					     enum HW_TransitionState_t val);
+
+#endif  /* __HW_PRCM_H */
diff --git a/drivers/dsp/bridge/pmgr/chnl.c b/drivers/dsp/bridge/pmgr/chnl.c
new file mode 100644
index 0000000..6331b97
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/chnl.c
@@ -0,0 +1,170 @@
+/*
+ * chnl.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * WCD channel interface: multiplexes data streams through the single
+ * physical link managed by a Bridge mini-driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/proc.h>
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/chnlpriv.h>
+#include <chnlobj.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/chnl.h>
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;
+
+/*
+ *  ======== CHNL_Create ========
+ *  Purpose:
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given 'Bridge board.
+ */
+DSP_STATUS CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+		       struct DEV_OBJECT *hDevObject,
+		       IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
+{
+	DSP_STATUS status;
+	struct CHNL_MGR *hChnlMgr;
+	struct CHNL_MGR_ *pChnlMgr = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phChnlMgr != NULL);
+	DBC_Require(pMgrAttrs != NULL);
+
+	*phChnlMgr = NULL;
+
+	/* Validate args: */
+	if ((0 < pMgrAttrs->cChannels) &&
+	   (pMgrAttrs->cChannels <= CHNL_MAXCHANNELS))
+		status = DSP_SOK;
+	else if (pMgrAttrs->cChannels == 0)
+		status = DSP_EINVALIDARG;
+	else
+		status = CHNL_E_MAXCHANNELS;
+
+	if (pMgrAttrs->uWordSize == 0)
+		status = CHNL_E_INVALIDWORDSIZE;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetChnlMgr(hDevObject, &hChnlMgr);
+		if (DSP_SUCCEEDED(status) && hChnlMgr != NULL)
+			status = CHNL_E_MGREXISTS;
+
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		struct WMD_DRV_INTERFACE *pIntfFxns;
+		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+		/* Let WMD channel module finish the create: */
+		status = (*pIntfFxns->pfnChnlCreate)(&hChnlMgr, hDevObject,
+			  pMgrAttrs);
+		if (DSP_SUCCEEDED(status)) {
+			/* Fill in WCD channel module's fields of the
+			 * CHNL_MGR structure */
+			pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
+			pChnlMgr->pIntfFxns = pIntfFxns;
+			/* Finally, return the new channel manager handle: */
+			*phChnlMgr = hChnlMgr;
+		}
+	}
+
+	DBC_Ensure(DSP_FAILED(status) || CHNL_IsValidMgr(pChnlMgr));
+
+	return status;
+}
+
+/*
+ *  ======== CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ */
+DSP_STATUS CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+{
+	struct CHNL_MGR_ *pChnlMgr = (struct CHNL_MGR_ *)hChnlMgr;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status;
+
+	DBC_Require(cRefs > 0);
+
+	if (CHNL_IsValidMgr(pChnlMgr)) {
+		pIntfFxns = pChnlMgr->pIntfFxns;
+		/* Let WMD channel module destroy the CHNL_MGR: */
+		status = (*pIntfFxns->pfnChnlDestroy)(hChnlMgr);
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_FAILED(status) || !CHNL_IsValidMgr(pChnlMgr));
+
+	return status;
+}
+
+/*
+ *  ======== CHNL_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CHNL module.
+ */
+void CHNL_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+
+/*
+ *  ======== CHNL_Init ========
+ *  Purpose:
+ *      Initialize the CHNL module's private state.
+ */
+bool CHNL_Init(void)
+{
+	bool fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+
diff --git a/drivers/dsp/bridge/pmgr/chnlobj.h b/drivers/dsp/bridge/pmgr/chnlobj.h
new file mode 100644
index 0000000..3c2b14f
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/chnlobj.h
@@ -0,0 +1,56 @@
+/*
+ * chnlobj.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Structure subcomponents of channel class library channel objects which
+ * are exposed to class driver from mini-driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef CHNLOBJ_
+#define CHNLOBJ_
+
+#include <dspbridge/chnldefs.h>
+#include <dspbridge/wmd.h>
+
+/* Object validateion macros: */
+#define CHNL_IsValidMgr(h) \
+		((h != NULL) && ((h)->dwSignature == CHNL_MGRSIGNATURE))
+
+#define CHNL_IsValidChnl(h)\
+		((h != NULL) && ((h)->dwSignature == CHNL_SIGNATURE))
+
+/*
+ *  This struct is the first field in a CHNL_MGR struct, as implemented in
+ *  a WMD channel class library.  Other, implementation specific fields
+ *  follow this structure in memory.
+ */
+struct CHNL_MGR_ {
+	/* These must be the first fields in a CHNL_MGR struct: */
+	u32 dwSignature;	/* Used for object validation.   */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+} ;
+
+/*
+ *  This struct is the first field in a CHNL_OBJECT struct, as implemented in
+ *  a WMD channel class library.  Other, implementation specific fields
+ *  follow this structure in memory.
+ */
+struct CHNL_OBJECT_ {
+	/* These must be the first fields in a CHNL_OBJECT struct: */
+	u32 dwSignature;	/* Used for object validation.      */
+	struct CHNL_MGR_ *pChnlMgr;	/* Pointer back to channel manager. */
+} ;
+
+#endif				/* CHNLOBJ_ */
+
diff --git a/drivers/dsp/bridge/pmgr/cmm.c b/drivers/dsp/bridge/pmgr/cmm.c
new file mode 100644
index 0000000..c1a3a55
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/cmm.c
@@ -0,0 +1,1155 @@
+/*
+ * cmm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * The Communication(Shared) Memory Management(CMM) module provides
+ * shared memory management services for DSP/BIOS Bridge data streaming
+ * and messaging.
+ *
+ * Multiple shared memory segments can be registered with CMM.
+ * Each registered SM segment is represented by a SM "allocator" that
+ * describes a block of physically contiguous shared memory used for
+ * future allocations by CMM.
+ *
+ * Memory is coelesced back to the appropriate heap when a buffer is
+ * freed.
+ *
+ * Notes:
+ *   Va: Virtual address.
+ *   Pa: Physical or kernel system address.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+#include <dspbridge/utildefs.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/proc.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/cmm.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+/* Object signatures */
+#define CMMSIGNATURE       0x004d4d43	/* "CMM"   (in reverse) */
+#define SMEMSIGNATURE      0x4D454D53	/* "SMEM"  SM space     */
+#define CMMXLATESIGNATURE  0x584d4d43	/* "CMMX"  CMM Xlator   */
+
+#define NEXT_PA(pNode)   (pNode->dwPA + pNode->ulSize)
+
+/* Other bus/platform translations */
+#define DSPPA2GPPPA(base, x, y)  ((x)+(y))
+#define GPPPA2DSPPA(base, x, y)  ((x)-(y))
+
+/*
+ *  Allocators define a block of contiguous memory used for future allocations.
+ *
+ *      sma - shared memory allocator.
+ *      vma - virtual memory allocator.(not used).
+ */
+struct CMM_ALLOCATOR {	/* sma */
+	u32 dwSignature;	/* SMA allocator signature SMEMSIGNATURE */
+	unsigned int dwSmBase;		/* Start of physical SM block */
+	u32 ulSmSize;		/* Size of SM block in bytes */
+	unsigned int dwVmBase;		/* Start of VM block. (Dev driver
+				 * context for 'sma') */
+	u32 dwDSPPhysAddrOffset;	/* DSP PA to GPP PA offset for this
+					 * SM space */
+	s8 cFactor;			/* DSPPa to GPPPa Conversion Factor */
+	unsigned int dwDSPBase;	/* DSP virt base byte address */
+	u32 ulDSPSize;	/* DSP seg size in bytes */
+	struct CMM_OBJECT *hCmmMgr;	/* back ref to parent mgr */
+	struct LST_LIST *pFreeListHead;	/* node list of available memory */
+	struct LST_LIST *pInUseListHead;	/* node list of memory in use */
+} ;
+
+struct CMM_XLATOR {	/* Pa<->Va translator object */
+	u32 dwSignature;	/* "CMMX" */
+	struct CMM_OBJECT *hCmmMgr;  /* CMM object this translator associated */
+	/*
+	 *  Client process virtual base address that corresponds to phys SM
+	 *  base address for translator's ulSegId.
+	 *  Only 1 segment ID currently supported.
+	 */
+	unsigned int dwVirtBase;	/* virtual base address */
+	u32 ulVirtSize;	/* size of virt space in bytes */
+	u32 ulSegId;		/* Segment Id */
+} ;
+
+/* CMM Mgr */
+struct CMM_OBJECT {
+	u32 dwSignature;	/* Used for object validation */
+	/*
+	 * Cmm Lock is used to serialize access mem manager for multi-threads.
+	 */
+	struct SYNC_CSOBJECT *hCmmLock;	/* Lock to access cmm mgr */
+	struct LST_LIST *pNodeFreeListHead;	/* Free list of memory nodes */
+	u32 ulMinBlockSize;	/* Min SM block; default 16 bytes */
+	u32 dwPageSize;	/* Memory Page size (1k/4k) */
+	/* GPP SM segment ptrs */
+	struct CMM_ALLOCATOR *paGPPSMSegTab[CMM_MAXGPPSEGS];
+} ;
+
+/* Default CMM Mgr attributes */
+static struct CMM_MGRATTRS CMM_DFLTMGRATTRS = {
+	16	/* ulMinBlockSize, min block size(bytes) allocated by cmm mgr */
+};
+
+/* Default allocation attributes */
+static struct CMM_ATTRS CMM_DFLTALCTATTRS = {
+	1			/* ulSegId, default segment Id for allocator */
+};
+
+/* Address translator default attrs */
+static struct CMM_XLATORATTRS CMM_DFLTXLATORATTRS = {
+	1,	/* ulSegId, does not have to match CMM_DFLTALCTATTRS ulSegId */
+	0,			/* dwDSPBufs */
+	0,			/* dwDSPBufSize */
+	NULL,			/* pVmBase */
+	0,			/* dwVmSize */
+};
+
+/* SM node representing a block of memory. */
+struct CMM_MNODE {
+	struct list_head link;		/* must be 1st element */
+	u32 dwPA;		/* Phys addr */
+	u32 dwVA;		/* Virtual address in device process context */
+	u32 ulSize;		/* SM block size in bytes */
+       u32 hClientProc;        /* Process that allocated this mem block */
+} ;
+
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;		/* module reference count */
+
+/*  ----------------------------------- Function Prototypes */
+static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
+			  struct CMM_MNODE *pNode);
+static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
+					  u32 ulSegId);
+static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
+				      u32 uSize);
+static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
+				 u32 dwVA, u32 ulSize);
+/* get available slot for new allocator */
+static s32 GetSlot(struct CMM_OBJECT *hCmmMgr);
+static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA);
+
+/*
+ *  ======== CMM_CallocBuf ========
+ *  Purpose:
+ *      Allocate a SM buffer, zero contents, and return the physical address
+ *      and optional driver context virtual address(ppBufVA).
+ *
+ *      The freelist is sorted in increasing size order. Get the first
+ *      block that satifies the request and sort the remaining back on
+ *      the freelist; if large enough. The kept block is placed on the
+ *      inUseList.
+ */
+void *CMM_CallocBuf(struct CMM_OBJECT *hCmmMgr, u32 uSize,
+		    struct CMM_ATTRS *pAttrs, OUT void **ppBufVA)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	void *pBufPA = NULL;
+	struct CMM_MNODE *pNode = NULL;
+	struct CMM_MNODE *pNewNode = NULL;
+	struct CMM_ALLOCATOR *pAllocator = NULL;
+	u32 uDeltaSize;
+	u8 *pByte = NULL;
+	s32 cnt;
+
+	if (pAttrs == NULL)
+		pAttrs = &CMM_DFLTALCTATTRS;
+
+	if (ppBufVA != NULL)
+		*ppBufVA = NULL;
+
+	if ((MEM_IsValidHandle(pCmmMgr, CMMSIGNATURE)) && (uSize != 0)) {
+		if (pAttrs->ulSegId > 0) {
+			/* SegId > 0 is SM  */
+			/* get the allocator object for this segment id */
+			pAllocator = GetAllocator(pCmmMgr, pAttrs->ulSegId);
+			/* keep block size a multiple of ulMinBlockSize */
+			uSize = ((uSize - 1) & ~(pCmmMgr->ulMinBlockSize - 1))
+				+ pCmmMgr->ulMinBlockSize;
+			SYNC_EnterCS(pCmmMgr->hCmmLock);
+			pNode = GetFreeBlock(pAllocator, uSize);
+		}
+		if (pNode) {
+			uDeltaSize = (pNode->ulSize - uSize);
+			if (uDeltaSize >= pCmmMgr->ulMinBlockSize) {
+				/* create a new block with the leftovers and
+				 * add to freelist */
+				pNewNode = GetNode(pCmmMgr, pNode->dwPA + uSize,
+					   pNode->dwVA + uSize,
+					   (u32)uDeltaSize);
+				/* leftovers go free */
+				AddToFreeList(pAllocator, pNewNode);
+				/* adjust our node's size */
+				pNode->ulSize = uSize;
+			}
+			/* Tag node with client process requesting allocation
+			 * We'll need to free up a process's alloc'd SM if the
+			 * client process goes away.
+			 */
+			/* Return TGID instead of process handle */
+			pNode->hClientProc = current->tgid;
+
+			/* put our node on InUse list */
+			LST_PutTail(pAllocator->pInUseListHead,
+				   (struct list_head *)pNode);
+			pBufPA = (void *)pNode->dwPA;	/* physical address */
+			/* clear mem */
+			pByte = (u8 *)pNode->dwVA;
+			for (cnt = 0; cnt < (s32) uSize; cnt++, pByte++)
+				*pByte = 0;
+
+			if (ppBufVA != NULL) {
+				/* Virtual address */
+				*ppBufVA = (void *)pNode->dwVA;
+			}
+		}
+		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	}
+	return pBufPA;
+}
+
+/*
+ *  ======== CMM_Create ========
+ *  Purpose:
+ *      Create a communication memory manager object.
+ */
+DSP_STATUS CMM_Create(OUT struct CMM_OBJECT **phCmmMgr,
+		      struct DEV_OBJECT *hDevObject,
+		      IN CONST struct CMM_MGRATTRS *pMgrAttrs)
+{
+	struct CMM_OBJECT *pCmmObject = NULL;
+	DSP_STATUS status = DSP_SOK;
+	struct UTIL_SYSINFO sysInfo;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phCmmMgr != NULL);
+
+	*phCmmMgr = NULL;
+	/* create, zero, and tag a cmm mgr object */
+	MEM_AllocObject(pCmmObject, struct CMM_OBJECT, CMMSIGNATURE);
+	if (pCmmObject != NULL) {
+		if (pMgrAttrs == NULL)
+			pMgrAttrs = &CMM_DFLTMGRATTRS;	/* set defaults */
+
+		/* 4 bytes minimum */
+		DBC_Assert(pMgrAttrs->ulMinBlockSize >= 4);
+		/* save away smallest block allocation for this cmm mgr */
+		pCmmObject->ulMinBlockSize = pMgrAttrs->ulMinBlockSize;
+		/* save away the systems memory page size */
+		sysInfo.dwPageSize = PAGE_SIZE;
+		sysInfo.dwAllocationGranularity = PAGE_SIZE;
+		sysInfo.dwNumberOfProcessors = 1;
+		if (DSP_SUCCEEDED(status)) {
+			pCmmObject->dwPageSize = sysInfo.dwPageSize;
+		} else {
+			pCmmObject->dwPageSize = 0;
+			status = DSP_EFAIL;
+		}
+		/* Note: DSP SM seg table(aDSPSMSegTab[]) zero'd by
+		 * MEM_AllocObject */
+		if (DSP_SUCCEEDED(status)) {
+			/* create node free list */
+			pCmmObject->pNodeFreeListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
+			if (pCmmObject->pNodeFreeListHead == NULL)
+				status = DSP_EMEMORY;
+			else
+				INIT_LIST_HEAD(&pCmmObject->pNodeFreeListHead->
+					head);
+		}
+		if (DSP_SUCCEEDED(status))
+			status = SYNC_InitializeCS(&pCmmObject->hCmmLock);
+
+		if (DSP_SUCCEEDED(status))
+			*phCmmMgr = pCmmObject;
+		else
+			CMM_Destroy(pCmmObject, true);
+
+	} else {
+		status = DSP_EMEMORY;
+	}
+	return status;
+}
+
+/*
+ *  ======== CMM_Destroy ========
+ *  Purpose:
+ *      Release the communication memory manager resources.
+ */
+DSP_STATUS CMM_Destroy(struct CMM_OBJECT *hCmmMgr, bool bForce)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	struct CMM_INFO tempInfo;
+	DSP_STATUS status = DSP_SOK;
+	s32 nSlot;
+	struct CMM_MNODE *pNode;
+
+	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+		status = DSP_EHANDLE;
+		return status;
+	}
+	SYNC_EnterCS(pCmmMgr->hCmmLock);
+	/* If not force then fail if outstanding allocations exist */
+	if (!bForce) {
+		/* Check for outstanding memory allocations */
+		status = CMM_GetInfo(hCmmMgr, &tempInfo);
+		if (DSP_SUCCEEDED(status)) {
+			if (tempInfo.ulTotalInUseCnt > 0) {
+				/* outstanding allocations */
+				status = DSP_EFAIL;
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* UnRegister SM allocator */
+		for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
+			if (pCmmMgr->paGPPSMSegTab[nSlot] != NULL) {
+				UnRegisterGPPSMSeg(pCmmMgr->
+						   paGPPSMSegTab[nSlot]);
+				/* Set slot to NULL for future reuse */
+				pCmmMgr->paGPPSMSegTab[nSlot] = NULL;
+			}
+		}
+	}
+	if (pCmmMgr->pNodeFreeListHead != NULL) {
+		/* Free the free nodes */
+		while (!LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
+			pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
+				 pNodeFreeListHead);
+			kfree(pNode);
+		}
+		/* delete NodeFreeList list */
+		kfree(pCmmMgr->pNodeFreeListHead);
+	}
+	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	if (DSP_SUCCEEDED(status)) {
+		/* delete CS & cmm mgr object */
+		SYNC_DeleteCS(pCmmMgr->hCmmLock);
+		MEM_FreeObject(pCmmMgr);
+	}
+	return status;
+}
+
+/*
+ *  ======== CMM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ */
+void CMM_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+}
+
+/*
+ *  ======== CMM_FreeBuf ========
+ *  Purpose:
+ *      Free the given buffer.
+ */
+DSP_STATUS CMM_FreeBuf(struct CMM_OBJECT *hCmmMgr, void *pBufPA, u32 ulSegId)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	DSP_STATUS status = DSP_EPOINTER;
+	struct CMM_MNODE *pCurNode = NULL;
+	struct CMM_ALLOCATOR *pAllocator = NULL;
+	struct CMM_ATTRS *pAttrs;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBufPA != NULL);
+
+	if (ulSegId == 0) {
+		pAttrs = &CMM_DFLTALCTATTRS;
+		ulSegId = pAttrs->ulSegId;
+	}
+	if (!(MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) || !(ulSegId > 0)) {
+		status = DSP_EHANDLE;
+		return status;
+	}
+	/* get the allocator for this segment id */
+	pAllocator = GetAllocator(pCmmMgr, ulSegId);
+	if (pAllocator != NULL) {
+		SYNC_EnterCS(pCmmMgr->hCmmLock);
+		pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->
+			    pInUseListHead);
+		while (pCurNode) {
+			if ((u32)pBufPA == pCurNode->dwPA) {
+				/* Found it */
+				LST_RemoveElem(pAllocator->pInUseListHead,
+					      (struct list_head *)pCurNode);
+				/* back to freelist */
+				AddToFreeList(pAllocator, pCurNode);
+				status = DSP_SOK;	/* all right! */
+				break;
+			}
+			/* next node. */
+			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
+					pInUseListHead,
+					(struct list_head *)pCurNode);
+		}
+		SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	}
+	return status;
+}
+
+/*
+ *  ======== CMM_GetHandle ========
+ *  Purpose:
+ *      Return the communication memory manager object for this device.
+ *      This is typically called from the client process.
+ */
+DSP_STATUS CMM_GetHandle(void *hProcessor,
+			OUT struct CMM_OBJECT **phCmmMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phCmmMgr != NULL);
+	if (hProcessor != NULL)
+		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	else
+		hDevObject = DEV_GetFirst();	/* default */
+
+	if (DSP_SUCCEEDED(status))
+		status = DEV_GetCmmMgr(hDevObject, phCmmMgr);
+
+	return status;
+}
+
+/*
+ *  ======== CMM_GetInfo ========
+ *  Purpose:
+ *      Return the current memory utilization information.
+ */
+DSP_STATUS CMM_GetInfo(struct CMM_OBJECT *hCmmMgr,
+		       OUT struct CMM_INFO *pCmmInfo)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	u32 ulSeg;
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_ALLOCATOR *pAltr;
+	struct CMM_MNODE *pCurNode = NULL;
+
+	DBC_Require(pCmmInfo != NULL);
+
+	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+		status = DSP_EHANDLE;
+		return status;
+	}
+	SYNC_EnterCS(pCmmMgr->hCmmLock);
+	pCmmInfo->ulNumGPPSMSegs = 0;	/* # of SM segments */
+	pCmmInfo->ulTotalInUseCnt = 0;	/* Total # of outstanding alloc */
+	pCmmInfo->ulMinBlockSize = pCmmMgr->ulMinBlockSize; /* min block size */
+	/* check SM memory segments */
+	for (ulSeg = 1; ulSeg <= CMM_MAXGPPSEGS; ulSeg++) {
+		/* get the allocator object for this segment id */
+		pAltr = GetAllocator(pCmmMgr, ulSeg);
+		if (pAltr != NULL) {
+			pCmmInfo->ulNumGPPSMSegs++;
+			pCmmInfo->segInfo[ulSeg - 1].dwSegBasePa =
+				pAltr->dwSmBase - pAltr->ulDSPSize;
+			pCmmInfo->segInfo[ulSeg - 1].ulTotalSegSize =
+				pAltr->ulDSPSize + pAltr->ulSmSize;
+			pCmmInfo->segInfo[ulSeg - 1].dwGPPBasePA =
+				pAltr->dwSmBase;
+			pCmmInfo->segInfo[ulSeg - 1].ulGPPSize =
+				pAltr->ulSmSize;
+			pCmmInfo->segInfo[ulSeg - 1].dwDSPBaseVA =
+				pAltr->dwDSPBase;
+			pCmmInfo->segInfo[ulSeg - 1].ulDSPSize =
+				pAltr->ulDSPSize;
+			pCmmInfo->segInfo[ulSeg - 1].dwSegBaseVa =
+				pAltr->dwVmBase - pAltr->ulDSPSize;
+			pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt = 0;
+			pCurNode = (struct CMM_MNODE *)LST_First(pAltr->
+				pInUseListHead);
+			/* Count inUse blocks */
+			while (pCurNode) {
+				pCmmInfo->ulTotalInUseCnt++;
+				pCmmInfo->segInfo[ulSeg - 1].ulInUseCnt++;
+				/* next node. */
+				pCurNode = (struct CMM_MNODE *)LST_Next(pAltr->
+					pInUseListHead,
+					(struct list_head *)pCurNode);
+			}
+		}
+	}		/* end for */
+	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	return status;
+}
+
+/*
+ *  ======== CMM_Init ========
+ *  Purpose:
+ *      Initializes private state of CMM module.
+ */
+bool CMM_Init(void)
+{
+	bool fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+/*
+ *  ======== CMM_RegisterGPPSMSeg ========
+ *  Purpose:
+ *      Register a block of SM with the CMM to be used for later GPP SM
+ *      allocations.
+ */
+DSP_STATUS CMM_RegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 dwGPPBasePA,
+				u32 ulSize, u32 dwDSPAddrOffset,
+				s8 cFactor, u32 dwDSPBase,
+				u32 ulDSPSize, u32 *pulSegId,
+				u32 dwGPPBaseVA)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	struct CMM_ALLOCATOR *pSMA = NULL;
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_MNODE *pNewNode;
+	s32 nSlot;
+
+	DBC_Require(ulSize > 0);
+	DBC_Require(pulSegId != NULL);
+	DBC_Require(dwGPPBasePA != 0);
+	DBC_Require(dwGPPBaseVA != 0);
+	DBC_Require((cFactor <= CMM_ADDTODSPPA) &&
+		   (cFactor >= CMM_SUBFROMDSPPA));
+	dev_dbg(bridge, "%s: dwGPPBasePA %x ulSize %x dwDSPAddrOffset %x "
+			"dwDSPBase %x ulDSPSize %x dwGPPBaseVA %x\n", __func__,
+			dwGPPBasePA, ulSize, dwDSPAddrOffset, dwDSPBase,
+			ulDSPSize, dwGPPBaseVA);
+	if (!MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+		status = DSP_EHANDLE;
+		return status;
+	}
+	/* make sure we have room for another allocator */
+	SYNC_EnterCS(pCmmMgr->hCmmLock);
+	nSlot = GetSlot(pCmmMgr);
+	if (nSlot < 0) {
+		/* get a slot number */
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	/* Check if input ulSize is big enough to alloc at least one block */
+	if (DSP_SUCCEEDED(status)) {
+		if (ulSize < pCmmMgr->ulMinBlockSize) {
+			status = DSP_EINVALIDARG;
+			goto func_end;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* create, zero, and tag an SM allocator object */
+		MEM_AllocObject(pSMA, struct CMM_ALLOCATOR, SMEMSIGNATURE);
+	}
+	if (pSMA != NULL) {
+		pSMA->hCmmMgr = hCmmMgr;	/* ref to parent */
+		pSMA->dwSmBase = dwGPPBasePA;	/* SM Base phys */
+		pSMA->ulSmSize = ulSize;	/* SM segment size in bytes */
+		pSMA->dwVmBase = dwGPPBaseVA;
+		pSMA->dwDSPPhysAddrOffset = dwDSPAddrOffset;
+		pSMA->cFactor = cFactor;
+		pSMA->dwDSPBase = dwDSPBase;
+		pSMA->ulDSPSize = ulDSPSize;
+		if (pSMA->dwVmBase == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* return the actual segment identifier */
+			*pulSegId = (u32) nSlot + 1;
+			/* create memory free list */
+			pSMA->pFreeListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
+			if (pSMA->pFreeListHead == NULL) {
+				status = DSP_EMEMORY;
+				goto func_end;
+			}
+			INIT_LIST_HEAD(&pSMA->pFreeListHead->head);
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* create memory in-use list */
+			pSMA->pInUseListHead = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
+			if (pSMA->pInUseListHead == NULL) {
+				status = DSP_EMEMORY;
+				goto func_end;
+			}
+			INIT_LIST_HEAD(&pSMA->pInUseListHead->head);
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* Get a mem node for this hunk-o-memory */
+			pNewNode = GetNode(pCmmMgr, dwGPPBasePA,
+					   pSMA->dwVmBase, ulSize);
+			/* Place node on the SM allocator's free list */
+			if (pNewNode) {
+				LST_PutTail(pSMA->pFreeListHead,
+					   (struct list_head *)pNewNode);
+			} else {
+				status = DSP_EMEMORY;
+				goto func_end;
+			}
+		}
+		if (DSP_FAILED(status)) {
+			/* Cleanup allocator */
+			UnRegisterGPPSMSeg(pSMA);
+		}
+	} else {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	 /* make entry */
+	if (DSP_SUCCEEDED(status))
+		pCmmMgr->paGPPSMSegTab[nSlot] = pSMA;
+
+func_end:
+	SYNC_LeaveCS(pCmmMgr->hCmmLock);
+	return status;
+}
+
+/*
+ *  ======== CMM_UnRegisterGPPSMSeg ========
+ *  Purpose:
+ *      UnRegister GPP SM segments with the CMM.
+ */
+DSP_STATUS CMM_UnRegisterGPPSMSeg(struct CMM_OBJECT *hCmmMgr, u32 ulSegId)
+{
+	struct CMM_OBJECT *pCmmMgr = (struct CMM_OBJECT *)hCmmMgr;
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_ALLOCATOR *pSMA;
+	u32 ulId = ulSegId;
+
+	DBC_Require(ulSegId > 0);
+	if (MEM_IsValidHandle(hCmmMgr, CMMSIGNATURE)) {
+		if (ulSegId == CMM_ALLSEGMENTS)
+			ulId = 1;
+
+		if ((ulId > 0) && (ulId <= CMM_MAXGPPSEGS)) {
+			while (ulId <= CMM_MAXGPPSEGS) {
+				SYNC_EnterCS(pCmmMgr->hCmmLock);
+				/* slot = segId-1 */
+				pSMA = pCmmMgr->paGPPSMSegTab[ulId - 1];
+				if (pSMA != NULL) {
+					UnRegisterGPPSMSeg(pSMA);
+					/* Set alctr ptr to NULL for future
+					 * reuse */
+					pCmmMgr->paGPPSMSegTab[ulId - 1] = NULL;
+				} else if (ulSegId != CMM_ALLSEGMENTS) {
+					status = DSP_EFAIL;
+				}
+				SYNC_LeaveCS(pCmmMgr->hCmmLock);
+				if (ulSegId != CMM_ALLSEGMENTS)
+					break;
+
+				ulId++;
+			}	/* end while */
+		} else {
+			status = DSP_EINVALIDARG;
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== UnRegisterGPPSMSeg ========
+ *  Purpose:
+ *      UnRegister the SM allocator by freeing all its resources and
+ *      nulling cmm mgr table entry.
+ *  Note:
+ *      This routine is always called within cmm lock crit sect.
+ */
+static void UnRegisterGPPSMSeg(struct CMM_ALLOCATOR *pSMA)
+{
+	struct CMM_MNODE *pCurNode = NULL;
+	struct CMM_MNODE *pNextNode = NULL;
+
+	DBC_Require(pSMA != NULL);
+	if (pSMA->pFreeListHead != NULL) {
+		/* free nodes on free list */
+		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pFreeListHead);
+		while (pCurNode) {
+			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
+				     pFreeListHead,
+				    (struct list_head *)pCurNode);
+			LST_RemoveElem(pSMA->pFreeListHead,
+				      (struct list_head *)pCurNode);
+			kfree((void *) pCurNode);
+			/* next node. */
+			pCurNode = pNextNode;
+		}
+		kfree(pSMA->pFreeListHead);		/* delete freelist */
+		/* free nodes on InUse list */
+		pCurNode = (struct CMM_MNODE *)LST_First(pSMA->pInUseListHead);
+		while (pCurNode) {
+			pNextNode = (struct CMM_MNODE *)LST_Next(pSMA->
+				    pInUseListHead,
+				    (struct list_head *)pCurNode);
+			LST_RemoveElem(pSMA->pInUseListHead,
+				      (struct list_head *)pCurNode);
+			kfree((void *) pCurNode);
+			/* next node. */
+			pCurNode = pNextNode;
+		}
+		kfree(pSMA->pInUseListHead);		/* delete InUse list */
+	}
+	if ((void *) pSMA->dwVmBase != NULL)
+		MEM_UnmapLinearAddress((void *) pSMA->dwVmBase);
+
+	/* Free allocator itself */
+	MEM_FreeObject(pSMA);
+}
+
+/*
+ *  ======== GetSlot ========
+ *  Purpose:
+ *      An available slot # is returned. Returns negative on failure.
+ */
+static s32 GetSlot(struct CMM_OBJECT *pCmmMgr)
+{
+	s32 nSlot = -1;		/* neg on failure */
+	DBC_Require(pCmmMgr != NULL);
+	/* get first available slot in cmm mgr SMSegTab[] */
+	for (nSlot = 0; nSlot < CMM_MAXGPPSEGS; nSlot++) {
+		if (pCmmMgr->paGPPSMSegTab[nSlot] == NULL)
+			break;
+
+	}
+	if (nSlot == CMM_MAXGPPSEGS)
+		nSlot = -1;	/* failed */
+
+	return nSlot;
+}
+
+/*
+ *  ======== GetNode ========
+ *  Purpose:
+ *      Get a memory node from freelist or create a new one.
+ */
+static struct CMM_MNODE *GetNode(struct CMM_OBJECT *pCmmMgr, u32 dwPA,
+				 u32 dwVA, u32 ulSize)
+{
+	struct CMM_MNODE *pNode = NULL;
+
+	DBC_Require(pCmmMgr != NULL);
+	DBC_Require(dwPA != 0);
+	DBC_Require(dwVA != 0);
+	DBC_Require(ulSize != 0);
+	/* Check cmm mgr's node freelist */
+	if (LST_IsEmpty(pCmmMgr->pNodeFreeListHead)) {
+		pNode = (struct CMM_MNODE *)MEM_Calloc(sizeof(struct CMM_MNODE),
+			MEM_PAGED);
+	} else {
+		/* surely a valid element */
+		pNode = (struct CMM_MNODE *)LST_GetHead(pCmmMgr->
+			pNodeFreeListHead);
+	}
+	if (pNode) {
+		LST_InitElem((struct list_head *) pNode);	/* set self */
+		pNode->dwPA = dwPA;	/* Physical addr of start of block */
+		pNode->dwVA = dwVA;	/* Virtual   "            "        */
+		pNode->ulSize = ulSize;	/* Size of block */
+	}
+	return pNode;
+}
+
+/*
+ *  ======== DeleteNode ========
+ *  Purpose:
+ *      Put a memory node on the cmm nodelist for later use.
+ *      Doesn't actually delete the node. Heap thrashing friendly.
+ */
+static void DeleteNode(struct CMM_OBJECT *pCmmMgr, struct CMM_MNODE *pNode)
+{
+	DBC_Require(pNode != NULL);
+	LST_InitElem((struct list_head *) pNode);	/* init .self ptr */
+	LST_PutTail(pCmmMgr->pNodeFreeListHead, (struct list_head *) pNode);
+}
+
+/*
+ * ====== GetFreeBlock ========
+ *  Purpose:
+ *      Scan the free block list and return the first block that satisfies
+ *      the size.
+ */
+static struct CMM_MNODE *GetFreeBlock(struct CMM_ALLOCATOR *pAllocator,
+				      u32 uSize)
+{
+	if (pAllocator) {
+		struct CMM_MNODE *pCurNode = (struct CMM_MNODE *)
+					LST_First(pAllocator->pFreeListHead);
+		while (pCurNode) {
+			if (uSize <= (u32) pCurNode->ulSize) {
+				LST_RemoveElem(pAllocator->pFreeListHead,
+					      (struct list_head *)pCurNode);
+				return pCurNode;
+			}
+			/* next node. */
+			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
+					pFreeListHead,
+					(struct list_head *)pCurNode);
+		}
+	}
+	return NULL;
+}
+
+/*
+ *  ======== AddToFreeList ========
+ *  Purpose:
+ *      Coelesce node into the freelist in ascending size order.
+ */
+static void AddToFreeList(struct CMM_ALLOCATOR *pAllocator,
+			  struct CMM_MNODE *pNode)
+{
+	struct CMM_MNODE *pNodePrev = NULL;
+	struct CMM_MNODE *pNodeNext = NULL;
+	struct CMM_MNODE *pCurNode;
+	u32 dwThisPA;
+	u32 dwNextPA;
+
+	DBC_Require(pNode != NULL);
+	DBC_Require(pAllocator != NULL);
+	dwThisPA = pNode->dwPA;
+	dwNextPA = NEXT_PA(pNode);
+	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
+	while (pCurNode) {
+		if (dwThisPA == NEXT_PA(pCurNode)) {
+			/* found the block ahead of this one */
+			pNodePrev = pCurNode;
+		} else if (dwNextPA == pCurNode->dwPA) {
+			pNodeNext = pCurNode;
+		}
+		if ((pNodePrev == NULL) || (pNodeNext == NULL)) {
+			/* next node. */
+			pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
+					pFreeListHead,
+					(struct list_head *)pCurNode);
+		} else {
+			/* got 'em */
+			break;
+		}
+	}			/* while */
+	if (pNodePrev != NULL) {
+		/* combine with previous block */
+		LST_RemoveElem(pAllocator->pFreeListHead,
+			      (struct list_head *)pNodePrev);
+		/* grow node to hold both */
+		pNode->ulSize += pNodePrev->ulSize;
+		pNode->dwPA = pNodePrev->dwPA;
+		pNode->dwVA = pNodePrev->dwVA;
+		/* place node on mgr nodeFreeList */
+		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodePrev);
+	}
+	if (pNodeNext != NULL) {
+		/* combine with next block */
+		LST_RemoveElem(pAllocator->pFreeListHead,
+			      (struct list_head *)pNodeNext);
+		/* grow da node */
+		pNode->ulSize += pNodeNext->ulSize;
+		/* place node on mgr nodeFreeList */
+		DeleteNode((struct CMM_OBJECT *)pAllocator->hCmmMgr, pNodeNext);
+	}
+	/* Now, let's add to freelist in increasing size order */
+	pCurNode = (struct CMM_MNODE *)LST_First(pAllocator->pFreeListHead);
+	while (pCurNode) {
+		if (pNode->ulSize <= pCurNode->ulSize)
+			break;
+
+		/* next node. */
+		pCurNode = (struct CMM_MNODE *)LST_Next(pAllocator->
+			   pFreeListHead, (struct list_head *)pCurNode);
+	}
+	/* if pCurNode is NULL then add our pNode to the end of the freelist */
+	if (pCurNode == NULL) {
+		LST_PutTail(pAllocator->pFreeListHead,
+			   (struct list_head *)pNode);
+	} else {
+		/* insert our node before the current traversed node */
+		LST_InsertBefore(pAllocator->pFreeListHead,
+				(struct list_head *)pNode,
+				(struct list_head *)pCurNode);
+	}
+}
+
+/*
+ * ======== GetAllocator ========
+ *  Purpose:
+ *      Return the allocator for the given SM Segid.
+ *      SegIds:  1,2,3..max.
+ */
+static struct CMM_ALLOCATOR *GetAllocator(struct CMM_OBJECT *pCmmMgr,
+					  u32 ulSegId)
+{
+	struct CMM_ALLOCATOR *pAllocator = NULL;
+
+	DBC_Require(pCmmMgr != NULL);
+	DBC_Require((ulSegId > 0) && (ulSegId <= CMM_MAXGPPSEGS));
+	pAllocator = pCmmMgr->paGPPSMSegTab[ulSegId - 1];
+	if (pAllocator != NULL) {
+		/* make sure it's for real */
+		if (!MEM_IsValidHandle(pAllocator, SMEMSIGNATURE)) {
+			pAllocator = NULL;
+			DBC_Assert(false);
+		}
+	}
+	return pAllocator;
+}
+
+/*
+ *  The CMM_Xlator[xxx] routines below are used by Node and Stream
+ *  to perform SM address translation to the client process address space.
+ *  A "translator" object is created by a node/stream for each SM seg used.
+ */
+
+/*
+ *  ======== CMM_XlatorCreate ========
+ *  Purpose:
+ *      Create an address translator object.
+ */
+DSP_STATUS CMM_XlatorCreate(OUT struct CMM_XLATOROBJECT **phXlator,
+				struct CMM_OBJECT *hCmmMgr,
+				struct CMM_XLATORATTRS *pXlatorAttrs)
+{
+	struct CMM_XLATOR *pXlatorObject = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phXlator != NULL);
+	DBC_Require(hCmmMgr != NULL);
+
+	*phXlator = NULL;
+	if (pXlatorAttrs == NULL)
+		pXlatorAttrs = &CMM_DFLTXLATORATTRS;	/* set defaults */
+
+	MEM_AllocObject(pXlatorObject, struct CMM_XLATOR, CMMXLATESIGNATURE);
+	if (pXlatorObject != NULL) {
+		pXlatorObject->hCmmMgr = hCmmMgr;	/* ref back to CMM */
+		pXlatorObject->ulSegId = pXlatorAttrs->ulSegId;	/* SM segId */
+	} else {
+		status = DSP_EMEMORY;
+	}
+	if (DSP_SUCCEEDED(status))
+		*phXlator = (struct CMM_XLATOROBJECT *) pXlatorObject;
+
+	return status;
+}
+
+/*
+ *  ======== CMM_XlatorDelete ========
+ *  Purpose:
+ *      Free the Xlator resources.
+ *      VM gets freed later.
+ */
+DSP_STATUS CMM_XlatorDelete(struct CMM_XLATOROBJECT *hXlator, bool bForce)
+{
+	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+		MEM_FreeObject(pXlator);
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== CMM_XlatorAllocBuf ========
+ */
+void *CMM_XlatorAllocBuf(struct CMM_XLATOROBJECT *hXlator, void *pVaBuf,
+			u32 uPaSize)
+{
+	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
+	void *pBuf = NULL;
+	struct CMM_ATTRS attrs;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hXlator != NULL);
+	DBC_Require(pXlator->hCmmMgr != NULL);
+	DBC_Require(pVaBuf != NULL);
+	DBC_Require(uPaSize > 0);
+	DBC_Require(pXlator->ulSegId > 0);
+
+	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+		attrs.ulSegId = pXlator->ulSegId;
+		*(volatile u32 *)pVaBuf = 0;
+		/* Alloc SM */
+		pBuf = CMM_CallocBuf(pXlator->hCmmMgr, uPaSize, &attrs,  NULL);
+		if (pBuf) {
+			/* convert to translator(node/strm) process Virtual
+			 * address */
+			*(volatile u32 **)pVaBuf =
+				 (u32 *)CMM_XlatorTranslate(hXlator,
+							      pBuf, CMM_PA2VA);
+		}
+	}
+	return pBuf;
+}
+
+/*
+ *  ======== CMM_XlatorFreeBuf ========
+ *  Purpose:
+ *      Free the given SM buffer and descriptor.
+ *      Does not free virtual memory.
+ */
+DSP_STATUS CMM_XlatorFreeBuf(struct CMM_XLATOROBJECT *hXlator, void *pBufVa)
+{
+	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
+	DSP_STATUS status = DSP_EFAIL;
+	void *pBufPa = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBufVa != NULL);
+	DBC_Require(pXlator->ulSegId > 0);
+
+	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+		/* convert Va to Pa so we can free it. */
+		pBufPa = CMM_XlatorTranslate(hXlator, pBufVa, CMM_VA2PA);
+		if (pBufPa) {
+			status = CMM_FreeBuf(pXlator->hCmmMgr, pBufPa,
+					     pXlator->ulSegId);
+			if (DSP_FAILED(status)) {
+				/* Uh oh, this shouldn't happen. Descriptor
+				 * gone! */
+				DBC_Assert(false);   /* CMM is leaking mem! */
+			}
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== CMM_XlatorInfo ========
+ *  Purpose:
+ *      Set/Get translator info.
+ */
+DSP_STATUS CMM_XlatorInfo(struct CMM_XLATOROBJECT *hXlator, IN OUT u8 **pAddr,
+			 u32 ulSize, u32 uSegId, bool bSetInfo)
+{
+	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pAddr != NULL);
+	DBC_Require((uSegId > 0) && (uSegId <= CMM_MAXGPPSEGS));
+
+	if (MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE)) {
+		if (bSetInfo) {
+			/* set translators virtual address range */
+			pXlator->dwVirtBase = (u32)*pAddr;
+			pXlator->ulVirtSize = ulSize;
+		} else {	/* return virt base address */
+			*pAddr = (u8 *)pXlator->dwVirtBase;
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== CMM_XlatorTranslate ========
+ */
+void *CMM_XlatorTranslate(struct CMM_XLATOROBJECT *hXlator, void *pAddr,
+			  enum CMM_XLATETYPE xType)
+{
+	u32 dwAddrXlate = 0;
+	struct CMM_XLATOR *pXlator = (struct CMM_XLATOR *)hXlator;
+	struct CMM_OBJECT *pCmmMgr = NULL;
+	struct CMM_ALLOCATOR *pAlctr = NULL;
+	u32 dwOffset = 0;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pAddr != NULL);
+	DBC_Require((xType >= CMM_VA2PA) && (xType <= CMM_DSPPA2PA));
+
+	if (!MEM_IsValidHandle(pXlator, CMMXLATESIGNATURE))
+		goto loop_cont;
+
+	pCmmMgr = (struct CMM_OBJECT *)pXlator->hCmmMgr;
+	/* get this translator's default SM allocator */
+	DBC_Assert(pXlator->ulSegId > 0);
+	pAlctr = pCmmMgr->paGPPSMSegTab[pXlator->ulSegId - 1];
+	if (!MEM_IsValidHandle(pAlctr, SMEMSIGNATURE))
+		goto loop_cont;
+
+	if ((xType == CMM_VA2DSPPA) || (xType == CMM_VA2PA) ||
+	    (xType == CMM_PA2VA)) {
+		if (xType == CMM_PA2VA) {
+			/* Gpp Va = Va Base + offset */
+			dwOffset = (u8 *)pAddr - (u8 *)(pAlctr->dwSmBase -
+				    pAlctr->ulDSPSize);
+			dwAddrXlate = pXlator->dwVirtBase + dwOffset;
+			/* Check if translated Va base is in range */
+			if ((dwAddrXlate < pXlator->dwVirtBase) ||
+			   (dwAddrXlate >=
+			   (pXlator->dwVirtBase + pXlator->ulVirtSize))) {
+				dwAddrXlate = 0;	/* bad address */
+			}
+		} else {
+			/* Gpp PA =  Gpp Base + offset */
+			dwOffset = (u8 *)pAddr - (u8 *)pXlator->dwVirtBase;
+			dwAddrXlate = pAlctr->dwSmBase - pAlctr->ulDSPSize +
+				      dwOffset;
+		}
+	} else {
+		dwAddrXlate = (u32)pAddr;
+	}
+	 /*Now convert address to proper target physical address if needed*/
+	if ((xType == CMM_VA2DSPPA) || (xType == CMM_PA2DSPPA)) {
+		/* Got Gpp Pa now, convert to DSP Pa */
+		dwAddrXlate = GPPPA2DSPPA((pAlctr->dwSmBase - pAlctr->
+					 ulDSPSize), dwAddrXlate,
+					 pAlctr->dwDSPPhysAddrOffset *
+					 pAlctr->cFactor);
+	} else if (xType == CMM_DSPPA2PA) {
+		/* Got DSP Pa, convert to GPP Pa */
+		dwAddrXlate = DSPPA2GPPPA(pAlctr->dwSmBase - pAlctr->ulDSPSize,
+					  dwAddrXlate,
+					  pAlctr->dwDSPPhysAddrOffset *
+					  pAlctr->cFactor);
+	}
+loop_cont:
+	return (void *)dwAddrXlate;
+}
diff --git a/drivers/dsp/bridge/pmgr/cod.c b/drivers/dsp/bridge/pmgr/cod.c
new file mode 100644
index 0000000..1b535fd
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/cod.c
@@ -0,0 +1,660 @@
+/*
+ * cod.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This module implements DSP code management for the DSP/BIOS Bridge
+ * environment. It is mostly a thin wrapper.
+ *
+ * This module provides an interface for loading both static and
+ * dynamic code objects onto DSP systems.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/ldr.h>
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- Platform Manager */
+/* Include appropriate loader header file */
+#include <dspbridge/dbll.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/cod.h>
+
+/* magic number for handle validation */
+#define MAGIC	 0xc001beef
+
+/* macro to validate COD manager handles */
+#define IsValid(h)    ((h) != NULL && (h)->ulMagic == MAGIC)
+
+/*
+ *  ======== COD_MANAGER ========
+ */
+struct COD_MANAGER {
+	struct DBLL_TarObj *target;
+	struct DBLL_LibraryObj *baseLib;
+	bool fLoaded;		/* Base library loaded? */
+	u32 ulEntry;
+	struct LDR_MODULE *hDll;
+	struct DBLL_Fxns fxns;
+	struct DBLL_Attrs attrs;
+	char szZLFile[COD_MAXPATHLENGTH];
+	u32 ulMagic;
+} ;
+
+/*
+ *  ======== COD_LIBRARYOBJ ========
+ */
+struct COD_LIBRARYOBJ {
+	struct DBLL_LibraryObj *dbllLib;
+	struct COD_MANAGER *hCodMgr;
+} ;
+
+static u32 cRefs = 0L;
+
+static struct DBLL_Fxns dbllFxns = {
+	(DBLL_CloseFxn) DBLL_close,
+	(DBLL_CreateFxn) DBLL_create,
+	(DBLL_DeleteFxn) DBLL_delete,
+	(DBLL_ExitFxn) DBLL_exit,
+	(DBLL_GetAttrsFxn) DBLL_getAttrs,
+	(DBLL_GetAddrFxn) DBLL_getAddr,
+	(DBLL_GetCAddrFxn) DBLL_getCAddr,
+	(DBLL_GetSectFxn) DBLL_getSect,
+	(DBLL_InitFxn) DBLL_init,
+	(DBLL_LoadFxn) DBLL_load,
+	(DBLL_LoadSectFxn) DBLL_loadSect,
+	(DBLL_OpenFxn) DBLL_open,
+	(DBLL_ReadSectFxn) DBLL_readSect,
+	(DBLL_SetAttrsFxn) DBLL_setAttrs,
+	(DBLL_UnloadFxn) DBLL_unload,
+	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+};
+
+static bool NoOp(void);
+
+/*
+ * File operations (originally were under kfile.c)
+ */
+static s32 COD_fClose(struct file *hFile)
+{
+	/* Check for valid handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	filp_close(hFile, NULL);
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static struct file *COD_fOpen(CONST char *pszFileName, CONST char *pszMode)
+{
+	mm_segment_t fs;
+	struct file *hFile;
+
+	fs = get_fs();
+	set_fs(get_ds());
+
+	/* ignore given mode and open file as read-only */
+	hFile = filp_open(pszFileName, O_RDONLY, 0);
+
+	if (IS_ERR(hFile))
+		hFile = NULL;
+
+	set_fs(fs);
+
+	return hFile;
+}
+
+static s32 COD_fRead(void __user *pBuffer, s32 cSize, s32 cCount,
+		     struct file *hFile)
+{
+	/* check for valid file handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	if ((cSize > 0) && (cCount > 0) && pBuffer) {
+		u32 dwBytesRead;
+		mm_segment_t fs;
+
+		/* read from file */
+		fs = get_fs();
+		set_fs(get_ds());
+		dwBytesRead = hFile->f_op->read(hFile, pBuffer, cSize * cCount,
+						&(hFile->f_pos));
+		set_fs(fs);
+
+		if (!dwBytesRead)
+			return DSP_EFREAD;
+
+		return dwBytesRead / cSize;
+	}
+
+	return DSP_EINVALIDARG;
+}
+
+static s32 COD_fSeek(struct file *hFile, s32 lOffset, s32 cOrigin)
+{
+	loff_t dwCurPos;
+
+	/* check for valid file handle */
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	/* based on the origin flag, move the internal pointer */
+	dwCurPos = hFile->f_op->llseek(hFile, lOffset, cOrigin);
+
+	if ((s32)dwCurPos < 0)
+		return DSP_EFAIL;
+
+	/* we can't use DSP_SOK here */
+	return 0;
+}
+
+static s32 COD_fTell(struct file *hFile)
+{
+	loff_t dwCurPos;
+
+	if (!hFile)
+		return DSP_EHANDLE;
+
+	/* Get current position */
+	dwCurPos = hFile->f_op->llseek(hFile, 0, SEEK_CUR);
+
+	if ((s32)dwCurPos < 0)
+		return DSP_EFAIL;
+
+	return dwCurPos;
+}
+
+/*
+ *  ======== COD_Close ========
+ */
+void COD_Close(struct COD_LIBRARYOBJ *lib)
+{
+	struct COD_MANAGER *hMgr;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(lib != NULL);
+	DBC_Require(IsValid(((struct COD_LIBRARYOBJ *)lib)->hCodMgr));
+
+	hMgr = lib->hCodMgr;
+	hMgr->fxns.closeFxn(lib->dbllLib);
+
+	kfree(lib);
+}
+
+/*
+ *  ======== COD_Create ========
+ *  Purpose:
+ *      Create an object to manage code on a DSP system.
+ *      This object can be used to load an initial program image with
+ *      arguments that can later be expanded with
+ *      dynamically loaded object files.
+ *
+ */
+DSP_STATUS COD_Create(OUT struct COD_MANAGER **phMgr, char *pstrDummyFile,
+		     IN OPTIONAL CONST struct COD_ATTRS *attrs)
+{
+	struct COD_MANAGER *hMgrNew;
+	struct DBLL_Attrs zlAttrs;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMgr != NULL);
+
+	/* assume failure */
+	*phMgr = NULL;
+
+	/* we don't support non-default attrs yet */
+	if (attrs != NULL)
+		return DSP_ENOTIMPL;
+
+	hMgrNew = MEM_Calloc(sizeof(struct COD_MANAGER), MEM_NONPAGED);
+	if (hMgrNew == NULL)
+		return DSP_EMEMORY;
+
+	hMgrNew->ulMagic = MAGIC;
+
+	/* Set up loader functions */
+	hMgrNew->fxns = dbllFxns;
+
+	/* initialize the ZL module */
+	hMgrNew->fxns.initFxn();
+
+	zlAttrs.alloc = (DBLL_AllocFxn)NoOp;
+	zlAttrs.free = (DBLL_FreeFxn)NoOp;
+	zlAttrs.fread = (DBLL_ReadFxn)COD_fRead;
+	zlAttrs.fseek = (DBLL_SeekFxn)COD_fSeek;
+	zlAttrs.ftell = (DBLL_TellFxn)COD_fTell;
+	zlAttrs.fclose = (DBLL_FCloseFxn)COD_fClose;
+	zlAttrs.fopen = (DBLL_FOpenFxn)COD_fOpen;
+	zlAttrs.symLookup = NULL;
+	zlAttrs.baseImage = true;
+	zlAttrs.logWrite = NULL;
+	zlAttrs.logWriteHandle = NULL;
+	zlAttrs.write = NULL;
+	zlAttrs.rmmHandle = NULL;
+	zlAttrs.wHandle = NULL;
+	zlAttrs.symHandle = NULL;
+	zlAttrs.symArg = NULL;
+
+	hMgrNew->attrs = zlAttrs;
+
+	status = hMgrNew->fxns.createFxn(&hMgrNew->target, &zlAttrs);
+
+	if (DSP_FAILED(status)) {
+		COD_Delete(hMgrNew);
+		return COD_E_ZLCREATEFAILED;
+	}
+
+	/* return the new manager */
+	*phMgr = hMgrNew;
+
+	return DSP_SOK;
+}
+
+/*
+ *  ======== COD_Delete ========
+ *  Purpose:
+ *      Delete a code manager object.
+ */
+void COD_Delete(struct COD_MANAGER *hMgr)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hMgr));
+
+	if (hMgr->baseLib) {
+		if (hMgr->fLoaded)
+			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
+
+		hMgr->fxns.closeFxn(hMgr->baseLib);
+	}
+	if (hMgr->target) {
+		hMgr->fxns.deleteFxn(hMgr->target);
+		hMgr->fxns.exitFxn();
+	}
+	hMgr->ulMagic = ~MAGIC;
+	kfree(hMgr);
+}
+
+/*
+ *  ======== COD_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the COD module.
+ *
+ */
+void COD_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== COD_GetBaseLib ========
+ *  Purpose:
+ *      Get handle to the base image DBL library.
+ */
+DSP_STATUS COD_GetBaseLib(struct COD_MANAGER *hManager,
+				struct DBLL_LibraryObj **plib)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hManager));
+	DBC_Require(plib != NULL);
+
+	*plib = (struct DBLL_LibraryObj *) hManager->baseLib;
+
+	return status;
+}
+
+/*
+ *  ======== COD_GetBaseName ========
+ */
+DSP_STATUS COD_GetBaseName(struct COD_MANAGER *hManager, char *pszName,
+				u32 uSize)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hManager));
+	DBC_Require(pszName != NULL);
+
+	if (uSize <= COD_MAXPATHLENGTH)
+		strncpy(pszName, hManager->szZLFile, uSize);
+	else
+		status = DSP_EFAIL;
+
+	return status;
+}
+
+/*
+ *  ======== COD_GetEntry ========
+ *  Purpose:
+ *      Retrieve the entry point of a loaded DSP program image
+ *
+ */
+DSP_STATUS COD_GetEntry(struct COD_MANAGER *hManager, u32 *pulEntry)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hManager));
+	DBC_Require(pulEntry != NULL);
+
+	*pulEntry = hManager->ulEntry;
+
+	return DSP_SOK;
+}
+
+/*
+ *  ======== COD_GetLoader ========
+ *  Purpose:
+ *      Get handle to the DBLL loader.
+ */
+DSP_STATUS COD_GetLoader(struct COD_MANAGER *hManager,
+				struct DBLL_TarObj **phLoader)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hManager));
+	DBC_Require(phLoader != NULL);
+
+	*phLoader = (struct DBLL_TarObj *)hManager->target;
+
+	return status;
+}
+
+/*
+ *  ======== COD_GetSection ========
+ *  Purpose:
+ *      Retrieve the starting address and length of a section in the COFF file
+ *      given the section name.
+ */
+DSP_STATUS COD_GetSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
+			  OUT u32 *puAddr, OUT u32 *puLen)
+{
+	struct COD_MANAGER *hManager;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(lib != NULL);
+	DBC_Require(IsValid(lib->hCodMgr));
+	DBC_Require(pstrSect != NULL);
+	DBC_Require(puAddr != NULL);
+	DBC_Require(puLen != NULL);
+
+	*puAddr = 0;
+	*puLen = 0;
+	if (lib != NULL) {
+		hManager = lib->hCodMgr;
+		status = hManager->fxns.getSectFxn(lib->dbllLib, pstrSect,
+						   puAddr, puLen);
+	} else {
+		status = COD_E_NOSYMBOLSLOADED;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((*puAddr == 0) && (*puLen == 0)));
+
+	return status;
+}
+
+/*
+ *  ======== COD_GetSymValue ========
+ *  Purpose:
+ *      Retrieve the value for the specified symbol. The symbol is first
+ *      searched for literally and then, if not found, searched for as a
+ *      C symbol.
+ *
+ */
+DSP_STATUS COD_GetSymValue(struct COD_MANAGER *hMgr, char *pstrSym,
+			   u32 *pulValue)
+{
+	struct DBLL_Symbol *pSym;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hMgr));
+	DBC_Require(pstrSym != NULL);
+	DBC_Require(pulValue != NULL);
+
+	dev_dbg(bridge, "%s: hMgr: %p pstrSym: %s pulValue: %p\n",
+					__func__, hMgr, pstrSym, pulValue);
+	if (hMgr->baseLib) {
+		if (!hMgr->fxns.getAddrFxn(hMgr->baseLib, pstrSym, &pSym)) {
+			if (!hMgr->fxns.getCAddrFxn(hMgr->baseLib, pstrSym,
+			    &pSym))
+				return COD_E_SYMBOLNOTFOUND;
+		}
+	} else {
+		return COD_E_NOSYMBOLSLOADED;
+	}
+
+	*pulValue = pSym->value;
+
+	return DSP_SOK;
+}
+
+/*
+ *  ======== COD_Init ========
+ *  Purpose:
+ *      Initialize the COD module's private state.
+ *
+ */
+bool COD_Init(void)
+{
+	bool fRetVal = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetVal)
+		cRefs++;
+
+	DBC_Ensure((fRetVal && cRefs > 0) || (!fRetVal && cRefs >= 0));
+	return fRetVal;
+}
+
+/*
+ *  ======== COD_LoadBase ========
+ *  Purpose:
+ *      Load the initial program image, optionally with command-line arguments,
+ *      on the DSP system managed by the supplied handle. The program to be
+ *      loaded must be the first element of the args array and must be a fully
+ *      qualified pathname.
+ *  Details:
+ *      if nArgc doesn't match the number of arguments in the aArgs array, the
+ *      aArgs array is searched for a NULL terminating entry, and argc is
+ *      recalculated to reflect this.  In this way, we can support NULL
+ *      terminating aArgs arrays, if nArgc is very large.
+ */
+DSP_STATUS COD_LoadBase(struct COD_MANAGER *hMgr, u32 nArgc, char *aArgs[],
+			COD_WRITEFXN pfnWrite, void *pArb, char *envp[])
+{
+	DBLL_Flags flags;
+	struct DBLL_Attrs saveAttrs;
+	struct DBLL_Attrs newAttrs;
+	DSP_STATUS status;
+	u32 i;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hMgr));
+	DBC_Require(nArgc > 0);
+	DBC_Require(aArgs != NULL);
+	DBC_Require(aArgs[0] != NULL);
+	DBC_Require(pfnWrite != NULL);
+	DBC_Require(hMgr->baseLib != NULL);
+
+	/*
+	 *  Make sure every argv[] stated in argc has a value, or change argc to
+	 *  reflect true number in NULL terminated argv array.
+	 */
+	for (i = 0; i < nArgc; i++) {
+		if (aArgs[i] == NULL) {
+			nArgc = i;
+			break;
+		}
+	}
+
+	/* set the write function for this operation */
+	hMgr->fxns.getAttrsFxn(hMgr->target, &saveAttrs);
+
+	newAttrs = saveAttrs;
+	newAttrs.write = (DBLL_WriteFxn)pfnWrite;
+	newAttrs.wHandle = pArb;
+	newAttrs.alloc = (DBLL_AllocFxn)NoOp;
+	newAttrs.free = (DBLL_FreeFxn)NoOp;
+	newAttrs.logWrite = NULL;
+	newAttrs.logWriteHandle = NULL;
+
+	/* Load the image */
+	flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
+	status = hMgr->fxns.loadFxn(hMgr->baseLib, flags, &newAttrs,
+		 &hMgr->ulEntry);
+	if (DSP_FAILED(status))
+		hMgr->fxns.closeFxn(hMgr->baseLib);
+
+	if (DSP_SUCCEEDED(status))
+		hMgr->fLoaded = true;
+	else
+		hMgr->baseLib = NULL;
+
+	return status;
+}
+
+/*
+ *  ======== COD_Open ========
+ *      Open library for reading sections.
+ */
+DSP_STATUS COD_Open(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
+		    COD_FLAGS flags, struct COD_LIBRARYOBJ **pLib)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct COD_LIBRARYOBJ *lib = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hMgr));
+	DBC_Require(pszCoffPath != NULL);
+	DBC_Require(flags == COD_NOLOAD || flags == COD_SYMB);
+	DBC_Require(pLib != NULL);
+
+	*pLib = NULL;
+
+	lib = MEM_Calloc(sizeof(struct COD_LIBRARYOBJ), MEM_NONPAGED);
+	if (lib == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		lib->hCodMgr = hMgr;
+		status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags,
+					   &lib->dbllLib);
+		if (DSP_SUCCEEDED(status))
+			*pLib = lib;
+	}
+
+	if (DSP_FAILED(status))
+		pr_err("%s: error status 0x%x, pszCoffPath: %s flags: 0x%x\n",
+					__func__, status, pszCoffPath, flags);
+	return status;
+}
+
+/*
+ *  ======== COD_OpenBase ========
+ *  Purpose:
+ *      Open base image for reading sections.
+ */
+DSP_STATUS COD_OpenBase(struct COD_MANAGER *hMgr, IN char *pszCoffPath,
+			DBLL_Flags flags)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DBLL_LibraryObj *lib;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValid(hMgr));
+	DBC_Require(pszCoffPath != NULL);
+
+	/* if we previously opened a base image, close it now */
+	if (hMgr->baseLib) {
+		if (hMgr->fLoaded) {
+			hMgr->fxns.unloadFxn(hMgr->baseLib, &hMgr->attrs);
+			hMgr->fLoaded = false;
+		}
+		hMgr->fxns.closeFxn(hMgr->baseLib);
+		hMgr->baseLib = NULL;
+	}
+	status = hMgr->fxns.openFxn(hMgr->target, pszCoffPath, flags, &lib);
+	if (DSP_SUCCEEDED(status)) {
+		/* hang onto the library for subsequent sym table usage */
+		hMgr->baseLib = lib;
+		strncpy(hMgr->szZLFile, pszCoffPath, COD_MAXPATHLENGTH - 1);
+		hMgr->szZLFile[COD_MAXPATHLENGTH - 1] = '\0';
+	}
+
+	if (DSP_FAILED(status))
+		pr_err("%s: error status 0x%x pszCoffPath: %s\n", __func__,
+							status, pszCoffPath);
+	return status;
+}
+
+/*
+ *  ======== COD_ReadSection ========
+ *  Purpose:
+ *      Retrieve the content of a code section given the section name.
+ */
+DSP_STATUS COD_ReadSection(struct COD_LIBRARYOBJ *lib, IN char *pstrSect,
+			   OUT char *pstrContent, IN u32 cContentSize)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(lib != NULL);
+	DBC_Require(IsValid(lib->hCodMgr));
+	DBC_Require(pstrSect != NULL);
+	DBC_Require(pstrContent != NULL);
+
+	if (lib != NULL)
+		status = lib->hCodMgr->fxns.readSectFxn(lib->dbllLib, pstrSect,
+							pstrContent,
+							cContentSize);
+	else
+		status = COD_E_NOSYMBOLSLOADED;
+
+	return status;
+}
+
+/*
+ *  ======== NoOp ========
+ *  Purpose:
+ *      No Operation.
+ *
+ */
+static bool NoOp(void)
+{
+	return true;
+}
+
diff --git a/drivers/dsp/bridge/pmgr/dbll.c b/drivers/dsp/bridge/pmgr/dbll.c
new file mode 100644
index 0000000..904e03d
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/dbll.c
@@ -0,0 +1,1481 @@
+/*
+ * dbll.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+#include <dspbridge/gh.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/* Dynamic loader library interface */
+#include <dspbridge/dynamic_loader.h>
+#include <dspbridge/getsection.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/dbll.h>
+#include <dspbridge/rmm.h>
+
+#define DBLL_TARGSIGNATURE      0x544c4c44	/* "TLLD" */
+#define DBLL_LIBSIGNATURE       0x4c4c4c44	/* "LLLD" */
+
+/* Number of buckets for symbol hash table */
+#define MAXBUCKETS 211
+
+/* Max buffer length */
+#define MAXEXPR 128
+
+#ifndef UINT32_C
+#define UINT32_C(zzz) ((uint32_t)zzz)
+#endif
+#define DOFF_ALIGN(x) (((x) + 3) & ~UINT32_C(3))
+
+/*
+ *  ======== struct DBLL_TarObj* ========
+ *  A target may have one or more libraries of symbols/code/data loaded
+ *  onto it, where a library is simply the symbols/code/data contained
+ *  in a DOFF file.
+ */
+/*
+ *  ======== DBLL_TarObj ========
+ */
+struct DBLL_TarObj {
+	u32 dwSignature; 	/* For object validation */
+	struct DBLL_Attrs attrs;
+	struct DBLL_LibraryObj *head; 	/* List of all opened libraries */
+} ;
+
+/*
+ *  The following 4 typedefs are "super classes" of the dynamic loader
+ *  library types used in dynamic loader functions (dynamic_loader.h).
+ */
+/*
+ *  ======== DBLLStream ========
+ *  Contains Dynamic_Loader_Stream
+ */
+struct DBLLStream {
+	struct Dynamic_Loader_Stream dlStream;
+	struct DBLL_LibraryObj *lib;
+} ;
+
+/*
+ *  ======== DBLLSymbol ========
+ */
+struct DBLLSymbol {
+	struct Dynamic_Loader_Sym dlSymbol;
+	struct DBLL_LibraryObj *lib;
+} ;
+
+/*
+ *  ======== DBLLAlloc ========
+ */
+ struct DBLLAlloc {
+	struct Dynamic_Loader_Allocate dlAlloc;
+	struct DBLL_LibraryObj *lib;
+} ;
+
+/*
+ *  ======== DBLLInit ========
+ */
+struct DBLLInit {
+	struct Dynamic_Loader_Initialize dlInit;
+	struct DBLL_LibraryObj *lib;
+};
+
+/*
+ *  ======== DBLL_Library ========
+ *  A library handle is returned by DBLL_Open() and is passed to DBLL_load()
+ *  to load symbols/code/data, and to DBLL_unload(), to remove the
+ *  symbols/code/data loaded by DBLL_load().
+ */
+
+/*
+ *  ======== DBLL_LibraryObj ========
+ */
+ struct DBLL_LibraryObj {
+	u32 dwSignature; 	/* For object validation */
+	struct DBLL_LibraryObj *next; 	/* Next library in target's list */
+	struct DBLL_LibraryObj *prev; 	/* Previous in the list */
+	struct DBLL_TarObj *pTarget; 	/* target for this library */
+
+	/* Objects needed by dynamic loader */
+	struct DBLLStream stream;
+	struct DBLLSymbol symbol;
+	struct DBLLAlloc allocate;
+	struct DBLLInit init;
+	DLOAD_mhandle mHandle;
+
+	char *fileName; 	/* COFF file name */
+	void *fp; 		/* Opaque file handle */
+	u32 entry; 		/* Entry point */
+	DLOAD_mhandle desc; 	/* desc of DOFF file loaded */
+	u32 openRef; 		/* Number of times opened */
+	u32 loadRef; 		/* Number of times loaded */
+	struct GH_THashTab *symTab; 	/* Hash table of symbols */
+	u32 ulPos;
+} ;
+
+/*
+ *  ======== Symbol ========
+ */
+struct Symbol {
+	struct DBLL_Symbol value;
+	char *name;
+} ;
+extern bool bSymbolsReloaded;
+
+static void dofClose(struct DBLL_LibraryObj *zlLib);
+static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib);
+static s32 NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
+		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsiz);
+
+/*
+ *  Functions called by dynamic loader
+ *
+ */
+/* Dynamic_Loader_Stream */
+static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
+		     unsigned bufsize);
+static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos);
+/* Dynamic_Loader_Sym */
+static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
+					const char *name);
+static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
+					      const char *name,
+					      unsigned moduleId);
+static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
+						const char *name,
+						unsigned moduleid);
+static void purgeSymbolTable(struct Dynamic_Loader_Sym *this,
+			    unsigned moduleId);
+static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize);
+static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr);
+static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
+			va_list args);
+/* Dynamic_Loader_Allocate */
+static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
+		   struct LDR_SECTION_INFO *info, unsigned align);
+static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
+		      struct LDR_SECTION_INFO *info);
+
+/* Dynamic_Loader_Initialize */
+static int connect(struct Dynamic_Loader_Initialize *this);
+static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
+		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
+		  unsigned nbytes);
+static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
+		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
+		   unsigned nbytes);
+static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
+		   struct LDR_SECTION_INFO *info, unsigned nbytes,
+		   unsigned val);
+static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start);
+static void release(struct Dynamic_Loader_Initialize *this);
+
+/* symbol table hash functions */
+static u16 nameHash(void *name, u16 maxBucket);
+static bool nameMatch(void *name, void *sp);
+static void symDelete(void *sp);
+
+static u32 cRefs; 		/* module reference count */
+
+/* Symbol Redefinition */
+static int bRedefinedSymbol;
+static int bGblSearch = 1;
+
+/*
+ *  ======== DBLL_close ========
+ */
+void DBLL_close(struct DBLL_LibraryObj *zlLib)
+{
+	struct DBLL_TarObj *zlTarget;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(zlLib->openRef > 0);
+	zlTarget = zlLib->pTarget;
+	zlLib->openRef--;
+	if (zlLib->openRef == 0) {
+		/* Remove library from list */
+		if (zlTarget->head == zlLib)
+			zlTarget->head = zlLib->next;
+
+		if (zlLib->prev)
+			(zlLib->prev)->next = zlLib->next;
+
+		if (zlLib->next)
+			(zlLib->next)->prev = zlLib->prev;
+
+		/* Free DOF resources */
+		dofClose(zlLib);
+		kfree(zlLib->fileName);
+
+		/* remove symbols from symbol table */
+		if (zlLib->symTab)
+			GH_delete(zlLib->symTab);
+
+		/* remove the library object itself */
+		MEM_FreeObject(zlLib);
+		zlLib = NULL;
+	}
+}
+
+/*
+ *  ======== DBLL_create ========
+ */
+DSP_STATUS DBLL_create(struct DBLL_TarObj **pTarget, struct DBLL_Attrs *pAttrs)
+{
+	struct DBLL_TarObj *pzlTarget;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pAttrs != NULL);
+	DBC_Require(pTarget != NULL);
+
+	/* Allocate DBL target object */
+	MEM_AllocObject(pzlTarget, struct DBLL_TarObj, DBLL_TARGSIGNATURE);
+	if (pTarget != NULL) {
+		if (pzlTarget == NULL) {
+			*pTarget = NULL;
+			status = DSP_EMEMORY;
+		} else {
+			pzlTarget->attrs = *pAttrs;
+			*pTarget = (struct DBLL_TarObj *)pzlTarget;
+		}
+		DBC_Ensure((DSP_SUCCEEDED(status) &&
+			  MEM_IsValidHandle(((struct DBLL_TarObj *)(*pTarget)),
+			  DBLL_TARGSIGNATURE)) || (DSP_FAILED(status) &&
+			  *pTarget == NULL));
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DBLL_delete ========
+ */
+void DBLL_delete(struct DBLL_TarObj *target)
+{
+	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+
+	if (zlTarget != NULL)
+		MEM_FreeObject(zlTarget);
+
+}
+
+/*
+ *  ======== DBLL_exit ========
+ *  Discontinue usage of DBL module.
+ */
+void DBLL_exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	if (cRefs == 0)
+		GH_exit();
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== DBLL_getAddr ========
+ *  Get address of name in the specified library.
+ */
+bool DBLL_getAddr(struct DBLL_LibraryObj *zlLib, char *name,
+		  struct DBLL_Symbol **ppSym)
+{
+	struct Symbol *sym;
+	bool status = false;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(name != NULL);
+	DBC_Require(ppSym != NULL);
+	DBC_Require(zlLib->symTab != NULL);
+
+	sym = (struct Symbol *)GH_find(zlLib->symTab, name);
+	if (sym != NULL) {
+		*ppSym = &sym->value;
+		status = true;
+	}
+
+	dev_dbg(bridge, "%s: lib: %p name: %s pAddr: %p, status 0x%x\n",
+					 __func__, zlLib, name, ppSym, status);
+	return status;
+}
+
+/*
+ *  ======== DBLL_getAttrs ========
+ *  Retrieve the attributes of the target.
+ */
+void DBLL_getAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+{
+	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+	DBC_Require(pAttrs != NULL);
+
+	if ((pAttrs != NULL) && (zlTarget != NULL))
+		*pAttrs = zlTarget->attrs;
+
+}
+
+/*
+ *  ======== DBLL_getCAddr ========
+ *  Get address of a "C" name in the specified library.
+ */
+bool DBLL_getCAddr(struct DBLL_LibraryObj *zlLib, char *name,
+		   struct DBLL_Symbol **ppSym)
+{
+	struct Symbol *sym;
+	char cname[MAXEXPR + 1];
+	bool status = false;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(ppSym != NULL);
+	DBC_Require(zlLib->symTab != NULL);
+	DBC_Require(name != NULL);
+
+	cname[0] = '_';
+
+       strncpy(cname + 1, name, sizeof(cname) - 2);
+	cname[MAXEXPR] = '\0'; 	/* insure '\0' string termination */
+
+	/* Check for C name, if not found */
+	sym = (struct Symbol *)GH_find(zlLib->symTab, cname);
+
+	if (sym != NULL) {
+		*ppSym = &sym->value;
+		status = true;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DBLL_getSect ========
+ *  Get the base address and size (in bytes) of a COFF section.
+ */
+DSP_STATUS DBLL_getSect(struct DBLL_LibraryObj *lib, char *name, u32 *pAddr,
+			u32 *pSize)
+{
+	u32 uByteSize;
+	bool fOpenedDoff = false;
+	const struct LDR_SECTION_INFO *sect = NULL;
+	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(name != NULL);
+	DBC_Require(pAddr != NULL);
+	DBC_Require(pSize != NULL);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+
+	/* If DOFF file is not open, we open it. */
+	if (zlLib != NULL) {
+		if (zlLib->fp == NULL) {
+			status = dofOpen(zlLib);
+			if (DSP_SUCCEEDED(status))
+				fOpenedDoff = true;
+
+		} else {
+			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
+			 zlLib->ulPos, SEEK_SET);
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		uByteSize = 1;
+		if (DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
+			*pAddr = sect->load_addr;
+			*pSize = sect->size * uByteSize;
+			/* Make sure size is even for good swap */
+			if (*pSize % 2)
+				(*pSize)++;
+
+			/* Align size */
+			*pSize = DOFF_ALIGN(*pSize);
+		} else {
+			status = DSP_ENOSECT;
+		}
+	}
+	if (fOpenedDoff) {
+		dofClose(zlLib);
+		fOpenedDoff = false;
+	}
+
+	dev_dbg(bridge, "%s: lib: %p name: %s pAddr: %p pSize: %p, "
+		"status 0x%x\n", __func__, lib, name, pAddr, pSize, status);
+
+	return status;
+}
+
+/*
+ *  ======== DBLL_init ========
+ */
+bool DBLL_init(void)
+{
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0)
+		GH_init();
+
+	cRefs++;
+
+	return true;
+}
+
+/*
+ *  ======== DBLL_load ========
+ */
+DSP_STATUS DBLL_load(struct DBLL_LibraryObj *lib, DBLL_Flags flags,
+		     struct DBLL_Attrs *attrs, u32 *pEntry)
+{
+	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	struct DBLL_TarObj *dbzl;
+	bool gotSymbols = true;
+	s32 err;
+	DSP_STATUS status = DSP_SOK;
+	bool fOpenedDoff = false;
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(pEntry != NULL);
+	DBC_Require(attrs != NULL);
+
+	/*
+	 *  Load if not already loaded.
+	 */
+	if (zlLib->loadRef == 0 || !(flags & DBLL_DYNAMIC)) {
+		dbzl = zlLib->pTarget;
+		dbzl->attrs = *attrs;
+		/* Create a hash table for symbols if not already created */
+		if (zlLib->symTab == NULL) {
+			gotSymbols = false;
+			zlLib->symTab = GH_create(MAXBUCKETS,
+						 sizeof(struct Symbol),
+						 nameHash,
+						 nameMatch, symDelete);
+			if (zlLib->symTab == NULL)
+				status = DSP_EMEMORY;
+
+		}
+		/*
+		 *  Set up objects needed by the dynamic loader
+		 */
+		/* Stream */
+		zlLib->stream.dlStream.read_buffer = readBuffer;
+		zlLib->stream.dlStream.set_file_posn = setFilePosn;
+		zlLib->stream.lib = zlLib;
+		/* Symbol */
+		zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
+		if (gotSymbols) {
+			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
+							findInSymbolTable;
+		} else {
+			zlLib->symbol.dlSymbol.Add_To_Symbol_Table =
+							addToSymbolTable;
+		}
+		zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
+		zlLib->symbol.dlSymbol.Allocate = allocate;
+		zlLib->symbol.dlSymbol.Deallocate = deallocate;
+		zlLib->symbol.dlSymbol.Error_Report = errorReport;
+		zlLib->symbol.lib = zlLib;
+		/* Allocate */
+		zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
+		zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
+		zlLib->allocate.lib = zlLib;
+		/* Init */
+		zlLib->init.dlInit.connect = connect;
+		zlLib->init.dlInit.readmem = readMem;
+		zlLib->init.dlInit.writemem = writeMem;
+		zlLib->init.dlInit.fillmem = fillMem;
+		zlLib->init.dlInit.execute = execute;
+		zlLib->init.dlInit.release = release;
+		zlLib->init.lib = zlLib;
+		/* If COFF file is not open, we open it. */
+		if (zlLib->fp == NULL) {
+			status = dofOpen(zlLib);
+			if (DSP_SUCCEEDED(status))
+				fOpenedDoff = true;
+
+		}
+		if (DSP_SUCCEEDED(status)) {
+			zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell))
+					(zlLib->fp);
+			/* Reset file cursor */
+			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0,
+				 SEEK_SET);
+			bSymbolsReloaded = true;
+			/* The 5th argument, DLOAD_INITBSS, tells the DLL
+			 * module to zero-init all BSS sections.  In general,
+			 * this is not necessary and also increases load time.
+			 * We may want to make this configurable by the user */
+			err = Dynamic_Load_Module(&zlLib->stream.dlStream,
+			      &zlLib->symbol.dlSymbol, &zlLib->allocate.dlAlloc,
+			      &zlLib->init.dlInit, DLOAD_INITBSS,
+			      &zlLib->mHandle);
+
+			if (err != 0) {
+				status = DSP_EDYNLOAD;
+			} else if (bRedefinedSymbol) {
+				zlLib->loadRef++;
+				DBLL_unload(zlLib, (struct DBLL_Attrs *) attrs);
+				bRedefinedSymbol = false;
+				status = DSP_EDYNLOAD;
+			} else {
+				*pEntry = zlLib->entry;
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status))
+		zlLib->loadRef++;
+
+	/* Clean up DOFF resources */
+	if (fOpenedDoff)
+		dofClose(zlLib);
+
+	DBC_Ensure(DSP_FAILED(status) || zlLib->loadRef > 0);
+
+	dev_dbg(bridge, "%s: lib: %p flags: 0x%x pEntry: %p, status 0x%x\n",
+			__func__, lib, flags, pEntry, status);
+
+	return status;
+}
+
+/*
+ *  ======== DBLL_loadSect ========
+ *  Not supported for COFF.
+ */
+DSP_STATUS DBLL_loadSect(struct DBLL_LibraryObj *zlLib, char *sectName,
+			struct DBLL_Attrs *attrs)
+{
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+
+	return DSP_ENOTIMPL;
+}
+
+/*
+ *  ======== DBLL_open ========
+ */
+DSP_STATUS DBLL_open(struct DBLL_TarObj *target, char *file, DBLL_Flags flags,
+		    struct DBLL_LibraryObj **pLib)
+{
+	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	struct DBLL_LibraryObj *zlLib = NULL;
+	s32 err;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+	DBC_Require(zlTarget->attrs.fopen != NULL);
+	DBC_Require(file != NULL);
+	DBC_Require(pLib != NULL);
+
+	zlLib = zlTarget->head;
+	while (zlLib != NULL) {
+		if (strcmp(zlLib->fileName, file) == 0) {
+			/* Library is already opened */
+			zlLib->openRef++;
+			break;
+		}
+		zlLib = zlLib->next;
+	}
+	if (zlLib == NULL) {
+		/* Allocate DBL library object */
+		MEM_AllocObject(zlLib, struct DBLL_LibraryObj,
+				DBLL_LIBSIGNATURE);
+		if (zlLib == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			zlLib->ulPos = 0;
+			/* Increment ref count to allow close on failure
+			 * later on */
+			zlLib->openRef++;
+			zlLib->pTarget = zlTarget;
+			/* Keep a copy of the file name */
+			zlLib->fileName = MEM_Calloc(strlen(file) + 1,
+							MEM_PAGED);
+			if (zlLib->fileName == NULL) {
+				status = DSP_EMEMORY;
+			} else {
+				strncpy(zlLib->fileName, file,
+					strlen(file) + 1);
+			}
+			zlLib->symTab = NULL;
+		}
+	}
+	/*
+	 *  Set up objects needed by the dynamic loader
+	 */
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	/* Stream */
+	zlLib->stream.dlStream.read_buffer = readBuffer;
+	zlLib->stream.dlStream.set_file_posn = setFilePosn;
+	zlLib->stream.lib = zlLib;
+	/* Symbol */
+	zlLib->symbol.dlSymbol.Add_To_Symbol_Table = addToSymbolTable;
+	zlLib->symbol.dlSymbol.Find_Matching_Symbol = findSymbol;
+	zlLib->symbol.dlSymbol.Purge_Symbol_Table = purgeSymbolTable;
+	zlLib->symbol.dlSymbol.Allocate = allocate;
+	zlLib->symbol.dlSymbol.Deallocate = deallocate;
+	zlLib->symbol.dlSymbol.Error_Report = errorReport;
+	zlLib->symbol.lib = zlLib;
+	/* Allocate */
+	zlLib->allocate.dlAlloc.Allocate = rmmAlloc;
+	zlLib->allocate.dlAlloc.Deallocate = rmmDealloc;
+	zlLib->allocate.lib = zlLib;
+	/* Init */
+	zlLib->init.dlInit.connect = connect;
+	zlLib->init.dlInit.readmem = readMem;
+	zlLib->init.dlInit.writemem = writeMem;
+	zlLib->init.dlInit.fillmem = fillMem;
+	zlLib->init.dlInit.execute = execute;
+	zlLib->init.dlInit.release = release;
+	zlLib->init.lib = zlLib;
+	if (DSP_SUCCEEDED(status) && zlLib->fp == NULL)
+		status = dofOpen(zlLib);
+
+	zlLib->ulPos = (*(zlLib->pTarget->attrs.ftell)) (zlLib->fp);
+	(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long) 0, SEEK_SET);
+	/* Create a hash table for symbols if flag is set */
+	if (zlLib->symTab != NULL || !(flags & DBLL_SYMB))
+		goto func_cont;
+
+	zlLib->symTab = GH_create(MAXBUCKETS, sizeof(struct Symbol), nameHash,
+				 nameMatch, symDelete);
+	if (zlLib->symTab == NULL) {
+		status = DSP_EMEMORY;
+	} else {
+		/* Do a fake load to get symbols - set write function to NoOp */
+		zlLib->init.dlInit.writemem = NoOp;
+		err = Dynamic_Open_Module(&zlLib->stream.dlStream,
+					&zlLib->symbol.dlSymbol,
+					&zlLib->allocate.dlAlloc,
+					&zlLib->init.dlInit, 0,
+					&zlLib->mHandle);
+		if (err != 0) {
+			status = DSP_EDYNLOAD;
+		} else {
+			/* Now that we have the symbol table, we can unload */
+			err = Dynamic_Unload_Module(zlLib->mHandle,
+						   &zlLib->symbol.dlSymbol,
+						   &zlLib->allocate.dlAlloc,
+						   &zlLib->init.dlInit);
+			if (err != 0)
+				status = DSP_EDYNLOAD;
+
+			zlLib->mHandle = NULL;
+		}
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status)) {
+		if (zlLib->openRef == 1) {
+			/* First time opened - insert in list */
+			if (zlTarget->head)
+				(zlTarget->head)->prev = zlLib;
+
+			zlLib->prev = NULL;
+			zlLib->next = zlTarget->head;
+			zlTarget->head = zlLib;
+		}
+		*pLib = (struct DBLL_LibraryObj *)zlLib;
+	} else {
+		*pLib = NULL;
+		if (zlLib != NULL)
+			DBLL_close((struct DBLL_LibraryObj *)zlLib);
+
+	}
+	DBC_Ensure((DSP_SUCCEEDED(status) && (zlLib->openRef > 0) &&
+		  MEM_IsValidHandle(((struct DBLL_LibraryObj *)(*pLib)),
+		  DBLL_LIBSIGNATURE)) || (DSP_FAILED(status) && *pLib == NULL));
+
+	dev_dbg(bridge, "%s: target: %p file: %s pLib: %p, status 0x%x\n",
+					 __func__, target, file, pLib, status);
+
+	return status;
+}
+
+/*
+ *  ======== DBLL_readSect ========
+ *  Get the content of a COFF section.
+ */
+DSP_STATUS DBLL_readSect(struct DBLL_LibraryObj *lib, char *name,
+			 char *pContent, u32 size)
+{
+	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	bool fOpenedDoff = false;
+	u32 uByteSize; 		/* size of bytes */
+	u32 ulSectSize; 		/* size of section */
+	const struct LDR_SECTION_INFO *sect = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(name != NULL);
+	DBC_Require(pContent != NULL);
+	DBC_Require(size != 0);
+
+	/* If DOFF file is not open, we open it. */
+	if (zlLib != NULL) {
+		if (zlLib->fp == NULL) {
+			status = dofOpen(zlLib);
+			if (DSP_SUCCEEDED(status))
+				fOpenedDoff = true;
+
+		} else {
+			(*(zlLib->pTarget->attrs.fseek))(zlLib->fp,
+				zlLib->ulPos, SEEK_SET);
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	uByteSize = 1;
+	if (!DLOAD_GetSectionInfo(zlLib->desc, name, &sect)) {
+		status = DSP_ENOSECT;
+		goto func_cont;
+	}
+	/*
+	 * Ensure the supplied buffer size is sufficient to store
+	 * the section content to be read.
+	 */
+	ulSectSize = sect->size * uByteSize;
+	/* Make sure size is even for good swap */
+	if (ulSectSize % 2)
+		ulSectSize++;
+
+	/* Align size */
+	ulSectSize = DOFF_ALIGN(ulSectSize);
+	if (ulSectSize > size) {
+		status = DSP_EFAIL;
+	} else {
+		if (!DLOAD_GetSection(zlLib->desc, sect, pContent))
+			status = DSP_EFREAD;
+
+	}
+func_cont:
+	if (fOpenedDoff) {
+		dofClose(zlLib);
+		fOpenedDoff = false;
+	}
+
+	dev_dbg(bridge, "%s: lib: %p name: %s pContent: %p size: 0x%x, "
+		"status 0x%x\n", __func__, lib, name, pContent, size, status);
+	return status;
+}
+
+/*
+ *  ======== DBLL_setAttrs ========
+ *  Set the attributes of the target.
+ */
+void DBLL_setAttrs(struct DBLL_TarObj *target, struct DBLL_Attrs *pAttrs)
+{
+	struct DBLL_TarObj *zlTarget = (struct DBLL_TarObj *)target;
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlTarget, DBLL_TARGSIGNATURE));
+	DBC_Require(pAttrs != NULL);
+
+	if ((pAttrs != NULL) && (zlTarget != NULL))
+		zlTarget->attrs = *pAttrs;
+
+}
+
+/*
+ *  ======== DBLL_unload ========
+ */
+void DBLL_unload(struct DBLL_LibraryObj *lib, struct DBLL_Attrs *attrs)
+{
+	struct DBLL_LibraryObj *zlLib = (struct DBLL_LibraryObj *)lib;
+	s32 err = 0;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(zlLib, DBLL_LIBSIGNATURE));
+	DBC_Require(zlLib->loadRef > 0);
+	dev_dbg(bridge, "%s: lib: %p\n", __func__, lib);
+	zlLib->loadRef--;
+	/* Unload only if reference count is 0 */
+	if (zlLib->loadRef != 0)
+		goto func_end;
+
+	zlLib->pTarget->attrs = *attrs;
+	if (zlLib->mHandle) {
+		err = Dynamic_Unload_Module(zlLib->mHandle,
+			&zlLib->symbol.dlSymbol,
+			&zlLib->allocate.dlAlloc, &zlLib->init.dlInit);
+		if (err != 0) {
+			dev_dbg(bridge, "%s: failed: 0x%x\n", __func__, err);
+		}
+	}
+	/* remove symbols from symbol table */
+	if (zlLib->symTab != NULL) {
+		GH_delete(zlLib->symTab);
+		zlLib->symTab = NULL;
+	}
+	/* delete DOFF desc since it holds *lots* of host OS
+	 * resources */
+	dofClose(zlLib);
+func_end:
+	DBC_Ensure(zlLib->loadRef >= 0);
+}
+
+/*
+ *  ======== DBLL_unloadSect ========
+ *  Not supported for COFF.
+ */
+DSP_STATUS DBLL_unloadSect(struct DBLL_LibraryObj *lib, char *sectName,
+			  struct DBLL_Attrs *attrs)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(sectName != NULL);
+
+	return DSP_ENOTIMPL;
+}
+
+/*
+ *  ======== dofClose ========
+ */
+static void dofClose(struct DBLL_LibraryObj *zlLib)
+{
+	if (zlLib->desc) {
+		DLOAD_module_close(zlLib->desc);
+		zlLib->desc = NULL;
+	}
+	/* close file */
+	if (zlLib->fp) {
+		(zlLib->pTarget->attrs.fclose) (zlLib->fp);
+		zlLib->fp = NULL;
+	}
+}
+
+/*
+ *  ======== dofOpen ========
+ */
+static DSP_STATUS dofOpen(struct DBLL_LibraryObj *zlLib)
+{
+	void *open = *(zlLib->pTarget->attrs.fopen);
+	DSP_STATUS status = DSP_SOK;
+
+	/* First open the file for the dynamic loader, then open COF */
+	zlLib->fp = (void *)((DBLL_FOpenFxn)(open))(zlLib->fileName, "rb");
+
+	/* Open DOFF module */
+	if (zlLib->fp && zlLib->desc == NULL) {
+		(*(zlLib->pTarget->attrs.fseek))(zlLib->fp, (long)0, SEEK_SET);
+		zlLib->desc = DLOAD_module_open(&zlLib->stream.dlStream,
+						&zlLib->symbol.dlSymbol);
+		if (zlLib->desc == NULL) {
+			(zlLib->pTarget->attrs.fclose)(zlLib->fp);
+			zlLib->fp = NULL;
+			status = DSP_EFOPEN;
+		}
+	} else {
+		status = DSP_EFOPEN;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== nameHash ========
+ */
+static u16 nameHash(void *key, u16 maxBucket)
+{
+	u16 ret;
+	u16 hash;
+	char *name = (char *)key;
+
+	DBC_Require(name != NULL);
+
+	hash = 0;
+
+	while (*name) {
+		hash <<= 1;
+		hash ^= *name++;
+	}
+
+	ret = hash % maxBucket;
+
+	return ret;
+}
+
+/*
+ *  ======== nameMatch ========
+ */
+static bool nameMatch(void *key, void *value)
+{
+	DBC_Require(key != NULL);
+	DBC_Require(value != NULL);
+
+	if ((key != NULL) && (value != NULL)) {
+		if (strcmp((char *)key, ((struct Symbol *)value)->name) == 0)
+			return true;
+	}
+	return false;
+}
+
+/*
+ *  ======== NoOp ========
+ */
+static int NoOp(struct Dynamic_Loader_Initialize *thisptr, void *bufr,
+		LDR_ADDR locn, struct LDR_SECTION_INFO *info, unsigned bytsize)
+{
+	return 1;
+}
+
+/*
+ *  ======== symDelete ========
+ */
+static void symDelete(void *value)
+{
+	struct Symbol *sp = (struct Symbol *)value;
+
+	kfree(sp->name);
+}
+
+/*
+ *  Dynamic Loader Functions
+ */
+
+/* Dynamic_Loader_Stream */
+/*
+ *  ======== readBuffer ========
+ */
+static int readBuffer(struct Dynamic_Loader_Stream *this, void *buffer,
+		     unsigned bufsize)
+{
+	struct DBLLStream *pStream = (struct DBLLStream *)this;
+	struct DBLL_LibraryObj *lib;
+	int bytesRead = 0;
+
+	DBC_Require(this != NULL);
+	lib = pStream->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	if (lib != NULL) {
+		bytesRead = (*(lib->pTarget->attrs.fread))(buffer, 1, bufsize,
+			    lib->fp);
+	}
+	return bytesRead;
+}
+
+/*
+ *  ======== setFilePosn ========
+ */
+static int setFilePosn(struct Dynamic_Loader_Stream *this, unsigned int pos)
+{
+	struct DBLLStream *pStream = (struct DBLLStream *)this;
+	struct DBLL_LibraryObj *lib;
+	int status = 0; 		/* Success */
+
+	DBC_Require(this != NULL);
+	lib = pStream->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	if (lib != NULL) {
+		status = (*(lib->pTarget->attrs.fseek))(lib->fp, (long)pos,
+			 SEEK_SET);
+	}
+
+	return status;
+}
+
+/* Dynamic_Loader_Sym */
+
+/*
+ *  ======== findSymbol ========
+ */
+static struct dynload_symbol *findSymbol(struct Dynamic_Loader_Sym *this,
+					const char *name)
+{
+	struct dynload_symbol *retSym;
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+	struct DBLL_Symbol *pSym = NULL;
+	bool status = false; 	/* Symbol not found yet */
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	if (lib != NULL) {
+		if (lib->pTarget->attrs.symLookup) {
+			/* Check current lib + base lib + dep lib +
+			 * persistent lib */
+			status = (*(lib->pTarget->attrs.symLookup))
+				 (lib->pTarget->attrs.symHandle,
+				 lib->pTarget->attrs.symArg,
+				 lib->pTarget->attrs.rmmHandle, name, &pSym);
+		} else {
+			/* Just check current lib for symbol */
+			status = DBLL_getAddr((struct DBLL_LibraryObj *)lib,
+				 (char *)name, &pSym);
+			if (!status) {
+				status =
+				   DBLL_getCAddr((struct DBLL_LibraryObj *)lib,
+				   (char *)name, &pSym);
+			}
+		}
+	}
+
+	if (!status && bGblSearch) {
+		dev_dbg(bridge, "%s: Symbol not found: %s\n", __func__, name);
+	}
+
+	DBC_Assert((status && (pSym != NULL)) || (!status && (pSym == NULL)));
+
+	retSym = (struct dynload_symbol *)pSym;
+	return retSym;
+}
+
+/*
+ *  ======== findInSymbolTable ========
+ */
+static struct dynload_symbol *findInSymbolTable(struct Dynamic_Loader_Sym *this,
+						const char *name,
+						unsigned moduleid)
+{
+	struct dynload_symbol *retSym;
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+	struct Symbol *sym;
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	DBC_Require(lib->symTab != NULL);
+
+	sym = (struct Symbol *)GH_find(lib->symTab, (char *) name);
+
+	retSym = (struct dynload_symbol *)&sym->value;
+	return retSym;
+}
+
+/*
+ *  ======== addToSymbolTable ========
+ */
+static struct dynload_symbol *addToSymbolTable(struct Dynamic_Loader_Sym *this,
+					      const char *name,
+					      unsigned moduleId)
+{
+	struct Symbol *symPtr = NULL;
+	struct Symbol symbol;
+	struct dynload_symbol *pSym = NULL;
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+	struct dynload_symbol *retVal;
+
+	DBC_Require(this != NULL);
+	DBC_Require(name);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	/* Check to see if symbol is already defined in symbol table */
+	if (!(lib->pTarget->attrs.baseImage)) {
+		bGblSearch = false;
+		pSym = findSymbol(this, name);
+		bGblSearch = true;
+		if (pSym) {
+			bRedefinedSymbol = true;
+			dev_dbg(bridge, "%s already defined in symbol table\n",
+									name);
+			return NULL;
+		}
+	}
+	/* Allocate string to copy symbol name */
+	symbol.name = (char *)MEM_Calloc(strlen((char *const)name) + 1,
+							MEM_PAGED);
+	if (symbol.name == NULL)
+		return NULL;
+
+	if (symbol.name != NULL) {
+		/* Just copy name (value will be filled in by dynamic loader) */
+		strncpy(symbol.name, (char *const)name,
+			strlen((char *const)name) + 1);
+
+		/* Add symbol to symbol table */
+		symPtr = (struct Symbol *)GH_insert(lib->symTab, (void *)name,
+			 (void *)&symbol);
+		if (symPtr == NULL)
+			kfree(symbol.name);
+
+	}
+	if (symPtr != NULL)
+		retVal = (struct dynload_symbol *)&symPtr->value;
+	else
+		retVal = NULL;
+
+	return retVal;
+}
+
+/*
+ *  ======== purgeSymbolTable ========
+ */
+static void purgeSymbolTable(struct Dynamic_Loader_Sym *this, unsigned moduleId)
+{
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	/* May not need to do anything */
+}
+
+/*
+ *  ======== allocate ========
+ */
+static void *allocate(struct Dynamic_Loader_Sym *this, unsigned memsize)
+{
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+	void *buf;
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	buf = MEM_Calloc(memsize, MEM_PAGED);
+
+	return buf;
+}
+
+/*
+ *  ======== deallocate ========
+ */
+static void deallocate(struct Dynamic_Loader_Sym *this, void *memPtr)
+{
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	kfree(memPtr);
+}
+
+/*
+ *  ======== errorReport ========
+ */
+static void errorReport(struct Dynamic_Loader_Sym *this, const char *errstr,
+			va_list args)
+{
+	struct DBLLSymbol *pSymbol = (struct DBLLSymbol *)this;
+	struct DBLL_LibraryObj *lib;
+	char tempBuf[MAXEXPR];
+
+	DBC_Require(this != NULL);
+	lib = pSymbol->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	vsnprintf((char *)tempBuf, MAXEXPR, (char *)errstr, args);
+	dev_dbg(bridge, "%s\n", tempBuf);
+}
+
+/* Dynamic_Loader_Allocate */
+
+/*
+ *  ======== rmmAlloc ========
+ */
+static int rmmAlloc(struct Dynamic_Loader_Allocate *this,
+		   struct LDR_SECTION_INFO *info, unsigned align)
+{
+	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
+	struct DBLL_LibraryObj *lib;
+	DSP_STATUS status = DSP_SOK;
+	u32 memType;
+	struct RMM_Addr rmmAddr;
+	s32 retVal = TRUE;
+	unsigned stype = DLOAD_SECTION_TYPE(info->type);
+	char *pToken = NULL;
+	char *szSecLastToken = NULL;
+	char *szLastToken = NULL;
+	char *szSectName = NULL;
+	char *pszCur;
+	s32 tokenLen = 0;
+	s32 segId = -1;
+	s32 req = -1;
+	s32 count = 0;
+	u32 allocSize = 0;
+	u32 runAddrFlag = 0;
+
+	DBC_Require(this != NULL);
+	lib = pAlloc->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+
+	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
+		   DBLL_BSS : DBLL_DATA;
+
+	/* Attempt to extract the segment ID and requirement information from
+	 the name of the section */
+	DBC_Require(info->name);
+	tokenLen = strlen((char *)(info->name)) + 1;
+
+	szSectName = MEM_Calloc(tokenLen, MEM_PAGED);
+	szLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
+	szSecLastToken = MEM_Calloc(tokenLen, MEM_PAGED);
+
+	if (szSectName == NULL || szSecLastToken == NULL ||
+	   szLastToken == NULL) {
+		status = DSP_EMEMORY;
+		goto func_cont;
+	}
+	strncpy(szSectName, (char *)(info->name), tokenLen);
+	pszCur = szSectName;
+	while ((pToken = strsep(&pszCur, ":")) && *pToken != '\0') {
+		strncpy(szSecLastToken, szLastToken, strlen(szLastToken) + 1);
+		strncpy(szLastToken, pToken, strlen(pToken) + 1);
+		pToken = strsep(&pszCur, ":");
+		count++; 	/* optimizes processing*/
+	}
+	/* If pToken is 0 or 1, and szSecLastToken is DYN_DARAM or DYN_SARAM,
+	 or DYN_EXTERNAL, then mem granularity information is present
+	 within the section name - only process if there are at least three
+	 tokens within the section name (just a minor optimization)*/
+	if (count >= 3)
+		strict_strtol(szLastToken, 10, (long *)&req);
+
+	if ((req == 0) || (req == 1)) {
+		if (strcmp(szSecLastToken, "DYN_DARAM") == 0) {
+			segId = 0;
+		} else {
+			if (strcmp(szSecLastToken, "DYN_SARAM") == 0) {
+				segId = 1;
+			} else {
+				if (strcmp(szSecLastToken,
+				   "DYN_EXTERNAL") == 0)
+					segId = 2;
+			}
+		}
+	}
+func_cont:
+	kfree(szSectName);
+	szSectName = NULL;
+	kfree(szLastToken);
+	szLastToken = NULL;
+	kfree(szSecLastToken);
+	szSecLastToken = NULL;
+
+	if (memType == DBLL_CODE)
+		allocSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	else
+		allocSize = info->size;
+
+	if (info->load_addr != info->run_addr)
+		runAddrFlag = 1;
+	/* TODO - ideally, we can pass the alignment requirement also
+	 * from here */
+	if (lib != NULL) {
+		status = (lib->pTarget->attrs.alloc)(lib->pTarget->
+			 attrs.rmmHandle, memType, allocSize, align,
+			 (u32 *)&rmmAddr, segId, req, FALSE);
+	}
+	if (DSP_FAILED(status)) {
+		retVal = false;
+	} else {
+		/* RMM gives word address. Need to convert to byte address */
+		info->load_addr = rmmAddr.addr * DSPWORDSIZE;
+		if (!runAddrFlag)
+			info->run_addr = info->load_addr;
+		info->context = (u32)rmmAddr.segid;
+		dev_dbg(bridge, "%s: %s base = 0x%x len = 0x%x, "
+			"info->run_addr 0x%x, info->load_addr 0x%x\n",
+			__func__, info->name, info->load_addr / DSPWORDSIZE,
+			info->size / DSPWORDSIZE, info->run_addr,
+			info->load_addr);
+	}
+	return retVal;
+}
+
+/*
+ *  ======== rmmDealloc ========
+ */
+static void rmmDealloc(struct Dynamic_Loader_Allocate *this,
+			struct LDR_SECTION_INFO *info)
+{
+	struct DBLLAlloc *pAlloc = (struct DBLLAlloc *)this;
+	struct DBLL_LibraryObj *lib;
+	u32 segid;
+	DSP_STATUS status = DSP_SOK;
+	unsigned stype = DLOAD_SECTION_TYPE(info->type);
+	u32 memType;
+	u32 freeSize = 0;
+
+	memType = (stype == DLOAD_TEXT) ? DBLL_CODE : (stype == DLOAD_BSS) ?
+		  DBLL_BSS : DBLL_DATA;
+	DBC_Require(this != NULL);
+	lib = pAlloc->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	/* segid was set by alloc function */
+	segid = (u32)info->context;
+	if (memType == DBLL_CODE)
+		freeSize = info->size + GEM_L1P_PREFETCH_SIZE;
+	else
+		freeSize = info->size;
+	if (lib != NULL) {
+		status = (lib->pTarget->attrs.free)(lib->pTarget->
+			 attrs.symHandle, segid, info->load_addr / DSPWORDSIZE,
+			 freeSize, false);
+	}
+}
+
+/* Dynamic_Loader_Initialize */
+/*
+ *  ======== connect ========
+ */
+static int connect(struct Dynamic_Loader_Initialize *this)
+{
+	return true;
+}
+
+/*
+ *  ======== readMem ========
+ *  This function does not need to be implemented.
+ */
+static int readMem(struct Dynamic_Loader_Initialize *this, void *buf,
+		  LDR_ADDR addr, struct LDR_SECTION_INFO *info,
+		  unsigned nbytes)
+{
+	struct DBLLInit *pInit = (struct DBLLInit *)this;
+	struct DBLL_LibraryObj *lib;
+	int bytesRead = 0;
+
+	DBC_Require(this != NULL);
+	lib = pInit->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	/* Need WMD_BRD_Read function */
+	return bytesRead;
+}
+
+/*
+ *  ======== writeMem ========
+ */
+static int writeMem(struct Dynamic_Loader_Initialize *this, void *buf,
+		   LDR_ADDR addr, struct LDR_SECTION_INFO *info,
+		   unsigned nBytes)
+{
+	struct DBLLInit *pInit = (struct DBLLInit *)this;
+	struct DBLL_LibraryObj *lib;
+	struct DBLL_TarObj *pTarget;
+	struct DBLL_SectInfo sectInfo;
+	u32 memType;
+	bool retVal = true;
+
+	DBC_Require(this != NULL);
+	lib = pInit->lib;
+	if (!MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE))
+		return false;
+
+	pTarget = lib->pTarget;
+
+	memType = (DLOAD_SECTION_TYPE(info->type) == DLOAD_TEXT) ? DBLL_CODE :
+		  DBLL_DATA;
+	if (pTarget && pTarget->attrs.write) {
+		retVal = (*pTarget->attrs.write)(pTarget->attrs.wHandle,
+						 addr, buf, nBytes, memType);
+
+		if (pTarget->attrs.logWrite) {
+			sectInfo.name = info->name;
+			sectInfo.runAddr = info->run_addr;
+			sectInfo.loadAddr = info->load_addr;
+			sectInfo.size = info->size;
+			sectInfo.type = memType;
+			/* Pass the information about what we've written to
+			 * another module */
+			(*pTarget->attrs.logWrite)(
+				pTarget->attrs.logWriteHandle,
+				&sectInfo, addr, nBytes);
+		}
+	}
+	return retVal;
+}
+
+/*
+ *  ======== fillMem ========
+ *  Fill nBytes of memory at a given address with a given value by
+ *  writing from a buffer containing the given value.  Write in
+ *  sets of MAXEXPR (128) bytes to avoid large stack buffer issues.
+ */
+static int fillMem(struct Dynamic_Loader_Initialize *this, LDR_ADDR addr,
+		   struct LDR_SECTION_INFO *info, unsigned nBytes,
+		   unsigned val)
+{
+	bool retVal = true;
+	char *pBuf;
+	struct DBLL_LibraryObj *lib;
+	struct DBLLInit *pInit = (struct DBLLInit *)this;
+
+	DBC_Require(this != NULL);
+	lib = pInit->lib;
+	pBuf = NULL;
+	/* Pass the NULL pointer to writeMem to get the start address of Shared
+	    memory. This is a trick to just get the start address, there is no
+	    writing taking place with this Writemem
+	*/
+	if ((lib->pTarget->attrs.write) != (DBLL_WriteFxn)NoOp)
+		writeMem(this, &pBuf, addr, info, 0);
+	if (pBuf)
+		memset(pBuf, val, nBytes);
+
+	return retVal;
+}
+
+/*
+ *  ======== execute ========
+ */
+static int execute(struct Dynamic_Loader_Initialize *this, LDR_ADDR start)
+{
+	struct DBLLInit *pInit = (struct DBLLInit *)this;
+	struct DBLL_LibraryObj *lib;
+	bool retVal = true;
+
+	DBC_Require(this != NULL);
+	lib = pInit->lib;
+	DBC_Require(MEM_IsValidHandle(lib, DBLL_LIBSIGNATURE));
+	/* Save entry point */
+	if (lib != NULL)
+		lib->entry = (u32)start;
+
+	return retVal;
+}
+
+/*
+ *  ======== release ========
+ */
+static void release(struct Dynamic_Loader_Initialize *this)
+{
+}
+
diff --git a/drivers/dsp/bridge/pmgr/dev.c b/drivers/dsp/bridge/pmgr/dev.c
new file mode 100644
index 0000000..1e64001
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/dev.c
@@ -0,0 +1,1203 @@
+/*
+ * dev.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation of Bridge Mini-driver device operations.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/ldr.h>
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/cod.h>
+#include <dspbridge/drv.h>
+#include <dspbridge/proc.h>
+#include <dspbridge/dmm.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/mgr.h>
+#include <dspbridge/node.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/wcd.h>		/* WCD version info. */
+
+#include <dspbridge/chnl.h>
+#include <dspbridge/io.h>
+#include <dspbridge/msg.h>
+#include <dspbridge/cmm.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+
+#define SIGNATURE           0x5f564544	/* "DEV_" (in reverse) */
+#define MAKEVERSION(major, minor)   (major * 10 + minor)
+#define WCDVERSION          MAKEVERSION(WCD_MAJOR_VERSION, WCD_MINOR_VERSION)
+
+/* The WMD device object: */
+struct DEV_OBJECT {
+	/* LST requires "link" to be first field!                        */
+	struct list_head link;		/* Link to next DEV_OBJECT.      */
+	u32 devType;		/* Device Type */
+	u32 dwSignature;	/* Used for object validation.   */
+	struct CFG_DEVNODE *hDevNode;	/* Platform specific device id   */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle        */
+	struct WMD_DRV_INTERFACE intfFxns;	/* Function interface to WMD. */
+	struct BRD_OBJECT *lockOwner;	/* Client with exclusive access. */
+	struct COD_MANAGER *hCodMgr;	/* Code manager handle.          */
+	struct CHNL_MGR *hChnlMgr;	/* Channel manager.              */
+	struct DEH_MGR *hDehMgr;	/* DEH manager.                  */
+	struct MSG_MGR *hMsgMgr;	/* Message manager.              */
+	struct IO_MGR *hIOMgr;		/* IO manager (CHNL, MSG)        */
+	struct CMM_OBJECT *hCmmMgr;	/* SM memory manager.            */
+	struct DMM_OBJECT *hDmmMgr;	/* Dynamic memory manager.       */
+	struct LDR_MODULE *hModule;	/* WMD Module handle.            */
+	u32 uWordSize;	/* DSP word size: quick access.  */
+	struct DRV_OBJECT *hDrvObject;	/* Driver Object                 */
+	struct LST_LIST *procList;	/* List of Proceeosr attached to
+				 * this device  */
+	struct NODE_MGR *hNodeMgr;
+} ;
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;		/* Module reference count */
+
+/*  ----------------------------------- Function Prototypes */
+static DSP_STATUS FxnNotImplemented(int arg, ...);
+static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject);
+static bool IsValidHandle(struct DEV_OBJECT *hObj);
+static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
+			       OUT struct WMD_DRV_INTERFACE *pIntfFxns);
+/*
+ *  ======== DEV_BrdWriteFxn ========
+ *  Purpose:
+ *      Exported function to be used as the COD write function.  This function
+ *      is passed a handle to a DEV_hObject, then calls the
+ *      device's WMD_BRD_Write() function.
+ */
+u32 DEV_BrdWriteFxn(void *pArb, u32 ulDspAddr, void *pHostBuf,
+		      u32 ulNumBytes, u32 nMemSpace)
+{
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)pArb;
+	u32 ulWritten = 0;
+	DSP_STATUS status;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pHostBuf != NULL);	/* Required of BrdWrite(). */
+	if (IsValidHandle(pDevObject)) {
+		/* Require of BrdWrite() */
+		DBC_Assert(pDevObject->hWmdContext != NULL);
+		status = (*pDevObject->intfFxns.pfnBrdWrite)(pDevObject->
+			 hWmdContext, pHostBuf, ulDspAddr, ulNumBytes,
+			 nMemSpace);
+		 /* Special case of getting the address only */
+		if (ulNumBytes == 0)
+			ulNumBytes = 1;
+		if (DSP_SUCCEEDED(status))
+			ulWritten = ulNumBytes;
+
+	}
+	return ulWritten;
+}
+
+/*
+ *  ======== DEV_CreateDevice ========
+ *  Purpose:
+ *      Called by the operating system to load the PM Mini Driver for a
+ *      PM board (device).
+ */
+DSP_STATUS DEV_CreateDevice(OUT struct DEV_OBJECT **phDevObject,
+			    IN CONST char *pstrWMDFileName,
+			    IN CONST struct CFG_HOSTRES *pHostConfig,
+			    IN CONST struct CFG_DSPRES *pDspConfig,
+			    struct CFG_DEVNODE *hDevNode)
+{
+	struct LDR_MODULE *hModule = NULL;
+	struct WMD_DRV_INTERFACE *pDrvFxns = NULL;
+	struct DEV_OBJECT *pDevObject = NULL;
+	struct CHNL_MGRATTRS mgrAttrs;
+	struct IO_ATTRS ioMgrAttrs;
+	u32 uNumWindows;
+	struct DRV_OBJECT *hDrvObject = NULL;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDevObject != NULL);
+	DBC_Require(pstrWMDFileName != NULL);
+	DBC_Require(pHostConfig != NULL);
+	DBC_Require(pDspConfig != NULL);
+
+	/*  Get the WMD interface functions*/
+	WMD_DRV_Entry(&pDrvFxns, pstrWMDFileName);
+	if (DSP_FAILED(CFG_GetObject((u32 *) &hDrvObject, REG_DRV_OBJECT))) {
+		/* don't propogate CFG errors from this PROC function */
+		status = DSP_EFAIL;
+	}
+	/* Create the device object, and pass a handle to the WMD for
+	 * storage. */
+	if (DSP_SUCCEEDED(status)) {
+		DBC_Assert(pDrvFxns);
+		MEM_AllocObject(pDevObject, struct DEV_OBJECT, SIGNATURE);
+		if (pDevObject) {
+			/* Fill out the rest of the Dev Object structure: */
+			pDevObject->hDevNode = hDevNode;
+			pDevObject->hModule = hModule;
+			pDevObject->hCodMgr = NULL;
+			pDevObject->hChnlMgr = NULL;
+			pDevObject->hDehMgr = NULL;
+			pDevObject->lockOwner = NULL;
+			pDevObject->uWordSize = pDspConfig->uWordSize;
+			pDevObject->hDrvObject = hDrvObject;
+			pDevObject->devType = DSP_UNIT;
+			/* Store this WMD's interface functions, based on its
+			 * version. */
+			StoreInterfaceFxns(pDrvFxns, &pDevObject->intfFxns);
+			/* Call WMD_DEV_CREATE() to get the WMD's device
+			 * context handle. */
+			status = (pDevObject->intfFxns.pfnDevCreate)
+				 (&pDevObject->hWmdContext, pDevObject,
+				 pHostConfig, pDspConfig);
+			/* Assert WMD_DEV_Create()'s ensure clause: */
+			DBC_Assert(DSP_FAILED(status) || (pDevObject->
+				   hWmdContext != NULL));
+		} else {
+			status = DSP_EMEMORY;
+		}
+	}
+	/* Attempt to create the COD manager for this device: */
+	if (DSP_SUCCEEDED(status))
+		status = InitCodMgr(pDevObject);
+
+	/* Attempt to create the channel manager for this device: */
+	if (DSP_SUCCEEDED(status)) {
+		mgrAttrs.cChannels = CHNL_MAXCHANNELS;
+		ioMgrAttrs.bIRQ = pHostConfig->bIRQRegisters;
+		ioMgrAttrs.fShared = (pHostConfig->bIRQAttrib & CFG_IRQSHARED);
+		ioMgrAttrs.uWordSize = pDspConfig->uWordSize;
+		mgrAttrs.uWordSize = pDspConfig->uWordSize;
+		uNumWindows = pHostConfig->wNumMemWindows;
+		if (uNumWindows) {
+			/* Assume last memory window is for CHNL */
+			ioMgrAttrs.dwSMBase = pHostConfig->dwMemBase[1] +
+					      pHostConfig->dwOffsetForMonitor;
+			ioMgrAttrs.uSMLength = pHostConfig->dwMemLength[1] -
+					       pHostConfig->dwOffsetForMonitor;
+		} else {
+			ioMgrAttrs.dwSMBase = 0;
+			ioMgrAttrs.uSMLength = 0;
+			pr_err("%s: No memory reserved for shared structures\n",
+								__func__);
+		}
+		status = CHNL_Create(&pDevObject->hChnlMgr, pDevObject,
+				    &mgrAttrs);
+		if (status == DSP_ENOTIMPL) {
+			/* It's OK for a device not to have a channel
+			 * manager: */
+			status = DSP_SOK;
+		}
+		/* Create CMM mgr even if Msg Mgr not impl.  */
+		status = CMM_Create(&pDevObject->hCmmMgr,
+				   (struct DEV_OBJECT *)pDevObject, NULL);
+		/* Only create IO manager if we have a channel manager */
+		if (DSP_SUCCEEDED(status) && pDevObject->hChnlMgr) {
+			status = IO_Create(&pDevObject->hIOMgr, pDevObject,
+					   &ioMgrAttrs);
+		}
+		/* Only create DEH manager if we have an IO manager */
+		if (DSP_SUCCEEDED(status)) {
+			/* Instantiate the DEH module */
+			status = (*pDevObject->intfFxns.pfnDehCreate)
+				 (&pDevObject->hDehMgr, 	pDevObject);
+		}
+		/* Create DMM mgr .  */
+		status = DMM_Create(&pDevObject->hDmmMgr,
+				   (struct DEV_OBJECT *)pDevObject, NULL);
+	}
+	/* Add the new DEV_Object to the global list: */
+	if (DSP_SUCCEEDED(status)) {
+		LST_InitElem(&pDevObject->link);
+		status = DRV_InsertDevObject(hDrvObject, pDevObject);
+	}
+	/* Create the Processor List */
+	if (DSP_SUCCEEDED(status)) {
+		pDevObject->procList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
+		if (!(pDevObject->procList))
+			status = DSP_EFAIL;
+		else
+			INIT_LIST_HEAD(&pDevObject->procList->head);
+	}
+	 /*  If all went well, return a handle to the dev object;
+	 *  else, cleanup and return NULL in the OUT parameter.  */
+	if (DSP_SUCCEEDED(status)) {
+		*phDevObject = pDevObject;
+	} else {
+		kfree(pDevObject->procList);
+
+		if (pDevObject && pDevObject->hCodMgr)
+			COD_Delete(pDevObject->hCodMgr);
+
+		if (pDevObject && pDevObject->hDmmMgr)
+			DMM_Destroy(pDevObject->hDmmMgr);
+
+		if (pDevObject)
+			MEM_FreeObject(pDevObject);
+
+		*phDevObject = NULL;
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && IsValidHandle(*phDevObject)) ||
+		  (DSP_FAILED(status) && !*phDevObject));
+	return status;
+}
+
+/*
+ *  ======== DEV_Create2 ========
+ *  Purpose:
+ *      After successful loading of the image from WCD_InitComplete2
+ *      (PROC Auto_Start) or PROC_Load this fxn is called. This creates
+ *      the Node Manager and updates the DEV Object.
+ */
+DSP_STATUS DEV_Create2(struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(hDevObject));
+
+	/* There can be only one Node Manager per DEV object */
+	DBC_Assert(!pDevObject->hNodeMgr);
+	status = NODE_CreateMgr(&pDevObject->hNodeMgr, hDevObject);
+	if (DSP_FAILED(status))
+		pDevObject->hNodeMgr = NULL;
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr != NULL)
+		   || (DSP_FAILED(status) && pDevObject->hNodeMgr == NULL));
+	return status;
+}
+
+/*
+ *  ======== DEV_Destroy2 ========
+ *  Purpose:
+ *      Destroys the Node manager for this device.
+ */
+DSP_STATUS DEV_Destroy2(struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(hDevObject));
+
+	if (pDevObject->hNodeMgr) {
+		if (DSP_FAILED(NODE_DeleteMgr(pDevObject->hNodeMgr)))
+			status = DSP_EFAIL;
+		else
+			pDevObject->hNodeMgr = NULL;
+
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && pDevObject->hNodeMgr == NULL) ||
+		  DSP_FAILED(status));
+	return status;
+}
+
+/*
+ *  ======== DEV_DestroyDevice ========
+ *  Purpose:
+ *      Destroys the channel manager for this device, if any, calls
+ *      WMD_DEV_Destroy(), and then attempts to unload the WMD module.
+ */
+DSP_STATUS DEV_DestroyDevice(struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+
+	if (IsValidHandle(hDevObject)) {
+		if (pDevObject->hCodMgr) {
+			COD_Delete(pDevObject->hCodMgr);
+			pDevObject->hCodMgr = NULL;
+		}
+
+		if (pDevObject->hNodeMgr) {
+			NODE_DeleteMgr(pDevObject->hNodeMgr);
+			pDevObject->hNodeMgr = NULL;
+		}
+
+		/* Free the io, channel, and message managers for this board: */
+		if (pDevObject->hIOMgr) {
+			IO_Destroy(pDevObject->hIOMgr);
+			pDevObject->hIOMgr = NULL;
+		}
+		if (pDevObject->hChnlMgr) {
+			CHNL_Destroy(pDevObject->hChnlMgr);
+			pDevObject->hChnlMgr = NULL;
+		}
+		if (pDevObject->hMsgMgr) {
+			MSG_Delete(pDevObject->hMsgMgr);
+			pDevObject->hMsgMgr = NULL;
+		}
+
+		if (pDevObject->hDehMgr) {
+			/* Uninitialize DEH module. */
+			(*pDevObject->intfFxns.pfnDehDestroy)
+			(pDevObject->hDehMgr);
+			pDevObject->hDehMgr = NULL;
+		}
+		if (pDevObject->hCmmMgr) {
+			CMM_Destroy(pDevObject->hCmmMgr, true);
+			pDevObject->hCmmMgr = NULL;
+		}
+
+		if (pDevObject->hDmmMgr) {
+			DMM_Destroy(pDevObject->hDmmMgr);
+			pDevObject->hDmmMgr = NULL;
+		}
+
+		/* Call the driver's WMD_DEV_Destroy() function: */
+		/* Require of DevDestroy */
+		if (pDevObject->hWmdContext) {
+			status = (*pDevObject->intfFxns.pfnDevDestroy)
+				(pDevObject->hWmdContext);
+			pDevObject->hWmdContext = NULL;
+		} else
+			status = DSP_EFAIL;
+		if (DSP_SUCCEEDED(status)) {
+			kfree(pDevObject->procList);
+			pDevObject->procList = NULL;
+
+			/* Remove this DEV_Object from the global list: */
+			DRV_RemoveDevObject(pDevObject->hDrvObject, pDevObject);
+			/* Free The library * LDR_FreeModule
+			 * (pDevObject->hModule);*/
+			/* Free this dev object: */
+			MEM_FreeObject(pDevObject);
+			pDevObject = NULL;
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DEV_GetChnlMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the channel manager handle created for this
+ *      device.
+ */
+DSP_STATUS DEV_GetChnlMgr(struct DEV_OBJECT *hDevObject,
+			 OUT struct CHNL_MGR **phMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMgr != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phMgr = pDevObject->hChnlMgr;
+	} else {
+		*phMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+		  (*phMgr == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_GetCmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the shared memory manager created for this
+ *      device.
+ */
+DSP_STATUS DEV_GetCmmMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct CMM_OBJECT **phMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMgr != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phMgr = pDevObject->hCmmMgr;
+	} else {
+		*phMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+		  (*phMgr == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_GetDmmMgr ========
+ *  Purpose:
+ *      Retrieve the handle to the dynamic memory manager created for this
+ *      device.
+ */
+DSP_STATUS DEV_GetDmmMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct DMM_OBJECT **phMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMgr != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phMgr = pDevObject->hDmmMgr;
+	} else {
+		*phMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
+		  (*phMgr == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_GetCodMgr ========
+ *  Purpose:
+ *      Retrieve the COD manager create for this device.
+ */
+DSP_STATUS DEV_GetCodMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct COD_MANAGER **phCodMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phCodMgr != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phCodMgr = pDevObject->hCodMgr;
+	} else {
+		*phCodMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
+		  (*phCodMgr == NULL)));
+	return status;
+}
+
+/*
+ *  ========= DEV_GetDehMgr ========
+ */
+DSP_STATUS DEV_GetDehMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct DEH_MGR **phDehMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDehMgr != NULL);
+	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+	if (IsValidHandle(hDevObject)) {
+		*phDehMgr = hDevObject->hDehMgr;
+	} else {
+		*phDehMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== DEV_GetDevNode ========
+ *  Purpose:
+ *      Retrieve the platform specific device ID for this device.
+ */
+DSP_STATUS DEV_GetDevNode(struct DEV_OBJECT *hDevObject,
+			 OUT struct CFG_DEVNODE **phDevNode)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDevNode != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phDevNode = pDevObject->hDevNode;
+	} else {
+		*phDevNode = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
+		  (*phDevNode == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_GetFirst ========
+ *  Purpose:
+ *      Retrieve the first Device Object handle from an internal linked list
+ *      DEV_OBJECTs maintained by DEV.
+ */
+struct DEV_OBJECT *DEV_GetFirst(void)
+{
+	struct DEV_OBJECT *pDevObject = NULL;
+
+	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+
+	DBC_Ensure((pDevObject == NULL) || IsValidHandle(pDevObject));
+
+	return pDevObject;
+}
+
+/*
+ *  ======== DEV_GetIntfFxns ========
+ *  Purpose:
+ *      Retrieve the WMD interface function structure for the loaded WMD.
+ *      ppIntfFxns != NULL.
+ */
+DSP_STATUS DEV_GetIntfFxns(struct DEV_OBJECT *hDevObject,
+			  OUT struct WMD_DRV_INTERFACE **ppIntfFxns)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(ppIntfFxns != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*ppIntfFxns = &pDevObject->intfFxns;
+	} else {
+		*ppIntfFxns = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((ppIntfFxns != NULL) &&
+		  (*ppIntfFxns == NULL)));
+	return status;
+}
+
+/*
+ *  ========= DEV_GetIOMgr ========
+ */
+DSP_STATUS DEV_GetIOMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct IO_MGR **phIOMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phIOMgr != NULL);
+	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+
+	if (IsValidHandle(hDevObject)) {
+		*phIOMgr = hDevObject->hIOMgr;
+	} else {
+		*phIOMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DEV_GetNext ========
+ *  Purpose:
+ *      Retrieve the next Device Object handle from an internal linked list
+ *      of DEV_OBJECTs maintained by DEV, after having previously called
+ *      DEV_GetFirst() and zero or more DEV_GetNext
+ */
+struct DEV_OBJECT *DEV_GetNext(struct DEV_OBJECT *hDevObject)
+{
+	struct DEV_OBJECT *pNextDevObject = NULL;
+
+	if (IsValidHandle(hDevObject)) {
+		pNextDevObject = (struct DEV_OBJECT *)
+				 DRV_GetNextDevObject((u32)hDevObject);
+	}
+	DBC_Ensure((pNextDevObject == NULL) || IsValidHandle(pNextDevObject));
+	return pNextDevObject;
+}
+
+/*
+ *  ========= DEV_GetMsgMgr ========
+ */
+void DEV_GetMsgMgr(struct DEV_OBJECT *hDevObject,
+			OUT struct MSG_MGR **phMsgMgr)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMsgMgr != NULL);
+	DBC_Require(MEM_IsValidHandle(hDevObject, SIGNATURE));
+
+	*phMsgMgr = hDevObject->hMsgMgr;
+}
+
+/*
+ *  ======== DEV_GetNodeManager ========
+ *  Purpose:
+ *      Retrieve the Node Manager Handle
+ */
+DSP_STATUS DEV_GetNodeManager(struct DEV_OBJECT *hDevObject,
+				   OUT struct NODE_MGR **phNodeMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phNodeMgr != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phNodeMgr = pDevObject->hNodeMgr;
+	} else {
+		*phNodeMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNodeMgr != NULL) &&
+		  (*phNodeMgr == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_GetSymbol ========
+ */
+DSP_STATUS DEV_GetSymbol(struct DEV_OBJECT *hDevObject,
+			      IN CONST char *pstrSym, OUT u32 *pulValue)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct COD_MANAGER *hCodMgr;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pstrSym != NULL && pulValue != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
+		if (DSP_SUCCEEDED(status)) {
+			DBC_Assert(hCodMgr != NULL);
+			status = COD_GetSymValue(hCodMgr, (char *)pstrSym,
+				 pulValue);
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DEV_GetWMDContext ========
+ *  Purpose:
+ *      Retrieve the WMD Context handle, as returned by the WMD_Create fxn.
+ */
+DSP_STATUS DEV_GetWMDContext(struct DEV_OBJECT *hDevObject,
+			    OUT struct WMD_DEV_CONTEXT **phWmdContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phWmdContext != NULL);
+
+	if (IsValidHandle(hDevObject)) {
+		*phWmdContext = pDevObject->hWmdContext;
+	} else {
+		*phWmdContext = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phWmdContext != NULL) &&
+		  (*phWmdContext == NULL)));
+	return status;
+}
+
+/*
+ *  ======== DEV_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ */
+void DEV_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	if (cRefs == 0) {
+		CMM_Exit();
+		DMM_Exit();
+	}
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== DEV_Init ========
+ *  Purpose:
+ *      Initialize DEV's private state, keeping a reference count on each call.
+ */
+bool DEV_Init(void)
+{
+	bool fCmm, fDmm, fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0) {
+		fCmm = CMM_Init();
+		fDmm = DMM_Init();
+
+		fRetval = fCmm && fDmm;
+
+		if (!fRetval) {
+			if (fCmm)
+				CMM_Exit();
+
+
+			if (fDmm)
+				DMM_Exit();
+
+		}
+	}
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+/*
+ *  ======== DEV_NotifyClients ========
+ *  Purpose:
+ *      Notify all clients of this device of a change in device status.
+ */
+DSP_STATUS DEV_NotifyClients(struct DEV_OBJECT *hDevObject, u32 ulStatus)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	struct DEV_OBJECT *pDevObject = hDevObject;
+	void *hProcObject;
+
+	for (hProcObject = (void *)LST_First(pDevObject->procList);
+		hProcObject != NULL;
+		hProcObject = (void *)LST_Next(pDevObject->procList,
+					(struct list_head *)hProcObject))
+		PROC_NotifyClients(hProcObject, (u32) ulStatus);
+
+	return status;
+}
+
+/*
+ *  ======== DEV_RemoveDevice ========
+ */
+DSP_STATUS DEV_RemoveDevice(struct CFG_DEVNODE *hDevNode)
+{
+	struct DEV_OBJECT *hDevObject;	/* handle to device object */
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject;
+
+	/* Retrieve the device object handle originaly stored with
+	 * the DevNode: */
+	status = CFG_GetDevObject(hDevNode, (u32 *)&hDevObject);
+	if (DSP_SUCCEEDED(status)) {
+		/* Remove the Processor List */
+		pDevObject = (struct DEV_OBJECT *)hDevObject;
+		/* Destroy the device object. */
+		status = DEV_DestroyDevice(hDevObject);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DEV_SetChnlMgr ========
+ *  Purpose:
+ *      Set the channel manager for this device.
+ */
+DSP_STATUS DEV_SetChnlMgr(struct DEV_OBJECT *hDevObject, struct CHNL_MGR *hMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = hDevObject;
+
+	DBC_Require(cRefs > 0);
+
+	if (IsValidHandle(hDevObject))
+		pDevObject->hChnlMgr = hMgr;
+	else
+		status = DSP_EHANDLE;
+
+	DBC_Ensure(DSP_FAILED(status) || (pDevObject->hChnlMgr == hMgr));
+	return status;
+}
+
+/*
+ *  ======== DEV_SetMsgMgr ========
+ *  Purpose:
+ *      Set the message manager for this device.
+ */
+void DEV_SetMsgMgr(struct DEV_OBJECT *hDevObject, struct MSG_MGR *hMgr)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(hDevObject));
+
+	hDevObject->hMsgMgr = hMgr;
+}
+
+/*
+ *  ======== DEV_StartDevice ========
+ *  Purpose:
+ *      Initializes the new device with the BRIDGE environment.
+ */
+DSP_STATUS DEV_StartDevice(struct CFG_DEVNODE *hDevNode)
+{
+	struct DEV_OBJECT *hDevObject = NULL;	/* handle to 'Bridge Device */
+	struct CFG_HOSTRES hostRes;	/* resources struct. */
+	struct CFG_DSPRES dspRes;	/* DSP resources struct */
+	char szWMDFileName[CFG_MAXSEARCHPATHLEN] = "UMA"; /* wmd filename */
+	DSP_STATUS status;
+	struct MGR_OBJECT *hMgrObject = NULL;
+
+	DBC_Require(cRefs > 0);
+
+		status = CFG_GetHostResources(hDevNode, &hostRes);
+		if (DSP_SUCCEEDED(status)) {
+			/* Get DSP resources of device from Registry: */
+			status = CFG_GetDSPResources(hDevNode, &dspRes);
+		}
+	if (DSP_SUCCEEDED(status)) {
+		/* Given all resources, create a device object. */
+		status = DEV_CreateDevice(&hDevObject, szWMDFileName, &hostRes,
+					 &dspRes, hDevNode);
+		if (DSP_SUCCEEDED(status)) {
+			/* Store away the hDevObject with the DEVNODE */
+			status = CFG_SetDevObject(hDevNode, (u32)hDevObject);
+			if (DSP_FAILED(status)) {
+				/* Clean up */
+				DEV_DestroyDevice(hDevObject);
+				hDevObject = NULL;
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Create the Manager Object */
+		status = MGR_Create(&hMgrObject, hDevNode);
+	}
+	if (DSP_FAILED(status)) {
+		if (hDevObject)
+			DEV_DestroyDevice(hDevObject);
+
+		/* Ensure the device extension is NULL */
+		CFG_SetDevObject(hDevNode, 0L);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== FxnNotImplemented ========
+ *  Purpose:
+ *      Takes the place of a WMD Null Function.
+ *  Parameters:
+ *      Multiple, optional.
+ *  Returns:
+ *      DSP_ENOTIMPL:   Always.
+ */
+static DSP_STATUS FxnNotImplemented(int arg, ...)
+{
+	return DSP_ENOTIMPL;
+}
+
+/*
+ *  ======== IsValidHandle ========
+ *  Purpose:
+ *      Validate the device object handle.
+ *  Parameters:
+ *      hDevObject:     Handle to device object created with
+ *                      DEV_CreateDevice().
+ *  Returns:
+ *      true if handle is valid; false otherwise.
+ *  Requires:
+ *  Ensures:
+ */
+static bool IsValidHandle(struct DEV_OBJECT *hObj)
+{
+	bool retVal;
+
+	retVal = (hObj != NULL) && (hObj->dwSignature == SIGNATURE);
+
+	return retVal;
+}
+
+/*
+ *  ======== InitCodMgr ========
+ *  Purpose:
+ *      Create a COD manager for this device.
+ *  Parameters:
+ *      pDevObject:             Pointer to device object created with
+ *                              DEV_CreateDevice()
+ *  Returns:
+ *      DSP_SOK:                Success.
+ *      DSP_EHANDLE:            Invalid hDevObject.
+ *  Requires:
+ *      Should only be called once by DEV_CreateDevice() for a given DevObject.
+ *  Ensures:
+ */
+static DSP_STATUS InitCodMgr(struct DEV_OBJECT *pDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	char *szDummyFile = "dummy";
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(!IsValidHandle(pDevObject) ||
+		   (pDevObject->hCodMgr == NULL));
+
+	status = COD_Create(&pDevObject->hCodMgr, szDummyFile, NULL);
+
+	return status;
+}
+
+/*
+ *  ======== DEV_InsertProcObject ========
+ *  Purpose:
+ *      Insert a ProcObject into the list maintained by DEV.
+ *  Parameters:
+ *      pProcObject:        Ptr to ProcObject to insert.
+ *      pDevObject:         Ptr to Dev Object where the list is.
+  *     pbAlreadyAttached:  Ptr to return the bool
+ *  Returns:
+ *      DSP_SOK:           If successful.
+ *  Requires:
+ *      List Exists
+ *      hDevObject is Valid handle
+ *      DEV Initialized
+ *      pbAlreadyAttached != NULL
+ *      hProcObject != 0
+ *  Ensures:
+ *      DSP_SOK and List is not Empty.
+ */
+DSP_STATUS DEV_InsertProcObject(struct DEV_OBJECT *hDevObject,
+				     u32 hProcObject,
+				     OUT bool *pbAlreadyAttached)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(pDevObject));
+	DBC_Require(hProcObject != 0);
+	DBC_Require(pDevObject->procList != NULL);
+	DBC_Require(pbAlreadyAttached != NULL);
+	if (!LST_IsEmpty(pDevObject->procList))
+		*pbAlreadyAttached = true;
+
+	/* Add DevObject to tail. */
+	LST_PutTail(pDevObject->procList, (struct list_head *)hProcObject);
+
+	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDevObject->procList));
+
+	return status;
+}
+
+/*
+ *  ======== DEV_RemoveProcObject ========
+ *  Purpose:
+ *      Search for and remove a Proc object from the given list maintained
+ *      by the DEV
+ *  Parameters:
+ *      pProcObject:        Ptr to ProcObject to insert.
+ *      pDevObject          Ptr to Dev Object where the list is.
+ *  Returns:
+ *      DSP_SOK:            If successful.
+ *  Requires:
+ *      List exists and is not empty
+ *      hProcObject != 0
+ *      hDevObject is a valid Dev handle.
+ *  Ensures:
+ *  Details:
+ *      List will be deleted when the DEV is destroyed.
+ */
+DSP_STATUS DEV_RemoveProcObject(struct DEV_OBJECT *hDevObject,
+				     u32 hProcObject)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct list_head *pCurElem;
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hDevObject;
+
+	DBC_Require(IsValidHandle(pDevObject));
+	DBC_Require(hProcObject != 0);
+	DBC_Require(pDevObject->procList != NULL);
+	DBC_Require(!LST_IsEmpty(pDevObject->procList));
+
+	/* Search list for pDevObject: */
+	for (pCurElem = LST_First(pDevObject->procList); pCurElem != NULL;
+	    pCurElem = LST_Next(pDevObject->procList, pCurElem)) {
+		/* If found, remove it. */
+		if ((u32)pCurElem == hProcObject) {
+			LST_RemoveElem(pDevObject->procList, pCurElem);
+			status = DSP_SOK;
+			break;
+		}
+	}
+
+	return status;
+}
+
+DSP_STATUS DEV_GetDevType(struct DEV_OBJECT *hdevObject, u32 *devType)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)hdevObject;
+
+	*devType = pDevObject->devType;
+
+	return status;
+}
+
+/*
+ *  ======== StoreInterfaceFxns ========
+ *  Purpose:
+ *      Copy the WMD's interface functions into the device object,
+ *      ensuring that FxnNotImplemented() is set for:
+ *
+ *      1. All WMD function pointers which are NULL; and
+ *      2. All function slots in the struct DEV_OBJECT structure which have no
+ *         corresponding slots in the the WMD's interface, because the WMD
+ *         is of an *older* version.
+ *  Parameters:
+ *      pIntfFxns:      Interface Fxn Structure of the WCD's Dev Object.
+ *      pDrvFxns:       Interface Fxns offered by the WMD during DEV_Create().
+ *  Returns:
+ *  Requires:
+ *      Input pointers are valid.
+ *      WMD is *not* written for a newer WCD.
+ *  Ensures:
+ *      All function pointers in the dev object's Fxn interface are not NULL.
+ */
+static void StoreInterfaceFxns(struct WMD_DRV_INTERFACE *pDrvFxns,
+			      OUT struct WMD_DRV_INTERFACE *pIntfFxns)
+{
+	u32 dwWMDVersion;
+
+	/* Local helper macro: */
+#define  StoreFxn(cast, pfn) \
+    (pIntfFxns->pfn = ((pDrvFxns->pfn != NULL) ? pDrvFxns->pfn : \
+    (cast)FxnNotImplemented))
+
+	DBC_Require(pIntfFxns != NULL);
+	DBC_Require(pDrvFxns != NULL);
+	DBC_Require(MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
+		   pDrvFxns->dwWCDMinorVersion) <= WCDVERSION);
+	dwWMDVersion = MAKEVERSION(pDrvFxns->dwWCDMajorVersion,
+				  pDrvFxns->dwWCDMinorVersion);
+	pIntfFxns->dwWCDMajorVersion = pDrvFxns->dwWCDMajorVersion;
+	pIntfFxns->dwWCDMinorVersion = pDrvFxns->dwWCDMinorVersion;
+	/* Install functions up to WCD version .80 (first alpha): */
+	if (dwWMDVersion > 0) {
+		StoreFxn(WMD_DEV_CREATE, pfnDevCreate);
+		StoreFxn(WMD_DEV_DESTROY, pfnDevDestroy);
+		StoreFxn(WMD_DEV_CTRL, pfnDevCntrl);
+		StoreFxn(WMD_BRD_MONITOR, pfnBrdMonitor);
+		StoreFxn(WMD_BRD_START, pfnBrdStart);
+		StoreFxn(WMD_BRD_STOP, pfnBrdStop);
+		StoreFxn(WMD_BRD_STATUS, pfnBrdStatus);
+		StoreFxn(WMD_BRD_READ, pfnBrdRead);
+		StoreFxn(WMD_BRD_WRITE, pfnBrdWrite);
+		StoreFxn(WMD_BRD_SETSTATE, pfnBrdSetState);
+		StoreFxn(WMD_BRD_MEMCOPY, pfnBrdMemCopy);
+		StoreFxn(WMD_BRD_MEMWRITE, pfnBrdMemWrite);
+		StoreFxn(WMD_BRD_MEMMAP, pfnBrdMemMap);
+		StoreFxn(WMD_BRD_MEMUNMAP, pfnBrdMemUnMap);
+		StoreFxn(WMD_CHNL_CREATE, pfnChnlCreate);
+		StoreFxn(WMD_CHNL_DESTROY, pfnChnlDestroy);
+		StoreFxn(WMD_CHNL_OPEN, pfnChnlOpen);
+		StoreFxn(WMD_CHNL_CLOSE, pfnChnlClose);
+		StoreFxn(WMD_CHNL_ADDIOREQ, pfnChnlAddIOReq);
+		StoreFxn(WMD_CHNL_GETIOC, pfnChnlGetIOC);
+		StoreFxn(WMD_CHNL_CANCELIO, pfnChnlCancelIO);
+		StoreFxn(WMD_CHNL_FLUSHIO, pfnChnlFlushIO);
+		StoreFxn(WMD_CHNL_GETINFO, pfnChnlGetInfo);
+		StoreFxn(WMD_CHNL_GETMGRINFO, pfnChnlGetMgrInfo);
+		StoreFxn(WMD_CHNL_IDLE, pfnChnlIdle);
+		StoreFxn(WMD_CHNL_REGISTERNOTIFY, pfnChnlRegisterNotify);
+		StoreFxn(WMD_DEH_CREATE, pfnDehCreate);
+		StoreFxn(WMD_DEH_DESTROY, pfnDehDestroy);
+		StoreFxn(WMD_DEH_NOTIFY, pfnDehNotify);
+		StoreFxn(WMD_DEH_REGISTERNOTIFY, pfnDehRegisterNotify);
+		StoreFxn(WMD_DEH_GETINFO, pfnDehGetInfo);
+		StoreFxn(WMD_IO_CREATE, pfnIOCreate);
+		StoreFxn(WMD_IO_DESTROY, pfnIODestroy);
+		StoreFxn(WMD_IO_ONLOADED, pfnIOOnLoaded);
+		StoreFxn(WMD_IO_GETPROCLOAD, pfnIOGetProcLoad);
+		StoreFxn(WMD_MSG_CREATE, pfnMsgCreate);
+		StoreFxn(WMD_MSG_CREATEQUEUE, pfnMsgCreateQueue);
+		StoreFxn(WMD_MSG_DELETE, pfnMsgDelete);
+		StoreFxn(WMD_MSG_DELETEQUEUE, pfnMsgDeleteQueue);
+		StoreFxn(WMD_MSG_GET, pfnMsgGet);
+		StoreFxn(WMD_MSG_PUT, pfnMsgPut);
+		StoreFxn(WMD_MSG_REGISTERNOTIFY, pfnMsgRegisterNotify);
+		StoreFxn(WMD_MSG_SETQUEUEID, pfnMsgSetQueueId);
+	}
+	/* Add code for any additional functions in newer WMD versions here: */
+	/* Ensure postcondition: */
+	DBC_Ensure(pIntfFxns->pfnDevCreate != NULL);
+	DBC_Ensure(pIntfFxns->pfnDevDestroy != NULL);
+	DBC_Ensure(pIntfFxns->pfnDevCntrl != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdMonitor != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdStart != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdStop != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdStatus != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdRead != NULL);
+	DBC_Ensure(pIntfFxns->pfnBrdWrite != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlCreate != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlDestroy != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlOpen != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlClose != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlAddIOReq != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlGetIOC != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlCancelIO != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlFlushIO != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlGetInfo != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlGetMgrInfo != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlIdle != NULL);
+	DBC_Ensure(pIntfFxns->pfnChnlRegisterNotify != NULL);
+	DBC_Ensure(pIntfFxns->pfnDehCreate != NULL);
+	DBC_Ensure(pIntfFxns->pfnDehDestroy != NULL);
+	DBC_Ensure(pIntfFxns->pfnDehNotify != NULL);
+	DBC_Ensure(pIntfFxns->pfnDehRegisterNotify != NULL);
+	DBC_Ensure(pIntfFxns->pfnDehGetInfo != NULL);
+	DBC_Ensure(pIntfFxns->pfnIOCreate != NULL);
+	DBC_Ensure(pIntfFxns->pfnIODestroy != NULL);
+	DBC_Ensure(pIntfFxns->pfnIOOnLoaded != NULL);
+	DBC_Ensure(pIntfFxns->pfnIOGetProcLoad != NULL);
+	DBC_Ensure(pIntfFxns->pfnMsgSetQueueId != NULL);
+
+#undef  StoreFxn
+}
+
diff --git a/drivers/dsp/bridge/pmgr/dmm.c b/drivers/dsp/bridge/pmgr/dmm.c
new file mode 100644
index 0000000..7bf7091
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/dmm.c
@@ -0,0 +1,560 @@
+/*
+ * dmm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * The Dynamic Memory Manager (DMM) module manages the DSP Virtual address
+ * space that can be directly mapped to any MPU buffer or memory region
+ *
+ * Notes:
+ *   Region: Generic memory entitiy having a start address and a size
+ *   Chunk:  Reserved region
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/proc.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/dmm.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+/* Object signatures */
+#define DMMSIGNATURE       0x004d4d44	/* "DMM"   (in reverse) */
+
+#define DMM_ADDR_VIRTUAL(a) \
+	(((struct MapPage *)(a) - pVirtualMappingTable) * PG_SIZE_4K +\
+	dynMemMapBeg)
+#define DMM_ADDR_TO_INDEX(a) (((a) - dynMemMapBeg) / PG_SIZE_4K)
+
+/* DMM Mgr */
+struct DMM_OBJECT {
+	u32 dwSignature;	/* Used for object validation */
+	/* Dmm Lock is used to serialize access mem manager for
+	 * multi-threads. */
+	struct SYNC_CSOBJECT *hDmmLock;	/* Lock to access dmm mgr */
+};
+
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;		/* module reference count */
+struct MapPage {
+	u32   RegionSize:15;
+	u32   MappedSize:15;
+	u32   bReserved:1;
+	u32   bMapped:1;
+};
+
+/*  Create the free list */
+static struct MapPage *pVirtualMappingTable;
+static u32  iFreeRegion;	/* The index of free region */
+static u32  iFreeSize;
+static u32  dynMemMapBeg;	/* The Beginning of dynamic memory mapping */
+static u32  TableSize;/* The size of virtual and physical pages tables */
+
+/*  ----------------------------------- Function Prototypes */
+static struct MapPage *GetRegion(u32 addr);
+static struct MapPage *GetFreeRegion(u32 aSize);
+static struct MapPage *GetMappedRegion(u32 aAddr);
+#ifdef DSP_DMM_DEBUG
+u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+#endif
+
+/*  ======== DMM_CreateTables ========
+ *  Purpose:
+ *      Create table to hold the information of physical address
+ *      the buffer pages that is passed by the user, and the table
+ *      to hold the information of the virtual memory that is reserved
+ *      for DSP.
+ */
+DSP_STATUS DMM_CreateTables(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	status = DMM_DeleteTables(pDmmObj);
+	if (DSP_SUCCEEDED(status)) {
+		SYNC_EnterCS(pDmmObj->hDmmLock);
+		dynMemMapBeg = addr;
+		TableSize = PG_ALIGN_HIGH(size, PG_SIZE_4K)/PG_SIZE_4K;
+		/*  Create the free list */
+		pVirtualMappingTable = (struct MapPage *) MEM_Calloc
+			(TableSize * sizeof(struct MapPage), MEM_LARGEVIRTMEM);
+		if (pVirtualMappingTable == NULL)
+			status = DSP_EMEMORY;
+		else {
+			/* On successful allocation,
+			* all entries are zero ('free') */
+			iFreeRegion = 0;
+			iFreeSize = TableSize*PG_SIZE_4K;
+			pVirtualMappingTable[0].RegionSize = TableSize;
+		}
+		SYNC_LeaveCS(pDmmObj->hDmmLock);
+	}
+
+	if (DSP_FAILED(status))
+		pr_err("%s: failure, status 0x%x\n", __func__, status);
+
+	return status;
+}
+
+/*
+ *  ======== DMM_Create ========
+ *  Purpose:
+ *      Create a dynamic memory manager object.
+ */
+DSP_STATUS DMM_Create(OUT struct DMM_OBJECT **phDmmMgr,
+		     struct DEV_OBJECT *hDevObject,
+		     IN CONST struct DMM_MGRATTRS *pMgrAttrs)
+{
+	struct DMM_OBJECT *pDmmObject = NULL;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDmmMgr != NULL);
+
+	*phDmmMgr = NULL;
+	/* create, zero, and tag a cmm mgr object */
+	MEM_AllocObject(pDmmObject, struct DMM_OBJECT, DMMSIGNATURE);
+	if (pDmmObject != NULL) {
+		status = SYNC_InitializeCS(&pDmmObject->hDmmLock);
+		if (DSP_SUCCEEDED(status))
+			*phDmmMgr = pDmmObject;
+		else
+			DMM_Destroy(pDmmObject);
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DMM_Destroy ========
+ *  Purpose:
+ *      Release the communication memory manager resources.
+ */
+DSP_STATUS DMM_Destroy(struct DMM_OBJECT *hDmmMgr)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
+		status = DMM_DeleteTables(pDmmObj);
+		if (DSP_SUCCEEDED(status)) {
+			/* Delete CS & dmm mgr object */
+			SYNC_DeleteCS(pDmmObj->hDmmLock);
+			MEM_FreeObject(pDmmObj);
+		}
+	} else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+
+/*
+ *  ======== DMM_DeleteTables ========
+ *  Purpose:
+ *      Delete DMM Tables.
+ */
+DSP_STATUS DMM_DeleteTables(struct DMM_OBJECT *hDmmMgr)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	if (MEM_IsValidHandle(hDmmMgr, DMMSIGNATURE)) {
+		/* Delete all DMM tables */
+		SYNC_EnterCS(pDmmObj->hDmmLock);
+
+		vfree(pVirtualMappingTable);
+
+		SYNC_LeaveCS(pDmmObj->hDmmLock);
+	} else
+		status = DSP_EHANDLE;
+	return status;
+}
+
+
+
+
+/*
+ *  ======== DMM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ */
+void DMM_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+}
+
+/*
+ *  ======== DMM_GetHandle ========
+ *  Purpose:
+ *      Return the dynamic memory manager object for this device.
+ *      This is typically called from the client process.
+ */
+DSP_STATUS DMM_GetHandle(void *hProcessor,
+			OUT struct DMM_OBJECT **phDmmMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *hDevObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDmmMgr != NULL);
+	if (hProcessor != NULL)
+		status = PROC_GetDevObject(hProcessor, &hDevObject);
+	else
+		hDevObject = DEV_GetFirst();	/* default */
+
+	if (DSP_SUCCEEDED(status))
+		status = DEV_GetDmmMgr(hDevObject, phDmmMgr);
+
+	return status;
+}
+
+/*
+ *  ======== DMM_Init ========
+ *  Purpose:
+ *      Initializes private state of DMM module.
+ */
+bool DMM_Init(void)
+{
+	bool fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	pVirtualMappingTable = NULL ;
+	TableSize = 0;
+
+	return fRetval;
+}
+
+/*
+ *  ======== DMM_MapMemory ========
+ *  Purpose:
+ *      Add a mapping block to the reserved chunk. DMM assumes that this block
+ *  will be mapped in the DSP/IVA's address space. DMM returns an error if a
+ *  mapping overlaps another one. This function stores the info that will be
+ *  required later while unmapping the block.
+ */
+DSP_STATUS DMM_MapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 size)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	struct MapPage *chunk;
+	DSP_STATUS status = DSP_SOK;
+
+	SYNC_EnterCS(pDmmObj->hDmmLock);
+	/* Find the Reserved memory chunk containing the DSP block to
+	 * be mapped */
+	chunk = (struct MapPage *)GetRegion(addr);
+	if (chunk != NULL) {
+		/* Mark the region 'mapped', leave the 'reserved' info as-is */
+		chunk->bMapped = true;
+		chunk->MappedSize = (size/PG_SIZE_4K);
+	} else
+		status = DSP_ENOTFOUND;
+	SYNC_LeaveCS(pDmmObj->hDmmLock);
+
+	dev_dbg(bridge, "%s hDmmMgr %p, addr %x, size %x\n\tstatus %x, "
+		"chunk %p", __func__, hDmmMgr, addr, size, status, chunk);
+
+	return status;
+}
+
+/*
+ *  ======== DMM_ReserveMemory ========
+ *  Purpose:
+ *      Reserve a chunk of virtually contiguous DSP/IVA address space.
+ */
+DSP_STATUS DMM_ReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 size,
+							u32 *pRsvAddr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	struct MapPage *node;
+	u32 rsvAddr = 0;
+	u32 rsvSize = 0;
+
+	SYNC_EnterCS(pDmmObj->hDmmLock);
+
+	/* Try to get a DSP chunk from the free list */
+	node = GetFreeRegion(size);
+	if (node != NULL) {
+		/*  DSP chunk of given size is available. */
+		rsvAddr = DMM_ADDR_VIRTUAL(node);
+		/* Calculate the number entries to use */
+		rsvSize = size/PG_SIZE_4K;
+		if (rsvSize < node->RegionSize) {
+			/* Mark remainder of free region */
+			node[rsvSize].bMapped = false;
+			node[rsvSize].bReserved = false;
+			node[rsvSize].RegionSize = node->RegionSize - rsvSize;
+			node[rsvSize].MappedSize = 0;
+		}
+		/*  GetRegion will return first fit chunk. But we only use what
+			is requested. */
+		node->bMapped = false;
+		node->bReserved = true;
+		node->RegionSize = rsvSize;
+		node->MappedSize = 0;
+		/* Return the chunk's starting address */
+		*pRsvAddr = rsvAddr;
+	} else
+		/*dSP chunk of given size is not available */
+		status = DSP_EMEMORY;
+
+	SYNC_LeaveCS(pDmmObj->hDmmLock);
+
+	dev_dbg(bridge, "%s hDmmMgr %p, size %x, pRsvAddr %p\n\tstatus %x, "
+			"rsvAddr %x, rsvSize %x\n", __func__, hDmmMgr, size,
+			pRsvAddr, status, rsvAddr, rsvSize);
+
+	return status;
+}
+
+
+/*
+ *  ======== DMM_UnMapMemory ========
+ *  Purpose:
+ *      Remove the mapped block from the reserved chunk.
+ */
+DSP_STATUS DMM_UnMapMemory(struct DMM_OBJECT *hDmmMgr, u32 addr, u32 *pSize)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	struct MapPage *chunk;
+	DSP_STATUS status = DSP_SOK;
+
+	SYNC_EnterCS(pDmmObj->hDmmLock);
+	chunk = GetMappedRegion(addr) ;
+	if (chunk == NULL)
+		status = DSP_ENOTFOUND ;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Unmap the region */
+		*pSize = chunk->MappedSize * PG_SIZE_4K;
+		chunk->bMapped = false;
+		chunk->MappedSize = 0;
+	}
+	SYNC_LeaveCS(pDmmObj->hDmmLock);
+
+	dev_dbg(bridge, "%s: hDmmMgr %p, addr %x, pSize %p\n\tstatus %x, "
+		"chunk %p\n", __func__, hDmmMgr, addr, pSize, status, chunk);
+
+	return status;
+}
+
+/*
+ *  ======== DMM_UnReserveMemory ========
+ *  Purpose:
+ *      Free a chunk of reserved DSP/IVA address space.
+ */
+DSP_STATUS DMM_UnReserveMemory(struct DMM_OBJECT *hDmmMgr, u32 rsvAddr)
+{
+	struct DMM_OBJECT *pDmmObj = (struct DMM_OBJECT *)hDmmMgr;
+	struct MapPage *chunk;
+	u32 i;
+	DSP_STATUS status = DSP_SOK;
+	u32 chunkSize;
+
+	SYNC_EnterCS(pDmmObj->hDmmLock);
+
+	/* Find the chunk containing the reserved address */
+	chunk = GetMappedRegion(rsvAddr);
+	if (chunk == NULL)
+		status = DSP_ENOTFOUND;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Free all the mapped pages for this reserved region */
+		i = 0;
+		while (i < chunk->RegionSize) {
+			if (chunk[i].bMapped) {
+				/* Remove mapping from the page tables. */
+				chunkSize = chunk[i].MappedSize;
+				/* Clear the mapping flags */
+				chunk[i].bMapped = false;
+				chunk[i].MappedSize = 0;
+				i += chunkSize;
+			} else
+				i++;
+		}
+		/* Clear the flags (mark the region 'free') */
+		chunk->bReserved = false;
+		/* NOTE: We do NOT coalesce free regions here.
+		 * Free regions are coalesced in GetRegion(), as it traverses
+		 *the whole mapping table
+		 */
+	}
+	SYNC_LeaveCS(pDmmObj->hDmmLock);
+
+	dev_dbg(bridge, "%s: hDmmMgr %p, rsvAddr %x\n\tstatus %x chunk %p",
+			__func__, hDmmMgr, rsvAddr, status, chunk);
+
+	return status;
+}
+
+
+/*
+ *  ======== GetRegion ========
+ *  Purpose:
+ *      Returns a region containing the specified memory region
+ */
+static struct MapPage *GetRegion(u32 aAddr)
+{
+	struct MapPage *currRegion = NULL;
+	u32   i = 0;
+
+	if (pVirtualMappingTable != NULL) {
+		/* find page mapped by this address */
+		i = DMM_ADDR_TO_INDEX(aAddr);
+		if (i < TableSize)
+			currRegion = pVirtualMappingTable + i;
+	}
+
+	dev_dbg(bridge, "%s: currRegion %p, iFreeRegion %d, iFreeSize %d\n",
+			__func__, currRegion, iFreeRegion, iFreeSize);
+	return currRegion;
+}
+
+/*
+ *  ======== GetFreeRegion ========
+ *  Purpose:
+ *  Returns the requested free region
+ */
+static struct MapPage *GetFreeRegion(u32 aSize)
+{
+	struct MapPage *currRegion = NULL;
+	u32   i = 0;
+	u32   RegionSize = 0;
+	u32   nextI = 0;
+
+	if (pVirtualMappingTable == NULL)
+		return currRegion;
+	if (aSize > iFreeSize) {
+		/* Find the largest free region
+		* (coalesce during the traversal) */
+		while (i < TableSize) {
+			RegionSize = pVirtualMappingTable[i].RegionSize;
+			nextI = i+RegionSize;
+			if (pVirtualMappingTable[i].bReserved == false) {
+				/* Coalesce, if possible */
+				if (nextI < TableSize &&
+				pVirtualMappingTable[nextI].bReserved
+							== false) {
+					pVirtualMappingTable[i].RegionSize +=
+					pVirtualMappingTable[nextI].RegionSize;
+					continue;
+				}
+				RegionSize *= PG_SIZE_4K;
+				if (RegionSize > iFreeSize) 	{
+					iFreeRegion = i;
+					iFreeSize = RegionSize;
+				}
+			}
+			i = nextI;
+		}
+	}
+	if (aSize <= iFreeSize) {
+		currRegion = pVirtualMappingTable + iFreeRegion;
+		iFreeRegion += (aSize / PG_SIZE_4K);
+		iFreeSize -= aSize;
+	}
+	return currRegion;
+}
+
+/*
+ *  ======== GetMappedRegion ========
+ *  Purpose:
+ *  Returns the requestedmapped region
+ */
+static struct MapPage *GetMappedRegion(u32 aAddr)
+{
+	u32   i = 0;
+	struct MapPage *currRegion = NULL;
+
+	if (pVirtualMappingTable == NULL)
+		return currRegion;
+
+	i = DMM_ADDR_TO_INDEX(aAddr);
+	if (i < TableSize && (pVirtualMappingTable[i].bMapped ||
+			pVirtualMappingTable[i].bReserved))
+		currRegion = pVirtualMappingTable + i;
+	return currRegion;
+}
+
+#ifdef DSP_DMM_DEBUG
+u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr)
+{
+	struct MapPage *curNode = NULL;
+	u32 i;
+	u32 freemem = 0;
+	u32 bigsize = 0;
+
+	SYNC_EnterCS(hDmmMgr->hDmmLock);
+
+	if (pVirtualMappingTable != NULL) {
+		for (i = 0; i < TableSize; i +=
+				pVirtualMappingTable[i].RegionSize) {
+			curNode = pVirtualMappingTable + i;
+			if (curNode->bReserved == TRUE)	{
+				/*printk("RESERVED size = 0x%x, "
+					"Map size = 0x%x\n",
+					(curNode->RegionSize * PG_SIZE_4K),
+					(curNode->bMapped == false) ? 0 :
+					(curNode->MappedSize * PG_SIZE_4K));
+*/
+			} else {
+/*				printk("UNRESERVED size = 0x%x\n",
+					(curNode->RegionSize * PG_SIZE_4K));
+*/
+				freemem += (curNode->RegionSize * PG_SIZE_4K);
+				if (curNode->RegionSize > bigsize)
+					bigsize = curNode->RegionSize;
+			}
+		}
+	}
+	printk(KERN_INFO "Total DSP VA FREE memory = %d Mbytes\n",
+			freemem/(1024*1024));
+	printk(KERN_INFO "Total DSP VA USED memory= %d Mbytes \n",
+			(((TableSize * PG_SIZE_4K)-freemem))/(1024*1024));
+	printk(KERN_INFO "DSP VA - Biggest FREE block = %d Mbytes \n\n",
+			(bigsize*PG_SIZE_4K/(1024*1024)));
+	SYNC_LeaveCS(hDmmMgr->hDmmLock);
+
+	return 0;
+}
+#endif
diff --git a/drivers/dsp/bridge/pmgr/io.c b/drivers/dsp/bridge/pmgr/io.c
new file mode 100644
index 0000000..701d047
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/io.c
@@ -0,0 +1,144 @@
+/*
+ * io.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * IO manager interface: Manages IO between CHNL and MSG.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- This */
+#include <ioobj.h>
+#include <dspbridge/iodefs.h>
+#include <dspbridge/io.h>
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;
+
+/*
+ *  ======== IO_Create ========
+ *  Purpose:
+ *      Create an IO manager object, responsible for managing IO between
+ *      CHNL and MSG
+ */
+DSP_STATUS IO_Create(OUT struct IO_MGR **phIOMgr, struct DEV_OBJECT *hDevObject,
+		    IN CONST struct IO_ATTRS *pMgrAttrs)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct IO_MGR *hIOMgr = NULL;
+	struct IO_MGR_ *pIOMgr = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phIOMgr != NULL);
+	DBC_Require(pMgrAttrs != NULL);
+
+	*phIOMgr = NULL;
+
+	/* A memory base of 0 implies no memory base:  */
+	if ((pMgrAttrs->dwSMBase != 0) && (pMgrAttrs->uSMLength == 0))
+		status = CHNL_E_INVALIDMEMBASE;
+
+	if (pMgrAttrs->uWordSize == 0)
+		status = CHNL_E_INVALIDWORDSIZE;
+
+	if (DSP_SUCCEEDED(status)) {
+		DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+
+		/* Let WMD channel module finish the create: */
+		status = (*pIntfFxns->pfnIOCreate)(&hIOMgr, hDevObject,
+			 pMgrAttrs);
+
+		if (DSP_SUCCEEDED(status)) {
+			pIOMgr = (struct IO_MGR_ *) hIOMgr;
+			pIOMgr->pIntfFxns = pIntfFxns;
+			pIOMgr->hDevObject = hDevObject;
+
+			/* Return the new channel manager handle: */
+			*phIOMgr = hIOMgr;
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== IO_Destroy ========
+ *  Purpose:
+ *      Delete IO manager.
+ */
+DSP_STATUS IO_Destroy(struct IO_MGR *hIOMgr)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct IO_MGR_ *pIOMgr = (struct IO_MGR_ *)hIOMgr;
+	DSP_STATUS status;
+
+	DBC_Require(cRefs > 0);
+
+	pIntfFxns = pIOMgr->pIntfFxns;
+
+	/* Let WMD channel module destroy the IO_MGR: */
+	status = (*pIntfFxns->pfnIODestroy) (hIOMgr);
+
+	return status;
+}
+
+/*
+ *  ======== IO_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the IO module.
+ */
+void IO_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== IO_Init ========
+ *  Purpose:
+ *      Initialize the IO module's private state.
+ */
+bool IO_Init(void)
+{
+	bool fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
diff --git a/drivers/dsp/bridge/pmgr/ioobj.h b/drivers/dsp/bridge/pmgr/ioobj.h
new file mode 100644
index 0000000..4e3bd56
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/ioobj.h
@@ -0,0 +1,39 @@
+/*
+ * ioobj.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Structure subcomponents of channel class library IO objects which
+ * are exposed to class driver from mini-driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef IOOBJ_
+#define IOOBJ_
+
+#include <dspbridge/devdefs.h>
+#include <dspbridge/wmd.h>
+
+/*
+ *  This struct is the first field in a IO_MGR struct, as implemented in
+ *  a WMD channel class library.  Other, implementation specific fields
+ *  follow this structure in memory.
+ */
+struct IO_MGR_ {
+	/* These must be the first fields in a IO_MGR struct: */
+	u32 dwSignature;	/* Used for object validation.   */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context.  */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+	struct DEV_OBJECT *hDevObject;	/* Device this board represents. */
+} ;
+
+#endif				/* IOOBJ_ */
diff --git a/drivers/dsp/bridge/pmgr/msg.c b/drivers/dsp/bridge/pmgr/msg.c
new file mode 100644
index 0000000..adab478
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/msg.c
@@ -0,0 +1,133 @@
+/*
+ * msg.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge MSG Module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- Mini Driver */
+#include <dspbridge/wmd.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- This */
+#include <msgobj.h>
+#include <dspbridge/msg.h>
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;		/* module reference count */
+
+/*
+ *  ======== MSG_Create ========
+ *  Purpose:
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object.
+ */
+DSP_STATUS MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+		      struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct MSG_MGR_ *pMsgMgr;
+	struct MSG_MGR *hMsgMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phMsgMgr != NULL);
+	DBC_Require(msgCallback != NULL);
+	DBC_Require(hDevObject != NULL);
+
+	*phMsgMgr = NULL;
+
+	DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+
+	/* Let WMD message module finish the create: */
+	status = (*pIntfFxns->pfnMsgCreate)(&hMsgMgr, hDevObject, msgCallback);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Fill in WCD message module's fields of the MSG_MGR
+		 * structure */
+		pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
+		pMsgMgr->pIntfFxns = pIntfFxns;
+
+		/* Finally, return the new message manager handle: */
+		*phMsgMgr = hMsgMgr;
+	} else {
+		status = DSP_EFAIL;
+	}
+	return status;
+}
+
+/*
+ *  ======== MSG_Delete ========
+ *  Purpose:
+ *      Delete a MSG manager allocated in MSG_Create().
+ */
+void MSG_Delete(struct MSG_MGR *hMsgMgr)
+{
+	struct MSG_MGR_ *pMsgMgr = (struct MSG_MGR_ *)hMsgMgr;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+
+	DBC_Require(cRefs > 0);
+
+	if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE)) {
+		pIntfFxns = pMsgMgr->pIntfFxns;
+
+		/* Let WMD message module destroy the MSG_MGR: */
+		(*pIntfFxns->pfnMsgDelete)(hMsgMgr);
+	} else {
+		dev_dbg(bridge, "%s: Error hMsgMgr handle: %p\n",
+						__func__, hMsgMgr);
+	}
+}
+
+/*
+ *  ======== MSG_Exit ========
+ */
+void MSG_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== MSG_Init ========
+ */
+bool MSG_Init(void)
+{
+	DBC_Require(cRefs >= 0);
+
+	cRefs++;
+
+	DBC_Ensure(cRefs >= 0);
+
+	return true;
+}
+
diff --git a/drivers/dsp/bridge/pmgr/msgobj.h b/drivers/dsp/bridge/pmgr/msgobj.h
new file mode 100644
index 0000000..5fd048c
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/msgobj.h
@@ -0,0 +1,39 @@
+/*
+ * msgobj.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Structure subcomponents of channel class library MSG objects which
+ * are exposed to class driver from mini-driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MSGOBJ_
+#define MSGOBJ_
+
+#include <dspbridge/wmd.h>
+
+#include <dspbridge/msgdefs.h>
+
+/*
+ *  This struct is the first field in a MSG_MGR struct, as implemented in
+ *  a WMD channel class library.  Other, implementation specific fields
+ *  follow this structure in memory.
+ */
+struct MSG_MGR_ {
+	/* The first two fields must match those in msgobj.h */
+	u32 dwSignature;
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+};
+
+#endif				/* MSGOBJ_ */
+
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
new file mode 100644
index 0000000..3a11a5a
--- /dev/null
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -0,0 +1,1645 @@
+/*
+ * wcd.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Common WCD functions, also includes the wrapper
+ * functions called directly by the DeviceIOControl interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/services.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/chnl.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/drv.h>
+
+#include <dspbridge/proc.h>
+#include <dspbridge/strm.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/disp.h>
+#include <dspbridge/mgr.h>
+#include <dspbridge/node.h>
+#include <dspbridge/rmm.h>
+
+
+/*  ----------------------------------- Others */
+#include <dspbridge/msg.h>
+#include <dspbridge/cmm.h>
+#include <dspbridge/io.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/_dcd.h>
+#include <dspbridge/dbdcd.h>
+
+#include <dspbridge/resourcecleanup.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define MAX_TRACEBUFLEN 255
+#define MAX_LOADARGS    16
+#define MAX_NODES       64
+#define MAX_STREAMS     16
+#define MAX_BUFS	64
+
+/* Used to get dspbridge ioctl table */
+#define DB_GET_IOC_TABLE(cmd)	(DB_GET_MODULE(cmd) >> DB_MODULE_SHIFT)
+
+/* Device IOCtl function pointer */
+struct WCD_Cmd {
+	u32(*fxn)(union Trapped_Args *args, void *pr_ctxt);
+	u32 dwIndex;
+} ;
+
+/*  ----------------------------------- Globals */
+static u32 WCD_cRefs;
+
+/*
+ *  Function tables.
+ *  The order of these functions MUST be the same as the order of the command
+ *  numbers defined in wcdioctl.h  This is how an IOCTL number in user mode
+ *  turns into a function call in kernel mode.
+ */
+
+/* MGR wrapper functions */
+static struct WCD_Cmd mgr_cmd[] = {
+	{MGRWRAP_EnumNode_Info},		/* MGR_ENUMNODE_INFO */
+	{MGRWRAP_EnumProc_Info},		/* MGR_ENUMPROC_INFO */
+	{MGRWRAP_RegisterObject},		/* MGR_REGISTEROBJECT */
+	{MGRWRAP_UnregisterObject},		/* MGR_UNREGISTEROBJECT */
+	{MGRWRAP_WaitForBridgeEvents},		/* MGR_WAIT */
+	{MGRWRAP_GetProcessResourcesInfo},	/* MGR_GET_PROC_RES */
+};
+
+/* PROC wrapper functions */
+static struct WCD_Cmd proc_cmd[] = {
+	{PROCWRAP_Attach},			/* PROC_ATTACH */
+	{PROCWRAP_Ctrl},			/* PROC_CTRL */
+	{PROCWRAP_Detach},			/* PROC_DETACH */
+	{PROCWRAP_EnumNode_Info},		/* PROC_ENUMNODE */
+	{PROCWRAP_EnumResources},		/* PROC_ENUMRESOURCES */
+	{PROCWRAP_GetState},			/* PROC_GET_STATE */
+	{PROCWRAP_GetTrace},			/* PROC_GET_TRACE */
+	{PROCWRAP_Load},			/* PROC_LOAD */
+	{PROCWRAP_RegisterNotify},		/* PROC_REGISTERNOTIFY */
+	{PROCWRAP_Start},			/* PROC_START */
+	{PROCWRAP_ReserveMemory},		/* PROC_RSVMEM */
+	{PROCWRAP_UnReserveMemory},		/* PROC_UNRSVMEM */
+	{PROCWRAP_Map},				/* PROC_MAPMEM */
+	{PROCWRAP_UnMap},			/* PROC_UNMAPMEM */
+	{PROCWRAP_FlushMemory},			/* PROC_FLUSHMEMORY */
+	{PROCWRAP_Stop},			/* PROC_STOP */
+	{PROCWRAP_InvalidateMemory},		/* PROC_INVALIDATEMEMORY */
+};
+
+/* NODE wrapper functions */
+static struct WCD_Cmd node_cmd[] = {
+	{NODEWRAP_Allocate},			/* NODE_ALLOCATE */
+	{NODEWRAP_AllocMsgBuf},			/* NODE_ALLOCMSGBUF */
+	{NODEWRAP_ChangePriority},		/* NODE_CHANGEPRIORITY */
+	{NODEWRAP_Connect},			/* NODE_CONNECT */
+	{NODEWRAP_Create},			/* NODE_CREATE */
+	{NODEWRAP_Delete},			/* NODE_DELETE */
+	{NODEWRAP_FreeMsgBuf},			/* NODE_FREEMSGBUF */
+	{NODEWRAP_GetAttr},			/* NODE_GETATTR */
+	{NODEWRAP_GetMessage},			/* NODE_GETMESSAGE */
+	{NODEWRAP_Pause},			/* NODE_PAUSE */
+	{NODEWRAP_PutMessage},			/* NODE_PUTMESSAGE */
+	{NODEWRAP_RegisterNotify},		/* NODE_REGISTERNOTIFY */
+	{NODEWRAP_Run},				/* NODE_RUN */
+	{NODEWRAP_Terminate},			/* NODE_TERMINATE */
+	{NODEWRAP_GetUUIDProps},		/* NODE_GETUUIDPROPS */
+};
+
+/* STRM wrapper functions */
+static struct WCD_Cmd strm_cmd[] = {
+	{STRMWRAP_AllocateBuffer},		/* STRM_ALLOCATEBUFFER */
+	{STRMWRAP_Close},			/* STRM_CLOSE */
+	{STRMWRAP_FreeBuffer},			/* STRM_FREEBUFFER */
+	{STRMWRAP_GetEventHandle},		/* STRM_GETEVENTHANDLE */
+	{STRMWRAP_GetInfo},			/* STRM_GETINFO */
+	{STRMWRAP_Idle},			/* STRM_IDLE */
+	{STRMWRAP_Issue},			/* STRM_ISSUE */
+	{STRMWRAP_Open},			/* STRM_OPEN */
+	{STRMWRAP_Reclaim},			/* STRM_RECLAIM */
+	{STRMWRAP_RegisterNotify},		/* STRM_REGISTERNOTIFY */
+	{STRMWRAP_Select},			/* STRM_SELECT */
+};
+
+/* CMM wrapper functions */
+static struct WCD_Cmd cmm_cmd[] = {
+	{CMMWRAP_CallocBuf},			/* CMM_ALLOCBUF */
+	{CMMWRAP_FreeBuf},			/* CMM_FREEBUF */
+	{CMMWRAP_GetHandle},			/* CMM_GETHANDLE */
+	{CMMWRAP_GetInfo},			/* CMM_GETINFO */
+};
+
+/* Array used to store ioctl table sizes. It can hold up to 8 entries */
+static u8 size_cmd[] = {
+	ARRAY_SIZE(mgr_cmd),
+	ARRAY_SIZE(proc_cmd),
+	ARRAY_SIZE(node_cmd),
+	ARRAY_SIZE(strm_cmd),
+	ARRAY_SIZE(cmm_cmd),
+};
+
+static inline void __cp_fm_usr(void *to, const void __user *from,
+			       DSP_STATUS *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!from)) {
+		*err = DSP_EPOINTER;
+		return;
+	}
+
+	if (unlikely(copy_from_user(to, from, bytes)))
+		*err = DSP_EPOINTER;
+}
+#define cp_fm_usr(to, from, err, n)				\
+	__cp_fm_usr(to, from, &(err), (n) * sizeof(*(to)))
+
+static inline void __cp_to_usr(void __user *to, const void *from,
+			       DSP_STATUS *err, unsigned long bytes)
+{
+	if (DSP_FAILED(*err))
+		return;
+
+	if (unlikely(!to)) {
+		*err = DSP_EPOINTER;
+		return;
+	}
+
+	if (unlikely(copy_to_user(to, from, bytes)))
+		*err = DSP_EPOINTER;
+}
+#define cp_to_usr(to, from, err, n)				\
+	__cp_to_usr(to, from, &(err), (n) * sizeof(*(from)))
+
+/*
+ *  ======== WCD_CallDevIOCtl ========
+ *  Purpose:
+ *      Call the (wrapper) function for the corresponding WCD IOCTL.
+ */
+inline DSP_STATUS WCD_CallDevIOCtl(u32 cmd, union Trapped_Args *args,
+				    u32 *result, void *pr_ctxt)
+{
+	u32 (*ioctl_cmd)(union Trapped_Args *args, void *pr_ctxt) = NULL;
+	int i;
+
+	if (_IOC_TYPE(cmd) != DB) {
+		pr_err("%s: Incompatible dspbridge ioctl number\n", __func__);
+		goto err;
+	}
+
+	if (DB_GET_IOC_TABLE(cmd) > ARRAY_SIZE(size_cmd)) {
+		pr_err("%s: undefined ioctl module\n", __func__);
+		goto err;
+	}
+
+	/* Check the size of the required cmd table */
+	i = DB_GET_IOC(cmd);
+	if (i > size_cmd[DB_GET_IOC_TABLE(cmd)]) {
+		pr_err("%s: requested ioctl %d out of bounds for table %d\n",
+					__func__, i, DB_GET_IOC_TABLE(cmd));
+		goto err;
+	}
+
+	switch (DB_GET_MODULE(cmd)) {
+	case DB_MGR:
+		ioctl_cmd = mgr_cmd[i].fxn;
+		break;
+	case DB_PROC:
+		ioctl_cmd = proc_cmd[i].fxn;
+		break;
+	case DB_NODE:
+		ioctl_cmd = node_cmd[i].fxn;
+		break;
+	case DB_STRM:
+		ioctl_cmd = strm_cmd[i].fxn;
+		break;
+	case DB_CMM:
+		ioctl_cmd = cmm_cmd[i].fxn;
+		break;
+	}
+
+	if (!ioctl_cmd) {
+		pr_err("%s: requested ioctl not defined\n", __func__);
+		goto err;
+	} else {
+		*result = (*ioctl_cmd)(args, pr_ctxt);
+	}
+
+	return DSP_SOK;
+
+err:
+	return -EINVAL;
+}
+
+/*
+ *  ======== WCD_Exit ========
+ */
+void WCD_Exit(void)
+{
+	DBC_Require(WCD_cRefs > 0);
+	WCD_cRefs--;
+
+	if (WCD_cRefs == 0) {
+		/* Release all WCD modules initialized in WCD_Init(). */
+		COD_Exit();
+		DEV_Exit();
+		CHNL_Exit();
+		MSG_Exit();
+		IO_Exit();
+		STRM_Exit();
+		DISP_Exit();
+		NODE_Exit();
+		PROC_Exit();
+		MGR_Exit();
+		RMM_exit();
+		DRV_Exit();
+	}
+	DBC_Ensure(WCD_cRefs >= 0);
+}
+
+/*
+ *  ======== WCD_Init ========
+ *  Purpose:
+ *      Module initialization is done by SERVICES Init.
+ */
+bool WCD_Init(void)
+{
+	bool fInit = true;
+	bool fDRV, fDEV, fCOD, fCHNL, fMSG, fIO;
+	bool fMGR, fPROC, fNODE, fDISP, fSTRM, fRMM;
+
+	if (WCD_cRefs == 0) {
+		/* initialize class driver and other modules */
+		fDRV = DRV_Init();
+		fMGR = MGR_Init();
+		fPROC = PROC_Init();
+		fNODE = NODE_Init();
+		fDISP = DISP_Init();
+		fSTRM = STRM_Init();
+		fRMM = RMM_init();
+		fCHNL = CHNL_Init();
+		fMSG = MSG_Init();
+		fIO = IO_Init();
+		fDEV = DEV_Init();
+		fCOD = COD_Init();
+		fInit = fDRV && fDEV && fCHNL && fCOD &&
+			fMSG && fIO;
+		fInit = fInit && fMGR && fPROC && fRMM;
+		if (!fInit) {
+			if (fDRV)
+				DRV_Exit();
+
+			if (fMGR)
+				MGR_Exit();
+
+			if (fSTRM)
+				STRM_Exit();
+
+			if (fPROC)
+				PROC_Exit();
+
+			if (fNODE)
+				NODE_Exit();
+
+			if (fDISP)
+				DISP_Exit();
+
+			if (fCHNL)
+				CHNL_Exit();
+
+			if (fMSG)
+				MSG_Exit();
+
+			if (fIO)
+				IO_Exit();
+
+			if (fDEV)
+				DEV_Exit();
+
+			if (fCOD)
+				COD_Exit();
+
+			if (fRMM)
+				RMM_exit();
+
+		}
+	}
+	if (fInit)
+		WCD_cRefs++;
+
+	return fInit;
+}
+
+/*
+ *  ======== WCD_InitComplete2 ========
+ *  Purpose:
+ *      Perform any required WCD, and WMD initialization which
+ *      cannot not be performed in WCD_Init() or DEV_StartDevice() due
+ *      to the fact that some services are not yet
+ *      completely initialized.
+ *  Parameters:
+ *  Returns:
+ *      DSP_SOK:	Allow this device to load
+ *      DSP_EFAIL:      Failure.
+ *  Requires:
+ *      WCD initialized.
+ *  Ensures:
+ */
+DSP_STATUS WCD_InitComplete2(void)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CFG_DEVNODE *DevNode;
+	struct DEV_OBJECT *hDevObject;
+	u32 devType;
+
+	DBC_Require(WCD_cRefs > 0);
+
+	 /*  Walk the list of DevObjects, get each devnode, and attempting to
+	 *  autostart the board. Note that this requires COF loading, which
+	 *  requires KFILE.  */
+	for (hDevObject = DEV_GetFirst(); hDevObject != NULL;
+	     hDevObject = DEV_GetNext(hDevObject)) {
+		if (DSP_FAILED(DEV_GetDevNode(hDevObject, &DevNode)))
+			continue;
+
+		if (DSP_FAILED(DEV_GetDevType(hDevObject, &devType)))
+			continue;
+
+		if ((devType == DSP_UNIT) || (devType == IVA_UNIT)) {
+			if (DSP_FAILED(PROC_AutoStart(DevNode, hDevObject))) {
+				status = DSP_EFAIL;
+				/* break; */
+			}
+		}
+	}			/* End For Loop */
+
+	return status;
+}
+
+/* TODO: Remove deprecated and not implemented ioctl wrappers */
+
+/*
+ * ======== MGRWRAP_EnumNode_Info ========
+ */
+u32 MGRWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
+{
+	u8 *pNDBProps;
+	u32 uNumNodes;
+	DSP_STATUS status = DSP_SOK;
+	u32 size = args->ARGS_MGR_ENUMNODE_INFO.uNDBPropsSize;
+
+	if (size < sizeof(struct DSP_NDBPROPS))
+		return DSP_ESIZE;
+
+	pNDBProps = MEM_Alloc(size, MEM_NONPAGED);
+	if (pNDBProps == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = MGR_EnumNodeInfo(args->ARGS_MGR_ENUMNODE_INFO.uNode,
+					 (struct DSP_NDBPROPS *)pNDBProps,
+					 size, &uNumNodes);
+	}
+	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.pNDBProps, pNDBProps, status,
+		 size);
+	cp_to_usr(args->ARGS_MGR_ENUMNODE_INFO.puNumNodes, &uNumNodes, status,
+		 1);
+	kfree(pNDBProps);
+
+	return status;
+}
+
+/*
+ * ======== MGRWRAP_EnumProc_Info ========
+ */
+u32 MGRWRAP_EnumProc_Info(union Trapped_Args *args, void *pr_ctxt)
+{
+	u8 *pProcessorInfo;
+	u32 uNumProcs;
+	DSP_STATUS status = DSP_SOK;
+	u32 size = args->ARGS_MGR_ENUMPROC_INFO.uProcessorInfoSize;
+
+	if (size < sizeof(struct DSP_PROCESSORINFO))
+		return DSP_ESIZE;
+
+	pProcessorInfo = MEM_Alloc(size, MEM_NONPAGED);
+	if (pProcessorInfo == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = MGR_EnumProcessorInfo(args->
+				ARGS_MGR_ENUMPROC_INFO.uProcessor,
+				(struct DSP_PROCESSORINFO *)pProcessorInfo,
+				size, &uNumProcs);
+	}
+	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.pProcessorInfo, pProcessorInfo,
+		 status, size);
+	cp_to_usr(args->ARGS_MGR_ENUMPROC_INFO.puNumProcs, &uNumProcs,
+		 status, 1);
+	kfree(pProcessorInfo);
+
+	return status;
+}
+
+#define WRAP_MAP2CALLER(x) x
+/*
+ * ======== MGRWRAP_RegisterObject ========
+ */
+u32 MGRWRAP_RegisterObject(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+	struct DSP_UUID pUuid;
+	u32 pathSize = 0;
+	char *pszPathName = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* pathSize is increased by 1 to accommodate NULL */
+	pathSize = strlen_user((char *)
+			args->ARGS_MGR_REGISTEROBJECT.pszPathName) + 1;
+	pszPathName = MEM_Alloc(pathSize, MEM_NONPAGED);
+	if (!pszPathName)
+		goto func_end;
+	retVal = strncpy_from_user(pszPathName,
+			(char *)args->ARGS_MGR_REGISTEROBJECT.pszPathName,
+			pathSize);
+	if (!retVal) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
+
+	if (args->ARGS_MGR_REGISTEROBJECT.objType >= DSP_DCDMAXOBJTYPE)
+		return DSP_EINVALIDARG;
+
+	status = DCD_RegisterObject(&pUuid,
+				args->ARGS_MGR_REGISTEROBJECT.objType,
+				(char *)pszPathName);
+func_end:
+	kfree(pszPathName);
+	return status;
+}
+
+/*
+ * ======== MGRWRAP_UnregisterObject ========
+ */
+u32 MGRWRAP_UnregisterObject(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_UUID pUuid;
+
+	cp_fm_usr(&pUuid, args->ARGS_MGR_REGISTEROBJECT.pUuid, status, 1);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = DCD_UnregisterObject(&pUuid,
+			args->ARGS_MGR_UNREGISTEROBJECT.objType);
+func_end:
+	return status;
+
+}
+
+/*
+ * ======== MGRWRAP_WaitForBridgeEvents ========
+ */
+u32 MGRWRAP_WaitForBridgeEvents(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK, real_status = DSP_SOK;
+	struct DSP_NOTIFICATION *aNotifications[MAX_EVENTS];
+	struct DSP_NOTIFICATION notifications[MAX_EVENTS];
+	u32 uIndex, i;
+	u32 uCount = args->ARGS_MGR_WAIT.uCount;
+
+	if (uCount > MAX_EVENTS)
+		status = DSP_EINVALIDARG;
+
+	/* get the array of pointers to user structures */
+	cp_fm_usr(aNotifications, args->ARGS_MGR_WAIT.aNotifications,
+	 status, uCount);
+	/* get the events */
+	for (i = 0; i < uCount; i++) {
+		cp_fm_usr(&notifications[i], aNotifications[i], status, 1);
+		if (DSP_SUCCEEDED(status)) {
+			/* set the array of pointers to kernel structures*/
+			aNotifications[i] = &notifications[i];
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		real_status = MGR_WaitForBridgeEvents(aNotifications, uCount,
+			 &uIndex, args->ARGS_MGR_WAIT.uTimeout);
+	}
+	cp_to_usr(args->ARGS_MGR_WAIT.puIndex, &uIndex, status, 1);
+	return real_status;
+}
+
+
+/*
+ * ======== MGRWRAP_GetProcessResourceInfo ========
+ */
+u32 __deprecated MGRWRAP_GetProcessResourcesInfo(union Trapped_Args *args,
+						void *pr_ctxt)
+{
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
+}
+
+
+/*
+ * ======== PROCWRAP_Attach ========
+ */
+u32 PROCWRAP_Attach(union Trapped_Args *args, void *pr_ctxt)
+{
+	void *processor;
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_PROCESSORATTRIN attrIn, *pAttrIn = NULL;
+
+	/* Optional argument */
+	if (args->ARGS_PROC_ATTACH.pAttrIn) {
+		cp_fm_usr(&attrIn, args->ARGS_PROC_ATTACH.pAttrIn, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pAttrIn = &attrIn;
+		else
+			goto func_end;
+
+
+	}
+	status = PROC_Attach(args->ARGS_PROC_ATTACH.uProcessor, pAttrIn,
+			    &processor, pr_ctxt);
+	cp_to_usr(args->ARGS_PROC_ATTACH.phProcessor, &processor, status, 1);
+func_end:
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Ctrl ========
+ */
+u32 PROCWRAP_Ctrl(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 cbDataSize, __user *pSize = (u32 __user *)
+			args->ARGS_PROC_CTRL.pArgs;
+	u8 *pArgs = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	if (pSize) {
+		if (get_user(cbDataSize, pSize)) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		cbDataSize += sizeof(u32);
+		pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
+		if (pArgs == NULL) {
+			status = DSP_EMEMORY;
+			goto func_end;
+		}
+
+		cp_fm_usr(pArgs, args->ARGS_PROC_CTRL.pArgs, status,
+			 cbDataSize);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = PROC_Ctrl(args->ARGS_PROC_CTRL.hProcessor,
+				  args->ARGS_PROC_CTRL.dwCmd,
+				  (struct DSP_CBDATA *)pArgs);
+	}
+
+	/* cp_to_usr(args->ARGS_PROC_CTRL.pArgs, pArgs, status, 1);*/
+	kfree(pArgs);
+func_end:
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Detach ========
+ */
+u32 __deprecated PROCWRAP_Detach(union Trapped_Args *args, void *pr_ctxt)
+{
+	/* PROC_Detach called at bridge_release only */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_SOK;
+}
+
+/*
+ * ======== PROCWRAP_EnumNode_Info ========
+ */
+u32 PROCWRAP_EnumNode_Info(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	void *aNodeTab[MAX_NODES];
+	u32 uNumNodes;
+	u32 uAllocated;
+
+	if (!args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize)
+		return DSP_ESIZE;
+
+	status = PROC_EnumNodes(args->ARGS_PROC_ENUMNODE_INFO.hProcessor,
+				aNodeTab,
+				args->ARGS_PROC_ENUMNODE_INFO.uNodeTabSize,
+				&uNumNodes, &uAllocated);
+	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.aNodeTab, aNodeTab, status,
+		 uNumNodes);
+	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puNumNodes, &uNumNodes,
+		 status, 1);
+	cp_to_usr(args->ARGS_PROC_ENUMNODE_INFO.puAllocated, &uAllocated,
+		 status, 1);
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_FlushMemory ========
+ */
+u32 PROCWRAP_FlushMemory(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+
+	if (args->ARGS_PROC_FLUSHMEMORY.ulFlags >
+					 PROC_WRITEBACK_INVALIDATE_MEM)
+		return DSP_EINVALIDARG;
+
+	status = PROC_FlushMemory(args->ARGS_PROC_FLUSHMEMORY.hProcessor,
+				 args->ARGS_PROC_FLUSHMEMORY.pMpuAddr,
+				 args->ARGS_PROC_FLUSHMEMORY.ulSize,
+				 args->ARGS_PROC_FLUSHMEMORY.ulFlags);
+	return status;
+}
+
+
+/*
+ * ======== PROCWRAP_InvalidateMemory ========
+ */
+u32 PROCWRAP_InvalidateMemory(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+
+	status = PROC_InvalidateMemory(
+				  args->ARGS_PROC_INVALIDATEMEMORY.hProcessor,
+				  args->ARGS_PROC_INVALIDATEMEMORY.pMpuAddr,
+				  args->ARGS_PROC_INVALIDATEMEMORY.ulSize);
+	return status;
+}
+
+
+/*
+ * ======== PROCWRAP_EnumResources ========
+ */
+u32 PROCWRAP_EnumResources(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_RESOURCEINFO pResourceInfo;
+
+	if (args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize <
+		sizeof(struct DSP_RESOURCEINFO))
+		return DSP_ESIZE;
+
+	status = PROC_GetResourceInfo(args->ARGS_PROC_ENUMRESOURCES.hProcessor,
+			args->ARGS_PROC_ENUMRESOURCES.uResourceType,
+			&pResourceInfo,
+			args->ARGS_PROC_ENUMRESOURCES.uResourceInfoSize);
+
+	cp_to_usr(args->ARGS_PROC_ENUMRESOURCES.pResourceInfo, &pResourceInfo,
+						status, 1);
+
+	return status;
+
+}
+
+/*
+ * ======== PROCWRAP_GetState ========
+ */
+u32 PROCWRAP_GetState(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	struct DSP_PROCESSORSTATE procStatus;
+
+	if (args->ARGS_PROC_GETSTATE.uStateInfoSize <
+		sizeof(struct DSP_PROCESSORSTATE))
+		return DSP_ESIZE;
+
+	status = PROC_GetState(args->ARGS_PROC_GETSTATE.hProcessor, &procStatus,
+			      args->ARGS_PROC_GETSTATE.uStateInfoSize);
+	cp_to_usr(args->ARGS_PROC_GETSTATE.pProcStatus, &procStatus, status, 1);
+	return status;
+
+}
+
+/*
+ * ======== PROCWRAP_GetTrace ========
+ */
+u32 PROCWRAP_GetTrace(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	u8 *pBuf;
+
+	if (args->ARGS_PROC_GETTRACE.uMaxSize > MAX_TRACEBUFLEN)
+		return DSP_ESIZE;
+
+	pBuf = MEM_Calloc(args->ARGS_PROC_GETTRACE.uMaxSize, MEM_NONPAGED);
+	if (pBuf != NULL) {
+		status = PROC_GetTrace(args->ARGS_PROC_GETTRACE.hProcessor,
+				      pBuf, args->ARGS_PROC_GETTRACE.uMaxSize);
+	} else {
+		status = DSP_EMEMORY;
+	}
+	cp_to_usr(args->ARGS_PROC_GETTRACE.pBuf, pBuf, status,
+		 args->ARGS_PROC_GETTRACE.uMaxSize);
+	kfree(pBuf);
+
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Load ========
+ */
+u32 PROCWRAP_Load(union Trapped_Args *args, void *pr_ctxt)
+{
+	s32 i, len;
+	DSP_STATUS status = DSP_SOK;
+	char *temp;
+	s32 count = args->ARGS_PROC_LOAD.iArgc;
+	u8 **argv = NULL, **envp = NULL;
+
+	if (count <= 0 || count > MAX_LOADARGS) {
+		status = DSP_EINVALIDARG;
+		goto func_cont;
+	}
+
+	argv = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+	if (!argv) {
+		status = DSP_EMEMORY;
+		goto func_cont;
+	}
+
+	cp_fm_usr(argv, args->ARGS_PROC_LOAD.aArgv, status, count);
+	if (DSP_FAILED(status)) {
+		kfree(argv);
+		argv = NULL;
+		goto func_cont;
+	}
+
+	for (i = 0; i < count; i++) {
+		if (argv[i]) {
+			/* User space pointer to argument */
+			temp = (char *) argv[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
+			/* Kernel space pointer to argument */
+			argv[i] = MEM_Alloc(len, MEM_NONPAGED);
+			if (argv[i]) {
+				cp_fm_usr(argv[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					kfree(argv[i]);
+					argv[i] = NULL;
+					goto func_cont;
+				}
+			} else {
+				status = DSP_EMEMORY;
+				goto func_cont;
+			}
+		}
+	}
+	/* TODO: validate this */
+	if (args->ARGS_PROC_LOAD.aEnvp) {
+		/* number of elements in the envp array including NULL */
+		count = 0;
+		do {
+			get_user(temp, args->ARGS_PROC_LOAD.aEnvp + count);
+			count++;
+		} while (temp);
+		envp = MEM_Alloc(count * sizeof(u8 *), MEM_NONPAGED);
+		if (!envp) {
+			status = DSP_EMEMORY;
+			goto func_cont;
+		}
+
+		cp_fm_usr(envp, args->ARGS_PROC_LOAD.aEnvp, status, count);
+		if (DSP_FAILED(status)) {
+			kfree(envp);
+			envp = NULL;
+			goto func_cont;
+		}
+		for (i = 0; envp[i]; i++) {
+			/* User space pointer to argument */
+			temp = (char *)envp[i];
+			/* len is increased by 1 to accommodate NULL */
+			len = strlen_user((char *)temp) + 1;
+			/* Kernel space pointer to argument */
+			envp[i] = MEM_Alloc(len, MEM_NONPAGED);
+			if (envp[i]) {
+				cp_fm_usr(envp[i], temp, status, len);
+				if (DSP_FAILED(status)) {
+					kfree(envp[i]);
+					envp[i] = NULL;
+					goto func_cont;
+				}
+			} else {
+				status = DSP_EMEMORY;
+				goto func_cont;
+			}
+		}
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		status = PROC_Load(args->ARGS_PROC_LOAD.hProcessor,
+				args->ARGS_PROC_LOAD.iArgc,
+				(CONST char **)argv, (CONST char **)envp);
+	}
+func_cont:
+	if (envp) {
+		i = 0;
+		while (envp[i])
+			kfree(envp[i++]);
+
+		kfree(envp);
+	}
+
+	if (argv) {
+		count = args->ARGS_PROC_LOAD.iArgc;
+		for (i = 0; (i < count) && argv[i]; i++)
+			kfree(argv[i]);
+
+		kfree(argv);
+	}
+
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Map ========
+ */
+u32 PROCWRAP_Map(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	void *pMapAddr;
+
+	if (!args->ARGS_PROC_MAPMEM.ulSize)
+		return DSP_ESIZE;
+
+	status = PROC_Map(args->ARGS_PROC_MAPMEM.hProcessor,
+			 args->ARGS_PROC_MAPMEM.pMpuAddr,
+			 args->ARGS_PROC_MAPMEM.ulSize,
+			 args->ARGS_PROC_MAPMEM.pReqAddr, &pMapAddr,
+			 args->ARGS_PROC_MAPMEM.ulMapAttr, pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(pMapAddr, args->ARGS_PROC_MAPMEM.ppMapAddr)) {
+			status = DSP_EINVALIDARG;
+			PROC_UnMap(args->ARGS_PROC_MAPMEM.hProcessor,
+				pMapAddr, pr_ctxt);
+		}
+
+	}
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_RegisterNotify ========
+ */
+u32 PROCWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	struct DSP_NOTIFICATION notification;
+
+	/* Initialize the notification data structure  */
+	notification.psName = NULL;
+	notification.handle = NULL;
+
+	status = PROC_RegisterNotify(args->ARGS_PROC_REGISTER_NOTIFY.hProcessor,
+				    args->ARGS_PROC_REGISTER_NOTIFY.uEventMask,
+				    args->ARGS_PROC_REGISTER_NOTIFY.uNotifyType,
+				    &notification);
+	cp_to_usr(args->ARGS_PROC_REGISTER_NOTIFY.hNotification, &notification,
+		 status, 1);
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_ReserveMemory ========
+ */
+u32 PROCWRAP_ReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	void *pRsvAddr;
+
+	if ((args->ARGS_PROC_RSVMEM.ulSize <= 0) ||
+		(args->ARGS_PROC_RSVMEM.ulSize & (PG_SIZE_4K - 1)) != 0)
+		return DSP_ESIZE;
+
+	status = PROC_ReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
+				   args->ARGS_PROC_RSVMEM.ulSize, &pRsvAddr,
+				   pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		if (put_user(pRsvAddr, args->ARGS_PROC_RSVMEM.ppRsvAddr)) {
+			status = DSP_EINVALIDARG;
+			PROC_UnReserveMemory(args->ARGS_PROC_RSVMEM.hProcessor,
+				pRsvAddr, pr_ctxt);
+		}
+	}
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Start ========
+ */
+u32 PROCWRAP_Start(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = PROC_Start(args->ARGS_PROC_START.hProcessor);
+	return retVal;
+}
+
+/*
+ * ======== PROCWRAP_UnMap ========
+ */
+u32 PROCWRAP_UnMap(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+
+	status = PROC_UnMap(args->ARGS_PROC_UNMAPMEM.hProcessor,
+			   args->ARGS_PROC_UNMAPMEM.pMapAddr, pr_ctxt);
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_UnReserveMemory ========
+ */
+u32 PROCWRAP_UnReserveMemory(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+
+	status = PROC_UnReserveMemory(args->ARGS_PROC_UNRSVMEM.hProcessor,
+			     args->ARGS_PROC_UNRSVMEM.pRsvAddr, pr_ctxt);
+	return status;
+}
+
+/*
+ * ======== PROCWRAP_Stop ========
+ */
+u32 PROCWRAP_Stop(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = PROC_Stop(args->ARGS_PROC_STOP.hProcessor);
+
+	return retVal;
+}
+
+/*
+ * ======== NODEWRAP_Allocate ========
+ */
+u32 NODEWRAP_Allocate(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_UUID nodeId;
+	u32 cbDataSize = 0;
+	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_ALLOCATE.pArgs;
+	u8 *pArgs = NULL;
+	struct DSP_NODEATTRIN attrIn, *pAttrIn = NULL;
+	struct NODE_OBJECT *hNode;
+
+	/* Optional argument */
+	if (pSize) {
+		if (get_user(cbDataSize, pSize))
+			status = DSP_EFAIL;
+
+		cbDataSize += sizeof(u32);
+		if (DSP_SUCCEEDED(status)) {
+			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
+			if (pArgs == NULL)
+				status = DSP_EMEMORY;
+
+		}
+		cp_fm_usr(pArgs, args->ARGS_NODE_ALLOCATE.pArgs, status,
+			 cbDataSize);
+	}
+	cp_fm_usr(&nodeId, args->ARGS_NODE_ALLOCATE.pNodeID, status, 1);
+	if (DSP_FAILED(status))
+		goto func_cont;
+	/* Optional argument */
+	if (args->ARGS_NODE_ALLOCATE.pAttrIn) {
+		cp_fm_usr(&attrIn, args->ARGS_NODE_ALLOCATE.pAttrIn, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pAttrIn = &attrIn;
+		else
+			status = DSP_EMEMORY;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = NODE_Allocate(args->ARGS_NODE_ALLOCATE.hProcessor,
+				      &nodeId, (struct DSP_CBDATA *)pArgs,
+				      pAttrIn, &hNode, pr_ctxt);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		cp_to_usr(args->ARGS_NODE_ALLOCATE.phNode, &hNode, status, 1);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			NODE_Delete(hNode, pr_ctxt);
+		}
+	}
+func_cont:
+	kfree(pArgs);
+
+	return status;
+}
+
+/*
+ *  ======== NODEWRAP_AllocMsgBuf ========
+ */
+u32 NODEWRAP_AllocMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_BUFFERATTR *pAttr = NULL;
+	struct DSP_BUFFERATTR attr;
+	u8 *pBuffer = NULL;
+
+	if (!args->ARGS_NODE_ALLOCMSGBUF.uSize)
+		return DSP_ESIZE;
+
+	if (args->ARGS_NODE_ALLOCMSGBUF.pAttr) {	/* Optional argument */
+		cp_fm_usr(&attr, args->ARGS_NODE_ALLOCMSGBUF.pAttr, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pAttr = &attr;
+
+	}
+	/* IN OUT argument */
+	cp_fm_usr(&pBuffer, args->ARGS_NODE_ALLOCMSGBUF.pBuffer, status, 1);
+	if (DSP_SUCCEEDED(status)) {
+		status = NODE_AllocMsgBuf(args->ARGS_NODE_ALLOCMSGBUF.hNode,
+					 args->ARGS_NODE_ALLOCMSGBUF.uSize,
+					 pAttr, &pBuffer);
+	}
+	cp_to_usr(args->ARGS_NODE_ALLOCMSGBUF.pBuffer, &pBuffer, status, 1);
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_ChangePriority ========
+ */
+u32 NODEWRAP_ChangePriority(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = NODE_ChangePriority(args->ARGS_NODE_CHANGEPRIORITY.hNode,
+			args->ARGS_NODE_CHANGEPRIORITY.iPriority);
+
+	return retVal;
+}
+
+/*
+ * ======== NODEWRAP_Connect ========
+ */
+u32 NODEWRAP_Connect(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_STRMATTR attrs;
+	struct DSP_STRMATTR *pAttrs = NULL;
+	u32 cbDataSize;
+	u32 __user *pSize = (u32 __user *)args->ARGS_NODE_CONNECT.pConnParam;
+	u8 *pArgs = NULL;
+
+	/* Optional argument */
+	if (pSize) {
+		if (get_user(cbDataSize, pSize))
+			status = DSP_EFAIL;
+
+		cbDataSize += sizeof(u32);
+		if (DSP_SUCCEEDED(status)) {
+			pArgs = MEM_Alloc(cbDataSize, MEM_NONPAGED);
+			if (pArgs == NULL) {
+				status = DSP_EMEMORY;
+				goto func_cont;
+			}
+
+		}
+		cp_fm_usr(pArgs, args->ARGS_NODE_CONNECT.pConnParam, status,
+			 cbDataSize);
+		if (DSP_FAILED(status))
+			goto func_cont;
+	}
+	if (args->ARGS_NODE_CONNECT.pAttrs) {	/* Optional argument */
+		cp_fm_usr(&attrs, args->ARGS_NODE_CONNECT.pAttrs, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pAttrs = &attrs;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = NODE_Connect(args->ARGS_NODE_CONNECT.hNode,
+				     args->ARGS_NODE_CONNECT.uStream,
+				     args->ARGS_NODE_CONNECT.hOtherNode,
+				     args->ARGS_NODE_CONNECT.uOtherStream,
+				     pAttrs, (struct DSP_CBDATA *)pArgs);
+	}
+func_cont:
+	kfree(pArgs);
+
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_Create ========
+ */
+u32 NODEWRAP_Create(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = NODE_Create(args->ARGS_NODE_CREATE.hNode);
+
+	return retVal;
+}
+
+/*
+ * ======== NODEWRAP_Delete ========
+ */
+u32 NODEWRAP_Delete(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = NODE_Delete(args->ARGS_NODE_DELETE.hNode, pr_ctxt);
+
+	return retVal;
+}
+
+/*
+ *  ======== NODEWRAP_FreeMsgBuf ========
+ */
+u32 NODEWRAP_FreeMsgBuf(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_BUFFERATTR *pAttr = NULL;
+	struct DSP_BUFFERATTR attr;
+	if (args->ARGS_NODE_FREEMSGBUF.pAttr) {	/* Optional argument */
+		cp_fm_usr(&attr, args->ARGS_NODE_FREEMSGBUF.pAttr, status, 1);
+		if (DSP_SUCCEEDED(status))
+			pAttr = &attr;
+
+	}
+
+	if (!args->ARGS_NODE_FREEMSGBUF.pBuffer)
+		return DSP_EPOINTER;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = NODE_FreeMsgBuf(args->ARGS_NODE_FREEMSGBUF.hNode,
+					args->ARGS_NODE_FREEMSGBUF.pBuffer,
+					pAttr);
+	}
+
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_GetAttr ========
+ */
+u32 NODEWRAP_GetAttr(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_NODEATTR attr;
+
+	status = NODE_GetAttr(args->ARGS_NODE_GETATTR.hNode, &attr,
+			     args->ARGS_NODE_GETATTR.uAttrSize);
+	cp_to_usr(args->ARGS_NODE_GETATTR.pAttr, &attr, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_GetMessage ========
+ */
+u32 NODEWRAP_GetMessage(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	struct DSP_MSG msg;
+
+	status = NODE_GetMessage(args->ARGS_NODE_GETMESSAGE.hNode, &msg,
+				args->ARGS_NODE_GETMESSAGE.uTimeout);
+
+	cp_to_usr(args->ARGS_NODE_GETMESSAGE.pMessage, &msg, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_Pause ========
+ */
+u32 NODEWRAP_Pause(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = NODE_Pause(args->ARGS_NODE_PAUSE.hNode);
+
+	return retVal;
+}
+
+/*
+ * ======== NODEWRAP_PutMessage ========
+ */
+u32 NODEWRAP_PutMessage(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_MSG msg;
+
+	cp_fm_usr(&msg, args->ARGS_NODE_PUTMESSAGE.pMessage, status, 1);
+
+	if (DSP_SUCCEEDED(status)) {
+		status = NODE_PutMessage(args->ARGS_NODE_PUTMESSAGE.hNode, &msg,
+					args->ARGS_NODE_PUTMESSAGE.uTimeout);
+	}
+
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_RegisterNotify ========
+ */
+u32 NODEWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_NOTIFICATION notification;
+
+	/* Initialize the notification data structure  */
+	notification.psName = NULL;
+	notification.handle = NULL;
+
+	if (!args->ARGS_PROC_REGISTER_NOTIFY.uEventMask)
+		cp_fm_usr(&notification,
+			args->ARGS_PROC_REGISTER_NOTIFY.hNotification,
+			status, 1);
+
+	status = NODE_RegisterNotify(args->ARGS_NODE_REGISTERNOTIFY.hNode,
+				    args->ARGS_NODE_REGISTERNOTIFY.uEventMask,
+				    args->ARGS_NODE_REGISTERNOTIFY.uNotifyType,
+				    &notification);
+	cp_to_usr(args->ARGS_NODE_REGISTERNOTIFY.hNotification, &notification,
+		 status, 1);
+	return status;
+}
+
+/*
+ * ======== NODEWRAP_Run ========
+ */
+u32 NODEWRAP_Run(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = NODE_Run(args->ARGS_NODE_RUN.hNode);
+
+	return retVal;
+}
+
+/*
+ * ======== NODEWRAP_Terminate ========
+ */
+u32 NODEWRAP_Terminate(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	DSP_STATUS tempstatus;
+
+	status = NODE_Terminate(args->ARGS_NODE_TERMINATE.hNode, &tempstatus);
+
+	cp_to_usr(args->ARGS_NODE_TERMINATE.pStatus, &tempstatus, status, 1);
+
+	return status;
+}
+
+
+/*
+ * ======== NODEWRAP_GetUUIDProps ========
+ */
+u32 NODEWRAP_GetUUIDProps(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_UUID nodeId;
+	struct DSP_NDBPROPS    *pnodeProps = NULL;
+
+	cp_fm_usr(&nodeId, args->ARGS_NODE_GETUUIDPROPS.pNodeID, status, 1);
+	if (DSP_FAILED(status))
+		goto func_cont;
+	pnodeProps = MEM_Alloc(sizeof(struct DSP_NDBPROPS), MEM_NONPAGED);
+	if (pnodeProps != NULL) {
+		status = NODE_GetUUIDProps(args->
+					  ARGS_NODE_GETUUIDPROPS.hProcessor,
+					  &nodeId, pnodeProps);
+		cp_to_usr(args->ARGS_NODE_GETUUIDPROPS.pNodeProps, pnodeProps,
+			 status, 1);
+	} else
+		status = DSP_EMEMORY;
+func_cont:
+	kfree(pnodeProps);
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_AllocateBuffer ========
+ */
+u32 STRMWRAP_AllocateBuffer(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status;
+	u8 **apBuffer = NULL;
+	u32 uNumBufs = args->ARGS_STRM_ALLOCATEBUFFER.uNumBufs;
+
+	if (uNumBufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
+
+	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+
+	status = STRM_AllocateBuffer(args->ARGS_STRM_ALLOCATEBUFFER.hStream,
+				     args->ARGS_STRM_ALLOCATEBUFFER.uSize,
+				     apBuffer, uNumBufs, pr_ctxt);
+	if (DSP_SUCCEEDED(status)) {
+		cp_to_usr(args->ARGS_STRM_ALLOCATEBUFFER.apBuffer, apBuffer,
+			status, uNumBufs);
+		if (DSP_FAILED(status)) {
+			status = DSP_EPOINTER;
+			STRM_FreeBuffer(
+				args->ARGS_STRM_ALLOCATEBUFFER.hStream,
+				apBuffer, uNumBufs, pr_ctxt);
+		}
+	}
+	kfree(apBuffer);
+
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_Close ========
+ */
+u32 STRMWRAP_Close(union Trapped_Args *args, void *pr_ctxt)
+{
+	return STRM_Close(args->ARGS_STRM_CLOSE.hStream, pr_ctxt);
+}
+
+/*
+ * ======== STRMWRAP_FreeBuffer ========
+ */
+u32 STRMWRAP_FreeBuffer(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	u8 **apBuffer = NULL;
+	u32 uNumBufs = args->ARGS_STRM_FREEBUFFER.uNumBufs;
+
+	if (uNumBufs > MAX_BUFS)
+		return DSP_EINVALIDARG;
+
+	apBuffer = MEM_Alloc((uNumBufs * sizeof(u8 *)), MEM_NONPAGED);
+
+	cp_fm_usr(apBuffer, args->ARGS_STRM_FREEBUFFER.apBuffer, status,
+		 uNumBufs);
+
+	if (DSP_SUCCEEDED(status)) {
+		status = STRM_FreeBuffer(args->ARGS_STRM_FREEBUFFER.hStream,
+					 apBuffer, uNumBufs, pr_ctxt);
+	}
+	cp_to_usr(args->ARGS_STRM_FREEBUFFER.apBuffer, apBuffer, status,
+		 uNumBufs);
+	kfree(apBuffer);
+
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_GetEventHandle ========
+ */
+u32 __deprecated STRMWRAP_GetEventHandle(union Trapped_Args *args,
+					void *pr_ctxt)
+{
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_ENOTIMPL;
+}
+
+/*
+ * ======== STRMWRAP_GetInfo ========
+ */
+u32 STRMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_INFO strmInfo;
+	struct DSP_STREAMINFO user;
+	struct DSP_STREAMINFO *temp;
+
+	cp_fm_usr(&strmInfo, args->ARGS_STRM_GETINFO.pStreamInfo, status, 1);
+	temp = strmInfo.pUser;
+
+	strmInfo.pUser = &user;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = STRM_GetInfo(args->ARGS_STRM_GETINFO.hStream,
+			 &strmInfo, args->ARGS_STRM_GETINFO.uStreamInfoSize);
+	}
+	cp_to_usr(temp, strmInfo.pUser, status, 1);
+	strmInfo.pUser = temp;
+	cp_to_usr(args->ARGS_STRM_GETINFO.pStreamInfo, &strmInfo, status, 1);
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_Idle ========
+ */
+u32 STRMWRAP_Idle(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 retVal;
+
+	retVal = STRM_Idle(args->ARGS_STRM_IDLE.hStream,
+			args->ARGS_STRM_IDLE.bFlush);
+
+	return retVal;
+}
+
+/*
+ * ======== STRMWRAP_Issue ========
+ */
+u32 STRMWRAP_Issue(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	if (!args->ARGS_STRM_ISSUE.pBuffer)
+		return DSP_EPOINTER;
+
+	/* No need of doing cp_fm_usr for the user buffer (pBuffer)
+	as this is done in Bridge internal function WMD_CHNL_AddIOReq
+	in chnl_sm.c */
+	status = STRM_Issue(args->ARGS_STRM_ISSUE.hStream,
+			args->ARGS_STRM_ISSUE.pBuffer,
+			args->ARGS_STRM_ISSUE.dwBytes,
+			args->ARGS_STRM_ISSUE.dwBufSize,
+			args->ARGS_STRM_ISSUE.dwArg);
+
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_Open ========
+ */
+u32 STRMWRAP_Open(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_ATTR attr;
+	struct STRM_OBJECT *pStrm;
+	struct DSP_STREAMATTRIN strmAttrIn;
+
+	cp_fm_usr(&attr, args->ARGS_STRM_OPEN.pAttrIn, status, 1);
+
+	if (attr.pStreamAttrIn != NULL) {	/* Optional argument */
+		cp_fm_usr(&strmAttrIn, attr.pStreamAttrIn, status, 1);
+		if (DSP_SUCCEEDED(status)) {
+			attr.pStreamAttrIn = &strmAttrIn;
+			if (attr.pStreamAttrIn->lMode == STRMMODE_LDMA)
+				return DSP_ENOTIMPL;
+		}
+
+	}
+	status = STRM_Open(args->ARGS_STRM_OPEN.hNode,
+			  args->ARGS_STRM_OPEN.uDirection,
+			  args->ARGS_STRM_OPEN.uIndex, &attr, &pStrm,
+			  pr_ctxt);
+	cp_to_usr(args->ARGS_STRM_OPEN.phStream, &pStrm, status, 1);
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_Reclaim ========
+ */
+u32 STRMWRAP_Reclaim(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	u8 *pBufPtr;
+	u32 ulBytes;
+	u32 dwArg;
+	u32 ulBufSize;
+
+	status = STRM_Reclaim(args->ARGS_STRM_RECLAIM.hStream, &pBufPtr,
+			     &ulBytes, &ulBufSize, &dwArg);
+	cp_to_usr(args->ARGS_STRM_RECLAIM.pBufPtr, &pBufPtr, status, 1);
+	cp_to_usr(args->ARGS_STRM_RECLAIM.pBytes, &ulBytes, status, 1);
+	cp_to_usr(args->ARGS_STRM_RECLAIM.pdwArg, &dwArg, status, 1);
+
+	if (args->ARGS_STRM_RECLAIM.pBufSize != NULL) {
+		cp_to_usr(args->ARGS_STRM_RECLAIM.pBufSize, &ulBufSize,
+			 status, 1);
+	}
+
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_RegisterNotify ========
+ */
+u32 STRMWRAP_RegisterNotify(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_NOTIFICATION notification;
+
+	/* Initialize the notification data structure  */
+	notification.psName = NULL;
+	notification.handle = NULL;
+
+	status = STRM_RegisterNotify(args->ARGS_STRM_REGISTERNOTIFY.hStream,
+				    args->ARGS_STRM_REGISTERNOTIFY.uEventMask,
+				    args->ARGS_STRM_REGISTERNOTIFY.uNotifyType,
+				    &notification);
+	cp_to_usr(args->ARGS_STRM_REGISTERNOTIFY.hNotification, &notification,
+		 status, 1);
+
+	return status;
+}
+
+/*
+ * ======== STRMWRAP_Select ========
+ */
+u32 STRMWRAP_Select(union Trapped_Args *args, void *pr_ctxt)
+{
+	u32 mask;
+	struct STRM_OBJECT *aStrmTab[MAX_STREAMS];
+	DSP_STATUS status = DSP_SOK;
+
+	if (args->ARGS_STRM_SELECT.nStreams > MAX_STREAMS)
+		return DSP_EINVALIDARG;
+
+	cp_fm_usr(aStrmTab, args->ARGS_STRM_SELECT.aStreamTab, status,
+		 args->ARGS_STRM_SELECT.nStreams);
+	if (DSP_SUCCEEDED(status)) {
+		status = STRM_Select(aStrmTab, args->ARGS_STRM_SELECT.nStreams,
+				    &mask, args->ARGS_STRM_SELECT.uTimeout);
+	}
+	cp_to_usr(args->ARGS_STRM_SELECT.pMask, &mask, status, 1);
+	return status;
+}
+
+/* CMM */
+
+/*
+ * ======== CMMWRAP_CallocBuf ========
+ */
+u32 __deprecated CMMWRAP_CallocBuf(union Trapped_Args *args, void *pr_ctxt)
+{
+	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_ENOTIMPL;
+}
+
+/*
+ * ======== CMMWRAP_FreeBuf ========
+ */
+u32 __deprecated CMMWRAP_FreeBuf(union Trapped_Args *args, void *pr_ctxt)
+{
+	/* This operation is done in kernel */
+	pr_err("%s: deprecated dspbridge ioctl\n", __func__);
+	return DSP_ENOTIMPL;
+}
+
+/*
+ * ======== CMMWRAP_GetHandle ========
+ */
+u32 CMMWRAP_GetHandle(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_OBJECT *hCmmMgr;
+
+	status = CMM_GetHandle(args->ARGS_CMM_GETHANDLE.hProcessor, &hCmmMgr);
+
+	cp_to_usr(args->ARGS_CMM_GETHANDLE.phCmmMgr, &hCmmMgr, status, 1);
+
+	return status;
+}
+
+/*
+ * ======== CMMWRAP_GetInfo ========
+ */
+u32 CMMWRAP_GetInfo(union Trapped_Args *args, void *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_INFO cmmInfo;
+
+	status = CMM_GetInfo(args->ARGS_CMM_GETINFO.hCmmMgr, &cmmInfo);
+
+	cp_to_usr(args->ARGS_CMM_GETINFO.pCmmInfo, &cmmInfo, status, 1);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/rmgr/dbdcd.c b/drivers/dsp/bridge/rmgr/dbdcd.c
new file mode 100644
index 0000000..a45dde5
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/dbdcd.c
@@ -0,0 +1,1377 @@
+/*
+ * dbdcd.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * This file contains the implementation of the DSP/BIOS Bridge
+ * Configuration Database (DCD).
+ *
+ * Notes:
+ *   The fxn DCD_GetObjects can apply a callback fxn to each DCD object
+ *   that is located in a specified COFF file.  At the moment,
+ *   DCD_AutoRegister, DCD_AutoUnregister, and NLDR module all use
+ *   DCD_GetObjects.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/reg.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/cod.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/uuidutil.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/dbdcd.h>
+
+/*  ----------------------------------- Global defines. */
+#define SIGNATURE       0x5f444344	/* "DCD_" (in reverse). */
+
+#define IsValidHandle(h)	(((h) != NULL) && (h->dwSignature == SIGNATURE))
+
+#define MAX_INT2CHAR_LENGTH     16   /* Maximum int2char len of 32 bit int. */
+
+/* Name of section containing dependent libraries */
+#define DEPLIBSECT		".dspbridge_deplibs"
+
+/* DCD specific structures. */
+struct DCD_MANAGER {
+	u32 dwSignature;	/* Used for object validation.   */
+	struct COD_MANAGER *hCodMgr;	/* Handle to COD manager object. */
+};
+
+/* Global reference variables. */
+static u32 cRefs;
+static u32 cEnumRefs;
+
+/* Helper function prototypes. */
+static s32 Atoi(char *pszBuf);
+static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
+				  enum DSP_DCDOBJTYPE objType,
+				  struct DCD_GENERICOBJ *pGenObj);
+static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize);
+static char DspChar2GppChar(char *pWord, s32 cDspCharSize);
+static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
+				IN struct DSP_UUID *pUuid,
+				IN OUT u16 *pNumLibs,
+				OPTIONAL OUT u16 *pNumPersLibs,
+				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
+				OPTIONAL OUT bool *pPersistentDepLibs,
+				IN enum NLDR_PHASE phase);
+
+/*
+ *  ======== DCD_AutoRegister ========
+ *  Purpose:
+ *      Parses the supplied image and resigsters with DCD.
+ */
+DSP_STATUS DCD_AutoRegister(IN struct DCD_MANAGER *hDcdMgr,
+				IN char *pszCoffPath)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (IsValidHandle(hDcdMgr))
+		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
+					(DCD_REGISTERFXN)DCD_RegisterObject,
+					(void *)pszCoffPath);
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+/*
+ *  ======== DCD_AutoUnregister ========
+ *  Purpose:
+ *      Parses the supplied DSP image and unresiters from DCD.
+ */
+DSP_STATUS DCD_AutoUnregister(IN struct DCD_MANAGER *hDcdMgr,
+				IN char *pszCoffPath)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (IsValidHandle(hDcdMgr))
+		status = DCD_GetObjects(hDcdMgr, pszCoffPath,
+				(DCD_REGISTERFXN)DCD_RegisterObject, NULL);
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+/*
+ *  ======== DCD_CreateManager ========
+ *  Purpose:
+ *      Creates DCD manager.
+ */
+DSP_STATUS DCD_CreateManager(IN char *pszZlDllName,
+				OUT struct DCD_MANAGER **phDcdMgr)
+{
+	struct COD_MANAGER *hCodMgr;		/* COD manager handle */
+	struct DCD_MANAGER *pDcdMgr = NULL;	/* DCD Manager pointer */
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs >= 0);
+	DBC_Require(phDcdMgr);
+
+	status = COD_Create(&hCodMgr, pszZlDllName, NULL);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Create a DCD object. */
+	MEM_AllocObject(pDcdMgr, struct DCD_MANAGER, SIGNATURE);
+	if (pDcdMgr != NULL) {
+		/* Fill out the object. */
+		pDcdMgr->hCodMgr = hCodMgr;
+
+		/* Return handle to this DCD interface. */
+		*phDcdMgr = pDcdMgr;
+	} else {
+		status = DSP_EMEMORY;
+
+		/*
+		 * If allocation of DcdManager object failed, delete the
+		 * COD manager.
+		 */
+		COD_Delete(hCodMgr);
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status)) || ((hCodMgr == NULL) &&
+			(status == DSP_EFAIL)) || ((pDcdMgr == NULL) &&
+			(status == DSP_EMEMORY)));
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== DCD_DestroyManager ========
+ *  Purpose:
+ *      Frees DCD Manager object.
+ */
+DSP_STATUS DCD_DestroyManager(IN struct DCD_MANAGER *hDcdMgr)
+{
+	struct DCD_MANAGER *pDcdMgr = hDcdMgr;
+	DSP_STATUS status = DSP_EHANDLE;
+
+	DBC_Require(cRefs >= 0);
+
+	if (IsValidHandle(hDcdMgr)) {
+		/* Delete the COD manager. */
+		COD_Delete(pDcdMgr->hCodMgr);
+
+		/* Deallocate a DCD manager object. */
+		MEM_FreeObject(pDcdMgr);
+
+		status = DSP_SOK;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DCD_EnumerateObject ========
+ *  Purpose:
+ *      Enumerates objects in the DCD.
+ */
+DSP_STATUS DCD_EnumerateObject(IN s32 cIndex, IN enum DSP_DCDOBJTYPE objType,
+			       OUT struct DSP_UUID *pUuid)
+{
+	DSP_STATUS status = DSP_SOK;
+	char szRegKey[REG_MAXREGPATHLENGTH];
+	char szValue[REG_MAXREGPATHLENGTH];
+	char szData[REG_MAXREGPATHLENGTH];
+	u32 dwValueSize;
+	u32 dwDataSize;
+	struct DSP_UUID dspUuid;
+	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
+	u32 dwKeyLen = 0;
+
+	DBC_Require(cRefs >= 0);
+	DBC_Require(cIndex >= 0);
+	DBC_Require(pUuid != NULL);
+
+	if ((cIndex != 0) && (cEnumRefs == 0)) {
+		/*
+		 * If an enumeration is being performed on an index greater
+		 * than zero, then the current cEnumRefs must have been
+		 * incremented to greater than zero.
+		 */
+		status = DSP_ECHANGEDURINGENUM;
+	} else {
+		/* Enumerate a specific key in the registry by index. */
+		dwValueSize = REG_MAXREGPATHLENGTH;
+		dwDataSize = REG_MAXREGPATHLENGTH;
+
+		/*
+		 * Pre-determine final key length. It's length of DCD_REGKEY +
+		 *  "_\0" + length of szObjType string + terminating NULL.
+		 */
+		dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+		DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
+		/* Create proper REG key; concatenate DCD_REGKEY with
+		 * objType. */
+		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(szRegKey) + strlen("_\0")) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, "_\0", 2);
+		} else {
+			status = DSP_EFAIL;
+		}
+
+		/* This snprintf is guaranteed not to exceed max size of an
+		 * integer. */
+		status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d",
+				 objType);
+
+		if (status == -1) {
+			status = DSP_EFAIL;
+		} else {
+			status = DSP_SOK;
+			if ((strlen(szRegKey) + strlen(szObjType)) <
+			   REG_MAXREGPATHLENGTH) {
+				strncat(szRegKey, szObjType,
+					strlen(szObjType) + 1);
+			} else {
+				status = DSP_EFAIL;
+			}
+		}
+
+		if (DSP_SUCCEEDED(status)) {
+			status = REG_EnumValue(cIndex, szRegKey, szValue,
+					&dwValueSize, szData, &dwDataSize);
+		}
+
+		if (DSP_SUCCEEDED(status)) {
+			/* Create UUID value using string retrieved from
+			 * registry. */
+			UUID_UuidFromString(szValue, &dspUuid);
+
+			*pUuid = dspUuid;
+
+			/* Increment cEnumRefs to update reference count. */
+			cEnumRefs++;
+
+			status = DSP_SOK;
+		} else if (status == REG_E_NOMOREITEMS) {
+			/* At the end of enumeration. Reset cEnumRefs. */
+			cEnumRefs = 0;
+
+			status = DSP_SENUMCOMPLETE;
+		} else {
+			status = DSP_EFAIL;
+		}
+	}
+
+	DBC_Ensure(pUuid || (status == DSP_EFAIL));
+
+	return status;
+}
+
+/*
+ *  ======== DCD_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the DCD module.
+ */
+void DCD_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+	if (cRefs == 0) {
+		COD_Exit();
+	}
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== DCD_GetDepLibs ========
+ */
+DSP_STATUS DCD_GetDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+			 IN struct DSP_UUID *pUuid,
+			 u16 numLibs, OUT struct DSP_UUID *pDepLibUuids,
+			 OUT bool *pPersistentDepLibs, IN enum NLDR_PHASE phase)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(hDcdMgr));
+	DBC_Require(pUuid != NULL);
+	DBC_Require(pDepLibUuids != NULL);
+	DBC_Require(pPersistentDepLibs != NULL);
+
+	status = GetDepLibInfo(hDcdMgr, pUuid, &numLibs, NULL, pDepLibUuids,
+			      pPersistentDepLibs, phase);
+
+	return status;
+}
+
+/*
+ *  ======== DCD_GetNumDepLibs ========
+ */
+DSP_STATUS DCD_GetNumDepLibs(IN struct DCD_MANAGER *hDcdMgr,
+			    IN struct DSP_UUID *pUuid, OUT u16 *pNumLibs,
+			    OUT u16 *pNumPersLibs, IN enum NLDR_PHASE phase)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(IsValidHandle(hDcdMgr));
+	DBC_Require(pNumLibs != NULL);
+	DBC_Require(pNumPersLibs != NULL);
+	DBC_Require(pUuid != NULL);
+
+	status = GetDepLibInfo(hDcdMgr, pUuid, pNumLibs, pNumPersLibs,
+				NULL, NULL, phase);
+
+	return status;
+}
+
+/*
+ *  ======== DCD_GetObjectDef ========
+ *  Purpose:
+ *      Retrieves the properties of a node or processor based on the UUID and
+ *      object type.
+ */
+DSP_STATUS DCD_GetObjectDef(IN struct DCD_MANAGER *hDcdMgr,
+			IN struct DSP_UUID *pObjUuid,
+			IN enum DSP_DCDOBJTYPE objType,
+			OUT struct DCD_GENERICOBJ *pObjDef)
+{
+	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
+	struct COD_LIBRARYOBJ *lib = NULL;
+	DSP_STATUS status = DSP_SOK;
+	u32 ulAddr = 0;	/* Used by COD_GetSection */
+	u32 ulLen = 0;	/* Used by COD_GetSection */
+	u32 dwBufSize;	/* Used by REG functions */
+	char szRegKey[REG_MAXREGPATHLENGTH];
+	char *szUuid;		/*[MAXUUIDLEN];*/
+	char szRegData[REG_MAXREGPATHLENGTH];
+	char szSectName[MAXUUIDLEN + 2];	/* ".[UUID]\0" */
+	char *pszCoffBuf;
+	u32 dwKeyLen;		/* Len of REG key. */
+	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pObjDef != NULL);
+	DBC_Require(pObjUuid != NULL);
+
+	szUuid = (char *)MEM_Calloc(MAXUUIDLEN, MEM_PAGED);
+	if (!szUuid) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	if (!IsValidHandle(hDcdMgr)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	/* Pre-determine final key length. It's length of DCD_REGKEY +
+	 *  "_\0" + length of szObjType string + terminating NULL */
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
+	else
+		status = DSP_EFAIL;
+
+	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	if (status == -1) {
+		status = DSP_EFAIL;
+	} else {
+		status = DSP_SOK;
+
+		if ((strlen(szRegKey) + strlen(szObjType)) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		} else {
+			status = DSP_EFAIL;
+		}
+
+		/* Create UUID value to set in registry. */
+		UUID_UuidToString(pObjUuid, szUuid, MAXUUIDLEN);
+
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
+			status = DSP_EFAIL;
+
+		/* Retrieve paths from the registry based on struct DSP_UUID */
+		dwBufSize = REG_MAXREGPATHLENGTH;
+	}
+	if (DSP_SUCCEEDED(status))
+		status = REG_GetValue(szRegKey, (u8 *)szRegData, &dwBufSize);
+
+	if (DSP_FAILED(status)) {
+		status = DSP_EUUID;
+		goto func_end;
+	}
+
+	/* Open COFF file. */
+	status = COD_Open(pDcdMgr->hCodMgr, szRegData, COD_NOLOAD, &lib);
+	if (DSP_FAILED(status)) {
+		status = DSP_EDCDLOADBASE;
+		goto func_end;
+	}
+
+	/* Ensure szUuid + 1 is not greater than sizeof szSectName. */
+	DBC_Assert((strlen(szUuid) + 1) < sizeof(szSectName));
+
+	/* Create section name based on node UUID. A period is
+	 * pre-pended to the UUID string to form the section name.
+	 * I.e. ".24BC8D90_BB45_11d4_B756_006008BDB66F" */
+	strncpy(szSectName, ".", 2);
+	strncat(szSectName, szUuid, strlen(szUuid));
+
+	/* Get section information. */
+	status = COD_GetSection(lib, szSectName, &ulAddr, &ulLen);
+	if (DSP_FAILED(status)) {
+		status = DSP_EDCDGETSECT;
+		goto func_end;
+	}
+
+	/* Allocate zeroed buffer. */
+	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+#ifdef _DB_TIOMAP
+	if (strstr(szRegData, "iva") == NULL) {
+		/* Locate section by objectID and read its content. */
+		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+	} else {
+		status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
+	}
+#else
+	status = COD_ReadSection(lib, szSectName, pszCoffBuf, ulLen);
+#endif
+	if (DSP_SUCCEEDED(status)) {
+		/* Compres DSP buffer to conform to PC format. */
+		if (strstr(szRegData, "iva") == NULL) {
+			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+		} else {
+			CompressBuf(pszCoffBuf, ulLen, 1);
+			dev_dbg(bridge, "%s: Compressing IVA COFF buffer by 1 "
+						"for IVA!!\n", __func__);
+		}
+
+		/* Parse the content of the COFF buffer. */
+		status = GetAttrsFromBuf(pszCoffBuf, ulLen, objType, pObjDef);
+		if (DSP_FAILED(status))
+			status = DSP_EDCDPARSESECT;
+	} else {
+		status = DSP_EDCDREADSECT;
+	}
+
+	/* Free the previously allocated dynamic buffer. */
+	kfree(pszCoffBuf);
+func_end:
+	if (lib)
+		COD_Close(lib);
+
+	kfree(szUuid);
+
+	return status;
+}
+
+/*
+ *  ======== DCD_GetObjects ========
+ */
+DSP_STATUS DCD_GetObjects(IN struct DCD_MANAGER *hDcdMgr, IN char *pszCoffPath,
+			 DCD_REGISTERFXN registerFxn, void *handle)
+{
+	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
+	DSP_STATUS status = DSP_SOK;
+	char *pszCoffBuf;
+	char *pszCur;
+	struct COD_LIBRARYOBJ *lib = NULL;
+	u32 ulAddr = 0;	/* Used by COD_GetSection */
+	u32 ulLen = 0;	/* Used by COD_GetSection */
+	char seps[] = ":, ";
+	char *pToken = NULL;
+	struct DSP_UUID dspUuid;
+	s32 cObjectType;
+
+	DBC_Require(cRefs > 0);
+	if (!IsValidHandle(hDcdMgr)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	/* Open DSP coff file, don't load symbols. */
+	status = COD_Open(pDcdMgr->hCodMgr, pszCoffPath, COD_NOLOAD, &lib);
+	if (DSP_FAILED(status)) {
+		status = DSP_EDCDLOADBASE;
+		goto func_cont;
+	}
+
+	/* Get DCD_RESIGER_SECTION section information. */
+	status = COD_GetSection(lib, DCD_REGISTER_SECTION, &ulAddr, &ulLen);
+	if (DSP_FAILED(status) ||  !(ulLen > 0)) {
+		status = DSP_EDCDNOAUTOREGISTER;
+		goto func_cont;
+	}
+
+	/* Allocate zeroed buffer. */
+	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+#ifdef _DB_TIOMAP
+	if (strstr(pszCoffPath, "iva") == NULL) {
+		/* Locate section by objectID and read its content. */
+		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
+					pszCoffBuf, ulLen);
+	} else {
+		dev_dbg(bridge, "%s: Skipped Byte swap for IVA!!\n", __func__);
+		status = COD_ReadSection(lib, DCD_REGISTER_SECTION,
+					pszCoffBuf, ulLen);
+	}
+#else
+	status = COD_ReadSection(lib, DCD_REGISTER_SECTION, pszCoffBuf, ulLen);
+#endif
+	if (DSP_SUCCEEDED(status)) {
+		/* Compress DSP buffer to conform to PC format. */
+		if (strstr(pszCoffPath, "iva") == NULL) {
+			CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+		} else {
+			CompressBuf(pszCoffBuf, ulLen, 1);
+			dev_dbg(bridge, "%s: Compress COFF buffer with 1 word "
+						"for IVA!!\n", __func__);
+		}
+
+		/* Read from buffer and register object in buffer. */
+		pszCur = pszCoffBuf;
+		while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
+			/*  Retrieve UUID string. */
+			UUID_UuidFromString(pToken, &dspUuid);
+
+			/*  Retrieve object type */
+			pToken = strsep(&pszCur, seps);
+
+			/*  Retrieve object type */
+			cObjectType = Atoi(pToken);
+
+			/*
+			 *  Apply registerFxn to the found DCD object.
+			 *  Possible actions include:
+			 *
+			 *  1) Register found DCD object.
+			 *  2) Unregister found DCD object (when handle == NULL)
+			 *  3) Add overlay node.
+			 */
+			status = registerFxn(&dspUuid, cObjectType, handle);
+			if (DSP_FAILED(status)) {
+				/* if error occurs, break from while loop. */
+				break;
+			}
+		}
+	} else {
+		status = DSP_EDCDREADSECT;
+	}
+
+	/* Free the previously allocated dynamic buffer. */
+	kfree(pszCoffBuf);
+func_cont:
+	if (lib)
+		COD_Close(lib);
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== DCD_GetLibraryName ========
+ *  Purpose:
+ *      Retrieves the library name for the given UUID.
+ *
+ */
+DSP_STATUS DCD_GetLibraryName(IN struct DCD_MANAGER *hDcdMgr,
+			IN struct DSP_UUID *pUuid,
+			IN OUT char *pstrLibName, IN OUT u32 *pdwSize,
+			enum NLDR_PHASE phase, OUT bool *fPhaseSplit)
+{
+	char szRegKey[REG_MAXREGPATHLENGTH];
+	char szUuid[MAXUUIDLEN];
+	u32 dwKeyLen;		/* Len of REG key. */
+	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(pUuid != NULL);
+	DBC_Require(pstrLibName != NULL);
+	DBC_Require(pdwSize != NULL);
+	DBC_Require(IsValidHandle(hDcdMgr));
+
+	dev_dbg(bridge, "%s: hDcdMgr %p, pUuid %p, pstrLibName %p, pdwSize "
+					"%p\n", __func__, hDcdMgr, pUuid,
+					pstrLibName, pdwSize);
+
+	/*
+	 *  Pre-determine final key length. It's length of DCD_REGKEY +
+	 *  "_\0" + length of szObjType string + terminating NULL.
+	 */
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
+	else
+		status = DSP_EFAIL;
+
+	switch (phase) {
+	case NLDR_CREATE:
+		/* create phase type */
+		sprintf(szObjType, "%d", DSP_DCDCREATELIBTYPE);
+		break;
+	case NLDR_EXECUTE:
+		/* execute phase type */
+		sprintf(szObjType, "%d", DSP_DCDEXECUTELIBTYPE);
+		break;
+	case NLDR_DELETE:
+		/* delete phase type */
+		sprintf(szObjType, "%d", DSP_DCDDELETELIBTYPE);
+		break;
+	case NLDR_NOPHASE:
+		/* known to be a dependent library */
+		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
+		break;
+	default:
+		status = DSP_EINVALIDARG;
+		DBC_Assert(false);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		if ((strlen(szRegKey) + strlen(szObjType)) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		} else {
+			status = DSP_EFAIL;
+		}
+		/* Create UUID value to find match in registry. */
+		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
+		if ((strlen(szRegKey) + MAXUUIDLEN) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		} else {
+			status = DSP_EFAIL;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Retrieve path from the registry based on DSP_UUID */
+		status = REG_GetValue(szRegKey,	(u8 *)pstrLibName, pdwSize);
+	}
+
+	/* If can't find, phases might be registered as generic LIBRARYTYPE */
+	if (DSP_FAILED(status) && phase != NLDR_NOPHASE) {
+		if (fPhaseSplit)
+			*fPhaseSplit = false;
+
+		strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+		if ((strlen(szRegKey) + strlen("_\0")) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, "_\0", 2);
+		} else {
+			status = DSP_EFAIL;
+		}
+		sprintf(szObjType, "%d", DSP_DCDLIBRARYTYPE);
+		if ((strlen(szRegKey) + strlen(szObjType))
+		   < REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		} else {
+			status = DSP_EFAIL;
+		}
+		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
+			status = DSP_EFAIL;
+
+		status = REG_GetValue(szRegKey, (u8 *)pstrLibName, pdwSize);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DCD_Init ========
+ *  Purpose:
+ *      Initialize the DCD module.
+ */
+bool DCD_Init(void)
+{
+	bool fInitCOD;
+	bool fInit = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0) {
+		/* Initialize required modules. */
+		fInitCOD = COD_Init();
+
+		if (!fInitCOD) {
+			fInit = false;
+			/* Exit initialized modules. */
+			if (fInitCOD)
+				COD_Exit();
+		}
+	}
+
+	if (fInit)
+		cRefs++;
+
+	DBC_Ensure((fInit && (cRefs > 0)) || (!fInit && (cRefs == 0)));
+
+	return fInit;
+}
+
+/*
+ *  ======== DCD_RegisterObject ========
+ *  Purpose:
+ *      Registers a node or a processor with the DCD.
+ *      If pszPathName == NULL, unregister the specified DCD object.
+ */
+DSP_STATUS DCD_RegisterObject(IN struct DSP_UUID *pUuid,
+			IN enum DSP_DCDOBJTYPE objType,
+			IN char *pszPathName)
+{
+	DSP_STATUS status = DSP_SOK;
+	char szRegKey[REG_MAXREGPATHLENGTH];
+	char szUuid[MAXUUIDLEN + 1];
+	u32 dwPathSize = 0;
+	u32 dwKeyLen;				/* Len of REG key. */
+	char szObjType[MAX_INT2CHAR_LENGTH];	/* str. rep. of objType. */
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pUuid != NULL);
+	DBC_Require((objType == DSP_DCDNODETYPE) ||
+			(objType == DSP_DCDPROCESSORTYPE) ||
+			(objType == DSP_DCDLIBRARYTYPE) ||
+			(objType == DSP_DCDCREATELIBTYPE) ||
+			(objType == DSP_DCDEXECUTELIBTYPE) ||
+			(objType == DSP_DCDDELETELIBTYPE));
+
+	dev_dbg(bridge, "%s: object UUID %p, objType %d, szPathName %s\n",
+					__func__, pUuid, objType, pszPathName);
+
+	/*
+	 * Pre-determine final key length. It's length of DCD_REGKEY +
+	 *  "_\0" + length of szObjType string + terminating NULL.
+	 */
+	dwKeyLen = strlen(DCD_REGKEY) + 1 + sizeof(szObjType) + 1;
+	DBC_Assert(dwKeyLen < REG_MAXREGPATHLENGTH);
+
+	/* Create proper REG key; concatenate DCD_REGKEY with objType. */
+	strncpy(szRegKey, DCD_REGKEY, strlen(DCD_REGKEY) + 1);
+	if ((strlen(szRegKey) + strlen("_\0")) < REG_MAXREGPATHLENGTH)
+		strncat(szRegKey, "_\0", 2);
+	else {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+
+	status = snprintf(szObjType, MAX_INT2CHAR_LENGTH, "%d", objType);
+	if (status == -1) {
+		status = DSP_EFAIL;
+	} else {
+		status = DSP_SOK;
+		if ((strlen(szRegKey) + strlen(szObjType)) <
+		   REG_MAXREGPATHLENGTH) {
+			strncat(szRegKey, szObjType, strlen(szObjType) + 1);
+		} else
+			status = DSP_EFAIL;
+
+		/* Create UUID value to set in registry. */
+		UUID_UuidToString(pUuid, szUuid, MAXUUIDLEN);
+		if ((strlen(szRegKey) + MAXUUIDLEN) < REG_MAXREGPATHLENGTH)
+			strncat(szRegKey, szUuid, MAXUUIDLEN);
+		else
+			status = DSP_EFAIL;
+	}
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/*
+	 * If pszPathName != NULL, perform registration, otherwise,
+	 * perform unregistration.
+	 */
+	if (pszPathName) {
+		/* Add new reg value (UUID+objType) with COFF path info */
+		dwPathSize = strlen(pszPathName) + 1;
+		status = REG_SetValue(szRegKey, (u8 *)pszPathName, dwPathSize);
+		dev_dbg(bridge, "%s: pszPathName=%s, dwPathSize=%d\n", __func__,
+						pszPathName, dwPathSize);
+	} else {
+		/* Deregister an existing object */
+		status = REG_DeleteValue(szRegKey);
+	}
+
+
+	if (DSP_SUCCEEDED(status)) {
+		/*
+		 *  Because the node database has been updated through a
+		 *  successful object registration/de-registration operation,
+		 *  we need to reset the object enumeration counter to allow
+		 *  current enumerations to reflect this update in the node
+		 *  database.
+		 */
+		cEnumRefs = 0;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== DCD_UnregisterObject ========
+ *  Call DCD_Register object with pszPathName set to NULL to
+ *  perform actual object de-registration.
+ */
+DSP_STATUS DCD_UnregisterObject(IN struct DSP_UUID *pUuid,
+				IN enum DSP_DCDOBJTYPE objType)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pUuid != NULL);
+	DBC_Require((objType == DSP_DCDNODETYPE) ||
+		   (objType == DSP_DCDPROCESSORTYPE) ||
+		   (objType == DSP_DCDLIBRARYTYPE) ||
+		   (objType == DSP_DCDCREATELIBTYPE) ||
+		   (objType == DSP_DCDEXECUTELIBTYPE) ||
+		   (objType == DSP_DCDDELETELIBTYPE));
+
+	/*
+	 *  When DCD_RegisterObject is called with NULL as pathname,
+	 *  it indicates an unregister object operation.
+	 */
+	status = DCD_RegisterObject(pUuid, objType, NULL);
+
+	return status;
+}
+
+/*
+ **********************************************************************
+ * DCD Helper Functions
+ **********************************************************************
+ */
+
+/*
+ *  ======== Atoi ========
+ *  Purpose:
+ *      This function converts strings in decimal or hex format to integers.
+ */
+static s32 Atoi(char *pszBuf)
+{
+	char *pch = pszBuf;
+	s32 base = 0;
+
+	while (isspace(*pch))
+		pch++;
+
+	if (*pch == '-' || *pch == '+') {
+		base = 10;
+		pch++;
+	} else if (*pch && tolower(pch[strlen(pch) - 1]) == 'h') {
+		base = 16;
+	}
+
+	return simple_strtoul(pch, NULL, base);
+}
+
+/*
+ *  ======== GetAttrsFromBuf ========
+ *  Purpose:
+ *      Parse the content of a buffer filled with DSP-side data and
+ *      retrieve an object's attributes from it. IMPORTANT: Assume the
+ *      buffer has been converted from DSP format to GPP format.
+ */
+static DSP_STATUS GetAttrsFromBuf(char *pszBuf, u32 ulBufSize,
+				 enum DSP_DCDOBJTYPE objType,
+				 struct DCD_GENERICOBJ *pGenObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	char seps[] = ", ";
+	char *pszCur;
+	char *token;
+	s32 cLen = 0;
+	u32 i = 0;
+#ifdef _DB_TIOMAP
+	s32 iEntry;
+#endif
+
+	DBC_Require(pszBuf != NULL);
+	DBC_Require(ulBufSize != 0);
+	DBC_Require((objType == DSP_DCDNODETYPE)
+		    || (objType == DSP_DCDPROCESSORTYPE));
+	DBC_Require(pGenObj != NULL);
+
+	switch (objType) {
+	case DSP_DCDNODETYPE:
+		/*
+		 * Parse COFF sect buffer to retrieve individual tokens used
+		 * to fill in object attrs.
+		 */
+		pszCur = pszBuf;
+		token = strsep(&pszCur, seps);
+
+		/* u32 cbStruct */
+		pGenObj->objData.nodeObj.ndbProps.cbStruct =
+				(u32) Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* DSP_UUID uiNodeID */
+		UUID_UuidFromString(token,
+				  &pGenObj->objData.nodeObj.ndbProps.uiNodeID);
+		token = strsep(&pszCur, seps);
+
+		/* acName */
+		DBC_Require(token);
+		cLen = strlen(token);
+		if (cLen > DSP_MAXNAMELEN - 1)
+			cLen = DSP_MAXNAMELEN - 1;
+
+		strncpy(pGenObj->objData.nodeObj.ndbProps.acName,
+			   token, cLen);
+		pGenObj->objData.nodeObj.ndbProps.acName[cLen] = '\0';
+		token = strsep(&pszCur, seps);
+		/* u32 uNodeType */
+		pGenObj->objData.nodeObj.ndbProps.uNodeType = Atoi(token);
+		token = strsep(&pszCur, seps);
+		/* u32 bCacheOnGPP */
+		pGenObj->objData.nodeObj.ndbProps.bCacheOnGPP = Atoi(token);
+		token = strsep(&pszCur, seps);
+		/* DSP_RESOURCEREQMTS dspResourceReqmts */
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.cbStruct =
+				(u32) Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uStaticDataSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uGlobalDataSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uProgramMemSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uWCExecutionTime = Atoi(token);
+		token = strsep(&pszCur, seps);
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uWCPeriod = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uWCDeadline = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uAvgExectionTime = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.nodeObj.ndbProps.dspResourceReqmts.
+			uMinimumPeriod = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* s32 iPriority */
+		pGenObj->objData.nodeObj.ndbProps.iPriority = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uStackSize */
+		pGenObj->objData.nodeObj.ndbProps.uStackSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uSysStackSize */
+		pGenObj->objData.nodeObj.ndbProps.uSysStackSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uStackSeg */
+		pGenObj->objData.nodeObj.ndbProps.uStackSeg = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uMessageDepth */
+		pGenObj->objData.nodeObj.ndbProps.uMessageDepth = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uNumInputStreams */
+		pGenObj->objData.nodeObj.ndbProps.uNumInputStreams =
+			Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uNumOutputStreams */
+		pGenObj->objData.nodeObj.ndbProps.uNumOutputStreams =
+			Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* u32 uTimeout */
+		pGenObj->objData.nodeObj.ndbProps.uTimeout =
+			Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* char *pstrCreatePhaseFxn */
+		DBC_Require(token);
+		cLen = strlen(token);
+		pGenObj->objData.nodeObj.pstrCreatePhaseFxn =
+			MEM_Calloc(cLen + 1, MEM_PAGED);
+		strncpy(pGenObj->objData.nodeObj.pstrCreatePhaseFxn,
+			token, cLen);
+		pGenObj->objData.nodeObj.pstrCreatePhaseFxn[cLen] = '\0';
+		token = strsep(&pszCur, seps);
+
+		/* char *pstrExecutePhaseFxn */
+		DBC_Require(token);
+		cLen = strlen(token);
+		pGenObj->objData.nodeObj.pstrExecutePhaseFxn =
+			 MEM_Calloc(cLen + 1, MEM_PAGED);
+		strncpy(pGenObj->objData.nodeObj.pstrExecutePhaseFxn,
+			token, cLen);
+		pGenObj->objData.nodeObj.pstrExecutePhaseFxn[cLen] = '\0';
+		token = strsep(&pszCur, seps);
+
+		/* char *pstrDeletePhaseFxn */
+		DBC_Require(token);
+		cLen = strlen(token);
+		pGenObj->objData.nodeObj.pstrDeletePhaseFxn =
+			MEM_Calloc(cLen + 1, MEM_PAGED);
+		strncpy(pGenObj->objData.nodeObj.pstrDeletePhaseFxn,
+			token, cLen);
+		pGenObj->objData.nodeObj.pstrDeletePhaseFxn[cLen] = '\0';
+		token = strsep(&pszCur, seps);
+
+		/* Segment id for message buffers */
+		pGenObj->objData.nodeObj.uMsgSegid = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* Message notification type */
+		pGenObj->objData.nodeObj.uMsgNotifyType = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		/* char *pstrIAlgName */
+		if (token) {
+			cLen = strlen(token);
+			pGenObj->objData.nodeObj.pstrIAlgName =
+				MEM_Calloc(cLen + 1, MEM_PAGED);
+			strncpy(pGenObj->objData.nodeObj.pstrIAlgName,
+				token, cLen);
+			pGenObj->objData.nodeObj.pstrIAlgName[cLen] = '\0';
+			token = strsep(&pszCur, seps);
+		}
+
+		/* Load type (static, dynamic, or overlay) */
+		if (token) {
+			pGenObj->objData.nodeObj.usLoadType = Atoi(token);
+			token = strsep(&pszCur, seps);
+		}
+
+		/* Dynamic load data requirements */
+		if (token) {
+			pGenObj->objData.nodeObj.ulDataMemSegMask = Atoi(token);
+			token = strsep(&pszCur, seps);
+		}
+
+		/* Dynamic load code requirements */
+		if (token) {
+			pGenObj->objData.nodeObj.ulCodeMemSegMask = Atoi(token);
+			token = strsep(&pszCur, seps);
+		}
+
+		/* Extract node profiles into node properties */
+		if (token) {
+
+			pGenObj->objData.nodeObj.ndbProps.uCountProfiles =
+				Atoi(token);
+			for (i = 0; i < pGenObj->objData.nodeObj.ndbProps.
+			    uCountProfiles; i++) {
+				token = strsep(&pszCur, seps);
+				if (token) {
+					/* Heap Size for the node */
+					pGenObj->objData.nodeObj.ndbProps.
+						aProfiles[i].ulHeapSize =
+						Atoi(token);
+				}
+			}
+		}
+		token = strsep(&pszCur, seps);
+		if (token) {
+			pGenObj->objData.nodeObj.ndbProps.uStackSegName =
+				(u32)(token);
+		}
+
+		break;
+
+	case DSP_DCDPROCESSORTYPE:
+		/*
+		 * Parse COFF sect buffer to retrieve individual tokens used
+		 * to fill in object attrs.
+		 */
+		pszCur = pszBuf;
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.cbStruct = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.uProcessorFamily = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.uProcessorType = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.uClockRate = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.ulInternalMemSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.ulExternalMemSize = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.uProcessorID = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.tyRunningRTOS = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.nNodeMinPriority = Atoi(token);
+		token = strsep(&pszCur, seps);
+
+		pGenObj->objData.procObj.nNodeMaxPriority = Atoi(token);
+
+#ifdef _DB_TIOMAP
+		/* Proc object may contain additional(extended) attributes. */
+		/* attr must match proc.hxx */
+		for (iEntry = 0; iEntry < 7; iEntry++) {
+			token = strsep(&pszCur, seps);
+			pGenObj->objData.extProcObj.tyTlb[iEntry].ulGppPhys =
+				Atoi(token);
+
+			token = strsep(&pszCur, seps);
+			pGenObj->objData.extProcObj.tyTlb[iEntry].ulDspVirt =
+				Atoi(token);
+		}
+#endif
+
+		break;
+
+	default:
+		status = DSP_EFAIL;
+		break;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== CompressBuffer ========
+ *  Purpose:
+ *      Compress the DSP buffer, if necessary, to conform to PC format.
+ */
+static void CompressBuf(char *pszBuf, u32 ulBufSize, s32 cCharSize)
+{
+	char *p;
+	char ch;
+	char *q;
+
+	p = pszBuf;
+	if (p == NULL)
+		return;
+
+	for (q = pszBuf; q < (pszBuf + ulBufSize);) {
+		ch = DspChar2GppChar(q, cCharSize);
+		if (ch == '\\') {
+			q += cCharSize;
+			ch = DspChar2GppChar(q, cCharSize);
+			switch (ch) {
+			case 't':
+				*p = '\t';
+				break;
+
+			case 'n':
+				*p = '\n';
+				break;
+
+			case 'r':
+				*p = '\r';
+				break;
+
+			case '0':
+				*p = '\0';
+				break;
+
+			default:
+				*p = ch;
+				break;
+			}
+		} else {
+			*p = ch;
+		}
+		p++;
+		q += cCharSize;
+	}
+
+	/* NULL out remainder of buffer. */
+	while (p < q)
+		*p++ = '\0';
+}
+
+/*
+ *  ======== DspChar2GppChar ========
+ *  Purpose:
+ *      Convert DSP char to host GPP char in a portable manner
+ */
+static char DspChar2GppChar(char *pWord, s32 cDspCharSize)
+{
+	char ch = '\0';
+	char *chSrc;
+	s32 i;
+
+	for (chSrc = pWord, i = cDspCharSize; i > 0; i--)
+		ch |= *chSrc++;
+
+	return ch;
+}
+
+/*
+ *  ======== GetDepLibInfo ========
+ */
+static DSP_STATUS GetDepLibInfo(IN struct DCD_MANAGER *hDcdMgr,
+				IN struct DSP_UUID *pUuid,
+				IN OUT u16 *pNumLibs,
+				OPTIONAL OUT u16 *pNumPersLibs,
+				OPTIONAL OUT struct DSP_UUID *pDepLibUuids,
+				OPTIONAL OUT bool *pPersistentDepLibs,
+				enum NLDR_PHASE phase)
+{
+	struct DCD_MANAGER *pDcdMgr = hDcdMgr;	/* pointer to DCD manager */
+	char *pszCoffBuf = NULL;
+	char *pszCur;
+	char *pszFileName = NULL;
+	struct COD_LIBRARYOBJ *lib = NULL;
+	u32 ulAddr = 0;				/* Used by COD_GetSection */
+	u32 ulLen = 0;				/* Used by COD_GetSection */
+	u32 dwDataSize = COD_MAXPATHLENGTH;
+	char seps[] = ", ";
+	char *pToken = NULL;
+	bool fGetUuids = (pDepLibUuids != NULL);
+	u16 nDepLibs = 0;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	DBC_Require(IsValidHandle(hDcdMgr));
+	DBC_Require(pNumLibs != NULL);
+	DBC_Require(pUuid != NULL);
+
+	/*  Initialize to 0 dependent libraries, if only counting number of
+	 *  dependent libraries */
+	if (!fGetUuids) {
+		*pNumLibs = 0;
+		*pNumPersLibs = 0;
+	}
+
+	/* Allocate a buffer for file name */
+	pszFileName = MEM_Calloc(dwDataSize, MEM_PAGED);
+	if (pszFileName == NULL) {
+		status = DSP_EMEMORY;
+	} else {
+		/* Get the name of the library */
+		status = DCD_GetLibraryName(hDcdMgr, pUuid, pszFileName,
+			 &dwDataSize, phase, NULL);
+	}
+
+	/* Open the library */
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_Open(pDcdMgr->hCodMgr, pszFileName,
+				 COD_NOLOAD, &lib);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Get dependent library section information. */
+		status = COD_GetSection(lib, DEPLIBSECT, &ulAddr, &ulLen);
+
+		if (DSP_FAILED(status)) {
+			/* Ok, no dependent libraries */
+			ulLen = 0;
+			status = DSP_SNODEPENDENTLIBS;
+		}
+	}
+
+	if (DSP_FAILED(status) || !(ulLen > 0))
+		goto func_cont;
+
+	/* Allocate zeroed buffer. */
+	pszCoffBuf = MEM_Calloc(ulLen + 4, MEM_PAGED);
+	if (pszCoffBuf == NULL)
+		status = DSP_EMEMORY;
+
+	/* Read section contents. */
+	status = COD_ReadSection(lib, DEPLIBSECT, pszCoffBuf, ulLen);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	/* Compress and format DSP buffer to conform to PC format. */
+	CompressBuf(pszCoffBuf, ulLen, DSPWORDSIZE);
+
+	/* Read from buffer */
+	pszCur = pszCoffBuf;
+	while ((pToken = strsep(&pszCur, seps)) && *pToken != '\0') {
+		if (fGetUuids) {
+			if (nDepLibs >= *pNumLibs) {
+				/* Gone beyond the limit */
+				break;
+			} else {
+				/* Retrieve UUID string. */
+				UUID_UuidFromString(pToken,
+						 &(pDepLibUuids[nDepLibs]));
+				/* Is this library persistent? */
+				pToken = strsep(&pszCur, seps);
+				pPersistentDepLibs[nDepLibs] = Atoi(pToken);
+				nDepLibs++;
+			}
+		} else {
+			/* Advanc to next token */
+			pToken = strsep(&pszCur, seps);
+			if (Atoi(pToken))
+				(*pNumPersLibs)++;
+
+			/* Just counting number of dependent libraries */
+			(*pNumLibs)++;
+		}
+	}
+func_cont:
+	if (lib)
+		COD_Close(lib);
+
+	/* Free previously allocated dynamic buffers. */
+	kfree(pszFileName);
+
+	kfree(pszCoffBuf);
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/rmgr/disp.c b/drivers/dsp/bridge/rmgr/disp.c
new file mode 100644
index 0000000..645f233
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/disp.c
@@ -0,0 +1,738 @@
+/*
+ * disp.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Node Dispatcher interface. Communicates with Resource Manager Server
+ * (RMS) on DSP. Access to RMS is synchronized in NODE.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software;  you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmd.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/chnldefs.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/nodedefs.h>
+#include <dspbridge/nodepriv.h>
+#include <dspbridge/rms_sh.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/disp.h>
+
+#define DISP_SIGNATURE       0x50534944	/* "PSID" */
+
+/* Size of a reply from RMS */
+#define REPLYSIZE (3 * sizeof(RMS_WORD))
+
+/* Reserved channel offsets for communication with RMS */
+#define CHNLTORMSOFFSET       0
+#define CHNLFROMRMSOFFSET     1
+
+#define CHNLIOREQS      1
+
+#define SwapWord(x)     (((u32)(x) >> 16) | ((u32)(x) << 16))
+
+/*
+ *  ======== DISP_OBJECT ========
+ */
+struct DISP_OBJECT {
+	u32 dwSignature; 	/* Used for object validation */
+	struct DEV_OBJECT *hDevObject; 	/* Device for this processor */
+	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
+	struct CHNL_MGR *hChnlMgr; 	/* Channel manager */
+	struct CHNL_OBJECT *hChnlToDsp;   /* Channel for commands to RMS */
+	struct CHNL_OBJECT *hChnlFromDsp;   /* Channel for replies from RMS */
+	u8 *pBuf; 		/* Buffer for commands, replies */
+	u32 ulBufsize; 	/* pBuf size in bytes */
+	u32 ulBufsizeRMS; 	/* pBuf size in RMS words */
+	u32 uCharSize; 		/* Size of DSP character */
+	u32 uWordSize; 		/* Size of DSP word */
+	u32 uDataMauSize; 	/* Size of DSP Data MAU */
+};
+
+static u32 cRefs;
+
+static void DeleteDisp(struct DISP_OBJECT *hDisp);
+static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
+				struct NODE_STRMDEF strmDef, u32 max,
+				u32 uCharsInRMSWord);
+static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
+			     u32 ulBytes, OUT u32 *pdwArg);
+
+/*
+ *  ======== DISP_Create ========
+ *  Create a NODE Dispatcher object.
+ */
+DSP_STATUS DISP_Create(OUT struct DISP_OBJECT **phDispObject,
+		      struct DEV_OBJECT *hDevObject,
+		      IN CONST struct DISP_ATTRS *pDispAttrs)
+{
+	struct DISP_OBJECT *pDisp;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	u32 ulChnlId;
+	struct CHNL_ATTRS chnlAttrs;
+	DSP_STATUS status = DSP_SOK;
+	u32 devType;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDispObject != NULL);
+	DBC_Require(pDispAttrs != NULL);
+	DBC_Require(hDevObject != NULL);
+
+	*phDispObject = NULL;
+
+	/* Allocate Node Dispatcher object */
+	MEM_AllocObject(pDisp, struct DISP_OBJECT, DISP_SIGNATURE);
+	if (pDisp == NULL)
+		status = DSP_EMEMORY;
+	else
+		pDisp->hDevObject = hDevObject;
+
+	/* Get Channel manager and WMD function interface */
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetChnlMgr(hDevObject, &(pDisp->hChnlMgr));
+		if (DSP_SUCCEEDED(status)) {
+			(void) DEV_GetIntfFxns(hDevObject, &pIntfFxns);
+			pDisp->pIntfFxns = pIntfFxns;
+		}
+	}
+
+	/* check device type and decide if streams or messag'ing is used for
+	 * RMS/EDS */
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = DEV_GetDevType(hDevObject, &devType);
+
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	if (devType != DSP_UNIT) {
+		status = DSP_EFAIL;
+		goto func_cont;
+	}
+
+	pDisp->uCharSize = DSPWORDSIZE;
+	pDisp->uWordSize = DSPWORDSIZE;
+	pDisp->uDataMauSize = DSPWORDSIZE;
+	/* Open channels for communicating with the RMS */
+	chnlAttrs.uIOReqs = CHNLIOREQS;
+	chnlAttrs.hEvent = NULL;
+	ulChnlId = pDispAttrs->ulChnlOffset + CHNLTORMSOFFSET;
+	status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlToDsp),
+		 pDisp->hChnlMgr, CHNL_MODETODSP, ulChnlId, &chnlAttrs);
+
+	if (DSP_SUCCEEDED(status)) {
+		ulChnlId = pDispAttrs->ulChnlOffset + CHNLFROMRMSOFFSET;
+		status = (*pIntfFxns->pfnChnlOpen)(&(pDisp->hChnlFromDsp),
+			 pDisp->hChnlMgr, CHNL_MODEFROMDSP, ulChnlId,
+			 &chnlAttrs);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Allocate buffer for commands, replies */
+		pDisp->ulBufsize = pDispAttrs->ulChnlBufSize;
+		pDisp->ulBufsizeRMS = RMS_COMMANDBUFSIZE;
+		pDisp->pBuf = MEM_Calloc(pDisp->ulBufsize, MEM_PAGED);
+		if (pDisp->pBuf == NULL)
+			status = DSP_EMEMORY;
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status))
+		*phDispObject = pDisp;
+	else
+		DeleteDisp(pDisp);
+
+	DBC_Ensure(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
+		  ((DSP_SUCCEEDED(status)) &&
+		  (MEM_IsValidHandle((*phDispObject), DISP_SIGNATURE))));
+	return status;
+}
+
+/*
+ *  ======== DISP_Delete ========
+ *  Delete the NODE Dispatcher.
+ */
+void DISP_Delete(struct DISP_OBJECT *hDisp)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+
+	DeleteDisp(hDisp);
+
+	DBC_Ensure(!MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+}
+
+/*
+ *  ======== DISP_Exit ========
+ *  Discontinue usage of DISP module.
+ */
+void DISP_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== DISP_Init ========
+ *  Initialize the DISP module.
+ */
+bool DISP_Init(void)
+{
+	bool fRetVal = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetVal)
+		cRefs++;
+
+	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
+	return fRetVal;
+}
+
+/*
+ *  ======== DISP_NodeChangePriority ========
+ *  Change the priority of a node currently running on the target.
+ */
+DSP_STATUS DISP_NodeChangePriority(struct DISP_OBJECT *hDisp,
+				  struct NODE_OBJECT *hNode,
+				  u32 ulRMSFxn, NODE_ENV nodeEnv,
+				  s32 nPriority)
+{
+	u32 dwArg;
+	struct RMS_Command *pCommand;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_Require(hNode != NULL);
+
+	/* Send message to RMS to change priority */
+	pCommand = (struct RMS_Command *)(hDisp->pBuf);
+	pCommand->fxn = (RMS_WORD)(ulRMSFxn);
+	pCommand->arg1 = (RMS_WORD)nodeEnv;
+	pCommand->arg2 = nPriority;
+	status = SendMessage(hDisp, NODE_GetTimeout(hNode),
+		 sizeof(struct RMS_Command), &dwArg);
+
+	return status;
+}
+
+/*
+ *  ======== DISP_NodeCreate ========
+ *  Create a node on the DSP by remotely calling the node's create function.
+ */
+DSP_STATUS DISP_NodeCreate(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
+			  u32 ulRMSFxn, u32 ulCreateFxn,
+			  IN CONST struct NODE_CREATEARGS *pArgs,
+			  OUT NODE_ENV *pNodeEnv)
+{
+	struct NODE_MSGARGS msgArgs;
+	struct NODE_TASKARGS taskArgs;
+	struct RMS_Command *pCommand;
+	struct RMS_MsgArgs *pMsgArgs;
+	struct RMS_MoreTaskArgs *pMoreTaskArgs;
+	enum NODE_TYPE nodeType;
+	u32 dwLength;
+	RMS_WORD *pdwBuf = NULL;
+	u32 ulBytes;
+	u32 i;
+	u32 total;
+	u32 uCharsInRMSWord;
+	s32 taskArgsOffset;
+	s32 sioInDefOffset;
+	s32 sioOutDefOffset;
+	s32 sioDefsOffset;
+	s32 argsOffset = -1;
+	s32 offset;
+	struct NODE_STRMDEF strmDef;
+	u32 max;
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_NODEINFO nodeInfo;
+	u32 devType;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_Require(hNode != NULL);
+	DBC_Require(NODE_GetType(hNode) != NODE_DEVICE);
+	DBC_Require(pNodeEnv != NULL);
+
+	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (devType != DSP_UNIT) {
+		dev_dbg(bridge, "%s: unknown device type = 0x%x\n",
+							__func__, devType);
+		goto func_end;
+	}
+	DBC_Require(pArgs != NULL);
+	nodeType = NODE_GetType(hNode);
+	msgArgs = pArgs->asa.msgArgs;
+	max = hDisp->ulBufsizeRMS;    /*Max # of RMS words that can be sent */
+	DBC_Assert(max == RMS_COMMANDBUFSIZE);
+	uCharsInRMSWord = sizeof(RMS_WORD) / hDisp->uCharSize;
+	/* Number of RMS words needed to hold arg data */
+	dwLength = (msgArgs.uArgLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+	/* Make sure msg args and command fit in buffer */
+	total = sizeof(struct RMS_Command) / sizeof(RMS_WORD) +
+		sizeof(struct RMS_MsgArgs)
+		/ sizeof(RMS_WORD)  - 1 + dwLength;
+	if (total >= max) {
+		status = DSP_EFAIL;
+		dev_dbg(bridge, "%s: Message args too large for buffer! size "
+				"= %d, max = %d\n", __func__, total, max);
+	}
+	/*
+	 *  Fill in buffer to send to RMS.
+	 *  The buffer will have the following  format:
+	 *
+	 *  RMS command:
+	 *      Address of RMS_CreateNode()
+	 *      Address of node's create function
+	 *      dummy argument
+	 *      node type
+	 *
+	 *  Message Args:
+	 *      max number of messages
+	 *      segid for message buffer allocation
+	 *      notification type to use when message is received
+	 *      length of message arg data
+	 *      message args data
+	 *
+	 *  Task Args (if task or socket node):
+	 *      priority
+	 *      stack size
+	 *      system stack size
+	 *      stack segment
+	 *      misc
+	 *      number of input streams
+	 *      pSTRMInDef[] - offsets of STRM definitions for input streams
+	 *      number of output streams
+	 *      pSTRMOutDef[] - offsets of STRM definitions for output
+	 *      streams
+	 *      STRMInDef[] - array of STRM definitions for input streams
+	 *      STRMOutDef[] - array of STRM definitions for output streams
+	 *
+	 *  Socket Args (if DAIS socket node):
+	 *
+	 */
+	if (DSP_SUCCEEDED(status)) {
+		total = 0; 	/* Total number of words in buffer so far */
+		pdwBuf = (RMS_WORD *)hDisp->pBuf;
+		pCommand = (struct RMS_Command *)pdwBuf;
+		pCommand->fxn = (RMS_WORD)(ulRMSFxn);
+		pCommand->arg1 = (RMS_WORD)(ulCreateFxn);
+		if (NODE_GetLoadType(hNode) == NLDR_DYNAMICLOAD) {
+			/* Flush ICACHE on Load */
+			pCommand->arg2 = 1; 	/* dummy argument */
+		} else {
+			/* Do not flush ICACHE */
+			pCommand->arg2 = 0; 	/* dummy argument */
+		}
+		pCommand->data = NODE_GetType(hNode);
+		/*
+		 *  argsOffset is the offset of the data field in struct
+		 *  RMS_Command structure. We need this to calculate stream
+		 *  definition offsets.
+		 */
+		argsOffset = 3;
+		total += sizeof(struct RMS_Command) / sizeof(RMS_WORD);
+		/* Message args */
+		pMsgArgs = (struct RMS_MsgArgs *) (pdwBuf + total);
+		pMsgArgs->maxMessages = msgArgs.uMaxMessages;
+		pMsgArgs->segid = msgArgs.uSegid;
+		pMsgArgs->notifyType = msgArgs.uNotifyType;
+		pMsgArgs->argLength = msgArgs.uArgLength;
+		total += sizeof(struct RMS_MsgArgs) / sizeof(RMS_WORD) - 1;
+		memcpy(pdwBuf + total, msgArgs.pData, msgArgs.uArgLength);
+		total += dwLength;
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* If node is a task node, copy task create arguments into  buffer */
+	if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
+		taskArgs = pArgs->asa.taskArgs;
+		taskArgsOffset = total;
+		total += sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD) +
+			1 + taskArgs.uNumInputs + taskArgs.uNumOutputs;
+		/* Copy task arguments */
+		if (total < max) {
+			total = taskArgsOffset;
+			pMoreTaskArgs = (struct RMS_MoreTaskArgs *)(pdwBuf +
+					total);
+			/*
+			 * Get some important info about the node. Note that we
+			 * don't just reach into the hNode struct because
+			 * that would break the node object's abstraction.
+			 */
+			GetNodeInfo(hNode, &nodeInfo);
+			pMoreTaskArgs->priority = nodeInfo.uExecutionPriority;
+			pMoreTaskArgs->stackSize = taskArgs.uStackSize;
+			pMoreTaskArgs->sysstackSize = taskArgs.uSysStackSize;
+			pMoreTaskArgs->stackSeg = taskArgs.uStackSeg;
+			pMoreTaskArgs->heapAddr = taskArgs.uDSPHeapAddr;
+			pMoreTaskArgs->heapSize = taskArgs.uHeapSize;
+			pMoreTaskArgs->misc = taskArgs.ulDaisArg;
+			pMoreTaskArgs->numInputStreams = taskArgs.uNumInputs;
+			total +=
+			    sizeof(struct RMS_MoreTaskArgs) / sizeof(RMS_WORD);
+			dev_dbg(bridge, "%s: uDSPHeapAddr %x, uHeapSize %x\n",
+					__func__, taskArgs.uDSPHeapAddr,
+					taskArgs.uHeapSize);
+			/* Keep track of pSIOInDef[] and pSIOOutDef[]
+			 * positions in the buffer, since this needs to be
+			 * filled in later.  */
+			sioInDefOffset = total;
+			total += taskArgs.uNumInputs;
+			pdwBuf[total++] = taskArgs.uNumOutputs;
+			sioOutDefOffset = total;
+			total += taskArgs.uNumOutputs;
+			sioDefsOffset = total;
+			/* Fill SIO defs and offsets */
+			offset = sioDefsOffset;
+			for (i = 0; i < taskArgs.uNumInputs; i++) {
+				if (DSP_FAILED(status))
+					break;
+
+				pdwBuf[sioInDefOffset + i] =
+					(offset - argsOffset)
+					* (sizeof(RMS_WORD) / DSPWORDSIZE);
+				strmDef = taskArgs.strmInDef[i];
+				status = FillStreamDef(pdwBuf, &total, offset,
+					 strmDef, max, uCharsInRMSWord);
+				offset = total;
+			}
+			for (i = 0;  (i < taskArgs.uNumOutputs) &&
+			    (DSP_SUCCEEDED(status)); i++) {
+				pdwBuf[sioOutDefOffset + i] =
+					(offset - argsOffset)
+					* (sizeof(RMS_WORD) / DSPWORDSIZE);
+				strmDef = taskArgs.strmOutDef[i];
+				status = FillStreamDef(pdwBuf, &total, offset,
+					 strmDef, max, uCharsInRMSWord);
+				offset = total;
+			}
+		} else {
+			/* Args won't fit */
+			status = DSP_EFAIL;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		ulBytes = total * sizeof(RMS_WORD);
+		DBC_Assert(ulBytes < (RMS_COMMANDBUFSIZE * sizeof(RMS_WORD)));
+		status = SendMessage(hDisp, NODE_GetTimeout(hNode),
+			 ulBytes, pNodeEnv);
+		if (DSP_SUCCEEDED(status)) {
+			/*
+			 * Message successfully received from RMS.
+			 * Return the status of the Node's create function
+			 * on the DSP-side
+			 */
+			status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+			if (DSP_FAILED(status))
+				dev_dbg(bridge, "%s: DSP-side failed: 0x%x\n",
+							__func__, status);
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== DISP_NodeDelete ========
+ *  purpose:
+ *      Delete a node on the DSP by remotely calling the node's delete function.
+ *
+ */
+DSP_STATUS DISP_NodeDelete(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
+			  u32 ulRMSFxn, u32 ulDeleteFxn, NODE_ENV nodeEnv)
+{
+	u32 dwArg;
+	struct RMS_Command *pCommand;
+	DSP_STATUS status = DSP_SOK;
+	u32 devType;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_Require(hNode != NULL);
+
+	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+
+	if (DSP_SUCCEEDED(status)) {
+
+		if (devType == DSP_UNIT) {
+
+			/*
+			 *  Fill in buffer to send to RMS
+			 */
+			pCommand = (struct RMS_Command *)hDisp->pBuf;
+			pCommand->fxn = (RMS_WORD)(ulRMSFxn);
+			pCommand->arg1 = (RMS_WORD)nodeEnv;
+			pCommand->arg2 = (RMS_WORD)(ulDeleteFxn);
+			pCommand->data = NODE_GetType(hNode);
+
+			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
+					    sizeof(struct RMS_Command), &dwArg);
+			if (DSP_SUCCEEDED(status)) {
+				/*
+				 * Message successfully received from RMS.
+				 * Return the status of the Node's delete
+				 * function on the DSP-side
+				 */
+				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+				if (DSP_FAILED(status))
+					dev_dbg(bridge, "%s: DSP-side failed: "
+						"0x%x\n", __func__, status);
+			}
+
+
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== DISP_NodeRun ========
+ *  purpose:
+ *      Start execution of a node's execute phase, or resume execution of a node
+ *      that has been suspended (via DISP_NodePause()) on the DSP.
+ */
+DSP_STATUS DISP_NodeRun(struct DISP_OBJECT *hDisp, struct NODE_OBJECT *hNode,
+			u32 ulRMSFxn, u32 ulExecuteFxn, NODE_ENV nodeEnv)
+{
+	u32 dwArg;
+	struct RMS_Command *pCommand;
+	DSP_STATUS status = DSP_SOK;
+	u32 devType;
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hDisp, DISP_SIGNATURE));
+	DBC_Require(hNode != NULL);
+
+	status = DEV_GetDevType(hDisp->hDevObject, &devType);
+
+	if (DSP_SUCCEEDED(status)) {
+
+		if (devType == DSP_UNIT) {
+
+			/*
+			 *  Fill in buffer to send to RMS.
+			 */
+			pCommand = (struct RMS_Command *) hDisp->pBuf;
+			pCommand->fxn = (RMS_WORD) (ulRMSFxn);
+			pCommand->arg1 = (RMS_WORD) nodeEnv;
+			pCommand->arg2 = (RMS_WORD) (ulExecuteFxn);
+			pCommand->data = NODE_GetType(hNode);
+
+			status = SendMessage(hDisp, NODE_GetTimeout(hNode),
+				 sizeof(struct RMS_Command), &dwArg);
+			if (DSP_SUCCEEDED(status)) {
+				/*
+				 * Message successfully received from RMS.
+				 * Return the status of the Node's execute
+				 * function on the DSP-side
+				 */
+				status = (((RMS_WORD *)(hDisp->pBuf))[0]);
+				if (DSP_FAILED(status))
+					dev_dbg(bridge, "%s: DSP-side failed: "
+						"0x%x\n", __func__, status);
+		}
+
+	}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DeleteDisp ========
+ *  purpose:
+ *      Frees the resources allocated for the dispatcher.
+ */
+static void DeleteDisp(struct DISP_OBJECT *hDisp)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+
+	if (MEM_IsValidHandle(hDisp, DISP_SIGNATURE)) {
+		pIntfFxns = hDisp->pIntfFxns;
+
+		/* Free Node Dispatcher resources */
+		if (hDisp->hChnlFromDsp) {
+			/* Channel close can fail only if the channel handle
+			 * is invalid. */
+			status = (*pIntfFxns->pfnChnlClose)
+				 (hDisp->hChnlFromDsp);
+			if (DSP_FAILED(status)) {
+				dev_dbg(bridge, "%s: Failed to close channel "
+					"from RMS: 0x%x\n", __func__, status);
+			}
+		}
+		if (hDisp->hChnlToDsp) {
+			status = (*pIntfFxns->pfnChnlClose)(hDisp->hChnlToDsp);
+			if (DSP_FAILED(status)) {
+				dev_dbg(bridge, "%s: Failed to close channel to"
+					" RMS: 0x%x\n", __func__, status);
+			}
+		}
+		kfree(hDisp->pBuf);
+
+		MEM_FreeObject(hDisp);
+	}
+}
+
+/*
+ *  ======== FillStreamDef ========
+ *  purpose:
+ *      Fills stream definitions.
+ */
+static DSP_STATUS FillStreamDef(RMS_WORD *pdwBuf, u32 *ptotal, u32 offset,
+				struct NODE_STRMDEF strmDef, u32 max,
+				u32 uCharsInRMSWord)
+{
+	struct RMS_StrmDef *pStrmDef;
+	u32 total = *ptotal;
+	u32 uNameLen;
+	u32 dwLength;
+	DSP_STATUS status = DSP_SOK;
+
+	if (total + sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) >= max) {
+		status = DSP_EFAIL;
+	} else {
+		pStrmDef = (struct RMS_StrmDef *)(pdwBuf + total);
+		pStrmDef->bufsize = strmDef.uBufsize;
+		pStrmDef->nbufs = strmDef.uNumBufs;
+		pStrmDef->segid = strmDef.uSegid;
+		pStrmDef->align = strmDef.uAlignment;
+		pStrmDef->timeout = strmDef.uTimeout;
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		/*
+		 *  Since we haven't added the device name yet, subtract
+		 *  1 from total.
+		 */
+		total += sizeof(struct RMS_StrmDef) / sizeof(RMS_WORD) - 1;
+		DBC_Require(strmDef.szDevice);
+		dwLength = strlen(strmDef.szDevice) + 1;
+
+		/* Number of RMS_WORDS needed to hold device name */
+		uNameLen = (dwLength + uCharsInRMSWord - 1) / uCharsInRMSWord;
+
+		if (total + uNameLen >= max) {
+			status = DSP_EFAIL;
+		} else {
+			/*
+			 *  Zero out last word, since the device name may not
+			 *  extend to completely fill this word.
+			 */
+			pdwBuf[total + uNameLen - 1] = 0;
+			/** TODO USE SERVICES **/
+			memcpy(pdwBuf + total, strmDef.szDevice, dwLength);
+			total += uNameLen;
+			*ptotal = total;
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== SendMessage ======
+ *  Send command message to RMS, get reply from RMS.
+ */
+static DSP_STATUS SendMessage(struct DISP_OBJECT *hDisp, u32 dwTimeout,
+			     u32 ulBytes, u32 *pdwArg)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct CHNL_OBJECT *hChnl;
+	u32 dwArg = 0;
+	u8 *pBuf;
+	struct CHNL_IOC chnlIOC;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(pdwArg != NULL);
+
+	*pdwArg = (u32) NULL;
+	pIntfFxns = hDisp->pIntfFxns;
+	hChnl = hDisp->hChnlToDsp;
+	pBuf = hDisp->pBuf;
+
+	/* Send the command */
+	status = (*pIntfFxns->pfnChnlAddIOReq) (hChnl, pBuf, ulBytes, 0,
+		 0L, dwArg);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+	if (DSP_SUCCEEDED(status)) {
+		if (!CHNL_IsIOComplete(chnlIOC)) {
+			if (CHNL_IsTimedOut(chnlIOC))
+				status = DSP_ETIMEOUT;
+			else
+				status = DSP_EFAIL;
+		}
+	}
+	/* Get the reply */
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	hChnl = hDisp->hChnlFromDsp;
+	ulBytes = REPLYSIZE;
+	status = (*pIntfFxns->pfnChnlAddIOReq)(hChnl, pBuf, ulBytes,
+		 0, 0L, dwArg);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = (*pIntfFxns->pfnChnlGetIOC) (hChnl, dwTimeout, &chnlIOC);
+	if (DSP_SUCCEEDED(status)) {
+		if (CHNL_IsTimedOut(chnlIOC)) {
+			status = DSP_ETIMEOUT;
+		} else if (chnlIOC.cBytes < ulBytes) {
+			/* Did not get all of the reply from the RMS */
+			status = DSP_EFAIL;
+		} else {
+			if (CHNL_IsIOComplete(chnlIOC)) {
+				DBC_Assert(chnlIOC.pBuf == pBuf);
+				status = (*((RMS_WORD *)chnlIOC.pBuf));
+				*pdwArg = (((RMS_WORD *)(chnlIOC.pBuf))[1]);
+			} else {
+				status = DSP_EFAIL;
+			}
+		}
+	}
+func_end:
+	return status;
+}
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
new file mode 100644
index 0000000..47e5edd
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -0,0 +1,1086 @@
+/*
+ * drv.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge resource allocation module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/reg.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/drv.h>
+#include <dspbridge/dev.h>
+
+#include <dspbridge/node.h>
+#include <dspbridge/proc.h>
+#include <dspbridge/strm.h>
+#include <dspbridge/nodepriv.h>
+#include <dspbridge/wmdchnl.h>
+#include <dspbridge/resourcecleanup.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define SIGNATURE   0x5f52474d	/* "DRV_" (in reverse) */
+
+struct DRV_OBJECT {
+	u32 dwSignature;
+	struct LST_LIST *devList;
+	struct LST_LIST *devNodeString;
+};
+
+/*
+ *  This is the Device Extension. Named with the Prefix
+ *  DRV_ since it is living in this module
+ */
+struct DRV_EXT {
+	struct list_head link;
+	char szString[MAXREGPATHLENGTH];
+};
+
+/*  ----------------------------------- Globals */
+static s32 cRefs;
+
+/*  ----------------------------------- Function Prototypes */
+static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 fRequest);
+static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 fRequest);
+
+/* GPP PROCESS CLEANUP CODE */
+
+static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt);
+extern enum NODE_STATE NODE_GetState(HANDLE hNode);
+
+/* Allocate and add a node resource element
+* This function is called from .Node_Allocate.  */
+DSP_STATUS DRV_InsertNodeResElement(HANDLE hNode, HANDLE hNodeRes,
+					HANDLE hPCtxt)
+{
+	struct NODE_RES_OBJECT **pNodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct NODE_RES_OBJECT   *pTempNodeRes = NULL;
+
+	*pNodeRes = (struct NODE_RES_OBJECT *)MEM_Calloc
+		    (1 * sizeof(struct NODE_RES_OBJECT), MEM_PAGED);
+	if (*pNodeRes == NULL)
+		status = DSP_EHANDLE;
+
+	if (DSP_SUCCEEDED(status)) {
+		if (mutex_lock_interruptible(&pCtxt->node_mutex)) {
+			kfree(*pNodeRes);
+			return DSP_EFAIL;
+		}
+		(*pNodeRes)->hNode = hNode;
+		if (pCtxt->pNodeList != NULL) {
+			pTempNodeRes = pCtxt->pNodeList;
+			while (pTempNodeRes->next != NULL)
+				pTempNodeRes = pTempNodeRes->next;
+
+			pTempNodeRes->next = *pNodeRes;
+		} else {
+			pCtxt->pNodeList = *pNodeRes;
+		}
+		mutex_unlock(&pCtxt->node_mutex);
+	}
+
+	return status;
+}
+
+/* Release all Node resources and its context
+* This is called from .Node_Delete.  */
+DSP_STATUS DRV_RemoveNodeResElement(HANDLE hNodeRes, HANDLE hPCtxt)
+{
+	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	struct NODE_RES_OBJECT *pTempNode;
+	DSP_STATUS status = DSP_SOK;
+
+	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+		return DSP_EFAIL;
+	pTempNode = pCtxt->pNodeList;
+	if (pTempNode == pNodeRes) {
+		pCtxt->pNodeList = pNodeRes->next;
+	} else {
+		while (pTempNode && pTempNode->next != pNodeRes)
+			pTempNode = pTempNode->next;
+		if (!pTempNode)
+			status = DSP_ENOTFOUND;
+		else
+			pTempNode->next = pNodeRes->next;
+	}
+	mutex_unlock(&pCtxt->node_mutex);
+	kfree(pNodeRes);
+	return status;
+}
+
+/* Actual Node De-Allocation */
+static DSP_STATUS DRV_ProcFreeNodeRes(HANDLE hPCtxt)
+{
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct NODE_RES_OBJECT *pNodeList = NULL;
+	struct NODE_RES_OBJECT *pNodeRes = NULL;
+	u32  nState;
+
+	pNodeList = pCtxt->pNodeList;
+	while (pNodeList != NULL) {
+		pNodeRes = pNodeList;
+		pNodeList = pNodeList->next;
+		if (pNodeRes->nodeAllocated) {
+			nState = NODE_GetState(pNodeRes->hNode) ;
+			if (nState <= NODE_DELETING) {
+				if ((nState == NODE_RUNNING) ||
+					(nState == NODE_PAUSED) ||
+					(nState == NODE_TERMINATING)) {
+					status = NODE_Terminate
+						(pNodeRes->hNode, &status);
+					status = NODE_Delete(pNodeRes->hNode,
+							pCtxt);
+				} else if ((nState == NODE_ALLOCATED)
+					|| (nState == NODE_CREATED))
+					status = NODE_Delete(pNodeRes->hNode,
+							pCtxt);
+			}
+		}
+	}
+	return status;
+}
+
+/* Release all Mapped and Reserved DMM resources */
+DSP_STATUS DRV_RemoveAllDMMResElements(HANDLE hPCtxt)
+{
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct DMM_MAP_OBJECT *temp_map, *map_obj;
+	struct DMM_RSV_OBJECT *temp_rsv, *rsv_obj;
+
+	/* Free DMM mapped memory resources */
+	list_for_each_entry_safe(map_obj, temp_map, &pCtxt->dmm_map_list,
+			link) {
+		status = PROC_UnMap(pCtxt->hProcessor,
+				(void *)map_obj->dsp_addr, pCtxt);
+		if (DSP_FAILED(status))
+			pr_err("%s: PROC_UnMap failed!"
+					" status = 0x%xn", __func__, status);
+	}
+
+	/* Free DMM reserved memory resources */
+	list_for_each_entry_safe(rsv_obj, temp_rsv, &pCtxt->dmm_rsv_list,
+			link) {
+		status = PROC_UnReserveMemory(pCtxt->hProcessor,
+				(void *)rsv_obj->dsp_reserved_addr, pCtxt);
+		if (DSP_FAILED(status))
+			pr_err("%s: PROC_UnReserveMemory failed!"
+					" status = 0x%xn", __func__, status);
+	}
+	return status;
+}
+
+/* Update Node allocation status */
+void DRV_ProcNodeUpdateStatus(HANDLE hNodeRes, s32 status)
+{
+	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
+	DBC_Assert(hNodeRes != NULL);
+	pNodeRes->nodeAllocated = status;
+}
+
+/* Update Node Heap status */
+void DRV_ProcNodeUpdateHeapStatus(HANDLE hNodeRes, s32 status)
+{
+	struct NODE_RES_OBJECT *pNodeRes = (struct NODE_RES_OBJECT *)hNodeRes;
+	DBC_Assert(hNodeRes != NULL);
+	pNodeRes->heapAllocated = status;
+}
+
+/* Release all Node resources and its context
+* This is called from .bridge_release.
+*/
+DSP_STATUS 	DRV_RemoveAllNodeResElements(HANDLE hPCtxt)
+{
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct NODE_RES_OBJECT *pTempNode2 = NULL;
+	struct NODE_RES_OBJECT *pTempNode = NULL;
+
+	DRV_ProcFreeNodeRes(pCtxt);
+	pTempNode = pCtxt->pNodeList;
+	while (pTempNode != NULL) {
+		pTempNode2 = pTempNode;
+		pTempNode = pTempNode->next;
+		kfree(pTempNode2);
+	}
+	pCtxt->pNodeList = NULL;
+	return status;
+}
+
+/* Getting the node resource element */
+DSP_STATUS DRV_GetNodeResElement(HANDLE hNode, HANDLE hNodeRes, HANDLE hPCtxt)
+{
+	struct NODE_RES_OBJECT **nodeRes = (struct NODE_RES_OBJECT **)hNodeRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct NODE_RES_OBJECT *pTempNode2 = NULL;
+	struct NODE_RES_OBJECT *pTempNode = NULL;
+
+	if (mutex_lock_interruptible(&pCtxt->node_mutex))
+		return DSP_EFAIL;
+
+	pTempNode = pCtxt->pNodeList;
+	while ((pTempNode != NULL) && (pTempNode->hNode != hNode)) {
+		pTempNode2 = pTempNode;
+		pTempNode = pTempNode->next;
+	}
+
+	mutex_unlock(&pCtxt->node_mutex);
+
+	if (pTempNode != NULL)
+		*nodeRes = pTempNode;
+	else
+		status = DSP_ENOTFOUND;
+
+	return status;
+}
+
+/* Allocate the STRM resource element
+* This is called after the actual resource is allocated
+*/
+DSP_STATUS DRV_ProcInsertSTRMResElement(HANDLE hStreamHandle, HANDLE hSTRMRes,
+					HANDLE hPCtxt)
+{
+	struct STRM_RES_OBJECT **pSTRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_RES_OBJECT *pTempSTRMRes = NULL;
+
+	*pSTRMRes = (struct STRM_RES_OBJECT *)
+		    MEM_Calloc(1 * sizeof(struct STRM_RES_OBJECT), MEM_PAGED);
+	if (*pSTRMRes == NULL)
+		status = DSP_EHANDLE;
+
+	if (DSP_SUCCEEDED(status)) {
+		if (mutex_lock_interruptible(&pCtxt->strm_mutex)) {
+			kfree(*pSTRMRes);
+			return DSP_EFAIL;
+		}
+		(*pSTRMRes)->hStream = hStreamHandle;
+		if (pCtxt->pSTRMList != NULL) {
+			pTempSTRMRes = pCtxt->pSTRMList;
+			while (pTempSTRMRes->next != NULL)
+				pTempSTRMRes = pTempSTRMRes->next;
+
+			pTempSTRMRes->next = *pSTRMRes;
+		} else {
+			pCtxt->pSTRMList = *pSTRMRes;
+		}
+		mutex_unlock(&pCtxt->strm_mutex);
+	}
+	return status;
+}
+
+/* Release Stream resource element context
+* This function called after the actual resource is freed
+*/
+DSP_STATUS 	DRV_ProcRemoveSTRMResElement(HANDLE hSTRMRes, HANDLE hPCtxt)
+{
+	struct STRM_RES_OBJECT *pSTRMRes = (struct STRM_RES_OBJECT *)hSTRMRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	struct STRM_RES_OBJECT *pTempSTRMRes;
+	DSP_STATUS status = DSP_SOK;
+
+	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+		return DSP_EFAIL;
+	pTempSTRMRes = pCtxt->pSTRMList;
+
+	if (pCtxt->pSTRMList == pSTRMRes) {
+		pCtxt->pSTRMList = pSTRMRes->next;
+	} else {
+		while (pTempSTRMRes && pTempSTRMRes->next != pSTRMRes)
+			pTempSTRMRes = pTempSTRMRes->next;
+		if (pTempSTRMRes == NULL)
+			status = DSP_ENOTFOUND;
+		else
+			pTempSTRMRes->next = pSTRMRes->next;
+	}
+	mutex_unlock(&pCtxt->strm_mutex);
+	kfree(pSTRMRes);
+	return status;
+}
+
+/* Release all Stream resources and its context
+* This is called from .bridge_release.
+*/
+DSP_STATUS DRV_RemoveAllSTRMResElements(HANDLE hPCtxt)
+{
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_RES_OBJECT *strm_res = NULL;
+	struct STRM_RES_OBJECT *strm_tmp = NULL;
+	struct STRM_INFO strm_info;
+	struct DSP_STREAMINFO user;
+	u8 **apBuffer = NULL;
+	u8 *pBufPtr;
+	u32 ulBytes;
+	u32 dwArg;
+	s32 ulBufSize;
+
+	strm_tmp = pCtxt->pSTRMList;
+	while (strm_tmp) {
+		strm_res = strm_tmp;
+		strm_tmp = strm_tmp->next;
+		if (strm_res->uNumBufs) {
+			apBuffer = MEM_Alloc((strm_res->uNumBufs *
+					    sizeof(u8 *)), MEM_NONPAGED);
+			if (apBuffer) {
+				status = STRM_FreeBuffer(strm_res->hStream,
+					apBuffer, strm_res->uNumBufs, pCtxt);
+				kfree(apBuffer);
+			}
+		}
+		strm_info.pUser = &user;
+		user.uNumberBufsInStream = 0;
+		STRM_GetInfo(strm_res->hStream, &strm_info, sizeof(strm_info));
+		while (user.uNumberBufsInStream--)
+			STRM_Reclaim(strm_res->hStream, &pBufPtr, &ulBytes,
+					     (u32 *)&ulBufSize, &dwArg);
+		status = STRM_Close(strm_res->hStream, pCtxt);
+	}
+	return status;
+}
+
+/* Getting the stream resource element */
+DSP_STATUS DRV_GetSTRMResElement(HANDLE hStrm, HANDLE hSTRMRes, HANDLE hPCtxt)
+{
+	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_RES_OBJECT *pTempSTRM2 = NULL;
+	struct STRM_RES_OBJECT *pTempSTRM;
+
+	if (mutex_lock_interruptible(&pCtxt->strm_mutex))
+		return DSP_EFAIL;
+
+	pTempSTRM = pCtxt->pSTRMList;
+	while ((pTempSTRM != NULL) && (pTempSTRM->hStream != hStrm)) {
+		pTempSTRM2 = pTempSTRM;
+		pTempSTRM = pTempSTRM->next;
+	}
+
+	mutex_unlock(&pCtxt->strm_mutex);
+
+	if (pTempSTRM != NULL)
+		*STRMRes = pTempSTRM;
+	else
+		status = DSP_ENOTFOUND;
+
+	return status;
+}
+
+/* Updating the stream resource element */
+DSP_STATUS DRV_ProcUpdateSTRMRes(u32 uNumBufs, HANDLE hSTRMRes)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct STRM_RES_OBJECT **STRMRes = (struct STRM_RES_OBJECT **)hSTRMRes;
+
+	(*STRMRes)->uNumBufs = uNumBufs;
+	return status;
+}
+
+/* GPP PROCESS CLEANUP CODE END */
+
+/*
+ *  ======== = DRV_Create ======== =
+ *  Purpose:
+ *      DRV Object gets created only once during Driver Loading.
+ */
+DSP_STATUS DRV_Create(OUT struct DRV_OBJECT **phDRVObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DRV_OBJECT *pDRVObject = NULL;
+
+	DBC_Require(phDRVObject != NULL);
+	DBC_Require(cRefs > 0);
+
+	MEM_AllocObject(pDRVObject, struct DRV_OBJECT, SIGNATURE);
+	if (pDRVObject) {
+		/* Create and Initialize List of device objects */
+		pDRVObject->devList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
+		if (pDRVObject->devList) {
+			/* Create and Initialize List of device Extension */
+			pDRVObject->devNodeString = MEM_Calloc(sizeof(struct
+				LST_LIST), MEM_NONPAGED);
+			if (!(pDRVObject->devNodeString)) {
+				status = DSP_EFAIL;
+			} else {
+				INIT_LIST_HEAD(&pDRVObject->devNodeString->
+					head);
+				INIT_LIST_HEAD(&pDRVObject->devList->head);
+			}
+		} else {
+			status = DSP_EMEMORY;
+		}
+	} else {
+		status = DSP_EMEMORY;
+	}
+	/* Store the DRV Object in the Registry */
+	if (DSP_SUCCEEDED(status))
+		status = CFG_SetObject((u32) pDRVObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status)) {
+		*phDRVObject = pDRVObject;
+	} else {
+		kfree(pDRVObject->devList);
+		kfree(pDRVObject->devNodeString);
+		/* Free the DRV Object */
+		kfree(pDRVObject);
+	}
+
+	DBC_Ensure(DSP_FAILED(status) ||
+		  MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	return status;
+}
+
+/*
+ *  ======== DRV_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the DRV module.
+ */
+void DRV_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== = DRV_Destroy ======== =
+ *  purpose:
+ *      Invoked during bridge de-initialization
+ */
+DSP_STATUS DRV_Destroy(struct DRV_OBJECT *hDRVObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
+
+	/*
+	 *  Delete the List if it exists.Should not come here
+	 *  as the DRV_RemoveDevObject and the Last DRV_RequestResources
+	 *  removes the list if the lists are empty.
+	 */
+	kfree(pDRVObject->devList);
+	kfree(pDRVObject->devNodeString);
+	MEM_FreeObject(pDRVObject);
+	/* Update the DRV Object in Registry to be 0 */
+	(void)CFG_SetObject(0, REG_DRV_OBJECT);
+	DBC_Ensure(!MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	return status;
+}
+
+/*
+ *  ======== DRV_GetDevObject ========
+ *  Purpose:
+ *      Given a index, returns a handle to DevObject from the list.
+ */
+DSP_STATUS DRV_GetDevObject(u32 uIndex, struct DRV_OBJECT *hDrvObject,
+			   struct DEV_OBJECT **phDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_BRIDGE_DEBUG    /* used only for Assertions and debug messages.*/
+	struct DRV_OBJECT *pDrvObject = (struct DRV_OBJECT *)hDrvObject;
+#endif
+	struct DEV_OBJECT *pDevObject;
+	u32 i;
+	DBC_Require(MEM_IsValidHandle(pDrvObject, SIGNATURE));
+	DBC_Require(phDevObject != NULL);
+	DBC_Require(uIndex >= 0);
+	DBC_Require(cRefs > 0);
+	DBC_Assert(!(LST_IsEmpty(pDrvObject->devList)));
+
+	pDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	for (i = 0; i < uIndex; i++) {
+		pDevObject =
+		   (struct DEV_OBJECT *)DRV_GetNextDevObject((u32)pDevObject);
+	}
+	if (pDevObject) {
+		*phDevObject = (struct DEV_OBJECT *) pDevObject;
+	} else {
+		*phDevObject = NULL;
+		status = DSP_EFAIL;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DRV_GetFirstDevObject ========
+ *  Purpose:
+ *      Retrieve the first Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DRV.
+ */
+u32 DRV_GetFirstDevObject(void)
+{
+	u32 dwDevObject = 0;
+	struct DRV_OBJECT *pDrvObject;
+
+	if (DSP_SUCCEEDED
+	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+		if ((pDrvObject->devList != NULL) &&
+		   !LST_IsEmpty(pDrvObject->devList))
+			dwDevObject = (u32) LST_First(pDrvObject->devList);
+	}
+
+	return dwDevObject;
+}
+
+/*
+ *  ======== DRV_GetFirstDevNodeString ========
+ *  Purpose:
+ *      Retrieve the first Device Extension from an internal linked list of
+ *      of Pointer to DevNode Strings maintained by DRV.
+ */
+u32 DRV_GetFirstDevExtension(void)
+{
+	u32 dwDevExtension = 0;
+	struct DRV_OBJECT *pDrvObject;
+
+	if (DSP_SUCCEEDED
+	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+
+		if ((pDrvObject->devNodeString != NULL) &&
+		   !LST_IsEmpty(pDrvObject->devNodeString)) {
+			dwDevExtension = (u32)LST_First(pDrvObject->
+							devNodeString);
+		}
+	}
+
+	return dwDevExtension;
+}
+
+/*
+ *  ======== DRV_GetNextDevObject ========
+ *  Purpose:
+ *      Retrieve the next Device Object handle from an internal linked list of
+ *      of DEV_OBJECTs maintained by DRV, after having previously called
+ *      DRV_GetFirstDevObject() and zero or more DRV_GetNext.
+ */
+u32 DRV_GetNextDevObject(u32 hDevObject)
+{
+	u32 dwNextDevObject = 0;
+	struct DRV_OBJECT *pDrvObject;
+
+	DBC_Require(hDevObject != 0);
+
+	if (DSP_SUCCEEDED
+	    (CFG_GetObject((u32 *)&pDrvObject, REG_DRV_OBJECT))) {
+
+		if ((pDrvObject->devList != NULL) &&
+		   !LST_IsEmpty(pDrvObject->devList)) {
+			dwNextDevObject = (u32)LST_Next(pDrvObject->devList,
+					  (struct list_head *)hDevObject);
+		}
+	}
+	return dwNextDevObject;
+}
+
+/*
+ *  ======== DRV_GetNextDevExtension ========
+ *  Purpose:
+ *      Retrieve the next Device Extension from an internal linked list of
+ *      of pointer to DevNodeString maintained by DRV, after having previously
+ *      called DRV_GetFirstDevExtension() and zero or more
+ *      DRV_GetNextDevExtension().
+ */
+u32 DRV_GetNextDevExtension(u32 hDevExtension)
+{
+	u32 dwDevExtension = 0;
+	struct DRV_OBJECT *pDrvObject;
+
+	DBC_Require(hDevExtension != 0);
+
+	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&pDrvObject,
+	   REG_DRV_OBJECT))) {
+		if ((pDrvObject->devNodeString != NULL) &&
+		   !LST_IsEmpty(pDrvObject->devNodeString)) {
+			dwDevExtension = (u32)LST_Next(pDrvObject->
+				devNodeString,
+				(struct list_head *)hDevExtension);
+		}
+	}
+
+	return dwDevExtension;
+}
+
+/*
+ *  ======== DRV_Init ========
+ *  Purpose:
+ *      Initialize DRV module private state.
+ */
+DSP_STATUS DRV_Init(void)
+{
+	s32 fRetval = 1;	/* function return value */
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+/*
+ *  ======== DRV_InsertDevObject ========
+ *  Purpose:
+ *      Insert a DevObject into the list of Manager object.
+ */
+DSP_STATUS DRV_InsertDevObject(struct DRV_OBJECT *hDRVObject,
+				struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hDevObject != NULL);
+	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	DBC_Assert(pDRVObject->devList);
+
+	LST_PutTail(pDRVObject->devList, (struct list_head *)hDevObject);
+
+	DBC_Ensure(DSP_SUCCEEDED(status) && !LST_IsEmpty(pDRVObject->devList));
+
+	return status;
+}
+
+/*
+ *  ======== DRV_RemoveDevObject ========
+ *  Purpose:
+ *      Search for and remove a DeviceObject from the given list of DRV
+ *      objects.
+ */
+DSP_STATUS DRV_RemoveDevObject(struct DRV_OBJECT *hDRVObject,
+				struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDRVObject;
+	struct list_head *pCurElem;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(pDRVObject, SIGNATURE));
+	DBC_Require(hDevObject != NULL);
+
+	DBC_Require(pDRVObject->devList != NULL);
+	DBC_Require(!LST_IsEmpty(pDRVObject->devList));
+
+	/* Search list for pProcObject: */
+	for (pCurElem = LST_First(pDRVObject->devList); pCurElem != NULL;
+	    pCurElem = LST_Next(pDRVObject->devList, pCurElem)) {
+		/* If found, remove it. */
+		if ((struct DEV_OBJECT *) pCurElem == hDevObject) {
+			LST_RemoveElem(pDRVObject->devList, pCurElem);
+			status = DSP_SOK;
+			break;
+		}
+	}
+	/* Remove list if empty. */
+	if (LST_IsEmpty(pDRVObject->devList)) {
+		kfree(pDRVObject->devList);
+		pDRVObject->devList = NULL;
+	}
+	DBC_Ensure((pDRVObject->devList == NULL) ||
+		  !LST_IsEmpty(pDRVObject->devList));
+
+	return status;
+}
+
+/*
+ *  ======== DRV_RequestResources ========
+ *  Purpose:
+ *      Requests  resources from the OS.
+ */
+DSP_STATUS DRV_RequestResources(u32 dwContext, u32 *pDevNodeString)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DRV_OBJECT *pDRVObject;
+	struct DRV_EXT *pszdevNode;
+
+	DBC_Require(dwContext != 0);
+	DBC_Require(pDevNodeString != NULL);
+
+	/*
+	 *  Allocate memory to hold the string. This will live untill
+	 *  it is freed in the Release resources. Update the driver object
+	 *  list.
+	 */
+
+	status = CFG_GetObject((u32 *)&pDRVObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status)) {
+		pszdevNode = MEM_Calloc(sizeof(struct DRV_EXT), MEM_NONPAGED);
+		if (pszdevNode) {
+			LST_InitElem(&pszdevNode->link);
+			strncpy(pszdevNode->szString,
+				 (char *)dwContext, MAXREGPATHLENGTH - 1);
+			pszdevNode->szString[MAXREGPATHLENGTH - 1] = '\0';
+			/* Update the Driver Object List */
+			*pDevNodeString = (u32)pszdevNode->szString;
+			LST_PutTail(pDRVObject->devNodeString,
+					(struct list_head *)pszdevNode);
+		} else {
+			status = DSP_EMEMORY;
+			*pDevNodeString = 0;
+		}
+	} else {
+		dev_dbg(bridge, "%s: Failed to get Driver Object from Registry",
+								__func__);
+		*pDevNodeString = 0;
+	}
+
+	if (!(strcmp((char *) dwContext, "TIOMAP1510"))) {
+		dev_dbg(bridge, "%s: Allocating resources for UMA\n", __func__);
+		status = RequestBridgeResourcesDSP(dwContext, DRV_ASSIGN);
+	} else {
+		status = DSP_EFAIL;
+		dev_dbg(bridge, "%s: Unknown Device\n", __func__);
+	}
+
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s: Failed to reserve bridge resources\n",
+								__func__);
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && pDevNodeString != NULL &&
+		  !LST_IsEmpty(pDRVObject->devNodeString)) ||
+		  (DSP_FAILED(status) && *pDevNodeString == 0));
+
+	return status;
+}
+
+/*
+ *  ======== DRV_ReleaseResources ========
+ *  Purpose:
+ *      Releases  resources from the OS.
+ */
+DSP_STATUS DRV_ReleaseResources(u32 dwContext, struct DRV_OBJECT *hDrvObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DRV_OBJECT *pDRVObject = (struct DRV_OBJECT *)hDrvObject;
+	struct DRV_EXT *pszdevNode;
+
+	if (!(strcmp((char *)((struct DRV_EXT *)dwContext)->szString,
+	   "TIOMAP1510")))
+		status = RequestBridgeResources(dwContext, DRV_RELEASE);
+	else
+		dev_dbg(bridge, "%s: Unknown device\n", __func__);
+
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s: Failed to relese bridge resources\n",
+								__func__);
+
+	/*
+	 *  Irrespective of the status go ahead and clean it
+	 *  The following will over write the status.
+	 */
+	for (pszdevNode = (struct DRV_EXT *)DRV_GetFirstDevExtension();
+	    pszdevNode != NULL; pszdevNode = (struct DRV_EXT *)
+	    DRV_GetNextDevExtension((u32)pszdevNode)) {
+		if (!pDRVObject->devNodeString) {
+			/* When this could happen? */
+			continue;
+		}
+		if ((u32)pszdevNode == dwContext) {
+			/* Found it */
+			/* Delete from the Driver object list */
+			LST_RemoveElem(pDRVObject->devNodeString,
+				      (struct list_head *)pszdevNode);
+			kfree((void *) pszdevNode);
+			break;
+		}
+		/* Delete the List if it is empty */
+		if (LST_IsEmpty(pDRVObject->devNodeString)) {
+			kfree(pDRVObject->devNodeString);
+			pDRVObject->devNodeString = NULL;
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== RequestBridgeResources ========
+ *  Purpose:
+ *      Reserves shared memory for bridge.
+ */
+static DSP_STATUS RequestBridgeResources(u32 dwContext, s32 bRequest)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CFG_HOSTRES *pResources;
+	u32 dwBuffSize;
+
+	struct DRV_EXT *driverExt;
+	u32 shm_size;
+
+	DBC_Require(dwContext != 0);
+
+	if (!bRequest) {
+		driverExt = (struct DRV_EXT *)dwContext;
+		/* Releasing resources by deleting the registry key  */
+		dwBuffSize = sizeof(struct CFG_HOSTRES);
+		pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
+		if (pResources != NULL) {
+			if (DSP_FAILED(REG_GetValue(CURRENTCONFIG,
+					(u8 *)pResources, &dwBuffSize))) {
+				status = CFG_E_RESOURCENOTAVAIL;
+			}
+
+			dwBuffSize = sizeof(shm_size);
+			status = REG_GetValue(SHMSIZE, (u8 *)&shm_size,
+					      &dwBuffSize);
+			if (DSP_SUCCEEDED(status)) {
+				if ((pResources->dwMemBase[1]) &&
+				   (pResources->dwMemPhys[1])) {
+					MEM_FreePhysMem((void *)pResources->
+					dwMemBase[1], pResources->dwMemPhys[1],
+					shm_size);
+				}
+			} else {
+				dev_dbg(bridge, "%s: Error getting SHM size "
+					"from registry: %x. Not calling "
+					"MEM_FreePhysMem\n", __func__, status);
+			}
+			pResources->dwMemBase[1] = 0;
+			pResources->dwMemPhys[1] = 0;
+
+			if (pResources->dwPrmBase)
+				iounmap(pResources->dwPrmBase);
+			if (pResources->dwCmBase)
+				iounmap(pResources->dwCmBase);
+			if (pResources->dwMboxBase)
+				iounmap(pResources->dwMboxBase);
+			if (pResources->dwMemBase[0])
+				iounmap((void *)pResources->dwMemBase[0]);
+			if (pResources->dwMemBase[2])
+				iounmap((void *)pResources->dwMemBase[2]);
+			if (pResources->dwMemBase[3])
+				iounmap((void *)pResources->dwMemBase[3]);
+			if (pResources->dwMemBase[4])
+				iounmap((void *)pResources->dwMemBase[4]);
+			if (pResources->dwWdTimerDspBase)
+				iounmap(pResources->dwWdTimerDspBase);
+			if (pResources->dwDmmuBase)
+				iounmap(pResources->dwDmmuBase);
+			if (pResources->dwPerBase)
+				iounmap(pResources->dwPerBase);
+			if (pResources->dwPerPmBase)
+				iounmap((void *)pResources->dwPerPmBase);
+			if (pResources->dwCorePmBase)
+				iounmap((void *)pResources->dwCorePmBase);
+			if (pResources->dwSysCtrlBase)
+				iounmap(pResources->dwSysCtrlBase);
+
+			pResources->dwPrmBase = NULL;
+			pResources->dwCmBase = NULL;
+			pResources->dwMboxBase = NULL;
+			pResources->dwMemBase[0] = (u32) NULL;
+			pResources->dwMemBase[2] = (u32) NULL;
+			pResources->dwMemBase[3] = (u32) NULL;
+			pResources->dwMemBase[4] = (u32) NULL;
+			pResources->dwWdTimerDspBase = NULL;
+			pResources->dwDmmuBase = NULL;
+			pResources->dwSysCtrlBase = NULL;
+
+			dwBuffSize = sizeof(struct CFG_HOSTRES);
+			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
+				 (u32)dwBuffSize);
+			/*  Set all the other entries to NULL */
+			kfree(pResources);
+		} else {
+			status = DSP_EMEMORY;
+		}
+		return status;
+	}
+	dwBuffSize = sizeof(struct CFG_HOSTRES);
+	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
+	if (pResources != NULL) {
+		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
+		pResources->wNumMemWindows = 2;
+		/* First window is for DSP internal memory */
+
+		pResources->dwPrmBase = ioremap(OMAP_IVA2_PRM_BASE,
+							OMAP_IVA2_PRM_SIZE);
+		pResources->dwCmBase = ioremap(OMAP_IVA2_CM_BASE,
+							OMAP_IVA2_CM_SIZE);
+		pResources->dwMboxBase = ioremap(OMAP_MBOX_BASE,
+							OMAP_MBOX_SIZE);
+		pResources->dwSysCtrlBase = ioremap(OMAP_SYSC_BASE,
+							OMAP_SYSC_SIZE);
+		dev_dbg(bridge, "dwMemBase[0] 0x%x\n",
+						pResources->dwMemBase[0]);
+		dev_dbg(bridge, "dwMemBase[3] 0x%x\n",
+						pResources->dwMemBase[3]);
+		dev_dbg(bridge, "dwPrmBase %p\n", pResources->dwPrmBase);
+		dev_dbg(bridge, "dwCmBase %p\n", pResources->dwCmBase);
+		dev_dbg(bridge, "dwWdTimerDspBase %p\n",
+						pResources->dwWdTimerDspBase);
+		dev_dbg(bridge, "dwMboxBase %p\n", pResources->dwMboxBase);
+		dev_dbg(bridge, "dwDmmuBase %p\n", pResources->dwDmmuBase);
+
+		/* for 24xx base port is not mapping the mamory for DSP
+		 * internal memory TODO Do a ioremap here */
+		/* Second window is for DSP external memory shared with MPU */
+
+		/* For Linux, these are hard-coded values */
+		pResources->bIRQRegisters = 0;
+		pResources->bIRQAttrib = 0;
+		pResources->dwOffsetForMonitor = 0;
+		pResources->dwChnlOffset = 0;
+		/* CHNL_MAXCHANNELS */
+		pResources->dwNumChnls = CHNL_MAXCHANNELS;
+		pResources->dwChnlBufSize = 0x400;
+		dwBuffSize = sizeof(struct CFG_HOSTRES);
+		status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
+						sizeof(struct CFG_HOSTRES));
+		if (DSP_FAILED(status)) {
+			dev_dbg(bridge, "%s: Failed to set the registry value "
+					"for CURRENTCONFIG\n", __func__);
+		}
+		kfree(pResources);
+	}
+	/* End Mem alloc */
+	return status;
+}
+
+/*
+ *  ======== RequestBridgeResourcesDSP ========
+ *  Purpose:
+ *      Reserves shared memory for bridge.
+ */
+static DSP_STATUS RequestBridgeResourcesDSP(u32 dwContext, s32 bRequest)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CFG_HOSTRES *pResources;
+	u32 dwBuffSize;
+	u32 dmaAddr;
+	u32 shm_size;
+
+	DBC_Require(dwContext != 0);
+
+	dwBuffSize = sizeof(struct CFG_HOSTRES);
+
+	pResources = MEM_Calloc(dwBuffSize, MEM_NONPAGED);
+
+	if (pResources != NULL) {
+		if (DSP_FAILED(CFG_GetHostResources((struct CFG_DEVNODE *)
+		   dwContext, pResources))) {
+			/* Call CFG_GetHostResources to get reserve resouces */
+			status = RequestBridgeResources(dwContext, bRequest);
+			if (DSP_SUCCEEDED(status)) {
+				status = CFG_GetHostResources
+					((struct CFG_DEVNODE *) dwContext,
+					pResources);
+			}
+		}
+		/* wNumMemWindows must not be more than CFG_MAXMEMREGISTERS */
+		pResources->wNumMemWindows = 4;
+
+		pResources->dwMemBase[0] = 0;
+		pResources->dwMemBase[2] = (u32)ioremap(OMAP_DSP_MEM1_BASE,
+							OMAP_DSP_MEM1_SIZE);
+		pResources->dwMemBase[3] = (u32)ioremap(OMAP_DSP_MEM2_BASE,
+							OMAP_DSP_MEM2_SIZE);
+		pResources->dwMemBase[4] = (u32)ioremap(OMAP_DSP_MEM3_BASE,
+							OMAP_DSP_MEM3_SIZE);
+		pResources->dwPerBase = ioremap(OMAP_PER_CM_BASE,
+							OMAP_PER_CM_SIZE);
+		pResources->dwPerPmBase = (u32)ioremap(OMAP_PER_PRM_BASE,
+							OMAP_PER_PRM_SIZE);
+		pResources->dwCorePmBase = (u32)ioremap(OMAP_CORE_PRM_BASE,
+							OMAP_CORE_PRM_SIZE);
+		pResources->dwDmmuBase = ioremap(OMAP_DMMU_BASE,
+							OMAP_DMMU_SIZE);
+		pResources->dwWdTimerDspBase = NULL;
+
+		dev_dbg(bridge, "dwMemBase[0] 0x%x\n",
+						pResources->dwMemBase[0]);
+		dev_dbg(bridge, "dwMemBase[1] 0x%x\n",
+						pResources->dwMemBase[1]);
+		dev_dbg(bridge, "dwMemBase[2] 0x%x\n",
+						pResources->dwMemBase[2]);
+		dev_dbg(bridge, "dwMemBase[3] 0x%x\n",
+						pResources->dwMemBase[3]);
+		dev_dbg(bridge, "dwMemBase[4] 0x%x\n",
+						pResources->dwMemBase[4]);
+		dev_dbg(bridge, "dwPrmBase %p\n", pResources->dwPrmBase);
+		dev_dbg(bridge, "dwCmBase %p\n", pResources->dwCmBase);
+		dev_dbg(bridge, "dwWdTimerDspBase %p\n",
+						pResources->dwWdTimerDspBase);
+		dev_dbg(bridge, "dwMboxBase %p\n", pResources->dwMboxBase);
+		dev_dbg(bridge, "dwDmmuBase %p\n", pResources->dwDmmuBase);
+		dwBuffSize = sizeof(shm_size);
+		status = REG_GetValue(SHMSIZE, (u8 *)&shm_size, &dwBuffSize);
+		if (DSP_SUCCEEDED(status)) {
+			/* Allocate Physically contiguous,
+			 * non-cacheable  memory */
+			pResources->dwMemBase[1] =
+				(u32)MEM_AllocPhysMem(shm_size, 0x100000,
+							&dmaAddr);
+			if (pResources->dwMemBase[1] == 0) {
+				status = DSP_EMEMORY;
+				pr_err("SHM reservation Failed\n");
+			} else {
+				pResources->dwMemLength[1] = shm_size;
+				pResources->dwMemPhys[1] = dmaAddr;
+
+				dev_dbg(bridge, "%s: Bridge SHM address 0x%x "
+					"dmaAddr %x size %x\n", __func__,
+					 pResources->dwMemBase[1],
+					 dmaAddr, shm_size);
+			}
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* for Linux, these are hard-coded values */
+			pResources->bIRQRegisters = 0;
+			pResources->bIRQAttrib = 0;
+			pResources->dwOffsetForMonitor = 0;
+			pResources->dwChnlOffset = 0;
+			/* CHNL_MAXCHANNELS */
+			pResources->dwNumChnls = CHNL_MAXCHANNELS;
+			pResources->dwChnlBufSize = 0x400;
+			dwBuffSize = sizeof(struct CFG_HOSTRES);
+			status = REG_SetValue(CURRENTCONFIG, (u8 *)pResources,
+					     sizeof(struct CFG_HOSTRES));
+			if (DSP_FAILED(status)) {
+				dev_dbg(bridge, "%s: Failed to set the registry"
+					" value for CURRENTCONFIG\n", __func__);
+			}
+		}
+		kfree(pResources);
+	}
+	/* End Mem alloc */
+	return status;
+}
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.c b/drivers/dsp/bridge/rmgr/drv_interface.c
new file mode 100644
index 0000000..3f5af34
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/drv_interface.c
@@ -0,0 +1,573 @@
+/*
+ * drv_interface.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge driver interface.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+
+#include <dspbridge/host_os.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+
+#ifdef MODULE
+#include <linux/module.h>
+#endif
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/moduleparam.h>
+#include <linux/cdev.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/services.h>
+#include <dspbridge/sync.h>
+#include <dspbridge/reg.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/wcdioctl.h>
+#include <dspbridge/_dcd.h>
+#include <dspbridge/dspdrv.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/pwr.h>
+
+/*  ----------------------------------- This */
+#include <drv_interface.h>
+
+#include <dspbridge/cfg.h>
+#include <dspbridge/resourcecleanup.h>
+#include <dspbridge/chnl.h>
+#include <dspbridge/proc.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/drvdefs.h>
+#include <dspbridge/drv.h>
+
+#ifdef CONFIG_BRIDGE_DVFS
+#include <mach-omap2/omap3-opp.h>
+#endif
+
+#define BRIDGE_NAME "C6410"
+/*  ----------------------------------- Globals */
+#define DRIVER_NAME  "DspBridge"
+#define DSPBRIDGE_VERSION	"0.2"
+s32 dsp_debug;
+
+struct platform_device *omap_dspbridge_dev;
+struct device *bridge;
+
+/* This is a test variable used by Bridge to test different sleep states */
+s32 dsp_test_sleepstate;
+
+static struct cdev bridge_cdev;
+
+static struct class *bridge_class;
+
+static u32 driverContext;
+static s32 driver_major;
+static char *base_img;
+char *iva_img;
+static s32 shm_size = 0x500000;	/* 5 MB */
+static u32 phys_mempool_base;
+static u32 phys_mempool_size;
+static int tc_wordswapon;	/* Default value is always false */
+
+#ifdef CONFIG_PM
+struct omap34xx_bridge_suspend_data {
+	int suspended;
+	wait_queue_head_t suspend_wq;
+};
+
+static struct omap34xx_bridge_suspend_data bridge_suspend_data;
+
+static int omap34xxbridge_suspend_lockout(
+		struct omap34xx_bridge_suspend_data *s, struct file *f)
+{
+	if ((s)->suspended) {
+		if ((f)->f_flags & O_NONBLOCK)
+			return DSP_EDPMSUSPEND;
+		wait_event_interruptible((s)->suspend_wq, (s)->suspended == 0);
+	}
+	return 0;
+}
+#endif
+
+module_param(dsp_debug, int, 0);
+MODULE_PARM_DESC(dsp_debug, "Wait after loading DSP image. default = false");
+
+module_param(dsp_test_sleepstate, int, 0);
+MODULE_PARM_DESC(dsp_test_sleepstate, "DSP Sleep state = 0");
+
+module_param(base_img, charp, 0);
+MODULE_PARM_DESC(base_img, "DSP base image, default = NULL");
+
+module_param(shm_size, int, 0);
+MODULE_PARM_DESC(shm_size, "SHM size, default = 4 MB, minimum = 64 KB");
+
+module_param(phys_mempool_base, uint, 0);
+MODULE_PARM_DESC(phys_mempool_base,
+		"Physical memory pool base passed to driver");
+
+module_param(phys_mempool_size, uint, 0);
+MODULE_PARM_DESC(phys_mempool_size,
+		"Physical memory pool size passed to driver");
+module_param(tc_wordswapon, int, 0);
+MODULE_PARM_DESC(tc_wordswapon, "TC Word Swap Option. default = 0");
+
+MODULE_AUTHOR("Texas Instruments");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DSPBRIDGE_VERSION);
+
+static char *driver_name = DRIVER_NAME;
+
+static struct file_operations bridge_fops = {
+	.open		= bridge_open,
+	.release	= bridge_release,
+	.unlocked_ioctl	= bridge_ioctl,
+	.mmap		= bridge_mmap,
+};
+
+#ifdef CONFIG_PM
+static u32 timeOut = 1000;
+#ifdef CONFIG_BRIDGE_DVFS
+static struct clk *clk_handle;
+s32 dsp_max_opps = VDD1_OPP5;
+#endif
+
+/* Maximum Opps that can be requested by IVA*/
+/*vdd1 rate table*/
+#ifdef CONFIG_BRIDGE_DVFS
+const struct omap_opp  vdd1_rate_table_bridge[] = {
+	{0, 0, 0},
+	/*OPP1*/
+	{S125M, VDD1_OPP1, 0},
+	/*OPP2*/
+	{S250M, VDD1_OPP2, 0},
+	/*OPP3*/
+	{S500M, VDD1_OPP3, 0},
+	/*OPP4*/
+	{S550M, VDD1_OPP4, 0},
+	/*OPP5*/
+	{S600M, VDD1_OPP5, 0},
+};
+#endif
+#endif
+
+struct dspbridge_platform_data *omap_dspbridge_pdata;
+
+u32 vdd1_dsp_freq[6][4] = {
+	{0, 0, 0, 0},
+	/*OPP1*/
+	{0, 90000, 0, 86000},
+	/*OPP2*/
+	{0, 180000, 80000, 170000},
+	/*OPP3*/
+	{0, 360000, 160000, 340000},
+	/*OPP4*/
+	{0, 396000, 325000, 376000},
+	/*OPP5*/
+	{0, 430000, 355000, 430000},
+};
+
+#ifdef CONFIG_BRIDGE_DVFS
+static int dspbridge_post_scale(struct notifier_block *op, unsigned long level,
+				void *ptr)
+{
+	PWR_PM_PostScale(PRCM_VDD1, level);
+	return 0;
+}
+
+static struct notifier_block iva_clk_notifier = {
+	.notifier_call = dspbridge_post_scale,
+	NULL,
+};
+#endif
+
+static int __devinit omap34xx_bridge_probe(struct platform_device *pdev)
+{
+	int status;
+	u32 initStatus;
+	u32 temp;
+	dev_t   dev = 0 ;
+	int     result;
+#ifdef CONFIG_BRIDGE_DVFS
+	int i = 0;
+#endif
+	struct dspbridge_platform_data *pdata = pdev->dev.platform_data;
+
+	omap_dspbridge_dev = pdev;
+
+	/* Global bridge device */
+	bridge = &omap_dspbridge_dev->dev;
+
+	/* use 2.6 device model */
+	result = alloc_chrdev_region(&dev, 0, 1, driver_name);
+	if (result < 0) {
+		pr_err("%s: Can't get major %d\n", __func__, driver_major);
+		goto err1;
+	}
+
+	driver_major = MAJOR(dev);
+
+	cdev_init(&bridge_cdev, &bridge_fops);
+	bridge_cdev.owner = THIS_MODULE;
+
+	status = cdev_add(&bridge_cdev, dev, 1);
+	if (status) {
+		pr_err("%s: Failed to add bridge device\n", __func__);
+		goto err2;
+	}
+
+	/* udev support */
+	bridge_class = class_create(THIS_MODULE, "ti_bridge");
+
+	if (IS_ERR(bridge_class))
+		pr_err("%s: Error creating bridge class\n", __func__);
+
+	device_create(bridge_class, NULL, MKDEV(driver_major, 0),
+			NULL, "DspBridge");
+
+#ifdef CONFIG_PM
+	/* Initialize the wait queue */
+	if (!status) {
+		bridge_suspend_data.suspended = 0;
+		init_waitqueue_head(&bridge_suspend_data.suspend_wq);
+	}
+#endif
+
+	SERVICES_Init();
+
+	/*  Autostart flag.  This should be set to true if the DSP image should
+	 *  be loaded and run during bridge module initialization  */
+
+	if (base_img) {
+		temp = true;
+		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
+		REG_SetValue(DEFEXEC, (u8 *)base_img, strlen(base_img) + 1);
+	} else {
+		temp = false;
+		REG_SetValue(AUTOSTART, (u8 *)&temp, sizeof(temp));
+		REG_SetValue(DEFEXEC, (u8 *) "\0", (u32)2);
+	}
+
+	if (shm_size >= 0x10000) {	/* 64 KB */
+		initStatus = REG_SetValue(SHMSIZE, (u8 *)&shm_size,
+					  sizeof(shm_size));
+	} else {
+		initStatus = DSP_EINVALIDARG;
+		status = -1;
+		pr_err("%s: SHM size must be at least 64 KB\n", __func__);
+	}
+	dev_dbg(bridge, "%s: requested shm_size = 0x%x\n", __func__, shm_size);
+
+	if (pdata->phys_mempool_base && pdata->phys_mempool_size) {
+		phys_mempool_base = pdata->phys_mempool_base;
+		phys_mempool_size = pdata->phys_mempool_size;
+	}
+
+	dev_dbg(bridge, "%s: phys_mempool_base = 0x%x \n", __func__,
+							phys_mempool_base);
+
+	dev_dbg(bridge, "%s: phys_mempool_size = 0x%x\n", __func__,
+							phys_mempool_base);
+	if ((phys_mempool_base > 0x0) && (phys_mempool_size > 0x0))
+		MEM_ExtPhysPoolInit(phys_mempool_base, phys_mempool_size);
+	if (tc_wordswapon) {
+		dev_dbg(bridge, "%s: TC Word Swap is enabled\n", __func__);
+		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
+			    sizeof(tc_wordswapon));
+	} else {
+		dev_dbg(bridge, "%s: TC Word Swap is disabled\n", __func__);
+		REG_SetValue(TCWORDSWAP, (u8 *)&tc_wordswapon,
+			    sizeof(tc_wordswapon));
+	}
+	if (DSP_SUCCEEDED(initStatus)) {
+#ifdef CONFIG_BRIDGE_DVFS
+		for (i = 0; i < 6; i++)
+			pdata->mpu_speed[i] = vdd1_rate_table_bridge[i].rate;
+
+		clk_handle = clk_get(NULL, "iva2_ck");
+		if (!clk_handle)
+			pr_err("%s: clk_get failed to get iva2_ck\n", __func__);
+
+		if (clk_notifier_register(clk_handle, &iva_clk_notifier))
+			pr_err("%s: clk_notifier_register failed for iva2_ck\n",
+								__func__);
+#endif
+		driverContext = DSP_Init(&initStatus);
+		if (DSP_FAILED(initStatus)) {
+			status = -1;
+			pr_err("DSP Bridge driver initialization failed\n");
+		} else {
+			pr_info("DSP Bridge driver loaded\n");
+		}
+	}
+
+	DBC_Assert(status == 0);
+	DBC_Assert(DSP_SUCCEEDED(initStatus));
+
+	return 0;
+
+err2:
+	unregister_chrdev_region(dev, 1);
+err1:
+	return result;
+}
+
+static int __devexit omap34xx_bridge_remove(struct platform_device *pdev)
+{
+	dev_t devno;
+	bool ret;
+	DSP_STATUS dsp_status = DSP_SOK;
+	HANDLE hDrvObject = NULL;
+
+	dsp_status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	if (DSP_FAILED(dsp_status))
+		goto func_cont;
+
+#ifdef CONFIG_BRIDGE_DVFS
+	if (clk_notifier_unregister(clk_handle, &iva_clk_notifier))
+		pr_err("%s: clk_notifier_unregister failed for iva2_ck\n",
+								__func__);
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
+
+	if (driverContext) {
+		/* Put the DSP in reset state */
+		ret = DSP_Deinit(driverContext);
+		driverContext = 0;
+		DBC_Assert(ret == true);
+	}
+
+#ifdef CONFIG_BRIDGE_DVFS
+	clk_put(clk_handle);
+	clk_handle = NULL;
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
+
+func_cont:
+	MEM_ExtPhysPoolRelease();
+
+	SERVICES_Exit();
+
+	devno = MKDEV(driver_major, 0);
+	cdev_del(&bridge_cdev);
+	unregister_chrdev_region(devno, 1);
+	if (bridge_class) {
+		/* remove the device from sysfs */
+		device_destroy(bridge_class, MKDEV(driver_major, 0));
+		class_destroy(bridge_class);
+
+	}
+	return 0;
+}
+
+
+#ifdef CONFIG_PM
+static int bridge_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	u32 status;
+	u32 command = PWR_EMERGENCYDEEPSLEEP;
+
+	status = PWR_SleepDSP(command, timeOut);
+	if (DSP_FAILED(status))
+		return -1;
+
+	bridge_suspend_data.suspended = 1;
+	return 0;
+}
+
+static int bridge_resume(struct platform_device *pdev)
+{
+	u32 status;
+
+	status = PWR_WakeDSP(timeOut);
+	if (DSP_FAILED(status))
+		return -1;
+
+	bridge_suspend_data.suspended = 0;
+	wake_up(&bridge_suspend_data.suspend_wq);
+	return 0;
+}
+#else
+#define bridge_suspend NULL
+#define bridge_resume NULL
+#endif
+
+static struct platform_driver bridge_driver = {
+	.driver = {
+		.name = BRIDGE_NAME,
+	},
+	.probe	 = omap34xx_bridge_probe,
+	.remove	 = __devexit_p(omap34xx_bridge_remove),
+	.suspend = bridge_suspend,
+	.resume	 = bridge_resume,
+};
+
+static int __init bridge_init(void)
+{
+	return platform_driver_register(&bridge_driver);
+}
+
+static void __exit bridge_exit(void)
+{
+	platform_driver_unregister(&bridge_driver);
+}
+
+/*
+ * This function is called when an application opens handle to the
+ * bridge driver.
+ */
+static int bridge_open(struct inode *ip, struct file *filp)
+{
+	int status = 0;
+	struct PROCESS_CONTEXT *pr_ctxt = NULL;
+
+	/*
+	 * Allocate a new process context and insert it into global
+	 * process context list.
+	 */
+	pr_ctxt = MEM_Calloc(sizeof(struct PROCESS_CONTEXT), MEM_PAGED);
+	if (pr_ctxt) {
+		pr_ctxt->resState = PROC_RES_ALLOCATED;
+		spin_lock_init(&pr_ctxt->dmm_map_lock);
+		INIT_LIST_HEAD(&pr_ctxt->dmm_map_list);
+		spin_lock_init(&pr_ctxt->dmm_rsv_lock);
+		INIT_LIST_HEAD(&pr_ctxt->dmm_rsv_list);
+		mutex_init(&pr_ctxt->node_mutex);
+		mutex_init(&pr_ctxt->strm_mutex);
+	} else {
+		status = -ENOMEM;
+	}
+
+	filp->private_data = pr_ctxt;
+
+	return status;
+}
+
+/*
+ * This function is called when an application closes handle to the bridge
+ * driver.
+ */
+static int bridge_release(struct inode *ip, struct file *filp)
+{
+	int status = 0;
+	struct PROCESS_CONTEXT *pr_ctxt;
+
+	if (!filp->private_data) {
+		status = -EIO;
+		goto err;
+	}
+
+	pr_ctxt = filp->private_data;
+	flush_signals(current);
+	DRV_RemoveAllResources(pr_ctxt);
+	PROC_Detach(pr_ctxt);
+	kfree(pr_ctxt);
+
+	filp->private_data = NULL;
+
+err:
+	return status;
+}
+
+/* This function provides IO interface to the bridge driver. */
+static long bridge_ioctl(struct file *filp, unsigned int code,
+		unsigned long args)
+{
+	int status;
+	u32 retval = DSP_SOK;
+	union Trapped_Args pBufIn;
+
+	DBC_Require(filp != NULL);
+#ifdef CONFIG_PM
+	status = omap34xxbridge_suspend_lockout(&bridge_suspend_data, filp);
+	if (status != 0)
+		return status;
+#endif
+
+	if (!filp->private_data) {
+		status = -EIO;
+		goto err;
+	}
+
+	status = copy_from_user(&pBufIn, (union Trapped_Args *)args,
+				sizeof(union Trapped_Args));
+
+	if (!status) {
+		status = WCD_CallDevIOCtl(code, &pBufIn, &retval,
+				filp->private_data);
+
+		if (DSP_SUCCEEDED(status)) {
+			status = retval;
+		} else {
+			dev_dbg(bridge, "%s: IOCTL Failed, code: 0x%x "
+				"status 0x%x\n", __func__, code, status);
+			status = -1;
+		}
+
+	}
+
+err:
+	return status;
+}
+
+/* This function maps kernel space memory to user space memory. */
+static int bridge_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	u32 offset = vma->vm_pgoff << PAGE_SHIFT;
+	u32 status;
+
+	DBC_Assert(vma->vm_start < vma->vm_end);
+
+	vma->vm_flags |= VM_RESERVED | VM_IO;
+	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+
+	dev_dbg(bridge, "%s: vm filp %p offset %x start %lx end %lx page_prot "
+				"%lx flags %lx\n", __func__, filp, offset,
+				vma->vm_start, vma->vm_end, vma->vm_page_prot,
+				vma->vm_flags);
+
+	status = remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+				vma->vm_end - vma->vm_start, vma->vm_page_prot);
+	if (status != 0)
+		status = -EAGAIN;
+
+	return status;
+}
+
+/* To remove all process resources before removing the process from the
+ * process context list*/
+DSP_STATUS DRV_RemoveAllResources(HANDLE hPCtxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROCESS_CONTEXT *pCtxt = (struct PROCESS_CONTEXT *)hPCtxt;
+	DRV_RemoveAllSTRMResElements(pCtxt);
+	DRV_RemoveAllNodeResElements(pCtxt);
+	DRV_RemoveAllDMMResElements(pCtxt);
+	pCtxt->resState = PROC_RES_FREED;
+	return status;
+}
+
+/* Bridge driver initialization and de-initialization functions */
+module_init(bridge_init);
+module_exit(bridge_exit);
+
diff --git a/drivers/dsp/bridge/rmgr/drv_interface.h b/drivers/dsp/bridge/rmgr/drv_interface.h
new file mode 100644
index 0000000..ca6858a
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/drv_interface.h
@@ -0,0 +1,28 @@
+/*
+ * drv_interface.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef	_DRV_INTERFACE_H_
+#define _DRV_INTERFACE_H_
+
+/* Prototypes for all functions in this bridge */
+static int __init bridge_init(void);	/* Initialize bridge */
+static void __exit bridge_exit(void);	/* Opposite of initialize */
+static int bridge_open(struct inode *, struct file *);	/* Open */
+static int bridge_release(struct inode *, struct file *);	/* Release */
+static long bridge_ioctl(struct file *, unsigned int,
+			unsigned long);
+static int bridge_mmap(struct file *filp, struct vm_area_struct *vma);
+#endif				/* ifndef _DRV_INTERFACE_H_ */
diff --git a/drivers/dsp/bridge/rmgr/dspdrv.c b/drivers/dsp/bridge/rmgr/dspdrv.c
new file mode 100644
index 0000000..cc965c4
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/dspdrv.c
@@ -0,0 +1,144 @@
+/*
+ * dspdrv.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Interface to allocate and free bridge resources.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/reg.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/drv.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/_dcd.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/mgr.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/dspdrv.h>
+
+/*
+ *  ======== DSP_Init ========
+ *  	Allocates bridge resources. Loads a base image onto DSP, if specified.
+ */
+u32 DSP_Init(OUT u32 *initStatus)
+{
+	char devNode[MAXREGPATHLENGTH] = "TIOMAP1510";
+	DSP_STATUS status = DSP_EFAIL;
+	struct DRV_OBJECT *drvObject = NULL;
+	u32 deviceNode;
+	u32 deviceNodeString;
+
+	if (!WCD_Init())
+		goto func_cont;
+
+	status = DRV_Create(&drvObject);
+	if (DSP_FAILED(status)) {
+		WCD_Exit();
+		goto func_cont;
+	}		/* End DRV_Create */
+
+	/* Request Resources */
+	status = DRV_RequestResources((u32)&devNode, &deviceNodeString);
+	if (DSP_SUCCEEDED(status)) {
+		/* Attempt to Start the Device */
+		status = DEV_StartDevice((struct CFG_DEVNODE *)
+							deviceNodeString);
+		if (DSP_FAILED(status))
+			(void)DRV_ReleaseResources
+				((u32) deviceNodeString, drvObject);
+	} else {
+		dev_dbg(bridge, "%s: DRV_RequestResources Failed\n", __func__);
+		status = DSP_EFAIL;
+	}
+
+	/* Unwind whatever was loaded */
+	if (DSP_FAILED(status)) {
+		/* irrespective of the status of DEV_RemoveDevice we conitinue
+		 * unloading. Get the Driver Object iterate through and remove.
+		 * Reset the status to E_FAIL to avoid going through
+		 * WCD_InitComplete2. */
+		for (deviceNode = DRV_GetFirstDevExtension(); deviceNode != 0;
+		    deviceNode = DRV_GetNextDevExtension(deviceNode)) {
+			(void)DEV_RemoveDevice
+				((struct CFG_DEVNODE *)deviceNode);
+			(void)DRV_ReleaseResources((u32)deviceNode,
+				drvObject);
+		}
+		/* Remove the Driver Object */
+		(void)DRV_Destroy(drvObject);
+		drvObject = NULL;
+		WCD_Exit();
+		dev_dbg(bridge, "%s: Logical device failed init\n", __func__);
+	}	/* Unwinding the loaded drivers */
+func_cont:
+	/* Attempt to Start the Board */
+	if (DSP_SUCCEEDED(status)) {
+		/* BRD_AutoStart could fail if the dsp execuetable is not the
+		 * correct one. We should not propagate that error
+		 * into the device loader. */
+		(void)WCD_InitComplete2();
+	} else {
+		dev_dbg(bridge, "%s: Failed\n", __func__);
+	}			/* End WCD_InitComplete2 */
+	DBC_Ensure((DSP_SUCCEEDED(status) && drvObject != NULL) ||
+		  (DSP_FAILED(status) && drvObject == NULL));
+	*initStatus = status;
+	/* Return the Driver Object */
+	return (u32)drvObject;
+}
+
+/*
+ *  ======== DSP_Deinit ========
+ *  	Frees the resources allocated for bridge.
+ */
+bool DSP_Deinit(u32 deviceContext)
+{
+	bool retVal = true;
+	u32 deviceNode;
+	struct MGR_OBJECT *mgrObject = NULL;
+
+	while ((deviceNode = DRV_GetFirstDevExtension()) != 0) {
+		(void)DEV_RemoveDevice((struct CFG_DEVNODE *)deviceNode);
+
+		(void)DRV_ReleaseResources((u32)deviceNode,
+			 (struct DRV_OBJECT *)deviceContext);
+	}
+
+	(void) DRV_Destroy((struct DRV_OBJECT *) deviceContext);
+
+	/* Get the Manager Object from Registry
+	 * MGR Destroy will unload the DCD dll */
+	if (DSP_SUCCEEDED(CFG_GetObject((u32 *)&mgrObject, REG_MGR_OBJECT)))
+		(void)MGR_Destroy(mgrObject);
+
+	WCD_Exit();
+
+	return retVal;
+}
diff --git a/drivers/dsp/bridge/rmgr/mgr.c b/drivers/dsp/bridge/rmgr/mgr.c
new file mode 100644
index 0000000..cf015a4
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/mgr.c
@@ -0,0 +1,389 @@
+/*
+ * mgr.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation of Manager interface to the device object at the
+ * driver level. This queries the NDB data base and retrieves the
+ * data about Node and Processor.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/dbdcd.h>
+#include <dspbridge/drv.h>
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/mgr.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define ZLDLLNAME               ""
+#define SIGNATURE               0x5f52474d	/* "MGR_" (in reverse) */
+
+struct MGR_OBJECT {
+	u32 dwSignature;
+	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
+};
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;
+
+/*
+ *  ========= MGR_Create =========
+ *  Purpose:
+ *      MGR Object gets created only once during driver Loading.
+ */
+DSP_STATUS MGR_Create(OUT struct MGR_OBJECT **phMgrObject,
+		     struct CFG_DEVNODE *hDevNode)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct MGR_OBJECT *pMgrObject = NULL;
+
+	DBC_Require(phMgrObject != NULL);
+	DBC_Require(cRefs > 0);
+
+	MEM_AllocObject(pMgrObject, struct MGR_OBJECT, SIGNATURE);
+	if (pMgrObject) {
+		status = DCD_CreateManager(ZLDLLNAME, &pMgrObject->hDcdMgr);
+		if (DSP_SUCCEEDED(status)) {
+			/* If succeeded store the handle in the MGR Object */
+			status = CFG_SetObject((u32)pMgrObject,
+							REG_MGR_OBJECT);
+			if (DSP_SUCCEEDED(status)) {
+				*phMgrObject = pMgrObject;
+			} else {
+				DCD_DestroyManager(pMgrObject->hDcdMgr);
+				MEM_FreeObject(pMgrObject);
+			}
+		} else {
+			/* failed to Create DCD Manager */
+			MEM_FreeObject(pMgrObject);
+		}
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	DBC_Ensure(DSP_FAILED(status) ||
+		  MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	return status;
+}
+
+/*
+ *  ========= MGR_Destroy =========
+ *     This function is invoked during bridge driver unloading.Frees MGR object.
+ */
+DSP_STATUS MGR_Destroy(struct MGR_OBJECT *hMgrObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMgrObject;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hMgrObject, SIGNATURE));
+
+	/* Free resources */
+	if (hMgrObject->hDcdMgr)
+		DCD_DestroyManager(hMgrObject->hDcdMgr);
+
+	MEM_FreeObject(pMgrObject);
+	/* Update the Registry with NULL for MGR Object */
+	(void)CFG_SetObject(0, REG_MGR_OBJECT);
+
+	DBC_Ensure(DSP_FAILED(status) ||
+		 !MEM_IsValidHandle(hMgrObject, SIGNATURE));
+
+	return status;
+}
+
+/*
+ *  ======== MGR_EnumNodeInfo ========
+ *      Enumerate and get configuration information about nodes configured
+ *      in the node database.
+ */
+DSP_STATUS MGR_EnumNodeInfo(u32 uNode, OUT struct DSP_NDBPROPS *pNDBProps,
+			   u32 uNDBPropsSize, OUT u32 *puNumNodes)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DSP_UUID Uuid, uTempUuid;
+	u32 uTempIndex = 0;
+	u32 uNodeIndex = 0;
+	struct DCD_GENERICOBJ GenObj;
+	struct MGR_OBJECT *pMgrObject = NULL;
+
+	DBC_Require(pNDBProps != NULL);
+	DBC_Require(puNumNodes != NULL);
+	DBC_Require(uNDBPropsSize >= sizeof(struct DSP_NDBPROPS));
+	DBC_Require(cRefs > 0);
+
+	*puNumNodes = 0;
+	/* Get The Manager Object from the Registry */
+	status = CFG_GetObject((u32 *)&pMgrObject, REG_MGR_OBJECT);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	/* Forever loop till we hit failed or no more items in the
+	 * Enumeration. We will exit the loop other than DSP_SOK; */
+	while (status == DSP_SOK) {
+		status = DCD_EnumerateObject(uTempIndex++, DSP_DCDNODETYPE,
+					    &uTempUuid);
+		if (status == DSP_SOK) {
+			uNodeIndex++;
+			if (uNode == (uNodeIndex - 1))
+				Uuid = uTempUuid;
+
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		if (uNode > (uNodeIndex - 1)) {
+			status = DSP_EINVALIDARG;
+		} else {
+			status = DCD_GetObjectDef(pMgrObject->hDcdMgr,
+						(struct DSP_UUID *)&Uuid,
+						DSP_DCDNODETYPE, &GenObj);
+			if (DSP_SUCCEEDED(status)) {
+				/* Get the Obj def */
+				*pNDBProps = GenObj.objData.nodeObj.ndbProps;
+				*puNumNodes = uNodeIndex;
+			}
+		}
+	}
+
+func_cont:
+	DBC_Ensure((DSP_SUCCEEDED(status) && *puNumNodes > 0) ||
+		  (DSP_FAILED(status) && *puNumNodes == 0));
+
+	return status;
+}
+
+/*
+ *  ======== MGR_EnumProcessorInfo ========
+ *      Enumerate and get configuration information about available
+ *      DSP processors.
+ */
+DSP_STATUS MGR_EnumProcessorInfo(u32 uProcessor,
+				OUT struct DSP_PROCESSORINFO *pProcessorInfo,
+				u32 uProcessorInfoSize, OUT u32 *puNumProcs)
+{
+	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status1 = DSP_SOK;
+	DSP_STATUS status2 = DSP_SOK;
+	struct DSP_UUID uTempUuid;
+	u32 uTempIndex = 0;
+	u32 uProcIndex = 0;
+	struct DCD_GENERICOBJ GenObj;
+	struct MGR_OBJECT *pMgrObject = NULL;
+	struct MGR_PROCESSOREXTINFO *pExtInfo;
+	struct DEV_OBJECT *hDevObject;
+	struct DRV_OBJECT *hDrvObject;
+	s32 devType;
+	struct CFG_DEVNODE *devNode;
+	struct CFG_DSPRES chipResources;
+	bool procDetect = false;
+
+	DBC_Require(pProcessorInfo != NULL);
+	DBC_Require(puNumProcs != NULL);
+	DBC_Require(uProcessorInfoSize >= sizeof(struct DSP_PROCESSORINFO));
+	DBC_Require(cRefs > 0);
+
+	*puNumProcs = 0;
+	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status)) {
+		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
+		if (DSP_SUCCEEDED(status)) {
+			status = DEV_GetDevType(hDevObject, (u32 *) &devType);
+			status = DEV_GetDevNode(hDevObject, &devNode);
+			if (devType == DSP_UNIT)
+				status = CFG_GetDSPResources(devNode,
+							 &chipResources);
+			else
+				status = DSP_EFAIL;
+
+			if (DSP_SUCCEEDED(status)) {
+				pProcessorInfo->uProcessorType =
+						chipResources.uChipType;
+			}
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Get The Manager Object from the Registry */
+	if (DSP_FAILED(CFG_GetObject((u32 *)&pMgrObject,
+	   REG_MGR_OBJECT))) {
+		dev_dbg(bridge, "%s: Failed to get MGR Object\n", __func__);
+		goto func_end;
+	}
+	DBC_Assert(MEM_IsValidHandle(pMgrObject, SIGNATURE));
+	/* Forever loop till we hit no more items in the
+	 * Enumeration. We will exit the loop other than DSP_SOK; */
+	while (status1 == DSP_SOK) {
+		status1 = DCD_EnumerateObject(uTempIndex++,
+					     DSP_DCDPROCESSORTYPE,
+					     &uTempUuid);
+		if (status1 != DSP_SOK)
+			break;
+
+		uProcIndex++;
+		/* Get the Object properties to find the Device/Processor
+		 * Type */
+		if (procDetect != false)
+			continue;
+
+		status2 = DCD_GetObjectDef(pMgrObject->hDcdMgr,
+					(struct DSP_UUID *)&uTempUuid,
+					DSP_DCDPROCESSORTYPE,
+					&GenObj);
+		if (DSP_SUCCEEDED(status2)) {
+			/* Get the Obj def */
+			if (uProcessorInfoSize <
+					sizeof(struct MGR_PROCESSOREXTINFO)) {
+				*pProcessorInfo = GenObj.objData.procObj;
+			} else {
+				/* extended info */
+				pExtInfo = (struct MGR_PROCESSOREXTINFO *)
+						pProcessorInfo;
+				*pExtInfo = GenObj.objData.extProcObj;
+			}
+			dev_dbg(bridge, "%s: Got proctype  from DCD %x\n",
+				__func__, pProcessorInfo->uProcessorType);
+			/* See if we got the needed processor */
+			if (devType == DSP_UNIT) {
+				if (pProcessorInfo->uProcessorType ==
+				   DSPPROCTYPE_C64)
+					procDetect = true;
+			} else if (devType == IVA_UNIT) {
+				if (pProcessorInfo->uProcessorType ==
+				   IVAPROCTYPE_ARM7)
+					procDetect = true;
+			}
+			/* User applciatiuons aonly check for chip type, so
+			 * this clumsy overwrite */
+			pProcessorInfo->uProcessorType =
+					 chipResources.uChipType;
+		} else {
+			dev_dbg(bridge, "%s: Failed to get DCD processor info "
+						"%x\n", __func__, status2);
+			status = DSP_EFAIL;
+		}
+	}
+	*puNumProcs = uProcIndex;
+	if (procDetect == false) {
+		dev_dbg(bridge, "%s: Failed to get proc info from DCD, so use "
+						"CFG registry\n", __func__);
+		pProcessorInfo->uProcessorType = chipResources.uChipType;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== MGR_Exit ========
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ */
+void MGR_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+	cRefs--;
+	if (cRefs == 0)
+		DCD_Exit();
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== MGR_GetDCDHandle ========
+ *      Retrieves the MGR handle. Accessor Function.
+ */
+DSP_STATUS MGR_GetDCDHandle(struct MGR_OBJECT *hMGRHandle,
+			   OUT u32 *phDCDHandle)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct MGR_OBJECT *pMgrObject = (struct MGR_OBJECT *)hMGRHandle;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDCDHandle != NULL);
+
+	*phDCDHandle = (u32)NULL;
+	if (MEM_IsValidHandle(pMgrObject, SIGNATURE)) {
+		*phDCDHandle = (u32) pMgrObject->hDcdMgr;
+		status = DSP_SOK;
+	}
+	DBC_Ensure((DSP_SUCCEEDED(status) && *phDCDHandle != (u32)NULL) ||
+		  (DSP_FAILED(status) && *phDCDHandle == (u32)NULL));
+
+	return status;
+}
+
+/*
+ *  ======== MGR_Init ========
+ *      Initialize MGR's private state, keeping a reference count on each call.
+ */
+bool MGR_Init(void)
+{
+	bool fRetval = true;
+	bool fInitDCD = false;
+
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0) {
+		fInitDCD = DCD_Init();	/*  DCD Module */
+
+		if (!fInitDCD)
+			fRetval = false;
+	}
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+/*
+ *  ======== MGR_WaitForBridgeEvents ========
+ *      Block on any Bridge event(s)
+ */
+DSP_STATUS MGR_WaitForBridgeEvents(struct DSP_NOTIFICATION **aNotifications,
+				  u32 uCount, OUT u32 *puIndex, u32 uTimeout)
+{
+	DSP_STATUS status;
+	struct SYNC_OBJECT *hSyncEvents[MAX_EVENTS];
+	u32 i;
+
+	DBC_Require(uCount < MAX_EVENTS);
+
+	for (i = 0; i < uCount; i++)
+		hSyncEvents[i] = aNotifications[i]->handle;
+
+	status = SYNC_WaitOnMultipleEvents(hSyncEvents, uCount, uTimeout,
+					 puIndex);
+
+	return status;
+
+}
+
diff --git a/drivers/dsp/bridge/rmgr/nldr.c b/drivers/dsp/bridge/rmgr/nldr.c
new file mode 100644
index 0000000..481a1bc
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/nldr.c
@@ -0,0 +1,1844 @@
+/*
+ * nldr.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge dynamic + overlay Node loader.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/host_os.h>
+
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+#include <dspbridge/dbc.h>
+
+/* OS adaptation layer */
+#include <dspbridge/mem.h>
+
+/* Platform manager */
+#include <dspbridge/cod.h>
+#include <dspbridge/dev.h>
+
+/* Resource manager */
+#include <dspbridge/dbll.h>
+#include <dspbridge/dbdcd.h>
+#include <dspbridge/rmm.h>
+#include <dspbridge/uuidutil.h>
+
+#include <dspbridge/nldr.h>
+
+#define NLDR_SIGNATURE      0x52444c4e	/* "RDLN" */
+#define NLDR_NODESIGNATURE  0x4e444c4e	/* "NDLN" */
+
+/* Name of section containing dynamic load mem */
+#define DYNMEMSECT  ".dspbridge_mem"
+
+/* Name of section containing dependent library information */
+#define DEPLIBSECT  ".dspbridge_deplibs"
+
+/* Max depth of recursion for loading node's dependent libraries */
+#define MAXDEPTH	    5
+
+/* Max number of persistent libraries kept by a node */
+#define MAXLIBS	 5
+
+/*
+ *  Defines for extracting packed dynamic load memory requirements from two
+ *  masks.
+ *  These defines must match node.cdb and dynm.cdb
+ *  Format of data/code mask is:
+ *   uuuuuuuu|fueeeeee|fudddddd|fucccccc|
+ *  where
+ *      u = unused
+ *      cccccc = prefered/required dynamic mem segid for create phase data/code
+ *      dddddd = prefered/required dynamic mem segid for delete phase data/code
+ *      eeeeee = prefered/req. dynamic mem segid for execute phase data/code
+ *      f = flag indicating if memory is preferred or required:
+ *	  f = 1 if required, f = 0 if preferred.
+ *
+ *  The 6 bits of the segid are interpreted as follows:
+ *
+ *  If the 6th bit (bit 5) is not set, then this specifies a memory segment
+ *  between 0 and 31 (a maximum of 32 dynamic loading memory segments).
+ *  If the 6th bit (bit 5) is set, segid has the following interpretation:
+ *      segid = 32 - Any internal memory segment can be used.
+ *      segid = 33 - Any external memory segment can be used.
+ *      segid = 63 - Any memory segment can be used (in this case the
+ *		   required/preferred flag is irrelevant).
+ *
+ */
+/* Maximum allowed dynamic loading memory segments */
+#define MAXMEMSEGS      32
+
+#define MAXSEGID	3	/* Largest possible (real) segid */
+#define MEMINTERNALID   32	/* Segid meaning use internal mem */
+#define MEMEXTERNALID   33	/* Segid meaning use external mem */
+#define NULLID	  63	/* Segid meaning no memory req/pref */
+#define FLAGBIT	 7	/* 7th bit is pref./req. flag */
+#define SEGMASK	 0x3f	/* Bits 0 - 5 */
+
+#define CREATEBIT	0	/* Create segid starts at bit 0 */
+#define DELETEBIT	8	/* Delete segid starts at bit 8 */
+#define EXECUTEBIT      16	/* Execute segid starts at bit 16 */
+
+/*
+ *  Masks that define memory type.  Must match defines in dynm.cdb.
+ */
+#define DYNM_CODE	0x2
+#define DYNM_DATA	0x4
+#define DYNM_CODEDATA   (DYNM_CODE | DYNM_DATA)
+#define DYNM_INTERNAL   0x8
+#define DYNM_EXTERNAL   0x10
+
+/*
+ *  Defines for packing memory requirement/preference flags for code and
+ *  data of each of the node's phases into one mask.
+ *  The bit is set if the segid is required for loading code/data of the
+ *  given phase. The bit is not set, if the segid is preferred only.
+ *
+ *  These defines are also used as indeces into a segid array for the node.
+ *  eg node's segid[CREATEDATAFLAGBIT] is the memory segment id that the
+ *  create phase data is required or preferred to be loaded into.
+ */
+#define CREATEDATAFLAGBIT   0
+#define CREATECODEFLAGBIT   1
+#define EXECUTEDATAFLAGBIT  2
+#define EXECUTECODEFLAGBIT  3
+#define DELETEDATAFLAGBIT   4
+#define DELETECODEFLAGBIT   5
+#define MAXFLAGS	    6
+
+#define IsInternal(hNldr, segid) (((segid) <= MAXSEGID && \
+	    hNldr->segTable[(segid)] & DYNM_INTERNAL) || \
+	    (segid) == MEMINTERNALID)
+
+#define IsExternal(hNldr, segid) (((segid) <= MAXSEGID && \
+	    hNldr->segTable[(segid)] & DYNM_EXTERNAL) || \
+	    (segid) == MEMEXTERNALID)
+
+#define SWAPLONG(x) ((((x) << 24) & 0xFF000000) | (((x) << 8) & 0xFF0000L) | \
+	(((x) >> 8) & 0xFF00L) | (((x) >> 24) & 0xFF))
+
+#define SWAPWORD(x) ((((x) << 8) & 0xFF00) | (((x) >> 8) & 0xFF))
+
+    /*
+     *  These names may be embedded in overlay sections to identify which
+     *  node phase the section should be overlayed.
+     */
+#define PCREATE	 "create"
+#define PDELETE	 "delete"
+#define PEXECUTE	"execute"
+
+#define IsEqualUUID(uuid1, uuid2) (\
+	((uuid1).ulData1 == (uuid2).ulData1) && \
+	((uuid1).usData2 == (uuid2).usData2) && \
+	((uuid1).usData3 == (uuid2).usData3) && \
+	((uuid1).ucData4 == (uuid2).ucData4) && \
+	((uuid1).ucData5 == (uuid2).ucData5) && \
+	(strncmp((void *)(uuid1).ucData6, (void *)(uuid2).ucData6, 6)) == 0)
+
+    /*
+     *  ======== MemInfo ========
+     *  Format of dynamic loading memory segment info in coff file.
+     *  Must match dynm.h55.
+     */
+struct MemInfo {
+	u32 segid;		/* Dynamic loading memory segment number */
+	u32 base;
+	u32 len;
+	u32 type;		/* Mask of DYNM_CODE, DYNM_INTERNAL, etc. */
+};
+
+/*
+ *  ======== LibNode ========
+ *  For maintaining a tree of library dependencies.
+ */
+struct LibNode {
+	struct DBLL_LibraryObj *lib;	/* The library */
+	u16 nDepLibs;	/* Number of dependent libraries */
+	struct LibNode *pDepLibs;	/* Dependent libraries of lib */
+};
+
+/*
+ *  ======== OvlySect ========
+ *  Information needed to overlay a section.
+ */
+struct OvlySect {
+	struct OvlySect *pNextSect;
+	u32 loadAddr;		/* Load address of section */
+	u32 runAddr;		/* Run address of section */
+	u32 size;		/* Size of section */
+	u16 page;		/* DBL_CODE, DBL_DATA */
+};
+
+/*
+ *  ======== OvlyNode ========
+ *  For maintaining a list of overlay nodes, with sections that need to be
+ *  overlayed for each of the nodes phases.
+ */
+struct OvlyNode {
+	struct DSP_UUID uuid;
+	char *pNodeName;
+	struct OvlySect *pCreateSects;
+	struct OvlySect *pDeleteSects;
+	struct OvlySect *pExecuteSects;
+	struct OvlySect *pOtherSects;
+	u16 nCreateSects;
+	u16 nDeleteSects;
+	u16 nExecuteSects;
+	u16 nOtherSects;
+	u16 createRef;
+	u16 deleteRef;
+	u16 executeRef;
+	u16 otherRef;
+};
+
+/*
+ *  ======== NLDR_OBJECT ========
+ *  Overlay loader object.
+ */
+struct NLDR_OBJECT {
+	u32 dwSignature;	/* For object validation */
+	struct DEV_OBJECT *hDevObject;	/* Device object */
+	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
+	struct DBLL_TarObj *dbll;	/* The DBL loader */
+	struct DBLL_LibraryObj *baseLib;	/* Base image library */
+	struct RMM_TargetObj *rmm;	/* Remote memory manager for DSP */
+	struct DBLL_Fxns dbllFxns;	/* Loader function table */
+	struct DBLL_Attrs dbllAttrs;	/* attrs to pass to loader functions */
+	NLDR_OVLYFXN ovlyFxn;	/* "write" for overlay nodes */
+	NLDR_WRITEFXN writeFxn;	/* "write" for dynamic nodes */
+	struct OvlyNode *ovlyTable;	/* Table of overlay nodes */
+	u16 nOvlyNodes;	/* Number of overlay nodes in base */
+	u16 nNode;		/* Index for tracking overlay nodes */
+	u16 nSegs;		/* Number of dynamic load mem segs */
+	u32 *segTable;	/* memtypes of dynamic memory segs
+				 * indexed by segid
+				 */
+	u16 usDSPMauSize;	/* Size of DSP MAU */
+	u16 usDSPWordSize;	/* Size of DSP word */
+};
+
+/*
+ *  ======== NLDR_NODEOBJECT ========
+ *  Dynamic node object. This object is created when a node is allocated.
+ */
+struct NLDR_NODEOBJECT {
+	u32 dwSignature;	/* For object validation */
+	struct NLDR_OBJECT *pNldr;	/* Dynamic loader handle */
+	void *pPrivRef;		/* Handle to pass to DBL_WriteFxn */
+	struct DSP_UUID uuid;		/* Node's UUID */
+	bool fDynamic;		/* Dynamically loaded node? */
+	bool fOverlay;		/* Overlay node? */
+	bool *pfPhaseSplit;	/* Multiple phase libraries? */
+	struct LibNode root;		/* Library containing node phase */
+	struct LibNode createLib;    /* Library containing create phase lib */
+	struct LibNode executeLib;   /* Library containing execute phase lib */
+	struct LibNode deleteLib;    /* Library containing delete phase lib */
+	struct LibNode persLib[MAXLIBS];  /* libs remain loaded until Delete */
+	s32 nPersLib;		/* Number of persistent libraries */
+	/* Path in lib dependency tree */
+	struct DBLL_LibraryObj *libPath[MAXDEPTH + 1];
+	enum NLDR_PHASE phase;	/* Node phase currently being loaded */
+
+	/*
+	 *  Dynamic loading memory segments for data and code of each phase.
+	 */
+	u16 segId[MAXFLAGS];
+
+	/*
+	 *  Mask indicating whether each mem segment specified in segId[]
+	 *  is preferred or required.
+	 *  For example if (codeDataFlagMask & (1 << EXECUTEDATAFLAGBIT)) != 0,
+	 *  then it is required to load execute phase data into the memory
+	 *  specified by segId[EXECUTEDATAFLAGBIT].
+	 */
+	u32 codeDataFlagMask;
+};
+
+/* Dynamic loader function table */
+static struct DBLL_Fxns dbllFxns = {
+	(DBLL_CloseFxn) DBLL_close,
+	(DBLL_CreateFxn) DBLL_create,
+	(DBLL_DeleteFxn) DBLL_delete,
+	(DBLL_ExitFxn) DBLL_exit,
+	(DBLL_GetAttrsFxn) DBLL_getAttrs,
+	(DBLL_GetAddrFxn) DBLL_getAddr,
+	(DBLL_GetCAddrFxn) DBLL_getCAddr,
+	(DBLL_GetSectFxn) DBLL_getSect,
+	(DBLL_InitFxn) DBLL_init,
+	(DBLL_LoadFxn) DBLL_load,
+	(DBLL_LoadSectFxn) DBLL_loadSect,
+	(DBLL_OpenFxn) DBLL_open,
+	(DBLL_ReadSectFxn) DBLL_readSect,
+	(DBLL_SetAttrsFxn) DBLL_setAttrs,
+	(DBLL_UnloadFxn) DBLL_unload,
+	(DBLL_UnloadSectFxn) DBLL_unloadSect,
+};
+
+static u32 cRefs;		/* module reference count */
+
+static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
+			     u32 addr, u32 nBytes);
+static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
+			     enum DSP_DCDOBJTYPE objType,
+			     IN void *handle);
+static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
+			      struct OvlySect **pList,
+			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
+			      u32 addr, u32 nBytes);
+static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
+			s32 mtype);
+static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
+		     u16 nAlloc);
+static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
+			  char *symName, struct DBLL_Symbol **sym);
+static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
+			 struct LibNode *root, struct DSP_UUID uuid,
+			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
+			 enum NLDR_PHASE phase, u16 depth);
+static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
+			  enum NLDR_PHASE phase);
+static DSP_STATUS RemoteAlloc(void **pRef, u16 memType, u32 size,
+			     u32 align, u32 *dspAddr,
+			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
+			     bool reserve);
+static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
+			    u32 size, bool reserve);
+
+static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root);
+static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode,
+		      enum NLDR_PHASE phase);
+static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
+				    struct DBLL_LibraryObj *lib);
+static u32 findLcm(u32 a, u32 b);
+static u32 findGcf(u32 a, u32 b);
+
+/*
+ *  ======== NLDR_Allocate ========
+ */
+DSP_STATUS NLDR_Allocate(struct NLDR_OBJECT *hNldr, void *pPrivRef,
+			 IN CONST struct DCD_NODEPROPS *pNodeProps,
+			 OUT struct NLDR_NODEOBJECT **phNldrNode,
+			 IN bool *pfPhaseSplit)
+{
+	struct NLDR_NODEOBJECT *pNldrNode = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pNodeProps != NULL);
+	DBC_Require(phNldrNode != NULL);
+	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+
+	/* Initialize handle in case of failure */
+	*phNldrNode = NULL;
+	/* Allocate node object */
+	MEM_AllocObject(pNldrNode, struct NLDR_NODEOBJECT, NLDR_NODESIGNATURE);
+
+	if (pNldrNode == NULL) {
+		status = DSP_EMEMORY;
+	} else {
+		pNldrNode->pfPhaseSplit = pfPhaseSplit;
+		pNldrNode->nPersLib = 0;
+		pNldrNode->pNldr = hNldr;
+		pNldrNode->pPrivRef = pPrivRef;
+		/* Save node's UUID. */
+		pNldrNode->uuid = pNodeProps->ndbProps.uiNodeID;
+		/*
+		 *  Determine if node is a dynamically loaded node from
+		 *  ndbProps.
+		 */
+		if (pNodeProps->usLoadType == NLDR_DYNAMICLOAD) {
+			/* Dynamic node */
+			pNldrNode->fDynamic = true;
+			/*
+			 *  Extract memory requirements from ndbProps masks
+			 */
+			/* Create phase */
+			pNldrNode->segId[CREATEDATAFLAGBIT] = (u16)
+				(pNodeProps->ulDataMemSegMask >> CREATEBIT) &
+				SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulDataMemSegMask >>
+				(CREATEBIT + FLAGBIT)) & 1) <<
+				CREATEDATAFLAGBIT;
+			pNldrNode->segId[CREATECODEFLAGBIT] = (u16)
+				(pNodeProps->ulCodeMemSegMask >>
+				CREATEBIT) & SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulCodeMemSegMask >>
+				(CREATEBIT + FLAGBIT)) & 1) <<
+				CREATECODEFLAGBIT;
+			/* Execute phase */
+			pNldrNode->segId[EXECUTEDATAFLAGBIT] = (u16)
+				(pNodeProps->ulDataMemSegMask >>
+				EXECUTEBIT) & SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulDataMemSegMask >>
+				(EXECUTEBIT + FLAGBIT)) & 1) <<
+				EXECUTEDATAFLAGBIT;
+			pNldrNode->segId[EXECUTECODEFLAGBIT] = (u16)
+				(pNodeProps->ulCodeMemSegMask >>
+				EXECUTEBIT) & SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulCodeMemSegMask >>
+				(EXECUTEBIT + FLAGBIT)) & 1) <<
+				EXECUTECODEFLAGBIT;
+			/* Delete phase */
+			pNldrNode->segId[DELETEDATAFLAGBIT] = (u16)
+			    (pNodeProps->ulDataMemSegMask >> DELETEBIT) &
+			    SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulDataMemSegMask >>
+				(DELETEBIT + FLAGBIT)) & 1) <<
+				DELETEDATAFLAGBIT;
+			pNldrNode->segId[DELETECODEFLAGBIT] = (u16)
+				(pNodeProps->ulCodeMemSegMask >>
+				DELETEBIT) & SEGMASK;
+			pNldrNode->codeDataFlagMask |=
+				((pNodeProps->ulCodeMemSegMask >>
+				(DELETEBIT + FLAGBIT)) & 1) <<
+				DELETECODEFLAGBIT;
+		} else {
+			/* Non-dynamically loaded nodes are part of the
+			 * base image */
+			pNldrNode->root.lib = hNldr->baseLib;
+			/* Check for overlay node */
+			if (pNodeProps->usLoadType == NLDR_OVLYLOAD)
+				pNldrNode->fOverlay = true;
+
+		}
+		*phNldrNode = (struct NLDR_NODEOBJECT *) pNldrNode;
+	}
+	/* Cleanup on failure */
+	if (DSP_FAILED(status) && pNldrNode)
+		MEM_FreeObject(pNldrNode);
+
+	DBC_Ensure((DSP_SUCCEEDED(status) &&
+		  MEM_IsValidHandle(((struct NLDR_NODEOBJECT *)(*phNldrNode)),
+		  NLDR_NODESIGNATURE)) || (DSP_FAILED(status) &&
+		  *phNldrNode == NULL));
+	return status;
+}
+
+/*
+ *  ======== NLDR_Create ========
+ */
+DSP_STATUS NLDR_Create(OUT struct NLDR_OBJECT **phNldr,
+		      struct DEV_OBJECT *hDevObject,
+		      IN CONST struct NLDR_ATTRS *pAttrs)
+{
+	struct COD_MANAGER *hCodMgr;	/* COD manager */
+	char *pszCoffBuf = NULL;
+	char szZLFile[COD_MAXPATHLENGTH];
+	struct NLDR_OBJECT *pNldr = NULL;
+	struct DBLL_Attrs saveAttrs;
+	struct DBLL_Attrs newAttrs;
+	DBLL_Flags flags;
+	u32 ulEntry;
+	u16 nSegs = 0;
+	struct MemInfo *pMemInfo;
+	u32 ulLen = 0;
+	u32 ulAddr;
+	struct RMM_Segment *rmmSegs = NULL;
+	u16 i;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+	DBC_Require(phNldr != NULL);
+	DBC_Require(hDevObject != NULL);
+	DBC_Require(pAttrs != NULL);
+	DBC_Require(pAttrs->pfnOvly != NULL);
+	DBC_Require(pAttrs->pfnWrite != NULL);
+
+	/* Allocate dynamic loader object */
+	MEM_AllocObject(pNldr, struct NLDR_OBJECT, NLDR_SIGNATURE);
+	if (pNldr) {
+		pNldr->hDevObject = hDevObject;
+		/* warning, lazy status checking alert! */
+		status = DEV_GetCodMgr(hDevObject, &hCodMgr);
+		DBC_Assert(DSP_SUCCEEDED(status));
+		status = COD_GetLoader(hCodMgr, &pNldr->dbll);
+		DBC_Assert(DSP_SUCCEEDED(status));
+		status = COD_GetBaseLib(hCodMgr, &pNldr->baseLib);
+		DBC_Assert(DSP_SUCCEEDED(status));
+		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+		DBC_Assert(DSP_SUCCEEDED(status));
+		status = DSP_SOK;
+		/* end lazy status checking */
+		pNldr->usDSPMauSize = pAttrs->usDSPMauSize;
+		pNldr->usDSPWordSize = pAttrs->usDSPWordSize;
+		pNldr->dbllFxns = dbllFxns;
+		if (!(pNldr->dbllFxns.initFxn()))
+			status = DSP_EMEMORY;
+
+	} else {
+		status = DSP_EMEMORY;
+	}
+	/* Create the DCD Manager */
+	if (DSP_SUCCEEDED(status))
+		status = DCD_CreateManager(NULL, &pNldr->hDcdMgr);
+
+	/* Get dynamic loading memory sections from base lib */
+	if (DSP_SUCCEEDED(status)) {
+		status = pNldr->dbllFxns.getSectFxn(pNldr->baseLib, DYNMEMSECT,
+			 &ulAddr, &ulLen);
+		if (DSP_SUCCEEDED(status)) {
+			pszCoffBuf = MEM_Calloc(ulLen * pNldr->usDSPMauSize,
+						MEM_PAGED);
+			if (!pszCoffBuf) {
+				status = DSP_EMEMORY;
+			}
+		} else {
+			/* Ok to not have dynamic loading memory */
+			status = DSP_SOK;
+			ulLen = 0;
+			dev_dbg(bridge, "%s: failed - no dynamic loading mem "
+					"segments: 0x%x\n", __func__, status);
+		}
+	}
+	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+		/* Read section containing dynamic load mem segments */
+		status = pNldr->dbllFxns.readSectFxn(pNldr->baseLib, DYNMEMSECT,
+						    pszCoffBuf, ulLen);
+	}
+	if (DSP_SUCCEEDED(status) && ulLen > 0) {
+		/* Parse memory segment data */
+		nSegs = (u16)(*((u32 *)pszCoffBuf));
+		if (nSegs > MAXMEMSEGS)
+			status = DSP_ECORRUPTFILE;
+	}
+	/* Parse dynamic load memory segments */
+	if (DSP_SUCCEEDED(status) && nSegs > 0) {
+		rmmSegs = MEM_Calloc(sizeof(struct RMM_Segment) * nSegs,
+				    MEM_PAGED);
+		pNldr->segTable = MEM_Calloc(sizeof(u32) * nSegs, MEM_PAGED);
+		if (rmmSegs == NULL || pNldr->segTable == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			pNldr->nSegs = nSegs;
+			pMemInfo = (struct MemInfo *)(pszCoffBuf +
+				   sizeof(u32));
+			for (i = 0; i < nSegs; i++) {
+				rmmSegs[i].base = (pMemInfo + i)->base;
+				rmmSegs[i].length = (pMemInfo + i)->len;
+				rmmSegs[i].space = 0;
+				pNldr->segTable[i] = (pMemInfo + i)->type;
+				dev_dbg(bridge, "(proc) DLL MEMSEGMENT: %d, "
+					"Base: 0x%x, Length: 0x%x\n", i,
+					rmmSegs[i].base, rmmSegs[i].length);
+			}
+		}
+	}
+	/* Create Remote memory manager */
+	if (DSP_SUCCEEDED(status))
+		status = RMM_create(&pNldr->rmm, rmmSegs, nSegs);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* set the alloc, free, write functions for loader */
+		pNldr->dbllFxns.getAttrsFxn(pNldr->dbll, &saveAttrs);
+		newAttrs = saveAttrs;
+		newAttrs.alloc = (DBLL_AllocFxn) RemoteAlloc;
+		newAttrs.free = (DBLL_FreeFxn) RemoteFree;
+		newAttrs.symLookup = (DBLL_SymLookup) GetSymbolValue;
+		newAttrs.symHandle = pNldr;
+		newAttrs.write = (DBLL_WriteFxn) pAttrs->pfnWrite;
+		pNldr->ovlyFxn = pAttrs->pfnOvly;
+		pNldr->writeFxn = pAttrs->pfnWrite;
+		pNldr->dbllAttrs = newAttrs;
+	}
+	kfree(rmmSegs);
+
+	kfree(pszCoffBuf);
+
+	/* Get overlay nodes */
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_GetBaseName(hCodMgr, szZLFile, COD_MAXPATHLENGTH);
+		/* lazy check */
+		DBC_Assert(DSP_SUCCEEDED(status));
+		/* First count number of overlay nodes */
+		status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile, AddOvlyNode,
+					(void *) pNldr);
+		/* Now build table of overlay nodes */
+		if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
+			/* Allocate table for overlay nodes */
+			pNldr->ovlyTable =
+			MEM_Calloc(sizeof(struct OvlyNode) * pNldr->nOvlyNodes,
+				  MEM_PAGED);
+			/* Put overlay nodes in the table */
+			pNldr->nNode = 0;
+			status = DCD_GetObjects(pNldr->hDcdMgr, szZLFile,
+						AddOvlyNode,
+						(void *) pNldr);
+		}
+	}
+	/* Do a fake reload of the base image to get overlay section info */
+	if (DSP_SUCCEEDED(status) && pNldr->nOvlyNodes > 0) {
+		saveAttrs.write = fakeOvlyWrite;
+		saveAttrs.logWrite = AddOvlyInfo;
+		saveAttrs.logWriteHandle = pNldr;
+		flags = DBLL_CODE | DBLL_DATA | DBLL_SYMB;
+		status = pNldr->dbllFxns.loadFxn(pNldr->baseLib, flags,
+						&saveAttrs, &ulEntry);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		*phNldr = (struct NLDR_OBJECT *) pNldr;
+	} else {
+		if (pNldr)
+			NLDR_Delete((struct NLDR_OBJECT *) pNldr);
+
+		*phNldr = NULL;
+	}
+	/* FIXME:Temp. Fix. Must be removed */
+	DBC_Ensure((DSP_SUCCEEDED(status) &&
+			 MEM_IsValidHandle(((struct NLDR_OBJECT *)*phNldr),
+					  NLDR_SIGNATURE))
+			|| (DSP_FAILED(status) && (*phNldr == NULL)));
+	return status;
+}
+
+/*
+ *  ======== NLDR_Delete ========
+ */
+void NLDR_Delete(struct NLDR_OBJECT *hNldr)
+{
+	struct OvlySect *pSect;
+	struct OvlySect *pNext;
+	u16 i;
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+
+	hNldr->dbllFxns.exitFxn();
+	if (hNldr->rmm)
+		RMM_delete(hNldr->rmm);
+
+	kfree(hNldr->segTable);
+
+	if (hNldr->hDcdMgr)
+		DCD_DestroyManager(hNldr->hDcdMgr);
+
+	/* Free overlay node information */
+	if (hNldr->ovlyTable) {
+		for (i = 0; i < hNldr->nOvlyNodes; i++) {
+			pSect = hNldr->ovlyTable[i].pCreateSects;
+			while (pSect) {
+				pNext = pSect->pNextSect;
+				kfree(pSect);
+				pSect = pNext;
+			}
+			pSect = hNldr->ovlyTable[i].pDeleteSects;
+			while (pSect) {
+				pNext = pSect->pNextSect;
+				kfree(pSect);
+				pSect = pNext;
+			}
+			pSect = hNldr->ovlyTable[i].pExecuteSects;
+			while (pSect) {
+				pNext = pSect->pNextSect;
+				kfree(pSect);
+				pSect = pNext;
+			}
+			pSect = hNldr->ovlyTable[i].pOtherSects;
+			while (pSect) {
+				pNext = pSect->pNextSect;
+				kfree(pSect);
+				pSect = pNext;
+			}
+		}
+		kfree(hNldr->ovlyTable);
+	}
+	MEM_FreeObject(hNldr);
+	DBC_Ensure(!MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+}
+
+/*
+ *  ======== NLDR_Exit ========
+ *  Discontinue usage of NLDR module.
+ */
+void NLDR_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	if (cRefs == 0)
+		RMM_exit();
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== NLDR_GetFxnAddr ========
+ */
+DSP_STATUS NLDR_GetFxnAddr(struct NLDR_NODEOBJECT *hNldrNode, char *pstrFxn,
+			  u32 *pulAddr)
+{
+	struct DBLL_Symbol *pSym;
+	struct NLDR_OBJECT *hNldr;
+	DSP_STATUS status = DSP_SOK;
+	bool status1 = false;
+	s32 i = 0;
+	struct LibNode root = { NULL, 0, NULL };
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+	DBC_Require(pulAddr != NULL);
+	DBC_Require(pstrFxn != NULL);
+
+	hNldr = hNldrNode->pNldr;
+	/* Called from NODE_Create(), NODE_Delete(), or NODE_Run(). */
+	if (hNldrNode->fDynamic && *hNldrNode->pfPhaseSplit) {
+		switch (hNldrNode->phase) {
+		case NLDR_CREATE:
+			root = hNldrNode->createLib;
+			break;
+		case NLDR_EXECUTE:
+			root = hNldrNode->executeLib;
+			break;
+		case NLDR_DELETE:
+			root = hNldrNode->deleteLib;
+			break;
+		default:
+			DBC_Assert(false);
+			break;
+		}
+	} else {
+		/* for Overlay nodes or non-split Dynamic nodes */
+		root = hNldrNode->root;
+	}
+	status1 = hNldr->dbllFxns.getCAddrFxn(root.lib, pstrFxn, &pSym);
+	if (!status1)
+		status1 = hNldr->dbllFxns.getAddrFxn(root.lib, pstrFxn, &pSym);
+
+	/* If symbol not found, check dependent libraries */
+	if (!status1) {
+		for (i = 0; i < root.nDepLibs; i++) {
+			status1 = hNldr->dbllFxns.getAddrFxn(root.pDepLibs[i].
+					lib, pstrFxn, &pSym);
+			if (!status1) {
+				status1 = hNldr->dbllFxns.getCAddrFxn(root.
+					pDepLibs[i].lib, pstrFxn, &pSym);
+			}
+			if (status1) {
+				/* Symbol found */
+				break;
+			}
+		}
+	}
+	/* Check persistent libraries */
+	if (!status1) {
+		for (i = 0; i < hNldrNode->nPersLib; i++) {
+			status1 = hNldr->dbllFxns.getAddrFxn(hNldrNode->
+					persLib[i].lib,	pstrFxn, &pSym);
+			if (!status1) {
+				status1 =
+				    hNldr->dbllFxns.getCAddrFxn(hNldrNode->
+					persLib[i].lib,	pstrFxn, &pSym);
+			}
+			if (status1) {
+				/* Symbol found */
+				break;
+			}
+		}
+	}
+
+	if (status1)
+		*pulAddr = pSym->value;
+	else
+		status = DSP_ESYMBOL;
+
+	return status;
+}
+
+/*
+ *  ======== NLDR_GetRmmManager ========
+ *  Given a NLDR object, retrieve RMM Manager Handle
+ */
+DSP_STATUS NLDR_GetRmmManager(struct NLDR_OBJECT *hNldrObject,
+			     OUT struct RMM_TargetObj **phRmmMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct NLDR_OBJECT *pNldrObject = hNldrObject;
+	DBC_Require(phRmmMgr != NULL);
+
+	if (MEM_IsValidHandle(hNldrObject, NLDR_SIGNATURE)) {
+		*phRmmMgr = pNldrObject->rmm;
+	} else {
+		*phRmmMgr = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phRmmMgr != NULL) &&
+		  (*phRmmMgr == NULL)));
+
+	return status;
+}
+
+/*
+ *  ======== NLDR_Init ========
+ *  Initialize the NLDR module.
+ */
+bool NLDR_Init(void)
+{
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0)
+		RMM_init();
+
+	cRefs++;
+
+	DBC_Ensure(cRefs > 0);
+	return true;
+}
+
+/*
+ *  ======== NLDR_Load ========
+ */
+DSP_STATUS NLDR_Load(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+{
+	struct NLDR_OBJECT *hNldr;
+	struct DSP_UUID libUUID;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+
+	hNldr = hNldrNode->pNldr;
+
+	if (hNldrNode->fDynamic) {
+		hNldrNode->phase = phase;
+
+		libUUID = hNldrNode->uuid;
+
+		/* At this point, we may not know if node is split into
+		 * different libraries. So we'll go ahead and load the
+		 * library, and then save the pointer to the appropriate
+		 * location after we know. */
+
+		status = LoadLib(hNldrNode, &hNldrNode->root, libUUID, false,
+				hNldrNode->libPath, phase, 0);
+
+		if (DSP_SUCCEEDED(status)) {
+			if (*hNldrNode->pfPhaseSplit) {
+				switch (phase) {
+				case NLDR_CREATE:
+					hNldrNode->createLib = hNldrNode->root;
+					break;
+
+				case NLDR_EXECUTE:
+					hNldrNode->executeLib = hNldrNode->root;
+					break;
+
+				case NLDR_DELETE:
+					hNldrNode->deleteLib = hNldrNode->root;
+					break;
+
+				default:
+					DBC_Assert(false);
+					break;
+				}
+			}
+		}
+	} else {
+		if (hNldrNode->fOverlay)
+			status = LoadOvly(hNldrNode, phase);
+
+	}
+
+	return status;
+}
+
+/*
+ *  ======== NLDR_Unload ========
+ */
+DSP_STATUS NLDR_Unload(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct LibNode *pRootLib = NULL;
+	s32 i = 0;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNldrNode, NLDR_NODESIGNATURE));
+
+	if (hNldrNode != NULL) {
+		if (hNldrNode->fDynamic) {
+			if (*hNldrNode->pfPhaseSplit) {
+				switch (phase) {
+				case NLDR_CREATE:
+					pRootLib = &hNldrNode->createLib;
+					break;
+				case NLDR_EXECUTE:
+					pRootLib = &hNldrNode->executeLib;
+					break;
+				case NLDR_DELETE:
+					pRootLib = &hNldrNode->deleteLib;
+					/* Unload persistent libraries */
+					for (i = 0; i < hNldrNode->nPersLib;
+					    i++) {
+						UnloadLib(hNldrNode,
+							&hNldrNode->persLib[i]);
+					}
+					hNldrNode->nPersLib = 0;
+					break;
+				default:
+					DBC_Assert(false);
+					break;
+				}
+			} else {
+				/* Unload main library */
+				pRootLib = &hNldrNode->root;
+			}
+			if (pRootLib)
+				UnloadLib(hNldrNode, pRootLib);
+		} else {
+			if (hNldrNode->fOverlay)
+				UnloadOvly(hNldrNode, phase);
+
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== AddOvlyInfo ========
+ */
+static DSP_STATUS AddOvlyInfo(void *handle, struct DBLL_SectInfo *sectInfo,
+			     u32 addr, u32 nBytes)
+{
+	char *pNodeName;
+	char *pSectName = (char *)sectInfo->name;
+	bool fExists = false;
+	char seps = ':';
+	char *pch;
+	u16 i;
+	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
+	DSP_STATUS status = DSP_SOK;
+
+	/* Is this an overlay section (load address != run address)? */
+	if (sectInfo->loadAddr == sectInfo->runAddr)
+		goto func_end;
+
+	/* Find the node it belongs to */
+	for (i = 0; i < hNldr->nOvlyNodes; i++) {
+		pNodeName = hNldr->ovlyTable[i].pNodeName;
+		DBC_Require(pNodeName);
+		if (strncmp(pNodeName, pSectName + 1,
+				strlen(pNodeName)) == 0) {
+				/* Found the node */
+				break;
+		}
+	}
+	if (!(i < hNldr->nOvlyNodes))
+		goto func_end;
+
+	/* Determine which phase this section belongs to */
+	for (pch = pSectName + 1; *pch && *pch != seps; pch++)
+		;
+
+	if (*pch) {
+		pch++;	/* Skip over the ':' */
+		if (strncmp(pch, PCREATE, strlen(PCREATE)) == 0) {
+			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
+				pCreateSects, sectInfo, &fExists, addr, nBytes);
+			if (DSP_SUCCEEDED(status) && !fExists)
+				hNldr->ovlyTable[i].nCreateSects++;
+
+		} else
+		if (strncmp(pch, PDELETE, strlen(PDELETE)) == 0) {
+			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
+					    pDeleteSects, sectInfo, &fExists,
+					    addr, nBytes);
+			if (DSP_SUCCEEDED(status) && !fExists)
+				hNldr->ovlyTable[i].nDeleteSects++;
+
+		} else
+		if (strncmp(pch, PEXECUTE, strlen(PEXECUTE)) == 0) {
+			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
+					    pExecuteSects, sectInfo, &fExists,
+					    addr, nBytes);
+			if (DSP_SUCCEEDED(status) && !fExists)
+				hNldr->ovlyTable[i].nExecuteSects++;
+
+		} else {
+			/* Put in "other" sectins */
+			status = AddOvlySect(hNldr, &hNldr->ovlyTable[i].
+					    pOtherSects, sectInfo, &fExists,
+					    addr, nBytes);
+			if (DSP_SUCCEEDED(status) && !fExists)
+				hNldr->ovlyTable[i].nOtherSects++;
+
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== AddOvlyNode =========
+ *  Callback function passed to DCD_GetObjects.
+ */
+static DSP_STATUS AddOvlyNode(struct DSP_UUID *pUuid,
+			     enum DSP_DCDOBJTYPE objType,
+			     IN void *handle)
+{
+	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
+	char *pNodeName = NULL;
+	char *pBuf = NULL;
+	u32 uLen;
+	struct DCD_GENERICOBJ objDef;
+	DSP_STATUS status = DSP_SOK;
+
+	if (objType != DSP_DCDNODETYPE)
+		goto func_end;
+
+	status = DCD_GetObjectDef(hNldr->hDcdMgr, pUuid, objType, &objDef);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* If overlay node, add to the list */
+	if (objDef.objData.nodeObj.usLoadType == NLDR_OVLYLOAD) {
+		if (hNldr->ovlyTable == NULL) {
+			hNldr->nOvlyNodes++;
+		} else {
+			/* Add node to table */
+			hNldr->ovlyTable[hNldr->nNode].uuid = *pUuid;
+			DBC_Require(objDef.objData.nodeObj.ndbProps.acName);
+			uLen = strlen(objDef.objData.nodeObj.ndbProps.acName);
+			pNodeName = objDef.objData.nodeObj.ndbProps.acName;
+			pBuf = MEM_Calloc(uLen + 1, MEM_PAGED);
+			if (pBuf == NULL) {
+				status = DSP_EMEMORY;
+			} else {
+				strncpy(pBuf, pNodeName, uLen);
+				hNldr->ovlyTable[hNldr->nNode].pNodeName = pBuf;
+				hNldr->nNode++;
+			}
+		}
+	}
+	/* These were allocated in DCD_GetObjectDef */
+	kfree(objDef.objData.nodeObj.pstrCreatePhaseFxn);
+
+	kfree(objDef.objData.nodeObj.pstrExecutePhaseFxn);
+
+	kfree(objDef.objData.nodeObj.pstrDeletePhaseFxn);
+
+	kfree(objDef.objData.nodeObj.pstrIAlgName);
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== AddOvlySect ========
+ */
+static DSP_STATUS AddOvlySect(struct NLDR_OBJECT *hNldr,
+			      struct OvlySect **pList,
+			      struct DBLL_SectInfo *pSectInfo, bool *pExists,
+			      u32 addr, u32 nBytes)
+{
+	struct OvlySect *pNewSect = NULL;
+	struct OvlySect *pLastSect;
+	struct OvlySect *pSect;
+	DSP_STATUS status = DSP_SOK;
+
+	pSect = pLastSect = *pList;
+	*pExists = false;
+	while (pSect) {
+		/*
+		 *  Make sure section has not already been added. Multiple
+		 *  'write' calls may be made to load the section.
+		 */
+		if (pSect->loadAddr == addr) {
+			/* Already added */
+			*pExists = true;
+			break;
+		}
+		pLastSect = pSect;
+		pSect = pSect->pNextSect;
+	}
+
+	if (!pSect) {
+		/* New section */
+		pNewSect = MEM_Calloc(sizeof(struct OvlySect), MEM_PAGED);
+		if (pNewSect == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			pNewSect->loadAddr = addr;
+			pNewSect->runAddr = pSectInfo->runAddr +
+					    (addr - pSectInfo->loadAddr);
+			pNewSect->size = nBytes;
+			pNewSect->page = pSectInfo->type;
+		}
+
+		/* Add to the list */
+		if (DSP_SUCCEEDED(status)) {
+			if (*pList == NULL) {
+				/* First in the list */
+				*pList = pNewSect;
+			} else {
+				pLastSect->pNextSect = pNewSect;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== fakeOvlyWrite ========
+ */
+static s32 fakeOvlyWrite(void *handle, u32 dspAddr, void *buf, u32 nBytes,
+			s32 mtype)
+{
+	return (s32)nBytes;
+}
+
+/*
+ *  ======== FreeSects ========
+ */
+static void FreeSects(struct NLDR_OBJECT *hNldr, struct OvlySect *pPhaseSects,
+		     u16 nAlloc)
+{
+	struct OvlySect *pSect = pPhaseSects;
+	u16 i = 0;
+	bool fRet;
+
+	while (pSect && i < nAlloc) {
+		/* 'Deallocate' */
+		/* segid - page not supported yet */
+		/* Reserved memory */
+		fRet = RMM_free(hNldr->rmm, 0, pSect->runAddr, pSect->size,
+				true);
+		DBC_Assert(fRet);
+		pSect = pSect->pNextSect;
+		i++;
+	}
+}
+
+/*
+ *  ======== GetSymbolValue ========
+ *  Find symbol in library's base image.  If not there, check dependent
+ *  libraries.
+ */
+static bool GetSymbolValue(void *handle, void *pArg, void *rmmHandle,
+			  char *name, struct DBLL_Symbol **sym)
+{
+	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)handle;
+	struct NLDR_NODEOBJECT *hNldrNode = (struct NLDR_NODEOBJECT *)rmmHandle;
+	struct LibNode *root = (struct LibNode *)pArg;
+	u16 i;
+	bool status = false;
+
+	/* check the base image */
+	status = hNldr->dbllFxns.getAddrFxn(hNldr->baseLib, name, sym);
+	if (!status)
+		status = hNldr->dbllFxns.getCAddrFxn(hNldr->baseLib, name, sym);
+
+	/*
+	 *  Check in root lib itself. If the library consists of
+	 *  multiple object files linked together, some symbols in the
+	 *  library may need to be resolved.
+	 */
+	if (!status) {
+		status = hNldr->dbllFxns.getAddrFxn(root->lib, name, sym);
+		if (!status) {
+			status =
+			    hNldr->dbllFxns.getCAddrFxn(root->lib, name, sym);
+		}
+	}
+
+	/*
+	 *  Check in root lib's dependent libraries, but not dependent
+	 *  libraries' dependents.
+	 */
+	if (!status) {
+		for (i = 0; i < root->nDepLibs; i++) {
+			status = hNldr->dbllFxns.getAddrFxn(root->pDepLibs[i].
+							   lib, name, sym);
+			if (!status) {
+				status = hNldr->dbllFxns.getCAddrFxn(root->
+					 pDepLibs[i].lib, name, sym);
+			}
+			if (status) {
+				/* Symbol found */
+				break;
+			}
+		}
+	}
+	/*
+	 * Check in persistent libraries
+	 */
+	if (!status) {
+		for (i = 0; i < hNldrNode->nPersLib; i++) {
+			status = hNldr->dbllFxns.getAddrFxn(hNldrNode->
+				 persLib[i].lib, name, sym);
+			if (!status) {
+				status = hNldr->dbllFxns.getCAddrFxn
+					(hNldrNode->persLib[i].lib, name, sym);
+			}
+			if (status) {
+				/* Symbol found */
+				break;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== LoadLib ========
+ *  Recursively load library and all its dependent libraries. The library
+ *  we're loading is specified by a uuid.
+ */
+static DSP_STATUS LoadLib(struct NLDR_NODEOBJECT *hNldrNode,
+			 struct LibNode *root, struct DSP_UUID uuid,
+			 bool rootPersistent, struct DBLL_LibraryObj **libPath,
+			 enum NLDR_PHASE phase, u16 depth)
+{
+	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	u16 nLibs = 0;	/* Number of dependent libraries */
+	u16 nPLibs = 0;	/* Number of persistent libraries */
+	u16 nLoaded = 0;	/* Number of dep. libraries loaded */
+	u16 i;
+	u32 entry;
+	u32 dwBufSize = NLDR_MAXPATHLENGTH;
+	DBLL_Flags flags = DBLL_SYMB | DBLL_CODE | DBLL_DATA | DBLL_DYNAMIC;
+	struct DBLL_Attrs newAttrs;
+	char *pszFileName = NULL;
+	struct DSP_UUID *depLibUUIDs = NULL;
+	bool *persistentDepLibs = NULL;
+	DSP_STATUS status = DSP_SOK;
+	bool fStatus = false;
+	struct LibNode *pDepLib;
+
+	if (depth > MAXDEPTH) {
+		/* Error */
+		DBC_Assert(false);
+	}
+	root->lib = NULL;
+	/* Allocate a buffer for library file name of size DBL_MAXPATHLENGTH */
+	pszFileName = MEM_Calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
+	if (pszFileName == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Get the name of the library */
+		if (depth == 0) {
+			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
+				&uuid, pszFileName, &dwBufSize, phase,
+				hNldrNode->pfPhaseSplit);
+		} else {
+			/* Dependent libraries are registered with a phase */
+			status = DCD_GetLibraryName(hNldrNode->pNldr->hDcdMgr,
+				&uuid, pszFileName, &dwBufSize, NLDR_NOPHASE,
+				NULL);
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Open the library, don't load symbols */
+		status = hNldr->dbllFxns.openFxn(hNldr->dbll, pszFileName,
+			 DBLL_NOLOAD, &root->lib);
+	}
+	/* Done with file name */
+	kfree(pszFileName);
+
+	/* Check to see if library not already loaded */
+	if (DSP_SUCCEEDED(status) && rootPersistent) {
+		fStatus = findInPersistentLibArray(hNldrNode, root->lib);
+		/* Close library */
+		if (fStatus) {
+			hNldr->dbllFxns.closeFxn(root->lib);
+			return DSP_SALREADYLOADED;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Check for circular dependencies. */
+		for (i = 0; i < depth; i++) {
+			if (root->lib == libPath[i]) {
+				/* This condition could be checked by a
+				 * tool at build time. */
+				status = DSP_EDYNLOAD;
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Add library to current path in dependency tree */
+		libPath[depth] = root->lib;
+		depth++;
+		/* Get number of dependent libraries */
+		status = DCD_GetNumDepLibs(hNldrNode->pNldr->hDcdMgr, &uuid,
+					  &nLibs, &nPLibs, phase);
+	}
+	DBC_Assert(nLibs >= nPLibs);
+	if (DSP_SUCCEEDED(status)) {
+		if (!(*hNldrNode->pfPhaseSplit))
+			nPLibs = 0;
+
+		/* nLibs = #of dependent libraries */
+		root->nDepLibs = nLibs - nPLibs;
+		if (nLibs > 0) {
+			depLibUUIDs = MEM_Calloc(sizeof(struct DSP_UUID) *
+				      nLibs, MEM_PAGED);
+			persistentDepLibs =
+				MEM_Calloc(sizeof(bool) * nLibs, MEM_PAGED);
+			if (!depLibUUIDs || !persistentDepLibs)
+				status = DSP_EMEMORY;
+
+			if (root->nDepLibs > 0) {
+				/* Allocate arrays for dependent lib UUIDs,
+				 * lib nodes */
+				root->pDepLibs = MEM_Calloc
+					(sizeof(struct LibNode) *
+					(root->nDepLibs), MEM_PAGED);
+				if (!(root->pDepLibs))
+					status = DSP_EMEMORY;
+
+			}
+
+			if (DSP_SUCCEEDED(status)) {
+				/* Get the dependent library UUIDs */
+				status = DCD_GetDepLibs(hNldrNode->pNldr->
+					hDcdMgr, &uuid, nLibs, depLibUUIDs,
+					persistentDepLibs, phase);
+			}
+		}
+	}
+
+	/*
+	 *  Recursively load dependent libraries.
+	 */
+	if (DSP_SUCCEEDED(status)) {
+		for (i = 0; i < nLibs; i++) {
+			/* If root library is NOT persistent, and dep library
+			 * is, then record it.  If root library IS persistent,
+			 * the deplib is already included */
+			if (!rootPersistent && persistentDepLibs[i] &&
+			   *hNldrNode->pfPhaseSplit) {
+				if ((hNldrNode->nPersLib) > MAXLIBS) {
+					status = DSP_EDYNLOAD;
+					break;
+				}
+
+				/* Allocate library outside of phase */
+				pDepLib = &hNldrNode->persLib[hNldrNode->
+					  nPersLib];
+			} else {
+				if (rootPersistent)
+					persistentDepLibs[i] = true;
+
+
+				/* Allocate library within phase */
+				pDepLib = &root->pDepLibs[nLoaded];
+			}
+
+			status = LoadLib(hNldrNode, pDepLib,
+						depLibUUIDs[i],
+						persistentDepLibs[i], libPath,
+						phase,
+						depth);
+
+			if (DSP_SUCCEEDED(status)) {
+				if ((status != DSP_SALREADYLOADED) &&
+				   !rootPersistent && persistentDepLibs[i] &&
+				   *hNldrNode->pfPhaseSplit) {
+					(hNldrNode->nPersLib)++;
+				} else {
+					if (!persistentDepLibs[i] ||
+					   !(*hNldrNode->pfPhaseSplit)) {
+						nLoaded++;
+					}
+				}
+			} else {
+				break;
+			}
+		}
+	}
+
+	/* Now we can load the root library */
+	if (DSP_SUCCEEDED(status)) {
+		newAttrs = hNldr->dbllAttrs;
+		newAttrs.symArg = root;
+		newAttrs.rmmHandle = hNldrNode;
+		newAttrs.wHandle = hNldrNode->pPrivRef;
+		newAttrs.baseImage = false;
+
+		status = hNldr->dbllFxns.loadFxn(root->lib, flags, &newAttrs,
+			 &entry);
+	}
+
+	/*
+	 *  In case of failure, unload any dependent libraries that
+	 *  were loaded, and close the root library.
+	 *  (Persistent libraries are unloaded from the very top)
+	 */
+	if (DSP_FAILED(status)) {
+		if (phase != NLDR_EXECUTE) {
+			for (i = 0; i < hNldrNode->nPersLib; i++)
+				UnloadLib(hNldrNode, &hNldrNode->persLib[i]);
+
+			hNldrNode->nPersLib = 0;
+		}
+		for (i = 0; i < nLoaded; i++)
+			UnloadLib(hNldrNode, &root->pDepLibs[i]);
+
+		if (root->lib)
+			hNldr->dbllFxns.closeFxn(root->lib);
+
+	}
+
+	/* Going up one node in the dependency tree */
+	depth--;
+
+	kfree(depLibUUIDs);
+	depLibUUIDs = NULL;
+
+	kfree(persistentDepLibs);
+	persistentDepLibs = NULL;
+
+	return status;
+}
+
+/*
+ *  ======== LoadOvly ========
+ */
+static DSP_STATUS LoadOvly(struct NLDR_NODEOBJECT *hNldrNode,
+			  enum NLDR_PHASE phase)
+{
+	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	struct OvlyNode *pONode = NULL;
+	struct OvlySect *pPhaseSects = NULL;
+	struct OvlySect *pOtherSects = NULL;
+	u16 i;
+	u16 nAlloc = 0;
+	u16 nOtherAlloc = 0;
+	u16 *pRefCount = NULL;
+	u16 *pOtherRef = NULL;
+	u32 nBytes;
+	struct OvlySect *pSect;
+	DSP_STATUS status = DSP_SOK;
+
+	/* Find the node in the table */
+	for (i = 0; i < hNldr->nOvlyNodes; i++) {
+		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+			/* Found it */
+			pONode = &(hNldr->ovlyTable[i]);
+			break;
+		}
+	}
+
+	DBC_Assert(i < hNldr->nOvlyNodes);
+
+	if (!pONode) {
+		status = DSP_ENOTFOUND;
+		goto func_end;
+	}
+
+	switch (phase) {
+	case NLDR_CREATE:
+		pRefCount = &(pONode->createRef);
+		pOtherRef = &(pONode->otherRef);
+		pPhaseSects = pONode->pCreateSects;
+		pOtherSects = pONode->pOtherSects;
+		break;
+
+	case NLDR_EXECUTE:
+		pRefCount = &(pONode->executeRef);
+		pPhaseSects = pONode->pExecuteSects;
+		break;
+
+	case NLDR_DELETE:
+		pRefCount = &(pONode->deleteRef);
+		pPhaseSects = pONode->pDeleteSects;
+		break;
+
+	default:
+		DBC_Assert(false);
+		break;
+	}
+
+	if (pRefCount == NULL)
+		goto func_end;
+
+	if (*pRefCount != 0)
+		goto func_end;
+
+	/* 'Allocate' memory for overlay sections of this phase */
+	pSect = pPhaseSects;
+	while (pSect) {
+		/* allocate */ /* page not supported yet */
+		  /* reserve */ /* align */
+		status = RMM_alloc(hNldr->rmm, 0, pSect->size, 0,
+			 &(pSect->runAddr), true);
+		if (DSP_SUCCEEDED(status)) {
+			pSect = pSect->pNextSect;
+			nAlloc++;
+		} else {
+			break;
+		}
+	}
+	if (pOtherRef && *pOtherRef == 0) {
+		/* 'Allocate' memory for other overlay sections
+		 * (create phase) */
+		if (DSP_SUCCEEDED(status)) {
+			pSect = pOtherSects;
+			while (pSect) {
+				/* page not supported */ /* align */
+				/* reserve */
+				status = RMM_alloc(hNldr->rmm, 0, pSect->size,
+					 0, &(pSect->runAddr), true);
+				if (DSP_SUCCEEDED(status)) {
+					pSect = pSect->pNextSect;
+					nOtherAlloc++;
+				} else {
+					break;
+				}
+			}
+		}
+	}
+	if (*pRefCount == 0) {
+		if (DSP_SUCCEEDED(status)) {
+			/* Load sections for this phase */
+			pSect = pPhaseSects;
+			while (pSect && DSP_SUCCEEDED(status)) {
+				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
+					 pSect->runAddr, pSect->loadAddr,
+					 pSect->size, pSect->page);
+				if (nBytes != pSect->size)
+					status = DSP_EFAIL;
+
+				pSect = pSect->pNextSect;
+			}
+		}
+	}
+	if (pOtherRef && *pOtherRef == 0) {
+		if (DSP_SUCCEEDED(status)) {
+			/* Load other sections (create phase) */
+			pSect = pOtherSects;
+			while (pSect && DSP_SUCCEEDED(status)) {
+				nBytes = (*hNldr->ovlyFxn)(hNldrNode->pPrivRef,
+					 pSect->runAddr, pSect->loadAddr,
+					 pSect->size, pSect->page);
+				if (nBytes != pSect->size)
+					status = DSP_EFAIL;
+
+				pSect = pSect->pNextSect;
+			}
+		}
+	}
+	if (DSP_FAILED(status)) {
+		/* 'Deallocate' memory */
+		FreeSects(hNldr, pPhaseSects, nAlloc);
+		FreeSects(hNldr, pOtherSects, nOtherAlloc);
+	}
+func_end:
+	if (DSP_SUCCEEDED(status) && (pRefCount != NULL)) {
+		*pRefCount += 1;
+		if (pOtherRef)
+			*pOtherRef += 1;
+
+	}
+
+	return status;
+}
+
+/*
+ *  ======== RemoteAlloc ========
+ */
+static DSP_STATUS RemoteAlloc(void **pRef, u16 space, u32 size,
+			     u32 align, u32 *dspAddr,
+			     OPTIONAL s32 segmentId, OPTIONAL s32 req,
+			     bool reserve)
+{
+	struct NLDR_NODEOBJECT *hNode = (struct NLDR_NODEOBJECT *)pRef;
+	struct NLDR_OBJECT *hNldr;
+	struct RMM_TargetObj *rmm;
+	u16 memPhaseBit = MAXFLAGS;
+	u16 segid = 0;
+	u16 i;
+	u16 memType;
+	u32 nWords;
+	struct RMM_Addr *pRmmAddr = (struct RMM_Addr *)dspAddr;
+	bool fReq = false;
+	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
+	DBC_Require(MEM_IsValidHandle(hNode, NLDR_NODESIGNATURE));
+	DBC_Require(space == DBLL_CODE || space == DBLL_DATA ||
+		   space == DBLL_BSS);
+	hNldr = hNode->pNldr;
+	rmm = hNldr->rmm;
+	/* Convert size to DSP words */
+	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+	/* Modify memory 'align' to account for DSP cache line size */
+	align = findLcm(GEM_CACHE_LINE_SIZE, align);
+	dev_dbg(bridge, "%s: memory align to 0x%x\n", __func__, align);
+	if (segmentId != -1) {
+		pRmmAddr->segid = segmentId;
+		segid = segmentId;
+		fReq = req;
+	} else {
+		switch (hNode->phase) {
+		case NLDR_CREATE:
+			memPhaseBit = CREATEDATAFLAGBIT;
+			break;
+		case NLDR_DELETE:
+			memPhaseBit = DELETEDATAFLAGBIT;
+			break;
+		case NLDR_EXECUTE:
+			memPhaseBit = EXECUTEDATAFLAGBIT;
+			break;
+		default:
+			DBC_Assert(false);
+			break;
+		}
+		if (space == DBLL_CODE)
+			memPhaseBit++;
+
+		if (memPhaseBit < MAXFLAGS)
+			segid = hNode->segId[memPhaseBit];
+
+		/* Determine if there is a memory loading requirement */
+		if ((hNode->codeDataFlagMask >> memPhaseBit) & 0x1)
+			fReq = true;
+
+	}
+	memType = (space == DBLL_CODE) ? DYNM_CODE : DYNM_DATA;
+
+	/* Find an appropriate segment based on space */
+	if (segid == NULLID) {
+		/* No memory requirements of preferences */
+		DBC_Assert(!fReq);
+		goto func_cont;
+	}
+	if (segid <= MAXSEGID) {
+		DBC_Assert(segid < hNldr->nSegs);
+		/* Attempt to allocate from segid first. */
+		pRmmAddr->segid = segid;
+		status = RMM_alloc(rmm, segid, nWords, align, dspAddr, false);
+		if (DSP_FAILED(status)) {
+			dev_dbg(bridge, "%s: Unable allocate from segment %d\n",
+							__func__, segid);
+		}
+	} else {
+		/* segid > MAXSEGID ==> Internal or external memory */
+		DBC_Assert(segid == MEMINTERNALID || segid == MEMEXTERNALID);
+		 /*  Check for any internal or external memory segment,
+		  *  depending on segid.*/
+		memType |= segid == MEMINTERNALID ?
+				 DYNM_INTERNAL : DYNM_EXTERNAL;
+		for (i = 0; i < hNldr->nSegs; i++) {
+			if ((hNldr->segTable[i] & memType) != memType)
+				continue;
+
+			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
+					   false);
+			if (DSP_SUCCEEDED(status)) {
+				/* Save segid for freeing later */
+				pRmmAddr->segid = i;
+				break;
+			}
+		}
+	}
+func_cont:
+	/* Haven't found memory yet, attempt to find any segment that works */
+	if (status == DSP_EMEMORY && !fReq) {
+		dev_dbg(bridge, "%s: Preferred segment unavailable, trying "
+							"another\n", __func__);
+		for (i = 0; i < hNldr->nSegs; i++) {
+			/* All bits of memType must be set */
+			if ((hNldr->segTable[i] & memType) != memType)
+				continue;
+
+			status = RMM_alloc(rmm, i, nWords, align, dspAddr,
+					  false);
+			if (DSP_SUCCEEDED(status)) {
+				/* Save segid */
+				pRmmAddr->segid = i;
+				break;
+			}
+		}
+	}
+
+	return status;
+}
+
+static DSP_STATUS RemoteFree(void **pRef, u16 space, u32 dspAddr,
+				u32 size, bool reserve)
+{
+	struct NLDR_OBJECT *hNldr = (struct NLDR_OBJECT *)pRef;
+	struct RMM_TargetObj *rmm;
+	u32 nWords;
+	DSP_STATUS status = DSP_EMEMORY;	/* Set to fail */
+
+	DBC_Require(MEM_IsValidHandle(hNldr, NLDR_SIGNATURE));
+
+	rmm = hNldr->rmm;
+
+	/* Convert size to DSP words */
+	nWords = (size + hNldr->usDSPWordSize - 1) / hNldr->usDSPWordSize;
+
+	if (RMM_free(rmm, space, dspAddr, nWords, reserve))
+		status = DSP_SOK;
+
+	return status;
+}
+
+/*
+ *  ======== UnloadLib ========
+ */
+static void UnloadLib(struct NLDR_NODEOBJECT *hNldrNode, struct LibNode *root)
+{
+	struct DBLL_Attrs newAttrs;
+	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	u16 i;
+
+	DBC_Assert(root != NULL);
+
+	/* Unload dependent libraries */
+	for (i = 0; i < root->nDepLibs; i++)
+		UnloadLib(hNldrNode, &root->pDepLibs[i]);
+
+	root->nDepLibs = 0;
+
+	newAttrs = hNldr->dbllAttrs;
+	newAttrs.rmmHandle = hNldr->rmm;
+	newAttrs.wHandle = hNldrNode->pPrivRef;
+	newAttrs.baseImage = false;
+	newAttrs.symArg = root;
+
+	if (root->lib) {
+		/* Unload the root library */
+		hNldr->dbllFxns.unloadFxn(root->lib, &newAttrs);
+		hNldr->dbllFxns.closeFxn(root->lib);
+	}
+
+	/* Free dependent library list */
+	kfree(root->pDepLibs);
+	root->pDepLibs = NULL;
+}
+
+/*
+ *  ======== UnloadOvly ========
+ */
+static void UnloadOvly(struct NLDR_NODEOBJECT *hNldrNode, enum NLDR_PHASE phase)
+{
+	struct NLDR_OBJECT *hNldr = hNldrNode->pNldr;
+	struct OvlyNode *pONode = NULL;
+	struct OvlySect *pPhaseSects = NULL;
+	struct OvlySect *pOtherSects = NULL;
+	u16 i;
+	u16 nAlloc = 0;
+	u16 nOtherAlloc = 0;
+	u16 *pRefCount = NULL;
+	u16 *pOtherRef = NULL;
+
+	/* Find the node in the table */
+	for (i = 0; i < hNldr->nOvlyNodes; i++) {
+		if (IsEqualUUID(hNldrNode->uuid, hNldr->ovlyTable[i].uuid)) {
+			/* Found it */
+			pONode = &(hNldr->ovlyTable[i]);
+			break;
+		}
+	}
+
+	DBC_Assert(i < hNldr->nOvlyNodes);
+
+	if (!pONode)
+		/* TODO: Should we print warning here? */
+		return;
+
+	switch (phase) {
+	case NLDR_CREATE:
+		pRefCount = &(pONode->createRef);
+		pPhaseSects = pONode->pCreateSects;
+		nAlloc = pONode->nCreateSects;
+		break;
+	case NLDR_EXECUTE:
+		pRefCount = &(pONode->executeRef);
+		pPhaseSects = pONode->pExecuteSects;
+		nAlloc = pONode->nExecuteSects;
+		break;
+	case NLDR_DELETE:
+		pRefCount = &(pONode->deleteRef);
+		pOtherRef = &(pONode->otherRef);
+		pPhaseSects = pONode->pDeleteSects;
+		/* 'Other' overlay sections are unloaded in the delete phase */
+		pOtherSects = pONode->pOtherSects;
+		nAlloc = pONode->nDeleteSects;
+		nOtherAlloc = pONode->nOtherSects;
+		break;
+	default:
+		DBC_Assert(false);
+		break;
+	}
+	DBC_Assert(pRefCount && (*pRefCount > 0));
+	if (pRefCount && (*pRefCount > 0)) {
+		*pRefCount -= 1;
+		if (pOtherRef) {
+			DBC_Assert(*pOtherRef > 0);
+			*pOtherRef -= 1;
+		}
+	}
+
+	if (pRefCount && *pRefCount == 0) {
+		/* 'Deallocate' memory */
+		FreeSects(hNldr, pPhaseSects, nAlloc);
+	}
+	if (pOtherRef && *pOtherRef == 0)
+		FreeSects(hNldr, pOtherSects, nOtherAlloc);
+}
+
+/*
+ *  ======== findInPersistentLibArray ========
+ */
+static bool findInPersistentLibArray(struct NLDR_NODEOBJECT *hNldrNode,
+				    struct DBLL_LibraryObj *lib)
+{
+	s32 i = 0;
+
+	for (i = 0; i < hNldrNode->nPersLib; i++) {
+		if (lib == hNldrNode->persLib[i].lib)
+			return true;
+
+	}
+
+	return false;
+}
+
+/*
+ * ================ Find LCM (Least Common Multiplier ===
+ */
+static u32 findLcm(u32 a, u32 b)
+{
+	u32 retVal;
+
+	retVal = a * b / findGcf(a, b);
+
+	return retVal;
+}
+
+/*
+ * ================ Find GCF (Greatest Common Factor ) ===
+ */
+static u32 findGcf(u32 a, u32 b)
+{
+	u32 c;
+
+	/* Get the GCF (Greatest common factor between the numbers,
+	 * using Euclidian Algo */
+	while ((c = (a % b))) {
+		a = b;
+		b = c;
+	}
+	return b;
+}
+
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
new file mode 100644
index 0000000..94dd12c
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -0,0 +1,3148 @@
+/*
+ * node.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Node Manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/proc.h>
+#include <dspbridge/strm.h>
+#include <dspbridge/sync.h>
+#include <dspbridge/ntfy.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/cmm.h>
+#include <dspbridge/cod.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/msg.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/dbdcd.h>
+#include <dspbridge/disp.h>
+#include <dspbridge/rms_sh.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmd.h>
+#include <dspbridge/wmdioctl.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/gb.h>
+#include <dspbridge/uuidutil.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/nodepriv.h>
+#include <dspbridge/node.h>
+
+/* Static/Dynamic Loader includes */
+#include <dspbridge/dbll.h>
+#include <dspbridge/nldr.h>
+
+#include <dspbridge/drv.h>
+#include <dspbridge/drvdefs.h>
+#include <dspbridge/resourcecleanup.h>
+
+
+#define NODE_SIGNATURE      0x45444f4e	/* "EDON" */
+#define NODEMGR_SIGNATURE   0x52474d4e	/* "RGMN" */
+
+#define HOSTPREFIX	  "/host"
+#define PIPEPREFIX	  "/dbpipe"
+
+#define MaxInputs(h)  ((h)->dcdProps.objData.nodeObj.ndbProps.uNumInputStreams)
+#define MaxOutputs(h) ((h)->dcdProps.objData.nodeObj.ndbProps.uNumOutputStreams)
+
+#define NODE_GetPriority(h) ((h)->nPriority)
+#define NODE_SetPriority(hNode, nPriority) ((hNode)->nPriority = nPriority)
+#define NODE_SetState(hNode, state) ((hNode)->nState = state)
+
+#define MAXPIPES	100	/* Max # of /pipe connections (CSL limit) */
+#define MAXDEVSUFFIXLEN 2	/* Max(Log base 10 of MAXPIPES, MAXSTREAMS) */
+
+#define PIPENAMELEN     (sizeof(PIPEPREFIX) + MAXDEVSUFFIXLEN)
+#define HOSTNAMELEN     (sizeof(HOSTPREFIX) + MAXDEVSUFFIXLEN)
+
+#define MAXDEVNAMELEN	32	/* DSP_NDBPROPS.acName size */
+#define CREATEPHASE	1
+#define EXECUTEPHASE	2
+#define DELETEPHASE	3
+
+/* Define default STRM parameters */
+/*
+ *  TBD: Put in header file, make global DSP_STRMATTRS with defaults,
+ *  or make defaults configurable.
+ */
+#define DEFAULTBUFSIZE		32
+#define DEFAULTNBUFS		2
+#define DEFAULTSEGID		0
+#define DEFAULTALIGNMENT	0
+#define DEFAULTTIMEOUT		10000
+
+#define RMSQUERYSERVER		0
+#define RMSCONFIGURESERVER	1
+#define RMSCREATENODE		2
+#define RMSEXECUTENODE		3
+#define RMSDELETENODE		4
+#define RMSCHANGENODEPRIORITY	5
+#define RMSREADMEMORY		6
+#define RMSWRITEMEMORY		7
+#define RMSCOPY			8
+#define MAXTIMEOUT		2000
+
+#define NUMRMSFXNS		9
+
+#define PWR_TIMEOUT		500	/* default PWR timeout in msec */
+
+#define STACKSEGLABEL "L1DSRAM_HEAP"  /* Label for DSP Stack Segment Address */
+
+/*
+ *  ======== NODE_MGR ========
+ */
+struct NODE_MGR {
+	u32 dwSignature;	/* For object validation */
+	struct DEV_OBJECT *hDevObject;	/* Device object */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct DCD_MANAGER *hDcdMgr;	/* Proc/Node data manager */
+	struct DISP_OBJECT *hDisp;	/* Node dispatcher */
+	struct LST_LIST *nodeList;	/* List of all allocated nodes */
+	u32 uNumNodes;		/* Number of nodes in nodeList */
+	u32 uNumCreated;	/* Number of nodes *created* on DSP */
+	struct GB_TMap *pipeMap;		/* Pipe connection bit map */
+	struct GB_TMap *pipeDoneMap;	/* Pipes that are half free */
+	struct GB_TMap *chnlMap;		/* Channel allocation bit map */
+	struct GB_TMap *dmaChnlMap;	/* DMA Channel allocation bit map */
+	struct GB_TMap *zChnlMap;	/* Zero-Copy Channel alloc bit map */
+	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
+	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
+	u32 ulFxnAddrs[NUMRMSFXNS];	/* RMS function addresses */
+	struct MSG_MGR *hMsg;
+
+	/* Processor properties needed by Node Dispatcher */
+	u32 ulNumChnls;	/* Total number of channels */
+	u32 ulChnlOffset;	/* Offset of chnl ids rsvd for RMS */
+	u32 ulChnlBufSize;	/* Buffer size for data to RMS */
+	int procFamily;	/* eg, 5000 */
+	int procType;	/* eg, 5510 */
+	u32 uDSPWordSize;	/* Size of DSP word on host bytes */
+	u32 uDSPDataMauSize;	/* Size of DSP data MAU */
+	u32 uDSPMauSize;	/* Size of MAU */
+	s32 nMinPri;		/* Minimum runtime priority for node */
+	s32 nMaxPri;		/* Maximum runtime priority for node */
+
+	struct STRM_MGR *hStrmMgr;	/* STRM manager */
+
+	/* Loader properties */
+	struct NLDR_OBJECT *hNldr;	/* Handle to loader */
+	struct NLDR_FXNS nldrFxns;	/* Handle to loader functions */
+	bool fLoaderInit;	/* Loader Init function succeeded? */
+};
+
+/*
+ *  ======== CONNECTTYPE ========
+ */
+enum CONNECTTYPE {
+	NOTCONNECTED = 0,
+	NODECONNECT,
+	HOSTCONNECT,
+	DEVICECONNECT,
+} ;
+
+/*
+ *  ======== STREAM ========
+ */
+struct STREAM {
+	enum CONNECTTYPE type;	/* Type of stream connection */
+	u32 devId;		/* pipe or channel id */
+};
+
+/*
+ *  ======== NODE_OBJECT ========
+ */
+struct NODE_OBJECT {
+	struct list_head listElem;
+	u32 dwSignature;	/* For object validation */
+	struct NODE_MGR *hNodeMgr;	/* The manager of this node */
+	struct PROC_OBJECT *hProcessor;	/* Back pointer to processor */
+	struct DSP_UUID nodeId;	/* Node's ID */
+	s32 nPriority;		/* Node's current priority */
+	u32 uTimeout;		/* Timeout for blocking NODE calls */
+	u32 uHeapSize;		/* Heap Size */
+	u32 uDSPHeapVirtAddr;	/* Heap Size */
+	u32 uGPPHeapVirtAddr;	/* Heap Size */
+	enum NODE_TYPE nType;	/* Type of node: message, task, etc */
+	enum NODE_STATE nState;	/* NODE_ALLOCATED, NODE_CREATED, ... */
+	u32 uNumInputs;	/* Current number of inputs */
+	u32 uNumOutputs;	/* Current number of outputs */
+	u32 uMaxInputIndex;	/* Current max input stream index */
+	u32 uMaxOutputIndex;	/* Current max output stream index */
+	struct STREAM *inputs;		/* Node's input streams */
+	struct STREAM *outputs;	/* Node's output streams */
+	struct NODE_CREATEARGS createArgs;  /* Args for node create function */
+	NODE_ENV nodeEnv;	/* Environment returned by RMS */
+	struct DCD_GENERICOBJ dcdProps;	/* Node properties from DCD */
+	struct DSP_CBDATA *pArgs;	/* Optional args to pass to node */
+	struct NTFY_OBJECT *hNtfy;	/* Manages registered notifications */
+	char *pstrDevName;	/* device name, if device node */
+	struct SYNC_OBJECT *hSyncDone;	/* Synchronize NODE_Terminate */
+	s32 nExitStatus;	/* execute function return status */
+
+	/* Information needed for NODE_GetAttr() */
+	void *hDeviceOwner;	/* If dev node, task that owns it */
+	u32 uNumGPPInputs;	/* Current # of from GPP streams */
+	u32 uNumGPPOutputs;	/* Current # of to GPP streams */
+	/* Current stream connections */
+	struct DSP_STREAMCONNECT *streamConnect;
+
+	/* Message queue */
+	struct MSG_QUEUE *hMsgQueue;
+
+	/* These fields used for SM messaging */
+	struct CMM_XLATOROBJECT *hXlator;   /* Node's SM address translator */
+
+	/* Handle to pass to dynamic loader */
+	struct NLDR_NODEOBJECT *hNldrNode;
+	bool fLoaded;		/* Code is (dynamically) loaded */
+	bool fPhaseSplit;	/* Phases split in many libs or ovly */
+
+} ;
+
+/* Default buffer attributes */
+static struct DSP_BUFFERATTR NODE_DFLTBUFATTRS = {
+	0, 			/* cbStruct */
+	1, 			/* uSegment */
+	0, 			/* uAlignment */
+};
+
+static void DeleteNode(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt);
+static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr);
+static void FillStreamConnect(struct NODE_OBJECT *hNode1,
+			     struct NODE_OBJECT *hNode2, u32 uStream1,
+			     u32 uStream2);
+static void FillStreamDef(struct NODE_OBJECT *hNode,
+			struct NODE_STRMDEF *pstrmDef,
+			struct DSP_STRMATTR *pAttrs);
+static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream);
+static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
+				u32 uPhase);
+static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
+				struct NODE_OBJECT *hNode,
+				CONST struct DSP_UUID *pNodeId,
+				struct DCD_GENERICOBJ *pdcdProps);
+static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
+			      struct DEV_OBJECT *hDevObject);
+static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr);
+static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+			u32 ulNumBytes, u32 nMemSpace);
+static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
+			u32 ulNumBytes, u32 nMemSpace);
+
+#ifdef DSP_DMM_DEBUG
+extern u32 DMM_MemMapDump(struct DMM_OBJECT *hDmmMgr);
+#endif
+
+static u32 cRefs;		/* module reference count */
+
+/* Dynamic loader functions. */
+static struct NLDR_FXNS nldrFxns = {
+	NLDR_Allocate,
+	NLDR_Create,
+	NLDR_Delete,
+	NLDR_Exit,
+	NLDR_GetFxnAddr,
+	NLDR_Init,
+	NLDR_Load,
+	NLDR_Unload,
+};
+
+enum NODE_STATE NODE_GetState(HANDLE hNode)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
+		return  -1;
+	else
+		return pNode->nState;
+}
+
+/*
+ *  ======== NODE_Allocate ========
+ *  Purpose:
+ *      Allocate GPP resources to manage a node on the DSP.
+ */
+DSP_STATUS NODE_Allocate(struct PROC_OBJECT *hProcessor,
+			IN CONST struct DSP_UUID *pNodeId,
+			OPTIONAL IN CONST struct DSP_CBDATA *pArgs,
+			OPTIONAL IN CONST struct DSP_NODEATTRIN *pAttrIn,
+			OUT struct NODE_OBJECT **phNode,
+			struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct NODE_MGR *hNodeMgr;
+	struct DEV_OBJECT *hDevObject;
+	struct NODE_OBJECT *pNode = NULL;
+	enum NODE_TYPE nodeType = NODE_TASK;
+	struct NODE_MSGARGS *pmsgArgs;
+	struct NODE_TASKARGS *ptaskArgs;
+	u32 uNumStreams;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_OBJECT *hCmmMgr = NULL; /* Shared memory manager hndl */
+	u32 procId;
+	u32 pulValue;
+	u32 dynextBase;
+	u32 offSet = 0;
+	u32 ulStackSegAddr, ulStackSegVal;
+	u32 ulGppMemBase;
+	struct CFG_HOSTRES hostRes;
+	u32 pMappedAddr = 0;
+	u32 mapAttrs = 0x0;
+	struct DSP_PROCESSORSTATE procStatus;
+#ifdef DSP_DMM_DEBUG
+	struct DMM_OBJECT *hDmmMgr;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+#endif
+
+	HANDLE nodeRes;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hProcessor != NULL);
+	DBC_Require(phNode != NULL);
+	DBC_Require(pNodeId != NULL);
+
+	*phNode = NULL;
+
+	status = PROC_GetProcessorId(hProcessor, &procId);
+
+	if (procId != DSP_UNIT)
+		goto func_end;
+
+	status = PROC_GetDevObject(hProcessor, &hDevObject);
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
+		if (hNodeMgr == NULL)
+			status = DSP_EFAIL;
+
+	}
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = PROC_GetState(hProcessor, &procStatus,
+			sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in error state then don't attempt
+	    to send the message */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+
+	/* Assuming that 0 is not a valid function address */
+	if (hNodeMgr->ulFxnAddrs[0] == 0) {
+		/* No RMS on target - we currently can't handle this */
+		pr_err("%s: Failed, no RMS in base image\n", __func__);
+		status = DSP_EFAIL;
+	} else {
+		/* Validate pAttrIn fields, if non-NULL */
+		if (pAttrIn) {
+			/* Check if pAttrIn->iPriority is within range */
+			if (pAttrIn->iPriority < hNodeMgr->nMinPri ||
+			   pAttrIn->iPriority > hNodeMgr->nMaxPri)
+				status = DSP_ERANGE;
+		}
+	}
+	/* Allocate node object and fill in */
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	MEM_AllocObject(pNode, struct NODE_OBJECT, NODE_SIGNATURE);
+	if (pNode == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	pNode->hNodeMgr = hNodeMgr;
+	/* This critical section protects GetNodeProps */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Get DSP_NDBPROPS from node database */
+	status = GetNodeProps(hNodeMgr->hDcdMgr, pNode, pNodeId,
+			     &(pNode->dcdProps));
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	pNode->nodeId = *pNodeId;
+	pNode->hProcessor = hProcessor;
+	pNode->nType = pNode->dcdProps.objData.nodeObj.ndbProps.uNodeType;
+	pNode->uTimeout = pNode->dcdProps.objData.nodeObj.ndbProps.uTimeout;
+	pNode->nPriority = pNode->dcdProps.objData.nodeObj.ndbProps.iPriority;
+
+	/* Currently only C64 DSP builds support Node Dynamic * heaps */
+	/* Allocate memory for node heap */
+	pNode->createArgs.asa.taskArgs.uHeapSize = 0;
+	pNode->createArgs.asa.taskArgs.uDSPHeapAddr = 0;
+	pNode->createArgs.asa.taskArgs.uDSPHeapResAddr = 0;
+	pNode->createArgs.asa.taskArgs.uGPPHeapAddr = 0;
+	if (!pAttrIn)
+		goto func_cont;
+
+	/* Check if we have a user allocated node heap */
+	if (!(pAttrIn->pGPPVirtAddr))
+		goto func_cont;
+
+	/* check for page aligned Heap size */
+	if (((pAttrIn->uHeapSize) & (PG_SIZE_4K - 1))) {
+		pr_err("%s: node heap size not aligned to 4K, size = 0x%x \n",
+						__func__, pAttrIn->uHeapSize);
+		status = DSP_EINVALIDARG;
+	} else {
+		pNode->createArgs.asa.taskArgs.uHeapSize = pAttrIn->uHeapSize;
+		pNode->createArgs.asa.taskArgs.uGPPHeapAddr =
+						 (u32)pAttrIn->pGPPVirtAddr;
+	}
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = PROC_ReserveMemory(hProcessor,
+			pNode->createArgs.asa.taskArgs.uHeapSize + PAGE_SIZE,
+			(void **)&(pNode->createArgs.asa.taskArgs.
+				uDSPHeapResAddr), pr_ctxt);
+	if (DSP_FAILED(status)) {
+		pr_err("%s: Failed to reserve memory for heap: 0x%x\n",
+							__func__, status);
+		goto func_cont;
+	}
+#ifdef DSP_DMM_DEBUG
+	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	DMM_MemMapDump(hDmmMgr);
+#endif
+
+	mapAttrs |= DSP_MAPLITTLEENDIAN;
+	mapAttrs |= DSP_MAPELEMSIZE32;
+	mapAttrs |= DSP_MAPVIRTUALADDR;
+	status = PROC_Map(hProcessor, (void *)pAttrIn->pGPPVirtAddr,
+			pNode->createArgs.asa.taskArgs.uHeapSize,
+			(void *)pNode->createArgs.asa.taskArgs.uDSPHeapResAddr,
+			(void **)&pMappedAddr, mapAttrs, pr_ctxt);
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed to map memory for Heap: 0x%x\n",
+							__func__, status);
+	else
+		pNode->createArgs.asa.taskArgs.uDSPHeapAddr = (u32)pMappedAddr;
+
+func_cont:
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	if (pAttrIn != NULL) {
+		/* Overrides of NBD properties */
+		pNode->uTimeout = pAttrIn->uTimeout;
+		pNode->nPriority = pAttrIn->iPriority;
+	}
+	/* Create object to manage notifications */
+	if (DSP_SUCCEEDED(status))
+		status = NTFY_Create(&pNode->hNtfy);
+
+	if (DSP_SUCCEEDED(status)) {
+		nodeType = NODE_GetType(pNode);
+		 /*  Allocate DSP_STREAMCONNECT array for device, task, and
+		 *  dais socket nodes.  */
+		if (nodeType != NODE_MESSAGE) {
+			uNumStreams = MaxInputs(pNode) + MaxOutputs(pNode);
+			pNode->streamConnect = MEM_Calloc(uNumStreams *
+					sizeof(struct DSP_STREAMCONNECT),
+					MEM_PAGED);
+			if (uNumStreams > 0 && pNode->streamConnect == NULL)
+				status = DSP_EMEMORY;
+
+		}
+		if (DSP_SUCCEEDED(status) && (nodeType == NODE_TASK ||
+		   nodeType == NODE_DAISSOCKET)) {
+			/* Allocate arrays for maintainig stream connections */
+			pNode->inputs =
+				MEM_Calloc(MaxInputs(pNode) *
+					sizeof(struct STREAM), MEM_PAGED);
+			pNode->outputs =
+				MEM_Calloc(MaxOutputs(pNode) *
+					sizeof(struct STREAM), MEM_PAGED);
+			ptaskArgs = &(pNode->createArgs.asa.taskArgs);
+			ptaskArgs->strmInDef =
+				MEM_Calloc(MaxInputs(pNode) *
+					sizeof(struct NODE_STRMDEF),
+					MEM_PAGED);
+			ptaskArgs->strmOutDef =
+					MEM_Calloc(MaxOutputs(pNode) *
+						sizeof(struct NODE_STRMDEF),
+						MEM_PAGED);
+			if ((MaxInputs(pNode) > 0 && (pNode->inputs == NULL ||
+			   ptaskArgs->strmInDef == NULL)) ||
+			   (MaxOutputs(pNode) > 0 && (pNode->outputs == NULL ||
+			   ptaskArgs->strmOutDef == NULL)))
+				status = DSP_EMEMORY;
+		}
+	}
+	if (DSP_SUCCEEDED(status) && (nodeType != NODE_DEVICE)) {
+		/* Create an event that will be posted when RMS_EXIT is
+		 * received. */
+		status = SYNC_OpenEvent(&pNode->hSyncDone, NULL);
+		if (DSP_SUCCEEDED(status)) {
+			/*Get the shared mem mgr for this nodes dev object */
+			status = CMM_GetHandle(hProcessor, &hCmmMgr);
+			if (DSP_SUCCEEDED(status)) {
+				/* Allocate a SM addr translator for this node
+				 * w/ deflt attr */
+				status = CMM_XlatorCreate(&pNode->hXlator,
+					 hCmmMgr, NULL);
+			}
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* Fill in message args */
+			if ((pArgs != NULL) && (pArgs->cbData > 0)) {
+				pmsgArgs = &(pNode->createArgs.asa.msgArgs);
+				pmsgArgs->pData = MEM_Calloc(pArgs->cbData,
+							    MEM_PAGED);
+				if (pmsgArgs->pData == NULL) {
+					status = DSP_EMEMORY;
+				} else {
+					pmsgArgs->uArgLength = pArgs->cbData;
+					memcpy(pmsgArgs->pData, pArgs->cData,
+						pArgs->cbData);
+				}
+			}
+		}
+	}
+
+	if (DSP_SUCCEEDED(status) && nodeType != NODE_DEVICE) {
+		/* Create a message queue for this node */
+		pIntfFxns = hNodeMgr->pIntfFxns;
+		status = (*pIntfFxns->pfnMsgCreateQueue)(hNodeMgr->hMsg,
+				&pNode->hMsgQueue, 0,
+				    pNode->createArgs.asa.msgArgs.uMaxMessages,
+				    pNode);
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Create object for dynamic loading */
+
+		status = hNodeMgr->nldrFxns.pfnAllocate(hNodeMgr->hNldr,
+					     (void *) pNode,
+					     &pNode->dcdProps.objData.nodeObj,
+					     &pNode->hNldrNode,
+					     &pNode->fPhaseSplit);
+	}
+
+	/* Compare value read from Node Properties and check if it is same as
+	 * STACKSEGLABEL, if yes read the Address of STACKSEGLABEL, calculate
+	 * GPP Address, Read the value in that address and override the
+	 * uStackSeg value in task args */
+	if (DSP_SUCCEEDED(status) &&
+	   (char *)pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName !=
+	   NULL) {
+		if (strcmp((char *)
+		    pNode->dcdProps.objData.nodeObj.ndbProps.uStackSegName,
+		    STACKSEGLABEL) == 0) {
+			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
+				 hNldrNode, "DYNEXT_BEG", &dynextBase);
+			if (DSP_FAILED(status))
+				pr_err("%s: Failed to get addr for DYNEXT_BEG"
+					" status = 0x%x\n", __func__, status);
+
+			status = hNodeMgr->nldrFxns.pfnGetFxnAddr(pNode->
+				 hNldrNode, "L1DSRAM_HEAP", &pulValue);
+
+			if (DSP_FAILED(status))
+				pr_err("%s: Failed to get addr for L1DSRAM_HEAP"
+					" status = 0x%x\n", __func__, status);
+
+			status = CFG_GetHostResources((struct CFG_DEVNODE *)
+				 DRV_GetFirstDevExtension(), &hostRes);
+
+			if (DSP_FAILED(status)) {
+				pr_err("%s: Failed to get host resource, status"
+						" = 0x%x\n", __func__, status);
+				goto func_end;
+			}
+
+			ulGppMemBase = (u32)hostRes.dwMemBase[1];
+			offSet = pulValue - dynextBase;
+			ulStackSegAddr = ulGppMemBase + offSet;
+			ulStackSegVal = (u32)*((REG_UWORD32 *)
+					((u32)(ulStackSegAddr)));
+
+			dev_dbg(bridge, "%s: StackSegVal = 0x%x, StackSegAddr ="
+					" 0x%x\n", __func__, ulStackSegVal,
+					ulStackSegAddr);
+
+			pNode->createArgs.asa.taskArgs.uStackSeg =
+				ulStackSegVal;
+
+		}
+	}
+
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Add the node to the node manager's list of allocated
+		 * nodes. */
+		LST_InitElem((struct list_head *)pNode);
+		NODE_SetState(pNode, NODE_ALLOCATED);
+
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+
+		if (DSP_SUCCEEDED(status)) {
+			LST_PutTail(hNodeMgr->nodeList,
+					(struct list_head *) pNode);
+			++(hNodeMgr->uNumNodes);
+		}
+
+		/* Exit critical section */
+		(void) SYNC_LeaveCS(hNodeMgr->hSync);
+
+		/* Preset this to assume phases are split
+		 * (for overlay and dll) */
+		pNode->fPhaseSplit = true;
+
+		if (DSP_SUCCEEDED(status))
+			*phNode = pNode;
+
+
+		/* Notify all clients registered for DSP_NODESTATECHANGE. */
+		PROC_NotifyAllClients(hProcessor, DSP_NODESTATECHANGE);
+	} else {
+		/* Cleanup */
+		if (pNode)
+			DeleteNode(pNode, pr_ctxt);
+
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		DRV_InsertNodeResElement(*phNode, &nodeRes, pr_ctxt);
+		DRV_ProcNodeUpdateHeapStatus(nodeRes, true);
+		DRV_ProcNodeUpdateStatus(nodeRes, true);
+	}
+	DBC_Ensure((DSP_FAILED(status) && (*phNode == NULL)) ||
+		  (DSP_SUCCEEDED(status)
+		    && MEM_IsValidHandle((*phNode), NODE_SIGNATURE)));
+func_end:
+	dev_dbg(bridge, "%s: hProcessor: %p pNodeId: %p pArgs: %p pAttrIn: %p "
+			"phNode: %p status: 0x%x\n", __func__, hProcessor,
+			pNodeId, pArgs, pAttrIn, phNode, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_AllocMsgBuf ========
+ *  Purpose:
+ *      Allocates buffer for zero copy messaging.
+ */
+DBAPI NODE_AllocMsgBuf(struct NODE_OBJECT *hNode, u32 uSize,
+			OPTIONAL IN OUT struct DSP_BUFFERATTR *pAttr,
+			OUT u8 **pBuffer)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	DSP_STATUS status = DSP_SOK;
+	bool bVirtAddr = false;
+	bool bSetInfo;
+	u32 procId;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBuffer != NULL);
+
+	DBC_Require(uSize > 0);
+
+	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE))
+		status = DSP_EHANDLE;
+	else if (NODE_GetType(pNode) == NODE_DEVICE)
+		status = DSP_ENODETYPE;
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (pAttr == NULL)
+		pAttr = &NODE_DFLTBUFATTRS;	/* set defaults */
+
+	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	if (procId != DSP_UNIT) {
+		DBC_Assert(NULL);
+		goto func_end;
+	}
+	 /*  If segment ID includes MEM_SETVIRTUALSEGID then pBuffer is a
+	 *  virt  address, so set this info in this node's translator
+	 *  object for  future ref. If MEM_GETVIRTUALSEGID then retrieve
+	 *  virtual address  from node's translator.  */
+	if ((pAttr->uSegment & MEM_SETVIRTUALSEGID) ||
+			    (pAttr->uSegment & MEM_GETVIRTUALSEGID)) {
+		bVirtAddr = true;
+		bSetInfo = (pAttr->uSegment & MEM_SETVIRTUALSEGID) ?
+			   true : false;
+		pAttr->uSegment &= ~MEM_MASKVIRTUALSEGID; /* clear mask bits */
+		/* Set/get this node's translators virtual address base/size */
+		status = CMM_XlatorInfo(pNode->hXlator, pBuffer, uSize,
+					pAttr->uSegment, bSetInfo);
+	}
+	if (DSP_SUCCEEDED(status) && (!bVirtAddr)) {
+		if (pAttr->uSegment != 1) {
+			/* Node supports single SM segment only. */
+			status = DSP_EBADSEGID;
+		}
+		 /*  Arbitrary SM buffer alignment not supported for host side
+		  *  allocs, but guaranteed for the following alignment
+		  *  values.  */
+		switch (pAttr->uAlignment) {
+		case 0:
+		case 1:
+		case 2:
+		case 4:
+			break;
+		default:
+			/* alignment value not suportted */
+			status = DSP_EALIGNMENT;
+			break;
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* allocate physical buffer from segId in node's
+			 * translator */
+			(void)CMM_XlatorAllocBuf(pNode->hXlator, pBuffer,
+						 uSize);
+			if (*pBuffer == NULL) {
+				pr_err("%s: error - Out of shared memory\n",
+								__func__);
+				status = DSP_EMEMORY;
+			}
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== NODE_ChangePriority ========
+ *  Purpose:
+ *      Change the priority of a node in the allocated state, or that is
+ *      currently running or paused on the target.
+ */
+DSP_STATUS NODE_ChangePriority(struct NODE_OBJECT *hNode, s32 nPriority)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	struct NODE_MGR *hNodeMgr = NULL;
+	enum NODE_TYPE nodeType;
+	enum NODE_STATE state;
+	DSP_STATUS status = DSP_SOK;
+	u32 procId;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE) || !hNode->hNodeMgr) {
+		status = DSP_EHANDLE;
+	} else {
+		hNodeMgr = hNode->hNodeMgr;
+		nodeType = NODE_GetType(hNode);
+		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+			status = DSP_ENODETYPE;
+		else if (nPriority < hNodeMgr->nMinPri ||
+				nPriority > hNodeMgr->nMaxPri)
+				status = DSP_ERANGE;
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Enter critical section */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	state = NODE_GetState(hNode);
+	if (state == NODE_ALLOCATED || state == NODE_PAUSED) {
+		NODE_SetPriority(hNode, nPriority);
+	} else {
+		if (state != NODE_RUNNING) {
+			status = DSP_EWRONGSTATE;
+			goto func_cont;
+		}
+		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		if (procId == DSP_UNIT) {
+			status = DISP_NodeChangePriority(hNodeMgr->
+			    hDisp, hNode,
+			    hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
+			    hNode->nodeEnv, nPriority);
+		}
+		if (DSP_SUCCEEDED(status))
+			NODE_SetPriority(hNode, nPriority);
+
+	}
+func_cont:
+		/* Leave critical section */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== NODE_Connect ========
+ *  Purpose:
+ *      Connect two nodes on the DSP, or a node on the DSP to the GPP.
+ */
+DSP_STATUS NODE_Connect(struct NODE_OBJECT *hNode1, u32 uStream1,
+			struct NODE_OBJECT *hNode2,
+			u32 uStream2, OPTIONAL IN struct DSP_STRMATTR *pAttrs,
+			OPTIONAL IN struct DSP_CBDATA *pConnParam)
+{
+	struct NODE_MGR *hNodeMgr;
+	char *pstrDevName = NULL;
+	enum NODE_TYPE node1Type = NODE_TASK;
+	enum NODE_TYPE node2Type = NODE_TASK;
+	struct NODE_STRMDEF *pstrmDef;
+	struct NODE_STRMDEF *pInput = NULL;
+	struct NODE_STRMDEF *pOutput = NULL;
+	struct NODE_OBJECT *hDevNode;
+	struct NODE_OBJECT *hNode;
+	struct STREAM *pStream;
+	GB_BitNum pipeId = GB_NOBITS;
+	GB_BitNum chnlId = GB_NOBITS;
+	short int uMode;
+	u32 dwLength;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+
+	if ((hNode1 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
+			!MEM_IsValidHandle(hNode1, NODE_SIGNATURE)) ||
+			(hNode2 != (struct NODE_OBJECT *) DSP_HGPPNODE &&
+			!MEM_IsValidHandle(hNode2, NODE_SIGNATURE)))
+		status = DSP_EHANDLE;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* The two nodes must be on the same processor */
+		if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
+		   hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE &&
+		   hNode1->hNodeMgr != hNode2->hNodeMgr)
+			status = DSP_EFAIL;
+		/* Cannot connect a node to itself */
+		if (hNode1 == hNode2)
+			status = DSP_EFAIL;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* NODE_GetType() will return NODE_GPP if hNode =
+		 * DSP_HGPPNODE. */
+		node1Type = NODE_GetType(hNode1);
+		node2Type = NODE_GetType(hNode2);
+	/* Check stream indices ranges */
+		if ((node1Type != NODE_GPP && node1Type != NODE_DEVICE &&
+		   uStream1 >= MaxOutputs(hNode1)) || (node2Type != NODE_GPP &&
+		   node2Type != NODE_DEVICE && uStream2 >= MaxInputs(hNode2)))
+			status = DSP_EVALUE;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/*
+		 *  Only the following types of connections are allowed:
+		 *      task/dais socket < == > task/dais socket
+		 *      task/dais socket < == > device
+		 *      task/dais socket < == > GPP
+		 *
+		 *  ie, no message nodes, and at least one task or dais
+		 *  socket node.
+		 */
+		if (node1Type == NODE_MESSAGE || node2Type == NODE_MESSAGE ||
+		    (node1Type != NODE_TASK && node1Type != NODE_DAISSOCKET &&
+		     node2Type != NODE_TASK && node2Type != NODE_DAISSOCKET))
+			status = DSP_EFAIL;
+	}
+	/*
+	 * Check stream mode. Default is STRMMODE_PROCCOPY.
+	 */
+	if (DSP_SUCCEEDED(status) && pAttrs) {
+		if (pAttrs->lMode != STRMMODE_PROCCOPY)
+			status = DSP_ESTRMMODE;	/* illegal stream mode */
+
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (node1Type != NODE_GPP) {
+		hNodeMgr = hNode1->hNodeMgr;
+	} else {
+		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
+		hNodeMgr = hNode2->hNodeMgr;
+	}
+	/* Enter critical section */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	/* Nodes must be in the allocated state */
+	if (node1Type != NODE_GPP && NODE_GetState(hNode1) != NODE_ALLOCATED)
+		status = DSP_EWRONGSTATE;
+
+	if (node2Type != NODE_GPP && NODE_GetState(hNode2) != NODE_ALLOCATED)
+		status = DSP_EWRONGSTATE;
+
+	if (DSP_SUCCEEDED(status)) {
+		/*  Check that stream indices for task and dais socket nodes
+		 *  are not already be used. (Device nodes checked later) */
+		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
+			pOutput = &(hNode1->createArgs.asa.taskArgs.
+				  strmOutDef[uStream1]);
+			if (pOutput->szDevice != NULL)
+				status = DSP_EALREADYCONNECTED;
+
+		}
+		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
+			pInput = &(hNode2->createArgs.asa.taskArgs.
+				 strmInDef[uStream2]);
+			if (pInput->szDevice != NULL)
+				status = DSP_EALREADYCONNECTED;
+
+		}
+	}
+	/* Connecting two task nodes? */
+	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_TASK ||
+	   node1Type == NODE_DAISSOCKET) && (node2Type == NODE_TASK ||
+	   node2Type == NODE_DAISSOCKET))) {
+		/* Find available pipe */
+		pipeId = GB_findandset(hNodeMgr->pipeMap);
+		if (pipeId == GB_NOBITS) {
+			status = DSP_ENOMORECONNECTIONS;
+		} else {
+			hNode1->outputs[uStream1].type = NODECONNECT;
+			hNode2->inputs[uStream2].type = NODECONNECT;
+			hNode1->outputs[uStream1].devId = pipeId;
+			hNode2->inputs[uStream2].devId = pipeId;
+			pOutput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
+						      MEM_PAGED);
+			pInput->szDevice = MEM_Calloc(PIPENAMELEN + 1,
+						     MEM_PAGED);
+			if (pOutput->szDevice == NULL ||
+			   pInput->szDevice == NULL) {
+				/* Undo the connection */
+				kfree(pOutput->szDevice);
+
+				kfree(pInput->szDevice);
+
+				pOutput->szDevice = NULL;
+				pInput->szDevice = NULL;
+				GB_clear(hNodeMgr->pipeMap, pipeId);
+				status = DSP_EMEMORY;
+			} else {
+				/* Copy "/dbpipe<pipId>" name to device names */
+				sprintf(pOutput->szDevice, "%s%d",
+						PIPEPREFIX, pipeId);
+				strcpy(pInput->szDevice, pOutput->szDevice);
+			}
+		}
+	}
+	/* Connecting task node to host? */
+	if (DSP_SUCCEEDED(status) && (node1Type == NODE_GPP ||
+	   node2Type == NODE_GPP)) {
+		if (node1Type == NODE_GPP) {
+			uMode = CHNL_MODETODSP;
+		} else {
+			DBC_Assert(node2Type == NODE_GPP);
+			uMode = CHNL_MODEFROMDSP;
+		}
+		 /*  Reserve a channel id. We need to put the name "/host<id>"
+		 *  in the node's createArgs, but the host
+		 *  side channel will not be opened until DSPStream_Open is
+		 *  called for this node.  */
+		if (pAttrs) {
+			if (pAttrs->lMode == STRMMODE_RDMA) {
+				chnlId = GB_findandset(hNodeMgr->dmaChnlMap);
+				/* dma chans are 2nd transport chnl set
+				 * ids(e.g. 16-31)*/
+				(chnlId != GB_NOBITS) ?
+				   (chnlId = chnlId + hNodeMgr->ulNumChnls) :
+				   chnlId;
+			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
+				chnlId = GB_findandset(hNodeMgr->zChnlMap);
+				/* zero-copy chans are 3nd transport set
+				 * (e.g. 32-47) */
+				(chnlId != GB_NOBITS) ?  (chnlId = chnlId +
+					(2 * hNodeMgr->ulNumChnls)) : chnlId;
+			} else {	/* must be PROCCOPY */
+				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
+				chnlId = GB_findandset(hNodeMgr->chnlMap);
+				/* e.g. 0-15 */
+			}
+		} else {
+			/* default to PROCCOPY */
+			chnlId = GB_findandset(hNodeMgr->chnlMap);
+		}
+		if (chnlId == GB_NOBITS) {
+			status = DSP_ENOMORECONNECTIONS;
+			goto func_cont2;
+		}
+		pstrDevName = MEM_Calloc(HOSTNAMELEN + 1, MEM_PAGED);
+		if (pstrDevName != NULL)
+			goto func_cont2;
+
+		if (pAttrs) {
+			if (pAttrs->lMode == STRMMODE_RDMA) {
+				GB_clear(hNodeMgr->dmaChnlMap, chnlId -
+					 hNodeMgr->ulNumChnls);
+			} else if (pAttrs->lMode == STRMMODE_ZEROCOPY) {
+				GB_clear(hNodeMgr->zChnlMap, chnlId -
+					(2*hNodeMgr->ulNumChnls));
+			} else {
+				DBC_Assert(pAttrs->lMode == STRMMODE_PROCCOPY);
+				GB_clear(hNodeMgr->chnlMap, chnlId);
+			}
+		} else {
+			GB_clear(hNodeMgr->chnlMap, chnlId);
+		}
+		status = DSP_EMEMORY;
+func_cont2:
+		if (DSP_SUCCEEDED(status)) {
+			if (hNode1 == (struct NODE_OBJECT *) DSP_HGPPNODE) {
+				hNode2->inputs[uStream2].type = HOSTCONNECT;
+				hNode2->inputs[uStream2].devId = chnlId;
+				pInput->szDevice = pstrDevName;
+			} else {
+				hNode1->outputs[uStream1].type = HOSTCONNECT;
+				hNode1->outputs[uStream1].devId = chnlId;
+				pOutput->szDevice = pstrDevName;
+			}
+			sprintf(pstrDevName, "%s%d", HOSTPREFIX, chnlId);
+		}
+	}
+	/* Connecting task node to device node? */
+	if (DSP_SUCCEEDED(status) && ((node1Type == NODE_DEVICE) ||
+	   (node2Type == NODE_DEVICE))) {
+		if (node2Type == NODE_DEVICE) {
+			/* node1 == > device */
+			hDevNode = hNode2;
+			hNode = hNode1;
+			pStream = &(hNode1->outputs[uStream1]);
+			pstrmDef = pOutput;
+		} else {
+			/* device == > node2 */
+			hDevNode = hNode1;
+			hNode = hNode2;
+			pStream = &(hNode2->inputs[uStream2]);
+			pstrmDef = pInput;
+		}
+		/* Set up create args */
+		pStream->type = DEVICECONNECT;
+		dwLength = strlen(hDevNode->pstrDevName);
+		if (pConnParam != NULL) {
+			pstrmDef->szDevice = MEM_Calloc(dwLength + 1 +
+						(u32) pConnParam->cbData,
+						MEM_PAGED);
+		} else {
+			pstrmDef->szDevice = MEM_Calloc(dwLength + 1,
+							MEM_PAGED);
+		}
+		if (pstrmDef->szDevice == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			/* Copy device name */
+			strncpy(pstrmDef->szDevice, hDevNode->pstrDevName,
+				dwLength);
+			if (pConnParam != NULL) {
+				strncat(pstrmDef->szDevice,
+					(char *)pConnParam->cData,
+					(u32)pConnParam->cbData);
+			}
+			hDevNode->hDeviceOwner = hNode;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Fill in create args */
+		if (node1Type == NODE_TASK || node1Type == NODE_DAISSOCKET) {
+			hNode1->createArgs.asa.taskArgs.uNumOutputs++;
+			FillStreamDef(hNode1, pOutput, pAttrs);
+		}
+		if (node2Type == NODE_TASK || node2Type == NODE_DAISSOCKET) {
+			hNode2->createArgs.asa.taskArgs.uNumInputs++;
+			FillStreamDef(hNode2, pInput, pAttrs);
+		}
+		/* Update hNode1 and hNode2 streamConnect */
+		if (node1Type != NODE_GPP && node1Type != NODE_DEVICE) {
+			hNode1->uNumOutputs++;
+			if (uStream1 > hNode1->uMaxOutputIndex)
+				hNode1->uMaxOutputIndex = uStream1;
+
+		}
+		if (node2Type != NODE_GPP && node2Type != NODE_DEVICE) {
+			hNode2->uNumInputs++;
+			if (uStream2 > hNode2->uMaxInputIndex)
+				hNode2->uMaxInputIndex = uStream2;
+
+		}
+		FillStreamConnect(hNode1, hNode2, uStream1, uStream2);
+	}
+func_cont:
+	/* end of SYNC_EnterCS */
+	/* Exit critical section */
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+func_end:
+	dev_dbg(bridge, "%s: hNode1: %p uStream1: %d hNode2: %p uStream2: %d"
+				"pAttrs: %p status: 0x%x\n", __func__, hNode1,
+				uStream1, hNode2, uStream2, pAttrs, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_Create ========
+ *  Purpose:
+ *      Create a node on the DSP by remotely calling the node's create function.
+ */
+DSP_STATUS NODE_Create(struct NODE_OBJECT *hNode)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	struct NODE_MGR *hNodeMgr;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	u32 ulCreateFxn;
+	enum NODE_TYPE nodeType;
+	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status1 = DSP_SOK;
+	struct DSP_CBDATA cbData;
+	u32 procId = 255;
+	struct DSP_PROCESSORSTATE procStatus;
+	struct PROC_OBJECT *hProcessor;
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+#endif
+
+	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(pNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	hProcessor = hNode->hProcessor;
+	status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in error state then don't attempt to create
+	    new node */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	/* create struct DSP_CBDATA struct for PWR calls */
+	cbData.cbData = PWR_TIMEOUT;
+	nodeType = NODE_GetType(hNode);
+	hNodeMgr = hNode->hNodeMgr;
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* Get access to node dispatcher */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Check node state */
+	if (NODE_GetState(hNode) != NODE_ALLOCATED)
+		status = DSP_EWRONGSTATE;
+
+	if (DSP_SUCCEEDED(status))
+		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+
+	if (DSP_FAILED(status))
+		goto func_cont2;
+
+	if (procId != DSP_UNIT)
+		goto func_cont2;
+
+	/* Make sure streams are properly connected */
+	if ((hNode->uNumInputs && hNode->uMaxInputIndex >
+	   hNode->uNumInputs - 1) ||
+	   (hNode->uNumOutputs && hNode->uMaxOutputIndex >
+	   hNode->uNumOutputs - 1))
+		status = DSP_ENOTCONNECTED;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* If node's create function is not loaded, load it */
+		/* Boost the OPP level to max level that DSP can be requested */
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP3]);
+#endif
+		status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
+						   NLDR_CREATE);
+		/* Get address of node's create function */
+		if (DSP_SUCCEEDED(status)) {
+			hNode->fLoaded = true;
+			if (nodeType != NODE_DEVICE) {
+				status = GetFxnAddress(hNode, &ulCreateFxn,
+							CREATEPHASE);
+			}
+		} else {
+			pr_err("%s: failed to load create code: 0x%x\n",
+							__func__, status);
+		}
+		/* Request the lowest OPP level*/
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+		if (pdata->cpu_set_freq)
+			(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP1]);
+#endif
+		/* Get address of iAlg functions, if socket node */
+		if (DSP_SUCCEEDED(status)) {
+			if (nodeType == NODE_DAISSOCKET) {
+				status = hNodeMgr->nldrFxns.pfnGetFxnAddr
+					(hNode->hNldrNode, hNode->dcdProps.
+					objData.nodeObj.pstrIAlgName,
+					&hNode->createArgs.asa.taskArgs.
+					ulDaisArg);
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		if (nodeType != NODE_DEVICE) {
+			status = DISP_NodeCreate(hNodeMgr->hDisp, hNode,
+				 hNodeMgr->ulFxnAddrs[RMSCREATENODE],
+				 ulCreateFxn, &(hNode->createArgs),
+				 &(hNode->nodeEnv));
+			if (DSP_SUCCEEDED(status)) {
+				/* Set the message queue id to the node env
+				 * pointer */
+				pIntfFxns = hNodeMgr->pIntfFxns;
+				(*pIntfFxns->pfnMsgSetQueueId)(hNode->hMsgQueue,
+				hNode->nodeEnv);
+			}
+		}
+	}
+	/*  Phase II/Overlays: Create, execute, delete phases  possibly in
+	 *  different files/sections. */
+	if (hNode->fLoaded && hNode->fPhaseSplit) {
+		/* If create code was dynamically loaded, we can now unload
+		 * it. */
+		status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
+						      NLDR_CREATE);
+		hNode->fLoaded = false;
+	}
+	if (DSP_FAILED(status1))
+		pr_err("%s: Failed to unload create code: 0x%x\n",
+							__func__, status1);
+func_cont2:
+	/* Update node state and node manager state */
+	if (DSP_SUCCEEDED(status)) {
+		NODE_SetState(hNode, NODE_CREATED);
+		hNodeMgr->uNumCreated++;
+		goto func_cont;
+	}
+	if (status != DSP_EWRONGSTATE) {
+		/* Put back in NODE_ALLOCATED state if error occurred */
+		NODE_SetState(hNode, NODE_ALLOCATED);
+	}
+func_cont:
+		/* Free access to node dispatcher */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+func_end:
+	if (DSP_SUCCEEDED(status)) {
+		PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
+		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+	}
+
+	dev_dbg(bridge, "%s: hNode: %p status: 0x%x\n", __func__,
+							hNode, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_CreateMgr ========
+ *  Purpose:
+ *      Create a NODE Manager object.
+ */
+DSP_STATUS NODE_CreateMgr(OUT struct NODE_MGR **phNodeMgr,
+			 struct DEV_OBJECT *hDevObject)
+{
+	u32 i;
+	struct NODE_MGR *pNodeMgr = NULL;
+	struct DISP_ATTRS dispAttrs;
+	char *szZLFile = "";
+	struct NLDR_ATTRS nldrAttrs;
+	DSP_STATUS status = DSP_SOK;
+	u32 devType;
+	DBC_Require(cRefs > 0);
+	DBC_Require(phNodeMgr != NULL);
+	DBC_Require(hDevObject != NULL);
+
+	*phNodeMgr = NULL;
+	/* Allocate Node manager object */
+	MEM_AllocObject(pNodeMgr, struct NODE_MGR, NODEMGR_SIGNATURE);
+	if (pNodeMgr) {
+		pNodeMgr->hDevObject = hDevObject;
+		pNodeMgr->nodeList = MEM_Calloc(sizeof(struct LST_LIST),
+						MEM_NONPAGED);
+		pNodeMgr->pipeMap = GB_create(MAXPIPES);
+		pNodeMgr->pipeDoneMap = GB_create(MAXPIPES);
+		if (pNodeMgr->nodeList == NULL || pNodeMgr->pipeMap == NULL ||
+		   pNodeMgr->pipeDoneMap == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			INIT_LIST_HEAD(&pNodeMgr->nodeList->head);
+			status = NTFY_Create(&pNodeMgr->hNtfy);
+		}
+		pNodeMgr->uNumCreated = 0;
+	} else {
+		status = DSP_EMEMORY;
+	}
+	/* get devNodeType */
+	if (DSP_SUCCEEDED(status))
+		status = DEV_GetDevType(hDevObject, &devType);
+
+	/* Create the DCD Manager */
+	if (DSP_SUCCEEDED(status)) {
+		status = DCD_CreateManager(szZLFile, &pNodeMgr->hDcdMgr);
+		if (DSP_SUCCEEDED(status))
+			status = GetProcProps(pNodeMgr, hDevObject);
+
+	}
+	/* Create NODE Dispatcher */
+	if (DSP_SUCCEEDED(status)) {
+		dispAttrs.ulChnlOffset = pNodeMgr->ulChnlOffset;
+		dispAttrs.ulChnlBufSize = pNodeMgr->ulChnlBufSize;
+		dispAttrs.procFamily = pNodeMgr->procFamily;
+		dispAttrs.procType = pNodeMgr->procType;
+		status = DISP_Create(&pNodeMgr->hDisp, hDevObject, &dispAttrs);
+	}
+	/* Create a STRM Manager */
+	if (DSP_SUCCEEDED(status))
+		status = STRM_Create(&pNodeMgr->hStrmMgr, hDevObject);
+
+	if (DSP_SUCCEEDED(status)) {
+		DEV_GetIntfFxns(hDevObject, &pNodeMgr->pIntfFxns);
+		/* Get MSG queue manager */
+		DEV_GetMsgMgr(hDevObject, &pNodeMgr->hMsg);
+		status = SYNC_InitializeCS(&pNodeMgr->hSync);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		pNodeMgr->chnlMap = GB_create(pNodeMgr->ulNumChnls);
+		/* dma chnl map. ulNumChnls is # per transport */
+		pNodeMgr->dmaChnlMap = GB_create(pNodeMgr->ulNumChnls);
+		pNodeMgr->zChnlMap = GB_create(pNodeMgr->ulNumChnls);
+		if ((pNodeMgr->chnlMap == NULL) ||
+		   (pNodeMgr->dmaChnlMap == NULL) ||
+		   (pNodeMgr->zChnlMap == NULL)) {
+			status = DSP_EMEMORY;
+		} else {
+			/* Block out reserved channels */
+			for (i = 0; i < pNodeMgr->ulChnlOffset; i++)
+				GB_set(pNodeMgr->chnlMap, i);
+
+			/* Block out channels reserved for RMS */
+			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset);
+			GB_set(pNodeMgr->chnlMap, pNodeMgr->ulChnlOffset + 1);
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* NO RM Server on the IVA */
+		if (devType != IVA_UNIT) {
+			/* Get addresses of any RMS functions loaded */
+			status = GetRMSFxns(pNodeMgr);
+		}
+	}
+
+	/* Get loader functions and create loader */
+	if (DSP_SUCCEEDED(status))
+		pNodeMgr->nldrFxns = nldrFxns;	/* Dynamic loader functions */
+
+	if (DSP_SUCCEEDED(status)) {
+		nldrAttrs.pfnOvly = Ovly;
+		nldrAttrs.pfnWrite = Write;
+		nldrAttrs.usDSPWordSize = pNodeMgr->uDSPWordSize;
+		nldrAttrs.usDSPMauSize = pNodeMgr->uDSPMauSize;
+		pNodeMgr->fLoaderInit = pNodeMgr->nldrFxns.pfnInit();
+		status = pNodeMgr->nldrFxns.pfnCreate(&pNodeMgr->hNldr,
+						     hDevObject, &nldrAttrs);
+	}
+	if (DSP_SUCCEEDED(status))
+		*phNodeMgr = pNodeMgr;
+	else
+		DeleteNodeMgr(pNodeMgr);
+
+	DBC_Ensure((DSP_FAILED(status) && (*phNodeMgr == NULL)) ||
+		  (DSP_SUCCEEDED(status) &&
+		  MEM_IsValidHandle((*phNodeMgr), NODEMGR_SIGNATURE)));
+
+	return status;
+}
+
+/*
+ *  ======== NODE_Delete ========
+ *  Purpose:
+ *      Delete a node on the DSP by remotely calling the node's delete function.
+ *      Loads the node's delete function if necessary. Free GPP side resources
+ *      after node's delete function returns.
+ */
+DSP_STATUS NODE_Delete(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	struct NODE_MGR *hNodeMgr;
+	struct PROC_OBJECT *hProcessor;
+	struct DISP_OBJECT *hDisp;
+	u32 ulDeleteFxn;
+	enum NODE_TYPE nodeType;
+	enum NODE_STATE state;
+	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status1 = DSP_SOK;
+	struct DSP_CBDATA cbData;
+	u32 procId;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+
+	HANDLE		nodeRes;
+
+	struct DSP_PROCESSORSTATE procStatus;
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/* create struct DSP_CBDATA struct for PWR call */
+	cbData.cbData = PWR_TIMEOUT;
+	hNodeMgr = hNode->hNodeMgr;
+	hProcessor = hNode->hProcessor;
+	hDisp = hNodeMgr->hDisp;
+	nodeType = NODE_GetType(hNode);
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* Enter critical section */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	state = NODE_GetState(hNode);
+	 /*  Execute delete phase code for non-device node in all cases
+	  *  except when the node was only allocated. Delete phase must be
+	  *  executed even if create phase was executed, but failed.
+	  *  If the node environment pointer is non-NULL, the delete phase
+	  *  code must be  executed.  */
+	if (!(state == NODE_ALLOCATED && hNode->nodeEnv == (u32)NULL) &&
+	   nodeType != NODE_DEVICE) {
+		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+		if (DSP_FAILED(status))
+			goto func_cont1;
+
+		if (procId == DSP_UNIT || procId == IVA_UNIT) {
+			/*  If node has terminated, execute phase code will
+			 *  have already been unloaded in NODE_OnExit(). If the
+			 *  node is PAUSED, the execute phase is loaded, and it
+			 *  is now ok to unload it. If the node is running, we
+			 *  will unload the execute phase only after deleting
+			 *  the node.  */
+			if (state == NODE_PAUSED && hNode->fLoaded &&
+			   hNode->fPhaseSplit) {
+				/* Ok to unload execute code as long as node
+				 * is not * running */
+				status1 = hNodeMgr->nldrFxns.pfnUnload(hNode->
+					  hNldrNode, NLDR_EXECUTE);
+				hNode->fLoaded = false;
+				NODE_SetState(hNode, NODE_DONE);
+			}
+			/* Load delete phase code if not loaded or if haven't
+			 * * unloaded EXECUTE phase */
+			if ((!(hNode->fLoaded) || (state == NODE_RUNNING)) &&
+			   hNode->fPhaseSplit) {
+				status = hNodeMgr->nldrFxns.pfnLoad(hNode->
+					 hNldrNode, NLDR_DELETE);
+				if (DSP_SUCCEEDED(status))
+					hNode->fLoaded = true;
+				else
+					pr_err("%s: fail - load delete code:"
+						" 0x%x\n", __func__, status);
+			}
+		}
+func_cont1:
+		if (DSP_SUCCEEDED(status)) {
+			/* Unblock a thread trying to terminate the node */
+			(void)SYNC_SetEvent(hNode->hSyncDone);
+			if (procId == DSP_UNIT) {
+				/* ulDeleteFxn = address of node's delete
+				 * function */
+				status = GetFxnAddress(hNode, &ulDeleteFxn,
+						      DELETEPHASE);
+			} else if (procId == IVA_UNIT)
+				ulDeleteFxn = (u32)hNode->nodeEnv;
+			if (DSP_SUCCEEDED(status)) {
+				status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+				if (procStatus.iState != PROC_ERROR) {
+					status = DISP_NodeDelete(hDisp, hNode,
+					hNodeMgr->ulFxnAddrs[RMSDELETENODE],
+					ulDeleteFxn, hNode->nodeEnv);
+				} else
+					NODE_SetState(hNode, NODE_DONE);
+
+				/* Unload execute, if not unloaded, and delete
+				 * function */
+				if (state == NODE_RUNNING &&
+				   hNode->fPhaseSplit) {
+					status1 = hNodeMgr->nldrFxns.pfnUnload(
+						hNode->hNldrNode, NLDR_EXECUTE);
+				}
+				if (DSP_FAILED(status1))
+					pr_err("%s: fail - unload execute code:"
+						" 0x%x\n", __func__, status1);
+
+				status1 = hNodeMgr->nldrFxns.pfnUnload(
+					  hNode->hNldrNode, NLDR_DELETE);
+				hNode->fLoaded = false;
+				if (DSP_FAILED(status1))
+					pr_err("%s: fail - unload delete code: "
+						"0x%x\n", __func__, status1);
+			}
+		}
+	}
+	/* Free host side resources even if a failure occurred */
+	/* Remove node from hNodeMgr->nodeList */
+	LST_RemoveElem(hNodeMgr->nodeList, (struct list_head *) hNode);
+	hNodeMgr->uNumNodes--;
+	/* Decrement count of nodes created on DSP */
+	if ((state != NODE_ALLOCATED) || ((state == NODE_ALLOCATED) &&
+	(hNode->nodeEnv != (u32) NULL)))
+		hNodeMgr->uNumCreated--;
+	 /*  Free host-side resources allocated by NODE_Create()
+	 *  DeleteNode() fails if SM buffers not freed by client!  */
+	if (DRV_GetNodeResElement(hNode, &nodeRes, pr_ctxt) != DSP_ENOTFOUND)
+		DRV_ProcNodeUpdateStatus(nodeRes, false);
+	DeleteNode(hNode, pr_ctxt);
+
+	DRV_RemoveNodeResElement(nodeRes, pr_ctxt);
+	/* Exit critical section */
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	PROC_NotifyClients(hProcessor, DSP_NODESTATECHANGE);
+func_end:
+	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_DeleteMgr ========
+ *  Purpose:
+ *      Delete the NODE Manager.
+ */
+DSP_STATUS NODE_DeleteMgr(struct NODE_MGR *hNodeMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+		DeleteNodeMgr(hNodeMgr);
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+/*
+ *  ======== NODE_EnumNodes ========
+ *  Purpose:
+ *      Enumerate currently allocated nodes.
+ */
+DSP_STATUS NODE_EnumNodes(struct NODE_MGR *hNodeMgr, void **aNodeTab,
+			 u32 uNodeTabSize, OUT u32 *puNumNodes,
+			 OUT u32 *puAllocated)
+{
+	struct NODE_OBJECT *hNode;
+	u32 i;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
+	DBC_Require(puNumNodes != NULL);
+	DBC_Require(puAllocated != NULL);
+
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/* Enter critical section */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_SUCCEEDED(status)) {
+		if (hNodeMgr->uNumNodes > uNodeTabSize) {
+			*puAllocated = hNodeMgr->uNumNodes;
+			*puNumNodes = 0;
+			status = DSP_ESIZE;
+		} else {
+			hNode = (struct NODE_OBJECT *)LST_First(hNodeMgr->
+				nodeList);
+			for (i = 0; i < hNodeMgr->uNumNodes; i++) {
+				DBC_Assert(MEM_IsValidHandle(hNode,
+					  NODE_SIGNATURE));
+				aNodeTab[i] = hNode;
+				hNode = (struct NODE_OBJECT *)LST_Next
+					(hNodeMgr->nodeList,
+					(struct list_head *)hNode);
+			}
+			*puAllocated = *puNumNodes = hNodeMgr->uNumNodes;
+		}
+	}
+	/* end of SYNC_EnterCS */
+	/* Exit critical section */
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== NODE_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NODE module.
+ */
+void NODE_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== NODE_FreeMsgBuf ========
+ *  Purpose:
+ *      Frees the message buffer.
+ */
+DSP_STATUS NODE_FreeMsgBuf(struct NODE_OBJECT *hNode, IN u8 *pBuffer,
+				 OPTIONAL struct DSP_BUFFERATTR *pAttr)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	DSP_STATUS status = DSP_SOK;
+	u32 procId;
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBuffer != NULL);
+	DBC_Require(pNode != NULL);
+	DBC_Require(pNode->hXlator != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+	if (procId == DSP_UNIT) {
+		if (DSP_SUCCEEDED(status)) {
+			if (pAttr == NULL) {
+				/* set defaults */
+				pAttr = &NODE_DFLTBUFATTRS;
+			}
+			 /* Node supports single SM segment only */
+			if (pAttr->uSegment != 1)
+				status = DSP_EBADSEGID;
+
+			/* pBuffer is clients Va. */
+			status = CMM_XlatorFreeBuf(pNode->hXlator, pBuffer);
+		}
+	} else {
+		DBC_Assert(NULL);	/* BUG */
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== NODE_GetAttr ========
+ *  Purpose:
+ *      Copy the current attributes of the specified node into a DSP_NODEATTR
+ *      structure.
+ */
+DSP_STATUS NODE_GetAttr(struct NODE_OBJECT *hNode,
+			OUT struct DSP_NODEATTR *pAttr, u32 uAttrSize)
+{
+	struct NODE_MGR *hNodeMgr;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(cRefs > 0);
+	DBC_Require(pAttr != NULL);
+	DBC_Require(uAttrSize >= sizeof(struct DSP_NODEATTR));
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		hNodeMgr = hNode->hNodeMgr;
+		 /* Enter hNodeMgr critical section (since we're accessing
+		  * data that could be changed by NODE_ChangePriority() and
+		  * NODE_Connect().  */
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+		if (DSP_SUCCEEDED(status)) {
+			pAttr->cbStruct = sizeof(struct DSP_NODEATTR);
+			/* DSP_NODEATTRIN */
+			pAttr->inNodeAttrIn.cbStruct =
+					 sizeof(struct DSP_NODEATTRIN);
+			pAttr->inNodeAttrIn.iPriority = hNode->nPriority;
+			pAttr->inNodeAttrIn.uTimeout = hNode->uTimeout;
+			pAttr->inNodeAttrIn.uHeapSize =
+				hNode->createArgs.asa.taskArgs.uHeapSize;
+			pAttr->inNodeAttrIn.pGPPVirtAddr = (void *)
+				hNode->createArgs.asa.taskArgs.uGPPHeapAddr;
+			pAttr->uInputs = hNode->uNumGPPInputs;
+			pAttr->uOutputs = hNode->uNumGPPOutputs;
+			/* DSP_NODEINFO */
+			GetNodeInfo(hNode, &(pAttr->iNodeInfo));
+		}
+		/* end of SYNC_EnterCS */
+		/* Exit critical section */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	}
+	return status;
+}
+
+/*
+ *  ======== NODE_GetChannelId ========
+ *  Purpose:
+ *      Get the channel index reserved for a stream connection between the
+ *      host and a node.
+ */
+DSP_STATUS NODE_GetChannelId(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
+			    OUT u32 *pulId)
+{
+	enum NODE_TYPE nodeType;
+	DSP_STATUS status = DSP_EVALUE;
+	DBC_Require(cRefs > 0);
+	DBC_Require(uDir == DSP_TONODE || uDir == DSP_FROMNODE);
+	DBC_Require(pulId != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		return status;
+	}
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET) {
+		status = DSP_ENODETYPE;
+		return status;
+	}
+	if (uDir == DSP_TONODE) {
+		if (uIndex < MaxInputs(hNode)) {
+			if (hNode->inputs[uIndex].type == HOSTCONNECT) {
+				*pulId = hNode->inputs[uIndex].devId;
+				status = DSP_SOK;
+			}
+		}
+	} else {
+		DBC_Assert(uDir == DSP_FROMNODE);
+		if (uIndex < MaxOutputs(hNode)) {
+			if (hNode->outputs[uIndex].type == HOSTCONNECT) {
+				*pulId = hNode->outputs[uIndex].devId;
+				status = DSP_SOK;
+			}
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== NODE_GetMessage ========
+ *  Purpose:
+ *      Retrieve a message from a node on the DSP.
+ */
+DSP_STATUS NODE_GetMessage(struct NODE_OBJECT *hNode, OUT struct DSP_MSG *pMsg,
+			  u32 uTimeout)
+{
+	struct NODE_MGR *hNodeMgr;
+	enum NODE_TYPE nodeType;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+	void *pTmpBuf;
+	struct DSP_PROCESSORSTATE procStatus;
+	struct PROC_OBJECT *hProcessor;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pMsg != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	hProcessor = hNode->hProcessor;
+	status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in error state then don't attempt to get the
+	    message */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	hNodeMgr = hNode->hNodeMgr;
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
+	   nodeType != NODE_DAISSOCKET) {
+		status = DSP_ENODETYPE;
+		goto func_end;
+	}
+	 /*  This function will block unless a message is available. Since
+	 *  DSPNode_RegisterNotify() allows notification when a message
+	 *  is available, the system can be designed so that
+	 *  DSPNode_GetMessage() is only called when a message is
+	 *  available.  */
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	status = (*pIntfFxns->pfnMsgGet)(hNode->hMsgQueue, pMsg, uTimeout);
+	/* Check if message contains SM descriptor */
+	if (DSP_FAILED(status) ||  !(pMsg->dwCmd & DSP_RMSBUFDESC))
+		goto func_end;
+
+	 /* Translate DSP byte addr to GPP Va.  */
+	pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
+		(void *)(pMsg->dwArg1 * hNode->hNodeMgr->uDSPWordSize),
+		CMM_DSPPA2PA);
+	if (pTmpBuf  != NULL) {
+		/* now convert this GPP Pa to Va */
+		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator, pTmpBuf,
+							CMM_PA2VA);
+		if (pTmpBuf != NULL) {
+			/* Adjust SM size in msg */
+			pMsg->dwArg1 = (u32) pTmpBuf;
+			pMsg->dwArg2 *= hNode->hNodeMgr->uDSPWordSize;
+		} else {
+			status = DSP_ETRANSLATE;
+		}
+	} else {
+		status = DSP_ETRANSLATE;
+	}
+func_end:
+	dev_dbg(bridge, "%s: hNode: %p pMsg: %p uTimeout: 0x%x\n", __func__,
+							hNode, pMsg, uTimeout);
+	return status;
+}
+
+/*
+ *   ======== NODE_GetNldrObj ========
+ */
+DSP_STATUS NODE_GetNldrObj(struct NODE_MGR *hNodeMgr,
+			  struct NLDR_OBJECT **phNldrObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct NODE_MGR *pNodeMgr = hNodeMgr;
+	DBC_Require(phNldrObj != NULL);
+
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+		status = DSP_EHANDLE;
+	else
+		*phNldrObj = pNodeMgr->hNldr;
+
+	DBC_Ensure(DSP_SUCCEEDED(status) || ((phNldrObj != NULL) &&
+		  (*phNldrObj == NULL)));
+	return status;
+}
+
+/*
+ *  ======== NODE_GetStrmMgr ========
+ *  Purpose:
+ *      Returns the Stream manager.
+ */
+DSP_STATUS NODE_GetStrmMgr(struct NODE_OBJECT *hNode,
+			  struct STRM_MGR **phStrmMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+		status = DSP_EHANDLE;
+	else
+		*phStrmMgr = hNode->hNodeMgr->hStrmMgr;
+
+	return status;
+}
+
+/*
+ *  ======== NODE_GetLoadType ========
+ */
+enum NLDR_LOADTYPE NODE_GetLoadType(struct NODE_OBJECT *hNode)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: Failed. hNode: %p\n", __func__, hNode);
+		return -1;
+	} else {
+		return hNode->dcdProps.objData.nodeObj.usLoadType;
+	}
+}
+
+/*
+ *  ======== NODE_GetTimeout ========
+ *  Purpose:
+ *      Returns the timeout value for this node.
+ */
+u32 NODE_GetTimeout(struct NODE_OBJECT *hNode)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		dev_dbg(bridge, "%s: failed. hNode: %p\n", __func__, hNode);
+		return 0;
+	} else {
+		return hNode->uTimeout;
+	}
+}
+
+/*
+ *  ======== NODE_GetType ========
+ *  Purpose:
+ *      Returns the node type.
+ */
+enum NODE_TYPE NODE_GetType(struct NODE_OBJECT *hNode)
+{
+	enum NODE_TYPE nodeType;
+
+	if (hNode == (struct NODE_OBJECT *) DSP_HGPPNODE)
+		nodeType = NODE_GPP;
+	else {
+		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+			nodeType = -1;
+		else
+			nodeType = hNode->nType;
+	}
+	return nodeType;
+}
+
+/*
+ *  ======== NODE_Init ========
+ *  Purpose:
+ *      Initialize the NODE module.
+ */
+bool NODE_Init(void)
+{
+	DBC_Require(cRefs >= 0);
+
+	cRefs++;
+
+	return true;
+}
+
+/*
+ *  ======== NODE_OnExit ========
+ *  Purpose:
+ *      Gets called when RMS_EXIT is received for a node.
+ */
+void NODE_OnExit(struct NODE_OBJECT *hNode, s32 nStatus)
+{
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		return;
+	}
+	/* Set node state to done */
+	NODE_SetState(hNode, NODE_DONE);
+	hNode->nExitStatus = nStatus;
+	if (hNode->fLoaded && hNode->fPhaseSplit) {
+		(void)hNode->hNodeMgr->nldrFxns.pfnUnload(hNode->hNldrNode,
+							 NLDR_EXECUTE);
+		hNode->fLoaded = false;
+	}
+	/* Unblock call to NODE_Terminate */
+	(void) SYNC_SetEvent(hNode->hSyncDone);
+	/* Notify clients */
+	PROC_NotifyClients(hNode->hProcessor, DSP_NODESTATECHANGE);
+	NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+}
+
+/*
+ *  ======== NODE_Pause ========
+ *  Purpose:
+ *      Suspend execution of a node currently running on the DSP.
+ */
+DSP_STATUS NODE_Pause(struct NODE_OBJECT *hNode)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	enum NODE_TYPE nodeType;
+	enum NODE_STATE state;
+	struct NODE_MGR *hNodeMgr;
+	DSP_STATUS status = DSP_SOK;
+	u32 procId;
+	struct DSP_PROCESSORSTATE procStatus;
+	struct PROC_OBJECT *hProcessor;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		nodeType = NODE_GetType(hNode);
+		if (nodeType != NODE_TASK && nodeType != NODE_DAISSOCKET)
+			status = DSP_ENODETYPE;
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+
+	if (procId == IVA_UNIT)
+		status = DSP_ENOTIMPL;
+
+	if (DSP_SUCCEEDED(status)) {
+		hNodeMgr = hNode->hNodeMgr;
+
+		/* Enter critical section */
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+
+		if (DSP_SUCCEEDED(status)) {
+			state = NODE_GetState(hNode);
+			/* Check node state */
+			if (state != NODE_RUNNING)
+				status = DSP_EWRONGSTATE;
+
+			if (DSP_FAILED(status))
+				goto func_cont;
+			hProcessor = hNode->hProcessor;
+			status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+			if (DSP_FAILED(status))
+				goto func_cont;
+			/* If processor is in error state then don't attempt
+			    to send the message */
+			if (procStatus.iState == PROC_ERROR) {
+				status = DSP_EFAIL;
+				goto func_cont;
+			}
+			if (DSP_SUCCEEDED(status)) {
+				status = DISP_NodeChangePriority(hNodeMgr->
+				   hDisp, hNode,
+				   hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY],
+				   hNode->nodeEnv, NODE_SUSPENDEDPRI);
+			}
+
+			/* Update state */
+			if (DSP_SUCCEEDED(status))
+				NODE_SetState(hNode, NODE_PAUSED);
+		}
+func_cont:
+		/* End of SYNC_EnterCS */
+		/* Leave critical section */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+		if (DSP_SUCCEEDED(status)) {
+			PROC_NotifyClients(hNode->hProcessor,
+					  DSP_NODESTATECHANGE);
+			NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+		}
+	}
+func_end:
+	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_PutMessage ========
+ *  Purpose:
+ *      Send a message to a message node, task node, or XDAIS socket node. This
+ *      function will block until the message stream can accommodate the
+ *      message, or a timeout occurs.
+ */
+DSP_STATUS NODE_PutMessage(struct NODE_OBJECT *hNode,
+			  IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+{
+	struct NODE_MGR *hNodeMgr = NULL;
+	enum NODE_TYPE nodeType;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	enum NODE_STATE state;
+	DSP_STATUS status = DSP_SOK;
+	void *pTmpBuf;
+	struct DSP_MSG newMsg;
+	struct DSP_PROCESSORSTATE procStatus;
+	struct PROC_OBJECT *hProcessor;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pMsg != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	hProcessor = hNode->hProcessor;
+	status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in bad state then don't attempt sending the
+	    message */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	hNodeMgr = hNode->hNodeMgr;
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_MESSAGE && nodeType != NODE_TASK &&
+	    nodeType != NODE_DAISSOCKET)
+		status = DSP_ENODETYPE;
+
+	if (DSP_SUCCEEDED(status)) {
+		/*  Check node state. Can't send messages to a node after
+		 *  we've sent the RMS_EXIT command. There is still the
+		 *  possibility that NODE_Terminate can be called after we've
+		 *  checked the state. Could add another SYNC object to
+		 *  prevent this (can't use hNodeMgr->hSync, since we don't
+		 *  want to block other NODE functions). However, the node may
+		 *  still exit on its own, before this message is sent.  */
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+		if (DSP_SUCCEEDED(status)) {
+			state = NODE_GetState(hNode);
+			if (state == NODE_TERMINATING || state == NODE_DONE)
+				status = DSP_EWRONGSTATE;
+
+		}
+		/* end of SYNC_EnterCS */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* assign pMsg values to new msg  */
+	newMsg = *pMsg;
+	/* Now, check if message contains a SM buffer descriptor */
+	if (pMsg->dwCmd & DSP_RMSBUFDESC) {
+		/* Translate GPP Va to DSP physical buf Ptr. */
+		pTmpBuf = CMM_XlatorTranslate(hNode->hXlator,
+			(void *)newMsg.dwArg1, CMM_VA2DSPPA);
+		if (pTmpBuf != NULL) {
+			/* got translation, convert to MAUs in msg */
+			if (hNode->hNodeMgr->uDSPWordSize != 0) {
+				newMsg.dwArg1 =
+					(u32)pTmpBuf /
+					hNode->hNodeMgr->uDSPWordSize;
+				/* MAUs */
+				newMsg.dwArg2 /= hNode->hNodeMgr->uDSPWordSize;
+			} else {
+				pr_err("%s: uDSPWordSize is zero!\n", __func__);
+				status = DSP_EFAIL;	/* bad DSPWordSize */
+			}
+		} else {	/* failed to translate buffer address */
+			status = DSP_ETRANSLATE;
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		pIntfFxns = hNodeMgr->pIntfFxns;
+		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue,
+			 &newMsg, uTimeout);
+	}
+func_end:
+	dev_dbg(bridge, "%s: hNode: %p pMsg: %p uTimeout: 0x%x, "
+		"status 0x%x\n", __func__, hNode, pMsg, uTimeout, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this node.
+ */
+DSP_STATUS NODE_RegisterNotify(struct NODE_OBJECT *hNode, u32 uEventMask,
+				u32 uNotifyType,
+				struct DSP_NOTIFICATION *hNotification)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hNotification != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		/* Check if event mask is a valid node related event */
+		if (uEventMask & ~(DSP_NODESTATECHANGE |
+		   DSP_NODEMESSAGEREADY))
+			status = DSP_EVALUE;
+
+		/* Check if notify type is valid */
+		if (uNotifyType != DSP_SIGNALEVENT)
+			status = DSP_EVALUE;
+
+		/* Only one Notification can be registered at a
+		 * time - Limitation */
+		if (uEventMask == (DSP_NODESTATECHANGE |
+		   DSP_NODEMESSAGEREADY))
+			status = DSP_EVALUE;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		if (uEventMask == DSP_NODESTATECHANGE) {
+			status = NTFY_Register(hNode->hNtfy, hNotification,
+				 uEventMask & DSP_NODESTATECHANGE, uNotifyType);
+		} else {
+			/* Send Message part of event mask to MSG */
+			pIntfFxns = hNode->hNodeMgr->pIntfFxns;
+			status = (*pIntfFxns->pfnMsgRegisterNotify)
+				 (hNode->hMsgQueue,
+				 uEventMask & DSP_NODEMESSAGEREADY, uNotifyType,
+				 hNotification);
+		}
+
+	}
+	dev_dbg(bridge, "%s: hNode: %p uEventMask: 0x%x uNotifyType: 0x%x "
+			"hNotification: %p status 0x%x\n", __func__, hNode,
+			uEventMask, uNotifyType, hNotification, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_Run ========
+ *  Purpose:
+ *      Start execution of a node's execute phase, or resume execution of a node
+ *      that has been suspended (via NODE_NodePause()) on the DSP. Load the
+ *      node's execute function if necessary.
+ */
+DSP_STATUS NODE_Run(struct NODE_OBJECT *hNode)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	struct NODE_MGR *hNodeMgr;
+	enum NODE_TYPE nodeType;
+	enum NODE_STATE state;
+	u32 ulExecuteFxn;
+	u32 ulFxnAddr;
+	DSP_STATUS status = DSP_SOK;
+	u32 procId;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct DSP_PROCESSORSTATE procStatus;
+	struct PROC_OBJECT *hProcessor;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	hProcessor = hNode->hProcessor;
+	status = PROC_GetState(hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in error state then don't attempt to run the node */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	nodeType = NODE_GetType(hNode);
+	if (nodeType == NODE_DEVICE)
+		status = DSP_ENODETYPE;
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	hNodeMgr = hNode->hNodeMgr;
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	/* Enter critical section */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	state = NODE_GetState(hNode);
+	if (state != NODE_CREATED && state != NODE_PAUSED)
+		status = DSP_EWRONGSTATE;
+
+	if (DSP_SUCCEEDED(status))
+		status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+
+	if (DSP_FAILED(status))
+		goto func_cont1;
+
+	if ((procId != DSP_UNIT) && (procId != IVA_UNIT))
+		goto func_cont1;
+
+	if (state == NODE_CREATED) {
+		/* If node's execute function is not loaded, load it */
+		if (!(hNode->fLoaded) && hNode->fPhaseSplit) {
+			status = hNodeMgr->nldrFxns.pfnLoad(hNode->hNldrNode,
+				NLDR_EXECUTE);
+			if (DSP_SUCCEEDED(status)) {
+				hNode->fLoaded = true;
+			} else {
+				pr_err("%s: fail - load execute code: 0x%x\n",
+							__func__, status);
+			}
+		}
+		if (DSP_SUCCEEDED(status)) {
+			/* Get address of node's execute function */
+			if (procId == IVA_UNIT)
+				ulExecuteFxn = (u32) hNode->nodeEnv;
+			else {
+				status = GetFxnAddress(hNode, &ulExecuteFxn,
+					 EXECUTEPHASE);
+			}
+		}
+		if (DSP_SUCCEEDED(status)) {
+			ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSEXECUTENODE];
+			status = DISP_NodeRun(hNodeMgr->hDisp, hNode, ulFxnAddr,
+					     ulExecuteFxn, hNode->nodeEnv);
+		}
+	} else if (state == NODE_PAUSED) {
+		ulFxnAddr = hNodeMgr->ulFxnAddrs[RMSCHANGENODEPRIORITY];
+		status = DISP_NodeChangePriority(hNodeMgr->hDisp, hNode,
+						ulFxnAddr, hNode->nodeEnv,
+						NODE_GetPriority(hNode));
+	} else {
+		/* We should never get here */
+		DBC_Assert(false);
+	}
+func_cont1:
+	/* Update node state. */
+	if (DSP_SUCCEEDED(status))
+		NODE_SetState(hNode, NODE_RUNNING);
+	 else /* Set state back to previous value */
+		NODE_SetState(hNode, state);
+	/*End of SYNC_EnterCS */
+	/* Exit critical section */
+func_cont:
+	(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	if (DSP_SUCCEEDED(status)) {
+		PROC_NotifyClients(hNode->hProcessor,
+			  DSP_NODESTATECHANGE);
+		NTFY_Notify(hNode->hNtfy, DSP_NODESTATECHANGE);
+	}
+func_end:
+	dev_dbg(bridge, "%s: hNode: %p status 0x%x\n", __func__, hNode, status);
+	return status;
+}
+
+/*
+ *  ======== NODE_Terminate ========
+ *  Purpose:
+ *      Signal a node running on the DSP that it should exit its execute phase
+ *      function.
+ */
+DSP_STATUS NODE_Terminate(struct NODE_OBJECT *hNode, OUT DSP_STATUS *pStatus)
+{
+	struct NODE_OBJECT *pNode = (struct NODE_OBJECT *)hNode;
+	struct NODE_MGR *hNodeMgr = NULL;
+	enum NODE_TYPE nodeType;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	enum NODE_STATE state;
+	struct DSP_MSG msg, killmsg;
+	DSP_STATUS status = DSP_SOK;
+	u32 procId, killTimeOut;
+	struct DEH_MGR *hDehMgr;
+	struct DSP_PROCESSORSTATE procStatus;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pStatus != NULL);
+
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE) || !hNode->hNodeMgr) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (pNode->hProcessor == NULL) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	status = PROC_GetProcessorId(pNode->hProcessor, &procId);
+
+	if (DSP_SUCCEEDED(status)) {
+		hNodeMgr = hNode->hNodeMgr;
+		nodeType = NODE_GetType(hNode);
+		if (nodeType != NODE_TASK && nodeType !=
+			   NODE_DAISSOCKET)
+				status = DSP_ENODETYPE;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Check node state */
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+		if (DSP_SUCCEEDED(status)) {
+			state = NODE_GetState(hNode);
+			if (state != NODE_RUNNING) {
+				status = DSP_EWRONGSTATE;
+				/* Set the exit status if node terminated on
+				 * its own. */
+				if (state == NODE_DONE)
+					*pStatus = hNode->nExitStatus;
+
+			} else {
+				NODE_SetState(hNode, NODE_TERMINATING);
+			}
+		}
+		/* end of SYNC_EnterCS */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/*
+		 *  Send exit message. Do not change state to NODE_DONE
+		 *  here. That will be done in callback.
+		 */
+		status = PROC_GetState(pNode->hProcessor, &procStatus,
+					sizeof(struct DSP_PROCESSORSTATE));
+		if (DSP_FAILED(status))
+			goto func_cont;
+		/* If processor is in error state then don't attempt to send
+		 * A kill task command */
+		if (procStatus.iState == PROC_ERROR) {
+			status = DSP_EFAIL;
+			goto func_cont;
+		}
+
+		msg.dwCmd = RMS_EXIT;
+		msg.dwArg1 = hNode->nodeEnv;
+		killmsg.dwCmd = RMS_KILLTASK;
+		killmsg.dwArg1 = hNode->nodeEnv;
+		pIntfFxns = hNodeMgr->pIntfFxns;
+
+		if (hNode->uTimeout > MAXTIMEOUT)
+			killTimeOut = MAXTIMEOUT;
+		else
+			killTimeOut = (hNode->uTimeout)*2;
+
+		status = (*pIntfFxns->pfnMsgPut)(hNode->hMsgQueue, &msg,
+							hNode->uTimeout);
+		if (DSP_SUCCEEDED(status)) {
+			/*  Wait on synchronization object that will be
+			 *  posted in the callback on receiving RMS_EXIT
+			 *  message, or by NODE_Delete. Check for valid hNode,
+			 *  in case posted by NODE_Delete().  */
+			status = SYNC_WaitOnEvent(hNode->hSyncDone,
+							killTimeOut/2);
+			if (DSP_FAILED(status)) {
+				if (status == DSP_ETIMEOUT) {
+					status = (*pIntfFxns->pfnMsgPut)
+						 (hNode->hMsgQueue, &killmsg,
+						 hNode->uTimeout);
+					if (DSP_SUCCEEDED(status)) {
+						status = SYNC_WaitOnEvent
+							(hNode->hSyncDone,
+							killTimeOut/2);
+						if (DSP_FAILED(status)) {
+							/* Here it goes the part
+							* of the simulation of
+							* the DSP exception */
+						    DEV_GetDehMgr(hNodeMgr->
+							hDevObject, &hDehMgr);
+						    if (hDehMgr) {
+							(*pIntfFxns->
+							pfnDehNotify)(hDehMgr,
+							DSP_SYSERROR,
+							DSP_EXCEPTIONABORT);
+							    status = DSP_EFAIL;
+						    }
+						} else
+						    status = DSP_SOK;
+					}
+				} else
+					status = DSP_EFAIL;
+			} else 	/* Convert SYNC status to DSP status */
+				status = DSP_SOK;
+		}
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status)) {
+		/* Enter CS before getting exit status, in case node was
+		 * deleted. */
+		status = SYNC_EnterCS(hNodeMgr->hSync);
+		/* Make sure node wasn't deleted while we blocked */
+		if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE)) {
+			status = DSP_EFAIL;
+		} else {
+			*pStatus = hNode->nExitStatus;
+			dev_dbg(bridge, "%s: hNode: %p env 0x%x status 0x%x\n",
+				__func__, hNode, hNode->nodeEnv, status);
+		}
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	}		/*End of SYNC_EnterCS */
+func_end:
+	return status;
+}
+
+/*
+ *  ======== DeleteNode ========
+ *  Purpose:
+ *      Free GPP resources allocated in NODE_Allocate() or NODE_Connect().
+ */
+static void DeleteNode(struct NODE_OBJECT *hNode,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct NODE_MGR *hNodeMgr;
+	struct CMM_XLATOROBJECT *hXlator;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	u32 i;
+	enum NODE_TYPE nodeType;
+	struct STREAM stream;
+	struct NODE_MSGARGS msgArgs;
+	struct NODE_TASKARGS taskArgs;
+#ifdef DSP_DMM_DEBUG
+	struct DMM_OBJECT *hDmmMgr;
+	struct PROC_OBJECT *pProcObject =
+			(struct PROC_OBJECT *)hNode->hProcessor;
+#endif
+	DSP_STATUS status;
+	if (!MEM_IsValidHandle(hNode, NODE_SIGNATURE))
+		goto func_end;
+	hNodeMgr = hNode->hNodeMgr;
+	if (!MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE))
+		goto func_end;
+	hXlator = hNode->hXlator;
+	nodeType = NODE_GetType(hNode);
+	if (nodeType != NODE_DEVICE) {
+		msgArgs = hNode->createArgs.asa.msgArgs;
+		kfree(msgArgs.pData);
+
+		/* Free MSG queue */
+		if (hNode->hMsgQueue) {
+			pIntfFxns = hNodeMgr->pIntfFxns;
+			(*pIntfFxns->pfnMsgDeleteQueue) (hNode->hMsgQueue);
+			hNode->hMsgQueue = NULL;
+		}
+		if (hNode->hSyncDone)
+			(void) SYNC_CloseEvent(hNode->hSyncDone);
+
+		/* Free all stream info */
+		if (hNode->inputs) {
+			for (i = 0; i < MaxInputs(hNode); i++) {
+				stream = hNode->inputs[i];
+				FreeStream(hNodeMgr, stream);
+			}
+			kfree(hNode->inputs);
+			hNode->inputs = NULL;
+		}
+		if (hNode->outputs) {
+			for (i = 0; i < MaxOutputs(hNode); i++) {
+				stream = hNode->outputs[i];
+				FreeStream(hNodeMgr, stream);
+			}
+			kfree(hNode->outputs);
+			hNode->outputs = NULL;
+		}
+		taskArgs = hNode->createArgs.asa.taskArgs;
+		if (taskArgs.strmInDef) {
+			for (i = 0; i < MaxInputs(hNode); i++) {
+				kfree(taskArgs.strmInDef[i].szDevice);
+				taskArgs.strmInDef[i].szDevice = NULL;
+			}
+			kfree(taskArgs.strmInDef);
+			taskArgs.strmInDef = NULL;
+		}
+		if (taskArgs.strmOutDef) {
+			for (i = 0; i < MaxOutputs(hNode); i++) {
+				kfree(taskArgs.strmOutDef[i].szDevice);
+				taskArgs.strmOutDef[i].szDevice = NULL;
+			}
+			kfree(taskArgs.strmOutDef);
+			taskArgs.strmOutDef = NULL;
+		}
+		if (taskArgs.uDSPHeapResAddr) {
+			status = PROC_UnMap(hNode->hProcessor,
+					   (void *)taskArgs.uDSPHeapAddr,
+					   pr_ctxt);
+
+			status = PROC_UnReserveMemory(hNode->hProcessor,
+					(void *)taskArgs.uDSPHeapResAddr,
+					pr_ctxt);
+#ifdef DSP_DMM_DEBUG
+			status = DMM_GetHandle(pProcObject, &hDmmMgr);
+			if (DSP_SUCCEEDED(status))
+				DMM_MemMapDump(hDmmMgr);
+#endif
+		}
+	}
+	if (nodeType != NODE_MESSAGE) {
+		kfree(hNode->streamConnect);
+		hNode->streamConnect = NULL;
+	}
+	kfree(hNode->pstrDevName);
+	hNode->pstrDevName = NULL;
+
+	if (hNode->hNtfy) {
+		NTFY_Delete(hNode->hNtfy);
+		hNode->hNtfy = NULL;
+	}
+
+	/* These were allocated in DCD_GetObjectDef (via NODE_Allocate) */
+	kfree(hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn);
+	hNode->dcdProps.objData.nodeObj.pstrCreatePhaseFxn = NULL;
+
+	kfree(hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn);
+	hNode->dcdProps.objData.nodeObj.pstrExecutePhaseFxn = NULL;
+
+	kfree(hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn);
+	hNode->dcdProps.objData.nodeObj.pstrDeletePhaseFxn = NULL;
+
+	kfree(hNode->dcdProps.objData.nodeObj.pstrIAlgName);
+	hNode->dcdProps.objData.nodeObj.pstrIAlgName = NULL;
+
+	/* Free all SM address translator resources */
+	if (hXlator) {
+		(void) CMM_XlatorDelete(hXlator, TRUE);	/* force free */
+		hXlator = NULL;
+	}
+
+	kfree(hNode->hNldrNode);
+	hNode->hNldrNode = NULL;
+	hNode->hNodeMgr = NULL;
+	MEM_FreeObject(hNode);
+	hNode = NULL;
+func_end:
+	return;
+}
+
+/*
+ *  ======== DeleteNodeMgr ========
+ *  Purpose:
+ *      Frees the node manager.
+ */
+static void DeleteNodeMgr(struct NODE_MGR *hNodeMgr)
+{
+	struct NODE_OBJECT *hNode;
+
+	if (MEM_IsValidHandle(hNodeMgr, NODEMGR_SIGNATURE)) {
+		/* Free resources */
+		if (hNodeMgr->hDcdMgr)
+			DCD_DestroyManager(hNodeMgr->hDcdMgr);
+
+		/* Remove any elements remaining in lists */
+		if (hNodeMgr->nodeList) {
+			while ((hNode =
+				(struct NODE_OBJECT *)LST_GetHead(hNodeMgr->
+				nodeList)))
+					DeleteNode(hNode, NULL);
+
+			DBC_Assert(LST_IsEmpty(hNodeMgr->nodeList));
+			kfree(hNodeMgr->nodeList);
+		}
+		if (hNodeMgr->hNtfy)
+			NTFY_Delete(hNodeMgr->hNtfy);
+
+		if (hNodeMgr->pipeMap)
+			GB_delete(hNodeMgr->pipeMap);
+
+		if (hNodeMgr->pipeDoneMap)
+			GB_delete(hNodeMgr->pipeDoneMap);
+
+		if (hNodeMgr->chnlMap)
+			GB_delete(hNodeMgr->chnlMap);
+
+		if (hNodeMgr->dmaChnlMap)
+			GB_delete(hNodeMgr->dmaChnlMap);
+
+		if (hNodeMgr->zChnlMap)
+			GB_delete(hNodeMgr->zChnlMap);
+
+		if (hNodeMgr->hDisp)
+			DISP_Delete(hNodeMgr->hDisp);
+
+		if (hNodeMgr->hSync)
+			SYNC_DeleteCS(hNodeMgr->hSync);
+
+		if (hNodeMgr->hStrmMgr)
+			STRM_Delete(hNodeMgr->hStrmMgr);
+
+		/* Delete the loader */
+		if (hNodeMgr->hNldr)
+			hNodeMgr->nldrFxns.pfnDelete(hNodeMgr->hNldr);
+
+		if (hNodeMgr->fLoaderInit)
+			hNodeMgr->nldrFxns.pfnExit();
+
+		MEM_FreeObject(hNodeMgr);
+	}
+}
+
+/*
+ *  ======== FillStreamConnect ========
+ *  Purpose:
+ *      Fills stream information.
+ */
+static void FillStreamConnect(struct NODE_OBJECT *hNode1,
+				struct NODE_OBJECT *hNode2,
+				u32 uStream1, u32 uStream2)
+{
+	u32 uStrmIndex;
+	struct DSP_STREAMCONNECT *pStrm1 = NULL;
+	struct DSP_STREAMCONNECT *pStrm2 = NULL;
+	enum NODE_TYPE node1Type = NODE_TASK;
+	enum NODE_TYPE node2Type = NODE_TASK;
+
+	node1Type = NODE_GetType(hNode1);
+	node2Type = NODE_GetType(hNode2);
+	if (hNode1 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
+
+		if (node1Type != NODE_DEVICE) {
+			uStrmIndex = hNode1->uNumInputs +
+					hNode1->uNumOutputs - 1;
+			pStrm1 = &(hNode1->streamConnect[uStrmIndex]);
+			pStrm1->cbStruct = sizeof(struct DSP_STREAMCONNECT);
+			pStrm1->uThisNodeStreamIndex = uStream1;
+		}
+
+		if (hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE) {
+				/* NODE == > NODE */
+			if (node1Type != NODE_DEVICE) {
+				pStrm1->hConnectedNode = hNode2;
+				pStrm1->uiConnectedNodeID = hNode2->nodeId;
+				pStrm1->uConnectedNodeStreamIndex = uStream2;
+				pStrm1->lType = CONNECTTYPE_NODEOUTPUT;
+			}
+			if (node2Type != NODE_DEVICE) {
+				uStrmIndex = hNode2->uNumInputs +
+						hNode2->uNumOutputs - 1;
+				pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
+				pStrm2->cbStruct =
+					sizeof(struct DSP_STREAMCONNECT);
+				pStrm2->uThisNodeStreamIndex = uStream2;
+				pStrm2->hConnectedNode = hNode1;
+				pStrm2->uiConnectedNodeID = hNode1->nodeId;
+				pStrm2->uConnectedNodeStreamIndex = uStream1;
+				pStrm2->lType = CONNECTTYPE_NODEINPUT;
+			}
+		} else if (node1Type != NODE_DEVICE)
+				pStrm1->lType = CONNECTTYPE_GPPOUTPUT;
+	} else {
+		/* GPP == > NODE */
+		DBC_Assert(hNode2 != (struct NODE_OBJECT *)DSP_HGPPNODE);
+		uStrmIndex = hNode2->uNumInputs + hNode2->uNumOutputs - 1;
+		pStrm2 = &(hNode2->streamConnect[uStrmIndex]);
+		pStrm2->cbStruct = sizeof(struct DSP_STREAMCONNECT);
+		pStrm2->uThisNodeStreamIndex = uStream2;
+		pStrm2->lType = CONNECTTYPE_GPPINPUT;
+	}
+}
+
+/*
+ *  ======== FillStreamDef ========
+ *  Purpose:
+ *      Fills Stream attributes.
+ */
+static void FillStreamDef(struct NODE_OBJECT *hNode,
+			  struct NODE_STRMDEF *pstrmDef,
+			  struct DSP_STRMATTR *pAttrs)
+{
+	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
+
+	if (pAttrs != NULL) {
+		pstrmDef->uNumBufs = pAttrs->uNumBufs;
+		pstrmDef->uBufsize = pAttrs->uBufsize / hNodeMgr->
+							uDSPDataMauSize;
+		pstrmDef->uSegid = pAttrs->uSegid;
+		pstrmDef->uAlignment = pAttrs->uAlignment;
+		pstrmDef->uTimeout = pAttrs->uTimeout;
+	} else {
+		pstrmDef->uNumBufs = DEFAULTNBUFS;
+		pstrmDef->uBufsize = DEFAULTBUFSIZE / hNodeMgr->
+							uDSPDataMauSize;
+		pstrmDef->uSegid = DEFAULTSEGID;
+		pstrmDef->uAlignment = DEFAULTALIGNMENT;
+		pstrmDef->uTimeout = DEFAULTTIMEOUT;
+	}
+}
+
+/*
+ *  ======== FreeStream ========
+ *  Purpose:
+ *      Updates the channel mask and frees the pipe id.
+ */
+static void FreeStream(struct NODE_MGR *hNodeMgr, struct STREAM stream)
+{
+	/* Free up the pipe id unless other node has not yet been deleted. */
+	if (stream.type == NODECONNECT) {
+		if (GB_test(hNodeMgr->pipeDoneMap, stream.devId)) {
+			/* The other node has already been deleted */
+			GB_clear(hNodeMgr->pipeDoneMap, stream.devId);
+			GB_clear(hNodeMgr->pipeMap, stream.devId);
+		} else {
+			/* The other node has not been deleted yet */
+			GB_set(hNodeMgr->pipeDoneMap, stream.devId);
+		}
+	} else if (stream.type == HOSTCONNECT) {
+		if (stream.devId < hNodeMgr->ulNumChnls) {
+			GB_clear(hNodeMgr->chnlMap, stream.devId);
+		} else if (stream.devId < (2 * hNodeMgr->ulNumChnls)) {
+			/* dsp-dma */
+			GB_clear(hNodeMgr->dmaChnlMap, stream.devId -
+				(1 * hNodeMgr->ulNumChnls));
+		} else if (stream.devId < (3 * hNodeMgr->ulNumChnls)) {
+			/* zero-copy */
+			GB_clear(hNodeMgr->zChnlMap, stream.devId -
+				(2 * hNodeMgr->ulNumChnls));
+		}
+	}
+}
+
+/*
+ *  ======== GetFxnAddress ========
+ *  Purpose:
+ *      Retrieves the address for create, execute or delete phase for a node.
+ */
+static DSP_STATUS GetFxnAddress(struct NODE_OBJECT *hNode, u32 *pulFxnAddr,
+				u32 uPhase)
+{
+	char *pstrFxnName = NULL;
+	struct NODE_MGR *hNodeMgr = hNode->hNodeMgr;
+	DSP_STATUS status = DSP_SOK;
+	DBC_Require(NODE_GetType(hNode) == NODE_TASK ||
+			NODE_GetType(hNode) == NODE_DAISSOCKET ||
+			NODE_GetType(hNode) == NODE_MESSAGE);
+
+	switch (uPhase) {
+	case CREATEPHASE:
+		pstrFxnName = hNode->dcdProps.objData.nodeObj.
+				pstrCreatePhaseFxn;
+		break;
+	case EXECUTEPHASE:
+		pstrFxnName = hNode->dcdProps.objData.nodeObj.
+				pstrExecutePhaseFxn;
+		break;
+	case DELETEPHASE:
+		pstrFxnName = hNode->dcdProps.objData.nodeObj.
+				pstrDeletePhaseFxn;
+		break;
+	default:
+		/* Should never get here */
+		DBC_Assert(false);
+		break;
+	}
+
+	status = hNodeMgr->nldrFxns.pfnGetFxnAddr(hNode->hNldrNode, pstrFxnName,
+						pulFxnAddr);
+
+	return status;
+}
+
+/*
+ *  ======== GetNodeInfo ========
+ *  Purpose:
+ *      Retrieves the node information.
+ */
+void GetNodeInfo(struct NODE_OBJECT *hNode, struct DSP_NODEINFO *pNodeInfo)
+{
+	u32 i;
+
+	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	DBC_Require(pNodeInfo != NULL);
+
+	pNodeInfo->cbStruct = sizeof(struct DSP_NODEINFO);
+	pNodeInfo->nbNodeDatabaseProps = hNode->dcdProps.objData.nodeObj.
+					 ndbProps;
+	pNodeInfo->uExecutionPriority = hNode->nPriority;
+	pNodeInfo->hDeviceOwner = hNode->hDeviceOwner;
+	pNodeInfo->uNumberStreams = hNode->uNumInputs + hNode->uNumOutputs;
+	pNodeInfo->uNodeEnv = hNode->nodeEnv;
+
+	pNodeInfo->nsExecutionState = NODE_GetState(hNode);
+
+	/* Copy stream connect data */
+	for (i = 0; i < hNode->uNumInputs + hNode->uNumOutputs; i++)
+		pNodeInfo->scStreamConnection[i] = hNode->streamConnect[i];
+
+}
+
+/*
+ *  ======== GetNodeProps ========
+ *  Purpose:
+ *      Retrieve node properties.
+ */
+static DSP_STATUS GetNodeProps(struct DCD_MANAGER *hDcdMgr,
+				struct NODE_OBJECT *hNode,
+				CONST struct DSP_UUID *pNodeId,
+				struct DCD_GENERICOBJ *pdcdProps)
+{
+	u32 uLen;
+	struct NODE_MSGARGS *pMsgArgs;
+	struct NODE_TASKARGS *pTaskArgs;
+	enum NODE_TYPE nodeType = NODE_TASK;
+	struct DSP_NDBPROPS *pndbProps = &(pdcdProps->objData.nodeObj.ndbProps);
+	DSP_STATUS status = DSP_SOK;
+	char szUuid[MAXUUIDLEN];
+
+	status = DCD_GetObjectDef(hDcdMgr, (struct DSP_UUID *)pNodeId,
+				 DSP_DCDNODETYPE, pdcdProps);
+
+	if (DSP_SUCCEEDED(status)) {
+		hNode->nType = nodeType = pndbProps->uNodeType;
+
+		/* Create UUID value to set in registry. */
+		UUID_UuidToString((struct DSP_UUID *)pNodeId, szUuid,
+				 MAXUUIDLEN);
+		dev_dbg(bridge, "(node) UUID: %s\n", szUuid);
+
+		/* Fill in message args that come from NDB */
+		if (nodeType != NODE_DEVICE) {
+			pMsgArgs = &(hNode->createArgs.asa.msgArgs);
+			pMsgArgs->uSegid = pdcdProps->objData.nodeObj.uMsgSegid;
+			pMsgArgs->uNotifyType = pdcdProps->objData.nodeObj.
+						uMsgNotifyType;
+			pMsgArgs->uMaxMessages = pndbProps->uMessageDepth;
+			dev_dbg(bridge, "(node) Max Number of Messages: 0x%x\n",
+				 pMsgArgs->uMaxMessages);
+		} else {
+			/* Copy device name */
+			DBC_Require(pndbProps->acName);
+			uLen = strlen(pndbProps->acName);
+			DBC_Assert(uLen < MAXDEVNAMELEN);
+			hNode->pstrDevName = MEM_Calloc(uLen + 1, MEM_PAGED);
+			if (hNode->pstrDevName == NULL) {
+				status = DSP_EMEMORY;
+			} else {
+				strncpy(hNode->pstrDevName,
+					pndbProps->acName, uLen);
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Fill in create args that come from NDB */
+		if (nodeType == NODE_TASK || nodeType == NODE_DAISSOCKET) {
+			pTaskArgs = &(hNode->createArgs.asa.taskArgs);
+			pTaskArgs->nPriority = pndbProps->iPriority;
+			pTaskArgs->uStackSize = pndbProps->uStackSize;
+			pTaskArgs->uSysStackSize = pndbProps->uSysStackSize;
+			pTaskArgs->uStackSeg = pndbProps->uStackSeg;
+			dev_dbg(bridge, "(node) Priority: 0x%x Stack Size: "
+				"0x%x words System Stack Size: 0x%x words "
+				"Stack Segment: 0x%x profile count : 0x%x\n",
+				pTaskArgs->nPriority, pTaskArgs->uStackSize,
+				pTaskArgs->uSysStackSize,
+				pTaskArgs->uStackSeg,
+				pndbProps->uCountProfiles);
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== GetProcProps ========
+ *  Purpose:
+ *      Retrieve the processor properties.
+ */
+static DSP_STATUS GetProcProps(struct NODE_MGR *hNodeMgr,
+				struct DEV_OBJECT *hDevObject)
+{
+	struct CFG_DEVNODE *hDevNode;
+	struct CFG_HOSTRES hostRes;
+	DSP_STATUS status = DSP_SOK;
+
+	status = DEV_GetDevNode(hDevObject, &hDevNode);
+	if (DSP_SUCCEEDED(status))
+		status = CFG_GetHostResources(hDevNode, &hostRes);
+
+	if (DSP_SUCCEEDED(status)) {
+		hNodeMgr->ulChnlOffset = hostRes.dwChnlOffset;
+		hNodeMgr->ulChnlBufSize = hostRes.dwChnlBufSize;
+		hNodeMgr->ulNumChnls = hostRes.dwNumChnls;
+
+		/*
+		 *  PROC will add an API to get DSP_PROCESSORINFO.
+		 *  Fill in default values for now.
+		 */
+		/* TODO -- Instead of hard coding, take from registry */
+		hNodeMgr->procFamily = 6000;
+		hNodeMgr->procType = 6410;
+		hNodeMgr->nMinPri = DSP_NODE_MIN_PRIORITY;
+		hNodeMgr->nMaxPri = DSP_NODE_MAX_PRIORITY;
+		hNodeMgr->uDSPWordSize = DSPWORDSIZE;
+		hNodeMgr->uDSPDataMauSize = DSPWORDSIZE;
+		hNodeMgr->uDSPMauSize = 1;
+
+	}
+	return status;
+}
+
+
+
+/*
+ *  ======== NODE_GetUUIDProps ========
+ *  Purpose:
+ *      Fetch Node UUID properties from DCD/DOF file.
+ */
+DSP_STATUS NODE_GetUUIDProps(void *hProcessor,
+			    IN CONST struct DSP_UUID *pNodeId,
+			    OUT struct DSP_NDBPROPS *pNodeProps)
+{
+	struct NODE_MGR *hNodeMgr = NULL;
+	struct DEV_OBJECT *hDevObject;
+	DSP_STATUS status = DSP_SOK;
+	struct DCD_NODEPROPS dcdNodeProps;
+	struct DSP_PROCESSORSTATE procStatus;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hProcessor != NULL);
+	DBC_Require(pNodeId != NULL);
+
+	if (hProcessor == NULL || pNodeId == NULL) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	status = PROC_GetState(hProcessor, &procStatus,
+			sizeof(struct DSP_PROCESSORSTATE));
+	if (DSP_FAILED(status))
+		goto func_end;
+	/* If processor is in error state then don't attempt
+	    to send the message */
+	if (procStatus.iState == PROC_ERROR) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+
+	status = PROC_GetDevObject(hProcessor, &hDevObject);
+	if (hDevObject) {
+		status = DEV_GetNodeManager(hDevObject, &hNodeMgr);
+		if (hNodeMgr == NULL) {
+			status = DSP_EHANDLE;
+			goto func_end;
+		}
+	}
+
+	/*
+	 * Enter the critical section. This is needed because
+	 * DCD_GetObjectDef will ultimately end up calling DBLL_open/close,
+	 * which needs to be protected in order to not corrupt the zlib manager
+	 * (COD).
+	 */
+	status = SYNC_EnterCS(hNodeMgr->hSync);
+
+	if (DSP_SUCCEEDED(status)) {
+		dcdNodeProps.pstrCreatePhaseFxn = NULL;
+		dcdNodeProps.pstrExecutePhaseFxn = NULL;
+		dcdNodeProps.pstrDeletePhaseFxn = NULL;
+		dcdNodeProps.pstrIAlgName = NULL;
+
+		status = DCD_GetObjectDef(hNodeMgr->hDcdMgr,
+				(struct DSP_UUID *) pNodeId,
+				DSP_DCDNODETYPE,
+				(struct DCD_GENERICOBJ *) &dcdNodeProps);
+		if (DSP_SUCCEEDED(status)) {
+			*pNodeProps = dcdNodeProps.ndbProps;
+			kfree(dcdNodeProps.pstrCreatePhaseFxn);
+
+			kfree(dcdNodeProps.pstrExecutePhaseFxn);
+
+			kfree(dcdNodeProps.pstrDeletePhaseFxn);
+
+			kfree(dcdNodeProps.pstrIAlgName);
+		}
+		/*  Leave the critical section, we're done.  */
+		(void)SYNC_LeaveCS(hNodeMgr->hSync);
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== GetRMSFxns ========
+ *  Purpose:
+ *      Retrieve the RMS functions.
+ */
+static DSP_STATUS GetRMSFxns(struct NODE_MGR *hNodeMgr)
+{
+	s32 i;
+	struct DEV_OBJECT *hDev = hNodeMgr->hDevObject;
+	DSP_STATUS status = DSP_SOK;
+
+	static char *pszFxns[NUMRMSFXNS] = {
+		"RMS_queryServer", 	/* RMSQUERYSERVER */
+		"RMS_configureServer", 	/* RMSCONFIGURESERVER */
+		"RMS_createNode", 	/* RMSCREATENODE */
+		"RMS_executeNode", 	/* RMSEXECUTENODE */
+		"RMS_deleteNode", 	/* RMSDELETENODE */
+		"RMS_changeNodePriority", 	/* RMSCHANGENODEPRIORITY */
+		"RMS_readMemory", 	/* RMSREADMEMORY */
+		"RMS_writeMemory", 	/* RMSWRITEMEMORY */
+		"RMS_copy", 	/* RMSCOPY */
+	};
+
+	for (i = 0; i < NUMRMSFXNS; i++) {
+		status = DEV_GetSymbol(hDev, pszFxns[i],
+			 &(hNodeMgr->ulFxnAddrs[i]));
+		if (DSP_FAILED(status)) {
+			if (status == COD_E_SYMBOLNOTFOUND) {
+				/*
+				 *  May be loaded dynamically (in the future),
+				 *  but return an error for now.
+				 */
+				dev_dbg(bridge, "%s: RMS function: %s currently"
+					 " not loaded\n", __func__, pszFxns[i]);
+			} else {
+				dev_dbg(bridge, "%s: Symbol not found: %s "
+						"status = 0x%x\n", __func__,
+						pszFxns[i], status);
+				break;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== Ovly ========
+ *  Purpose:
+ *      Called during overlay.Sends command to RMS to copy a block of data.
+ */
+static u32 Ovly(void *pPrivRef, u32 ulDspRunAddr, u32 ulDspLoadAddr,
+			u32 ulNumBytes, u32 nMemSpace)
+{
+	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *)pPrivRef;
+	struct NODE_MGR *hNodeMgr;
+	u32 ulBytes = 0;
+	u32 ulSize;
+	u32 ulTimeout;
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *hWmdContext;
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+
+	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+
+	hNodeMgr = hNode->hNodeMgr;
+
+	ulSize = ulNumBytes / hNodeMgr->uDSPWordSize;
+	ulTimeout = hNode->uTimeout;
+
+	/* Call new MemCopy function */
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
+	if (DSP_SUCCEEDED(status)) {
+		status = (*pIntfFxns->pfnBrdMemCopy)(hWmdContext, ulDspRunAddr,
+			 ulDspLoadAddr,	ulNumBytes, (u32) nMemSpace);
+		if (DSP_SUCCEEDED(status))
+			ulBytes = ulNumBytes;
+		else
+			pr_debug("%s: failed to copy brd memory, status 0x%x\n",
+							__func__, status);
+	} else {
+		pr_debug("%s: failed to get WMD context, status 0x%x\n",
+							__func__, status);
+	}
+
+	return ulBytes;
+}
+
+/*
+ *  ======== Write ========
+ */
+static u32 Write(void *pPrivRef, u32 ulDspAddr, void *pBuf,
+			u32 ulNumBytes, u32 nMemSpace)
+{
+	struct NODE_OBJECT *hNode = (struct NODE_OBJECT *) pPrivRef;
+	struct NODE_MGR *hNodeMgr;
+	u16 memType;
+	u32 ulTimeout;
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *hWmdContext;
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+
+	DBC_Require(MEM_IsValidHandle(hNode, NODE_SIGNATURE));
+	DBC_Require(nMemSpace & DBLL_CODE || nMemSpace & DBLL_DATA);
+
+	hNodeMgr = hNode->hNodeMgr;
+
+	ulTimeout = hNode->uTimeout;
+	memType = (nMemSpace & DBLL_CODE) ? RMS_CODE : RMS_DATA;
+
+	/* Call new MemWrite function */
+	pIntfFxns = hNodeMgr->pIntfFxns;
+	status = DEV_GetWMDContext(hNodeMgr->hDevObject, &hWmdContext);
+	status = (*pIntfFxns->pfnBrdMemWrite) (hWmdContext, pBuf, ulDspAddr,
+		 ulNumBytes, memType);
+
+	return ulNumBytes;
+}
+
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
new file mode 100644
index 0000000..10333c9
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -0,0 +1,1638 @@
+/*
+ * proc.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Processor interface at the driver level.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/* ------------------------------------ Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/sync.h>
+/*  ----------------------------------- Mini Driver */
+#include <dspbridge/wmd.h>
+#include <dspbridge/wmddeh.h>
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/cod.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/procpriv.h>
+#include <dspbridge/dmm.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/mgr.h>
+#include <dspbridge/node.h>
+#include <dspbridge/nldr.h>
+#include <dspbridge/rmm.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/dbdcd.h>
+#include <dspbridge/msg.h>
+#include <dspbridge/wmdioctl.h>
+#include <dspbridge/drv.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/proc.h>
+#include <dspbridge/pwr.h>
+
+#include <dspbridge/resourcecleanup.h>
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define PROC_SIGNATURE	   0x434F5250	/* "PROC" (in reverse). */
+#define MAXCMDLINELEN       255
+#define PROC_ENVPROCID      "PROC_ID=%d"
+#define MAXPROCIDLEN	(8 + 5)
+#define PROC_DFLT_TIMEOUT   10000	/* Time out in milliseconds  */
+#define PWR_TIMEOUT	 500	/* Sleep/wake timout in msec */
+#define EXTEND	      "_EXT_END"	/* Extmem end addr in DSP binary */
+
+extern char *iva_img;
+
+/*  ----------------------------------- Globals */
+
+/* The PROC_OBJECT structure.   */
+struct PROC_OBJECT {
+	struct list_head link;		/* Link to next PROC_OBJECT */
+	u32 dwSignature;		/* Used for object validation */
+	struct DEV_OBJECT *hDevObject;	/* Device this PROC represents */
+	u32 hProcess;			/* Process owning this Processor */
+	struct MGR_OBJECT *hMgrObject;	/* Manager Object Handle */
+	u32 uAttachCount;		/* Processor attach count */
+	u32 uProcessor;			/* Processor number */
+	u32 uTimeout;			/* Time out count */
+	enum DSP_PROCSTATE sState;	/* Processor state */
+	u32 ulUnit;			/* DDSP unit number */
+	bool bIsAlreadyAttached;	/*
+					 * True if the Device below has
+					 * GPP Client attached
+					 */
+	struct NTFY_OBJECT *hNtfy;	/* Manages  notifications */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD Context Handle */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	char *g_pszLastCoff;
+	struct list_head proc_object;
+};
+
+static u32 cRefs;
+
+struct SYNC_CSOBJECT *hProcLock;	/* For critical sections */
+
+/*  ----------------------------------- Function Prototypes */
+static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *hProcessor);
+static s32 GetEnvpCount(char **envp);
+static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
+			 char *szVar);
+
+/*
+ *  ======== PROC_Attach ========
+ *  Purpose:
+ *      Prepare for communication with a particular DSP processor, and return
+ *      a handle to the processor object.
+ */
+DSP_STATUS
+PROC_Attach(u32 uProcessor, OPTIONAL CONST struct DSP_PROCESSORATTRIN *pAttrIn,
+       void **phProcessor, struct PROCESS_CONTEXT *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEV_OBJECT *hDevObject;
+	struct PROC_OBJECT *pProcObject = NULL;
+	struct MGR_OBJECT *hMgrObject = NULL;
+	struct DRV_OBJECT *hDrvObject = NULL;
+	u32 devType;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phProcessor != NULL);
+
+	if (pr_ctxt->hProcessor) {
+		*phProcessor = pr_ctxt->hProcessor;
+		return status;
+	}
+
+	/* Get the Driver and Manager Object Handles */
+	status = CFG_GetObject((u32 *)&hDrvObject, REG_DRV_OBJECT);
+	if (DSP_SUCCEEDED(status))
+		status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Get the Device Object */
+		status = DRV_GetDevObject(uProcessor, hDrvObject, &hDevObject);
+	}
+	if (DSP_SUCCEEDED(status))
+		status = DEV_GetDevType(hDevObject, &devType);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* If we made it this far, create the Proceesor object: */
+	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
+	/* Fill out the Processor Object: */
+	if (pProcObject == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	pProcObject->hDevObject = hDevObject;
+	pProcObject->hMgrObject = hMgrObject;
+	pProcObject->uProcessor = devType;
+	/* Store TGID instead of process handle */
+	pProcObject->hProcess = current->tgid;
+
+	INIT_LIST_HEAD(&pProcObject->proc_object);
+
+	if (pAttrIn)
+		pProcObject->uTimeout = pAttrIn->uTimeout;
+	else
+		pProcObject->uTimeout = PROC_DFLT_TIMEOUT;
+
+	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetWMDContext(hDevObject,
+					 &pProcObject->hWmdContext);
+		if (DSP_FAILED(status))
+			MEM_FreeObject(pProcObject);
+	} else
+		MEM_FreeObject(pProcObject);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Create the Notification Object */
+	/* This is created with no event mask, no notify mask
+	 * and no valid handle to the notification. They all get
+	 * filled up when PROC_RegisterNotify is called */
+	status = NTFY_Create(&pProcObject->hNtfy);
+	if (DSP_SUCCEEDED(status)) {
+		/* Insert the Processor Object into the DEV List.
+		 * Return handle to this Processor Object:
+		 * Find out if the Device is already attached to a
+		 * Processor. If so, return AlreadyAttached status */
+		LST_InitElem(&pProcObject->link);
+		status = DEV_InsertProcObject(pProcObject->hDevObject,
+					     (u32)pProcObject,
+					     &pProcObject->bIsAlreadyAttached);
+		if (DSP_SUCCEEDED(status)) {
+			if (pProcObject->bIsAlreadyAttached)
+				status = DSP_SALREADYATTACHED;
+		} else {
+			if (pProcObject->hNtfy)
+				NTFY_Delete(pProcObject->hNtfy);
+
+			MEM_FreeObject(pProcObject);
+		}
+		if (DSP_SUCCEEDED(status)) {
+			*phProcessor = (void *)pProcObject;
+			pr_ctxt->hProcessor = *phProcessor;
+			(void)PROC_NotifyClients(pProcObject,
+						 DSP_PROCESSORATTACH);
+		}
+	} else {
+		/* Don't leak memory if DSP_FAILED */
+		MEM_FreeObject(pProcObject);
+	}
+func_end:
+	DBC_Ensure((status == DSP_EFAIL && *phProcessor == NULL) ||
+		  (DSP_SUCCEEDED(status) &&
+		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) ||
+		  (status == DSP_SALREADYATTACHED &&
+		  MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)));
+
+	return status;
+}
+
+static DSP_STATUS GetExecFile(struct CFG_DEVNODE *hDevNode,
+			     struct DEV_OBJECT *hDevObject,
+			     u32 size, char *execFile)
+{
+	s32 devType;
+	s32 len;
+
+	DEV_GetDevType(hDevObject, (u32 *) &devType);
+	if (devType == DSP_UNIT) {
+		return CFG_GetExecFile(hDevNode, size, execFile);
+	} else if (devType == IVA_UNIT) {
+		if (iva_img) {
+			len = strlen(iva_img);
+			strncpy(execFile, iva_img, len + 1);
+			return DSP_SOK;
+		}
+	}
+	return DSP_EFILE;
+}
+
+/*
+ *  ======== PROC_AutoStart ======== =
+ *  Purpose:
+ *      A Particular device gets loaded with the default image
+ *      if the AutoStart flag is set.
+ *  Parameters:
+ *      hDevObject:     Handle to the Device
+ *  Returns:
+ *      DSP_SOK:   On Successful Loading
+ *      DSP_EFAIL  General Failure
+ *  Requires:
+ *      hDevObject != NULL
+ *  Ensures:
+ */
+DSP_STATUS PROC_AutoStart(struct CFG_DEVNODE *hDevNode,
+			 struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	u32 dwAutoStart = 0;	/* autostart flag */
+	struct PROC_OBJECT *pProcObject;
+	char szExecFile[MAXCMDLINELEN];
+	char *argv[2];
+	struct MGR_OBJECT *hMgrObject = NULL;
+	s32 devType;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hDevNode != NULL);
+	DBC_Require(hDevObject != NULL);
+
+	/* Create a Dummy PROC Object */
+	status = CFG_GetObject((u32 *)&hMgrObject, REG_MGR_OBJECT);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	MEM_AllocObject(pProcObject, struct PROC_OBJECT, PROC_SIGNATURE);
+	if (pProcObject == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	pProcObject->hDevObject = hDevObject;
+	pProcObject->hMgrObject = hMgrObject;
+	status = DEV_GetIntfFxns(hDevObject, &pProcObject->pIntfFxns);
+	if (DSP_SUCCEEDED(status))
+		status = DEV_GetWMDContext(hDevObject,
+					&pProcObject->hWmdContext);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	/* Stop the Device, put it into standby mode */
+	status = PROC_Stop(pProcObject);
+
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = CFG_GetAutoStart(hDevNode, &dwAutoStart);
+	if (DSP_FAILED(status) || !dwAutoStart) {
+		status = DSP_EFAIL;
+		goto func_cont;
+	}
+	/* Get the default executable for this board... */
+	DEV_GetDevType(hDevObject, (u32 *)&devType);
+	pProcObject->uProcessor = devType;
+	status = GetExecFile(hDevNode, hDevObject, sizeof(szExecFile),
+							szExecFile);
+	if (DSP_SUCCEEDED(status)) {
+		argv[0] = szExecFile;
+		argv[1] = NULL;
+		/* ...and try to load it: */
+		status = PROC_Load(pProcObject, 1, (CONST char **)argv, NULL);
+		if (DSP_SUCCEEDED(status))
+			status = PROC_Start(pProcObject);
+	}
+	kfree(pProcObject->g_pszLastCoff);
+	pProcObject->g_pszLastCoff = NULL;
+func_cont:
+	MEM_FreeObject(pProcObject);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== PROC_Ctrl ========
+ *  Purpose:
+ *      Pass control information to the GPP device driver managing the
+ *      DSP processor.
+ *
+ *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
+ *      application developer's API.
+ *      Call the WMD_ICOTL Fxn with the Argument This is a Synchronous
+ *      Operation. arg can be null.
+ */
+DSP_STATUS PROC_Ctrl(void *hProcessor, u32 dwCmd,
+		    IN struct DSP_CBDATA *arg)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = hProcessor;
+	u32 timeout = 0;
+
+	DBC_Require(cRefs > 0);
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		/* intercept PWR deep sleep command */
+		if (dwCmd == WMDIOCTL_DEEPSLEEP) {
+			timeout = arg->cbData;
+			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		}
+		/* intercept PWR emergency sleep command */
+		else if (dwCmd == WMDIOCTL_EMERGENCYSLEEP) {
+			timeout = arg->cbData;
+			status = PWR_SleepDSP(PWR_EMERGENCYDEEPSLEEP, timeout);
+		} else if (dwCmd == PWR_DEEPSLEEP) {
+			/* timeout = arg->cbData; */
+			status = PWR_SleepDSP(PWR_DEEPSLEEP, timeout);
+		}
+		/* intercept PWR wake commands */
+		else if (dwCmd == WMDIOCTL_WAKEUP) {
+			timeout = arg->cbData;
+			status = PWR_WakeDSP(timeout);
+		} else if (dwCmd == PWR_WAKEUP) {
+			/* timeout = arg->cbData; */
+			status = PWR_WakeDSP(timeout);
+		} else
+		    if (DSP_SUCCEEDED
+			((*pProcObject->pIntfFxns->pfnDevCntrl)
+				(pProcObject->hWmdContext, dwCmd, arg))) {
+			status = DSP_SOK;
+		} else {
+			status = DSP_EFAIL;
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== PROC_Detach ========
+ *  Purpose:
+ *      Destroys the  Processor Object. Removes the notification from the Dev
+ *      List.
+ */
+DSP_STATUS PROC_Detach(struct PROCESS_CONTEXT *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = NULL;
+
+	DBC_Require(cRefs > 0);
+
+	pProcObject = (struct PROC_OBJECT *)pr_ctxt->hProcessor;
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		/* Notify the Client */
+		NTFY_Notify(pProcObject->hNtfy, DSP_PROCESSORDETACH);
+		/* Remove the notification memory */
+		if (pProcObject->hNtfy)
+			NTFY_Delete(pProcObject->hNtfy);
+
+		kfree(pProcObject->g_pszLastCoff);
+		pProcObject->g_pszLastCoff = NULL;
+		/* Remove the Proc from the DEV List */
+		(void)DEV_RemoveProcObject(pProcObject->hDevObject,
+			(u32)pProcObject);
+		/* Free the Processor Object */
+		MEM_FreeObject(pProcObject);
+		pr_ctxt->hProcessor = NULL;
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== PROC_EnumNodes ========
+ *  Purpose:
+ *      Enumerate and get configuration information about nodes allocated
+ *      on a DSP processor.
+ */
+DSP_STATUS PROC_EnumNodes(void *hProcessor, void **aNodeTab,
+		IN u32 uNodeTabSize, OUT u32 *puNumNodes,
+		OUT u32 *puAllocated)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct NODE_MGR *hNodeMgr = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(aNodeTab != NULL || uNodeTabSize == 0);
+	DBC_Require(puNumNodes != NULL);
+	DBC_Require(puAllocated != NULL);
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		if (DSP_SUCCEEDED(DEV_GetNodeManager(pProcObject->hDevObject,
+				 &hNodeMgr))) {
+			if (hNodeMgr) {
+				status = NODE_EnumNodes(hNodeMgr, aNodeTab,
+							uNodeTabSize,
+							puNumNodes,
+							puAllocated);
+			}
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/* Cache operation against kernel address instead of users */
+static int memory_sync_page(struct vm_area_struct *vma, unsigned long start,
+			    ssize_t len, enum DSP_FLUSHTYPE ftype)
+{
+	struct page *page;
+	void *kaddr;
+	unsigned long offset;
+	ssize_t rest;
+
+	while (len) {
+		page = follow_page(vma, start, FOLL_GET);
+		if (!page) {
+			pr_err("%s: no page for %08lx\n", __func__, start);
+			return -EINVAL;
+		} else if (IS_ERR(page)) {
+			pr_err("%s: err page for %08lx(%lu)\n", __func__, start,
+			       IS_ERR(page));
+			return IS_ERR(page);
+		}
+
+		offset = start & ~PAGE_MASK;
+		kaddr = kmap(page) + offset;
+		rest = min_t(ssize_t, PAGE_SIZE - offset, len);
+		MEM_FlushCache(kaddr, rest, ftype);
+
+		kunmap(page);
+		put_page(page);
+		len -= rest;
+		start += rest;
+	}
+
+	return 0;
+}
+
+/* Check if the given area blongs to process virtul memory address space */
+static int memory_sync_vma(unsigned long start, u32 len,
+			   enum DSP_FLUSHTYPE ftype)
+{
+	int err = 0;
+	unsigned long end;
+	struct vm_area_struct *vma;
+
+	end = start + len;
+	if (end <= start)
+		return -EINVAL;
+
+	while ((vma = find_vma(current->mm, start)) != NULL) {
+		ssize_t size;
+
+		if (vma->vm_flags & (VM_IO | VM_PFNMAP))
+			return -EINVAL;
+
+		if (vma->vm_start > start)
+			return -EINVAL;
+
+		size = min_t(ssize_t, vma->vm_end - start, len);
+		err = memory_sync_page(vma, start, size, ftype);
+		if (err)
+			break;
+
+		if (end <= vma->vm_end)
+			break;
+
+		start = vma->vm_end;
+	}
+
+	if (!vma)
+		err = -EINVAL;
+
+	return err;
+}
+
+static DSP_STATUS proc_memory_sync(void *hProcessor, void *pMpuAddr,
+				   u32 ulSize, u32 ulFlags,
+				   enum DSP_FLUSHTYPE FlushMemType)
+{
+	/* Keep STATUS here for future additions to this function */
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto err_out;
+	}
+
+	down_read(&current->mm->mmap_sem);
+
+	if (memory_sync_vma((u32)pMpuAddr, ulSize, FlushMemType)) {
+		pr_err("%s: InValid address parameters %p %x\n",
+		       __func__, pMpuAddr, ulSize);
+		status = DSP_EHANDLE;
+	}
+
+	up_read(&current->mm->mmap_sem);
+
+err_out:
+
+	return status;
+}
+
+/*
+ *  ======== PROC_FlushMemory ========
+ *  Purpose:
+ *     Flush cache
+ */
+DSP_STATUS PROC_FlushMemory(void *hProcessor, void *pMpuAddr,
+			    u32 ulSize, u32 ulFlags)
+{
+	enum DSP_FLUSHTYPE mtype = PROC_WRITEBACK_INVALIDATE_MEM;
+
+	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, ulFlags, mtype);
+}
+
+/*
+ *  ======== PROC_InvalidateMemory ========
+ *  Purpose:
+ *     Invalidates the memory specified
+ */
+DSP_STATUS PROC_InvalidateMemory(void *hProcessor, void *pMpuAddr,
+				 u32 ulSize)
+{
+	enum DSP_FLUSHTYPE mtype = PROC_INVALIDATE_MEM;
+
+	return proc_memory_sync(hProcessor, pMpuAddr, ulSize, 0, mtype);
+}
+
+/*
+ *  ======== PROC_GetResourceInfo ========
+ *  Purpose:
+ *      Enumerate the resources currently available on a processor.
+ */
+DSP_STATUS PROC_GetResourceInfo(void *hProcessor, u32 uResourceType,
+				OUT struct DSP_RESOURCEINFO *pResourceInfo,
+				u32 uResourceInfoSize)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct NODE_MGR *hNodeMgr = NULL;
+	struct NLDR_OBJECT *hNldr = NULL;
+	struct RMM_TargetObj *rmm = NULL;
+	struct IO_MGR *hIOMgr = NULL;		/* IO manager handle */
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pResourceInfo != NULL);
+	DBC_Require(uResourceInfoSize >= sizeof(struct DSP_RESOURCEINFO));
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	switch (uResourceType) {
+	case DSP_RESOURCE_DYNDARAM:
+	case DSP_RESOURCE_DYNSARAM:
+	case DSP_RESOURCE_DYNEXTERNAL:
+	case DSP_RESOURCE_DYNSRAM:
+		status = DEV_GetNodeManager(pProcObject->hDevObject,
+								&hNodeMgr);
+		if (DSP_FAILED(status))
+			goto func_end;
+
+		status = NODE_GetNldrObj(hNodeMgr, &hNldr);
+		if (DSP_SUCCEEDED(status)) {
+			status = NLDR_GetRmmManager(hNldr, &rmm);
+			if (DSP_SUCCEEDED(status)) {
+				DBC_Assert(rmm != NULL);
+				if (!RMM_stat(rmm,
+				   (enum DSP_MEMTYPE)uResourceType,
+				   (struct DSP_MEMSTAT *)&(pResourceInfo->
+				   result.memStat)))
+					status = DSP_EVALUE;
+			}
+		}
+		break;
+	case DSP_RESOURCE_PROCLOAD:
+		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
+		if (DSP_SUCCEEDED(status))
+			status = pProcObject->pIntfFxns->pfnIOGetProcLoad(
+				hIOMgr, (struct DSP_PROCLOADSTAT *)&
+				(pResourceInfo->result.procLoadStat));
+		break;
+	default:
+		status = DSP_EFAIL;
+		break;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== PROC_Exit ========
+ *  Purpose:
+ *      Decrement reference count, and free resources when reference count is
+ *      0.
+ */
+void PROC_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	if (hProcLock)
+		(void)SYNC_DeleteCS(hProcLock);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== PROC_GetDevObject ========
+ *  Purpose:
+ *      Return the Dev Object handle for a given Processor.
+ *
+ */
+DSP_STATUS PROC_GetDevObject(void *hProcessor,
+			     struct DEV_OBJECT **phDevObject)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phDevObject != NULL);
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		*phDevObject = pProcObject->hDevObject;
+		status = DSP_SOK;
+	} else {
+		*phDevObject = NULL;
+		status = DSP_EHANDLE;
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
+		   (DSP_FAILED(status) && *phDevObject == NULL));
+
+	return status;
+}
+
+/*
+ *  ======== PROC_GetState ========
+ *  Purpose:
+ *      Report the state of the specified DSP processor.
+ */
+DSP_STATUS PROC_GetState(void *hProcessor,
+			OUT struct DSP_PROCESSORSTATE *pProcStatus,
+			u32 uStateInfoSize)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	int brdStatus;
+	struct DEH_MGR *hDehMgr;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pProcStatus != NULL);
+	DBC_Require(uStateInfoSize >= sizeof(struct DSP_PROCESSORSTATE));
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		/* First, retrieve BRD state information */
+		status = (*pProcObject->pIntfFxns->pfnBrdStatus)
+				   (pProcObject->hWmdContext, &brdStatus);
+		if (DSP_SUCCEEDED(status)) {
+			switch (brdStatus) {
+			case BRD_STOPPED:
+				pProcStatus->iState = PROC_STOPPED;
+				break;
+			case BRD_SLEEP_TRANSITION:
+			case BRD_DSP_HIBERNATION:
+				/* Fall through */
+			case BRD_RUNNING:
+				pProcStatus->iState = PROC_RUNNING;
+				break;
+			case BRD_LOADED:
+				pProcStatus->iState = PROC_LOADED;
+				break;
+			case BRD_ERROR:
+				pProcStatus->iState = PROC_ERROR;
+				break;
+			default:
+				pProcStatus->iState = 0xFF;
+				status = DSP_EFAIL;
+				break;
+			}
+		}
+		/* Next, retrieve error information, if any */
+		status = DEV_GetDehMgr(pProcObject->hDevObject, &hDehMgr);
+		if (DSP_SUCCEEDED(status) && hDehMgr)
+			status = (*pProcObject->pIntfFxns->pfnDehGetInfo)
+				 (hDehMgr, &(pProcStatus->errInfo));
+	} else {
+		status = DSP_EHANDLE;
+	}
+	dev_dbg(bridge, "%s, results: status: 0x%x pProcStatus: 0x%x\n",
+					__func__, status, pProcStatus->iState);
+	return status;
+}
+
+/*
+ *  ======== PROC_GetTrace ========
+ *  Purpose:
+ *      Retrieve the current contents of the trace buffer, located on the
+ *      Processor.  Predefined symbols for the trace buffer must have been
+ *      configured into the DSP executable.
+ *  Details:
+ *      We support using the symbols SYS_PUTCBEG and SYS_PUTCEND to define a
+ *      trace buffer, only.  Treat it as an undocumented feature.
+ *      This call is destructive, meaning the processor is placed in the monitor
+ *      state as a result of this function.
+ */
+DSP_STATUS PROC_GetTrace(void *hProcessor, u8 *pBuf, u32 uMaxSize)
+{
+	DSP_STATUS status;
+	status = DSP_ENOTIMPL;
+	return status;
+}
+
+/*
+ *  ======== PROC_Init ========
+ *  Purpose:
+ *      Initialize PROC's private state, keeping a reference count on each call
+ */
+bool PROC_Init(void)
+{
+	bool fRetval = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (cRefs == 0)
+		(void)SYNC_InitializeCS(&hProcLock);
+
+	if (fRetval)
+		cRefs++;
+
+	DBC_Ensure((fRetval && (cRefs > 0)) || (!fRetval && (cRefs >= 0)));
+
+	return fRetval;
+}
+
+/*
+ *  ======== PROC_Load ========
+ *  Purpose:
+ *      Reset a processor and load a new base program image.
+ *      This will be an OEM-only function, and not part of the DSP/BIOS Bridge
+ *      application developer's API.
+ */
+DSP_STATUS PROC_Load(void *hProcessor, IN CONST s32 iArgc,
+		    IN CONST char **aArgv, IN CONST char **aEnvp)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct IO_MGR *hIOMgr;		/* IO manager handle */
+	struct MSG_MGR *hMsgMgr;
+	struct COD_MANAGER *hCodMgr;	/* Code manager handle */
+	char *pargv0;		/* temp argv[0] ptr */
+	char **newEnvp;		/* Updated envp[] array. */
+	char szProcID[MAXPROCIDLEN];	/* Size of "PROC_ID=<n>" */
+	s32 cEnvp;		/* Num elements in envp[]. */
+	s32 cNewEnvp;		/* "  " in newEnvp[]     */
+	s32 nProcID = 0;	/* Anticipate MP version. */
+	struct DCD_MANAGER *hDCDHandle;
+	struct DMM_OBJECT *hDmmMgr;
+	u32 dwExtEnd;
+	u32 uProcId;
+	int uBrdState;
+
+
+#ifdef OPT_LOAD_TIME_INSTRUMENTATION
+	struct timeval tv1;
+	struct timeval tv2;
+#endif
+
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+#endif
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(iArgc > 0);
+	DBC_Require(aArgv != NULL);
+
+#ifdef OPT_LOAD_TIME_INSTRUMENTATION
+	do_gettimeofday(&tv1);
+#endif
+	/* Call the WMD_BRD_Load Fxn */
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (DSP_FAILED(DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr))) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	status = PROC_Stop(hProcessor);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Place the board in the monitor state. */
+	status = PROC_Monitor(hProcessor);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Save ptr to  original argv[0]. */
+	pargv0 = (char *)aArgv[0];
+	/*Prepend "PROC_ID=<nProcID>"to envp array for target.*/
+	cEnvp = GetEnvpCount((char **)aEnvp);
+	cNewEnvp = (cEnvp ? (cEnvp + 1) : (cEnvp + 2));
+	newEnvp = MEM_Calloc(cNewEnvp * sizeof(char **), MEM_PAGED);
+	if (newEnvp) {
+		status = snprintf(szProcID, MAXPROCIDLEN, PROC_ENVPROCID,
+				    nProcID);
+		if (status == -1) {
+			dev_dbg(bridge, "%s: Proc ID string overflow\n",
+								__func__);
+			status = DSP_EFAIL;
+		} else {
+			newEnvp = PrependEnvp(newEnvp, (char **)aEnvp, cEnvp,
+					     cNewEnvp, szProcID);
+			/* Get the DCD Handle */
+			status = MGR_GetDCDHandle(pProcObject->hMgrObject,
+						 (u32 *)&hDCDHandle);
+			if (DSP_SUCCEEDED(status)) {
+				/*  Before proceeding with new load,
+				 *  check if a previously registered COFF
+				 *  exists.
+				 *  If yes, unregister nodes in previously
+				 *  registered COFF.  If any error occurred,
+				 *  set previously registered COFF to NULL.  */
+				if (pProcObject->g_pszLastCoff != NULL) {
+					status = DCD_AutoUnregister(hDCDHandle,
+						 pProcObject->g_pszLastCoff);
+					/* Regardless of auto unregister status,
+					 *  free previously allocated
+					 *  memory.  */
+					kfree(pProcObject->g_pszLastCoff);
+					pProcObject->g_pszLastCoff = NULL;
+				}
+			}
+			/* On success, do COD_OpenBase() */
+			status = COD_OpenBase(hCodMgr, (char *)aArgv[0],
+					     COD_SYMB);
+		}
+	} else {
+		status = DSP_EMEMORY;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Auto-register data base */
+		/* Get the DCD Handle */
+		status = MGR_GetDCDHandle(pProcObject->hMgrObject,
+					 (u32 *)&hDCDHandle);
+		if (DSP_SUCCEEDED(status)) {
+			/*  Auto register nodes in specified COFF
+			 *  file.  If registration did not fail,
+			 *  (status = DSP_SOK or DSP_EDCDNOAUTOREGISTER)
+			 *  save the name of the COFF file for
+			 *  de-registration in the future.  */
+			status = DCD_AutoRegister(hDCDHandle, (char *)aArgv[0]);
+			if (status == DSP_EDCDNOAUTOREGISTER)
+				status = DSP_SOK;
+
+			if (DSP_FAILED(status)) {
+				status = DSP_EFAIL;
+			} else {
+				DBC_Assert(pProcObject->g_pszLastCoff == NULL);
+				/* Allocate memory for pszLastCoff */
+				pProcObject->g_pszLastCoff = MEM_Calloc(
+					(strlen((char *)aArgv[0]) + 1),
+					MEM_PAGED);
+				/* If memory allocated, save COFF file name*/
+				if (pProcObject->g_pszLastCoff) {
+					strncpy(pProcObject->g_pszLastCoff,
+						(char *)aArgv[0],
+						(strlen((char *)aArgv[0]) + 1));
+				}
+			}
+		}
+	}
+	/* Update shared memory address and size */
+	if (DSP_SUCCEEDED(status)) {
+		/*  Create the message manager. This must be done
+		 *  before calling the IOOnLoaded function.  */
+		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
+		if (!hMsgMgr) {
+			status = MSG_Create(&hMsgMgr, pProcObject->hDevObject,
+					   (MSG_ONEXIT)NODE_OnExit);
+			DBC_Assert(DSP_SUCCEEDED(status));
+			DEV_SetMsgMgr(pProcObject->hDevObject, hMsgMgr);
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Set the Device object's message manager */
+		status = DEV_GetIOMgr(pProcObject->hDevObject, &hIOMgr);
+		DBC_Assert(DSP_SUCCEEDED(status));
+		status = (*pProcObject->pIntfFxns->pfnIOOnLoaded)(hIOMgr);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Now, attempt to load an exec: */
+
+	/* Boost the OPP level to Maximum level supported by baseport*/
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+	if (pdata->cpu_set_freq)
+		(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP5]);
+#endif
+		status = COD_LoadBase(hCodMgr, iArgc, (char **)aArgv,
+				     DEV_BrdWriteFxn,
+				     pProcObject->hDevObject, NULL);
+		if (DSP_FAILED(status)) {
+			if (status == COD_E_OPENFAILED) {
+				dev_dbg(bridge,	"%s: Failure to Load the EXE\n",
+								__func__);
+			}
+			if (status == COD_E_SYMBOLNOTFOUND) {
+				pr_err("%s: Couldn't parse the file\n",
+								__func__);
+			}
+		}
+	/* Requesting the lowest opp supported*/
+#if defined(CONFIG_BRIDGE_DVFS) && !defined(CONFIG_CPU_FREQ)
+	if (pdata->cpu_set_freq)
+		(*pdata->cpu_set_freq)(pdata->mpu_speed[VDD1_OPP1]);
+#endif
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Update the Processor status to loaded */
+		status = (*pProcObject->pIntfFxns->pfnBrdSetState)
+			 (pProcObject->hWmdContext, BRD_LOADED);
+		if (DSP_SUCCEEDED(status)) {
+			pProcObject->sState = PROC_LOADED;
+			if (pProcObject->hNtfy)
+				PROC_NotifyClients(pProcObject,
+						 DSP_PROCESSORSTATECHANGE);
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = PROC_GetProcessorId(hProcessor, &uProcId);
+		if (uProcId == DSP_UNIT) {
+			/* Use all available DSP address space after EXTMEM
+			 * for DMM */
+			if (DSP_SUCCEEDED(status))
+				status = COD_GetSymValue(hCodMgr, EXTEND,
+								&dwExtEnd);
+
+			/* Reset DMM structs and add an initial free chunk*/
+			if (DSP_SUCCEEDED(status)) {
+				status = DEV_GetDmmMgr(pProcObject->hDevObject,
+						      &hDmmMgr);
+				if (DSP_SUCCEEDED(status)) {
+					/* Set dwExtEnd to DMM START u8
+					  * address */
+					dwExtEnd = (dwExtEnd + 1) * DSPWORDSIZE;
+					 /* DMM memory is from EXT_END */
+					status = DMM_CreateTables(hDmmMgr,
+						dwExtEnd, DMMPOOLSIZE);
+				}
+			}
+		}
+	}
+	/* Restore the original argv[0] */
+	kfree(newEnvp);
+	aArgv[0] = pargv0;
+	if (DSP_SUCCEEDED(status)) {
+		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
+		   (pProcObject->hWmdContext, &uBrdState))) {
+			pr_info("%s: Processor Loaded %s\n", __func__, pargv0);
+			DBC_Assert(uBrdState == BRD_LOADED);
+		}
+	}
+
+func_end:
+	if (DSP_FAILED(status))
+		pr_err("%s: Processor failed to load\n", __func__);
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState == PROC_LOADED)
+		   || DSP_FAILED(status));
+#ifdef OPT_LOAD_TIME_INSTRUMENTATION
+	do_gettimeofday(&tv2);
+	if (tv2.tv_usec < tv1.tv_usec) {
+		tv2.tv_usec += 1000000;
+		tv2.tv_sec--;
+	}
+	dev_dbg(bridge, "%s: time to load %d sec and %d usec\n", __func__,
+		    tv2.tv_sec - tv1.tv_sec, tv2.tv_usec - tv1.tv_usec);
+#endif
+	return status;
+}
+
+/*
+ *  ======== PROC_Map ========
+ *  Purpose:
+ *      Maps a MPU buffer to DSP address space.
+ */
+DSP_STATUS PROC_Map(void *hProcessor, void *pMpuAddr, u32 ulSize,
+		   void *pReqAddr, void **ppMapAddr, u32 ulMapAttr,
+		   struct PROCESS_CONTEXT *pr_ctxt)
+{
+	u32 vaAlign;
+	u32 paAlign;
+	struct DMM_OBJECT *hDmmMgr;
+	u32 sizeAlign;
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct DMM_MAP_OBJECT *map_obj;
+
+	/* Calculate the page-aligned PA, VA and size */
+	vaAlign = PG_ALIGN_LOW((u32) pReqAddr, PG_SIZE_4K);
+	paAlign = PG_ALIGN_LOW((u32) pMpuAddr, PG_SIZE_4K);
+	sizeAlign = PG_ALIGN_HIGH(ulSize + (u32)pMpuAddr - paAlign,
+				 PG_SIZE_4K);
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/* Critical section */
+	(void)SYNC_EnterCS(hProcLock);
+	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+	if (DSP_SUCCEEDED(status))
+		status = DMM_MapMemory(hDmmMgr, vaAlign, sizeAlign);
+
+	/* Add mapping to the page tables. */
+	if (DSP_SUCCEEDED(status)) {
+
+		status = (*pProcObject->pIntfFxns->pfnBrdMemMap)
+			(pProcObject->hWmdContext, paAlign, vaAlign, sizeAlign,
+			ulMapAttr);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Mapped address = MSB of VA | LSB of PA */
+		*ppMapAddr = (void *) (vaAlign | ((u32) pMpuAddr &
+			     (PG_SIZE_4K - 1)));
+	} else {
+		DMM_UnMapMemory(hDmmMgr, vaAlign, &sizeAlign);
+	}
+	(void)SYNC_LeaveCS(hProcLock);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/*
+	 * A successful map should be followed by insertion of map_obj
+	 * into dmm_map_list, so that mapped memory resource tracking
+	 * remains uptodate
+	 */
+	map_obj = kmalloc(sizeof(struct DMM_MAP_OBJECT), GFP_KERNEL);
+	if (map_obj) {
+		map_obj->dsp_addr = (u32)*ppMapAddr;
+		spin_lock(&pr_ctxt->dmm_map_lock);
+		list_add(&map_obj->link, &pr_ctxt->dmm_map_list);
+		spin_unlock(&pr_ctxt->dmm_map_lock);
+	}
+
+func_end:
+	dev_dbg(bridge, "%s: hProcessor %p, pMpuAddr %p, ulSize %x, "
+		"pReqAddr %p, ulMapAttr %x, ppMapAddr %p, vaAlign %x, "
+		"paAlign %x, sizeAlign %x status 0x%x\n", __func__, hProcessor,
+		pMpuAddr, ulSize, pReqAddr, ulMapAttr,  ppMapAddr, vaAlign,
+		paAlign, sizeAlign, status);
+
+	return status;
+}
+
+/*
+ *  ======== PROC_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified of specific processor events.
+ */
+DSP_STATUS PROC_RegisterNotify(void *hProcessor, u32 uEventMask,
+			      u32 uNotifyType, struct DSP_NOTIFICATION
+			      *hNotification)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct DEH_MGR *hDehMgr;
+
+	DBC_Require(hNotification != NULL);
+	DBC_Require(cRefs > 0);
+
+	/* Check processor handle */
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/* Check if event mask is a valid processor related event */
+	if (uEventMask & ~(DSP_PROCESSORSTATECHANGE | DSP_PROCESSORATTACH |
+	   DSP_PROCESSORDETACH | DSP_PROCESSORRESTART | DSP_MMUFAULT |
+	   DSP_SYSERROR | DSP_PWRERROR))
+		status = DSP_EVALUE;
+
+	/* Check if notify type is valid */
+	if (uNotifyType != DSP_SIGNALEVENT)
+		status = DSP_EVALUE;
+
+	if (DSP_SUCCEEDED(status)) {
+		/* If event mask is not DSP_SYSERROR, DSP_MMUFAULT,
+		 * or DSP_PWRERROR then register event immediately. */
+		if (uEventMask &
+		    ~(DSP_SYSERROR | DSP_MMUFAULT | DSP_PWRERROR)) {
+			status = NTFY_Register(pProcObject->hNtfy,
+				 hNotification,	uEventMask, uNotifyType);
+			/* Special case alert, special case alert!
+			 * If we're trying to *deregister* (i.e. uEventMask
+			 * is 0), a DSP_SYSERROR or DSP_MMUFAULT notification,
+			 * we have to deregister with the DEH manager.
+			 * There's no way to know, based on uEventMask which
+			 * manager the notification event was registered with,
+			 * so if we're trying to deregister and NTFY_Register
+			 * failed, we'll give the deh manager a shot.
+			 */
+			if ((uEventMask == 0) && DSP_FAILED(status)) {
+				status = DEV_GetDehMgr(pProcObject->hDevObject,
+					 &hDehMgr);
+				DBC_Assert(pProcObject->pIntfFxns->
+					   pfnDehRegisterNotify);
+				status = (*pProcObject->pIntfFxns->
+					 pfnDehRegisterNotify)
+					 (hDehMgr, uEventMask, uNotifyType,
+					 hNotification);
+			}
+		} else {
+			status = DEV_GetDehMgr(pProcObject->hDevObject,
+					      &hDehMgr);
+			DBC_Assert(pProcObject->pIntfFxns->
+				  pfnDehRegisterNotify);
+			status = (*pProcObject->pIntfFxns->pfnDehRegisterNotify)
+				 (hDehMgr, uEventMask, uNotifyType,
+				 hNotification);
+
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== PROC_ReserveMemory ========
+ *  Purpose:
+ *      Reserve a virtually contiguous region of DSP address space.
+ */
+DSP_STATUS PROC_ReserveMemory(void *hProcessor, u32 ulSize,
+		     void **ppRsvAddr, struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct DMM_OBJECT *hDmmMgr;
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct DMM_RSV_OBJECT *rsv_obj;
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = DMM_ReserveMemory(hDmmMgr, ulSize, (u32 *)ppRsvAddr);
+	if (status != DSP_SOK)
+		goto func_end;
+
+	/*
+	 * A successful reserve should be followed by insertion of rsv_obj
+	 * into dmm_rsv_list, so that reserved memory resource tracking
+	 * remains uptodate
+	 */
+	rsv_obj = kmalloc(sizeof(struct DMM_RSV_OBJECT), GFP_KERNEL);
+	if (rsv_obj) {
+		rsv_obj->dsp_reserved_addr = (u32) *ppRsvAddr;
+		spin_lock(&pr_ctxt->dmm_rsv_lock);
+		list_add(&rsv_obj->link, &pr_ctxt->dmm_rsv_list);
+		spin_unlock(&pr_ctxt->dmm_rsv_lock);
+	}
+
+func_end:
+	dev_dbg(bridge, "%s: hProcessor: 0x%p ulSize: 0x%x ppRsvAddr: 0x%p "
+					"status 0x%x\n", __func__, hProcessor,
+					ulSize, ppRsvAddr, status);
+	return status;
+}
+
+/*
+ *  ======== PROC_Start ========
+ *  Purpose:
+ *      Start a processor running.
+ */
+DSP_STATUS PROC_Start(void *hProcessor)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct COD_MANAGER *hCodMgr;	/* Code manager handle    */
+	u32 dwDspAddr;	/* Loaded code's entry point.    */
+	int uBrdState;
+
+	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/* Call the WMD_BRD_Start */
+	if (pProcObject->sState != PROC_LOADED) {
+		status = DSP_EWRONGSTATE;
+		goto func_end;
+	}
+	status = DEV_GetCodMgr(pProcObject->hDevObject, &hCodMgr);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = COD_GetEntry(hCodMgr, &dwDspAddr);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	status = (*pProcObject->pIntfFxns->pfnBrdStart)
+		 (pProcObject->hWmdContext, dwDspAddr);
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	/* Call DEV_Create2 */
+	status = DEV_Create2(pProcObject->hDevObject);
+	if (DSP_SUCCEEDED(status)) {
+		pProcObject->sState = PROC_RUNNING;
+		/* Deep sleep switces off the peripheral clocks.
+		 * we just put the DSP CPU in idle in the idle loop.
+		 * so there is no need to send a command to DSP */
+
+		if (pProcObject->hNtfy) {
+			PROC_NotifyClients(pProcObject,
+					  DSP_PROCESSORSTATECHANGE);
+		}
+	} else {
+		/* Failed to Create Node Manager and DISP Object
+		 * Stop the Processor from running. Put it in STOPPED State */
+		(void)(*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
+			hWmdContext);
+		pProcObject->sState = PROC_STOPPED;
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status)) {
+		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
+		   (pProcObject->hWmdContext, &uBrdState))) {
+			pr_info("%s: dsp in running state\n", __func__);
+			DBC_Assert(uBrdState != BRD_HIBERNATION);
+		}
+	} else {
+		pr_err("%s: Failed to start the dsp\n", __func__);
+	}
+
+func_end:
+	DBC_Ensure((DSP_SUCCEEDED(status) && pProcObject->sState ==
+		  PROC_RUNNING)	|| DSP_FAILED(status));
+	return status;
+}
+
+/*
+ *  ======== PROC_Stop ========
+ *  Purpose:
+ *      Stop a processor running.
+ */
+DSP_STATUS PROC_Stop(void *hProcessor)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct MSG_MGR *hMsgMgr;
+	struct NODE_MGR *hNodeMgr;
+	void *hNode;
+	u32 uNodeTabSize = 1;
+	u32 uNumNodes = 0;
+	u32 uNodesAllocated = 0;
+	int uBrdState;
+
+	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
+	   (pProcObject->hWmdContext, &uBrdState))) {
+		if (uBrdState == BRD_ERROR)
+			WMD_DEH_ReleaseDummyMem();
+	}
+	/* check if there are any running nodes */
+	status = DEV_GetNodeManager(pProcObject->hDevObject, &hNodeMgr);
+	if (DSP_SUCCEEDED(status) && hNodeMgr) {
+		status = NODE_EnumNodes(hNodeMgr, &hNode, uNodeTabSize,
+					&uNumNodes, &uNodesAllocated);
+		if ((status == DSP_ESIZE) || (uNodesAllocated > 0)) {
+			pr_err("%s: Can't stop device, active nodes = %d \n",
+						__func__, uNodesAllocated);
+			return DSP_EWRONGSTATE;
+		}
+	}
+	/* Call the WMD_BRD_Stop */
+	/* It is OK to stop a device that does n't have nodes OR not started */
+	status = (*pProcObject->pIntfFxns->pfnBrdStop)(pProcObject->
+		 hWmdContext);
+	if (DSP_SUCCEEDED(status)) {
+		dev_dbg(bridge, "%s: processor in standby mode\n", __func__);
+		pProcObject->sState = PROC_STOPPED;
+		/* Destory the Node Manager, MSG Manager */
+		if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
+			/* Destroy the MSG by calling MSG_Delete */
+			DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
+			if (hMsgMgr) {
+				MSG_Delete(hMsgMgr);
+				DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
+			}
+			if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->
+			   pfnBrdStatus)(pProcObject->hWmdContext,
+			   &uBrdState)))
+				DBC_Assert(uBrdState == BRD_STOPPED);
+		}
+	} else {
+		pr_err("%s: Failed to stop the processor\n", __func__);
+	}
+func_end:
+
+	return status;
+}
+
+/*
+ *  ======== PROC_UnMap ========
+ *  Purpose:
+ *      Removes a MPU buffer mapping from the DSP address space.
+ */
+DSP_STATUS PROC_UnMap(void *hProcessor, void *pMapAddr,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct DMM_OBJECT *hDmmMgr;
+	u32 vaAlign;
+	u32 sizeAlign;
+	struct DMM_MAP_OBJECT *map_obj;
+
+	vaAlign = PG_ALIGN_LOW((u32) pMapAddr, PG_SIZE_4K);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	status = DMM_GetHandle(hProcessor, &hDmmMgr);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Critical section */
+	(void)SYNC_EnterCS(hProcLock);
+	/*
+	 * Update DMM structures. Get the size to unmap.
+	 * This function returns error if the VA is not mapped
+	 */
+	status = DMM_UnMapMemory(hDmmMgr, (u32) vaAlign, &sizeAlign);
+	/* Remove mapping from the page tables. */
+	if (DSP_SUCCEEDED(status)) {
+		status = (*pProcObject->pIntfFxns->pfnBrdMemUnMap)
+			 (pProcObject->hWmdContext, vaAlign, sizeAlign);
+	}
+	(void)SYNC_LeaveCS(hProcLock);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/*
+	 * A successful unmap should be followed by removal of map_obj
+	 * from dmm_map_list, so that mapped memory resource tracking
+	 * remains uptodate
+	 */
+	spin_lock(&pr_ctxt->dmm_map_lock);
+	list_for_each_entry(map_obj, &pr_ctxt->dmm_map_list, link) {
+		if (map_obj->dsp_addr == (u32)pMapAddr) {
+			list_del(&map_obj->link);
+			kfree(map_obj);
+			break;
+		}
+	}
+	spin_unlock(&pr_ctxt->dmm_map_lock);
+
+func_end:
+	dev_dbg(bridge, "%s: hProcessor: 0x%p pMapAddr: 0x%p status: 0x%x\n",
+					__func__, hProcessor, pMapAddr, status);
+	return status;
+}
+
+/*
+ *  ======== PROC_UnReserveMemory ========
+ *  Purpose:
+ *      Frees a previously reserved region of DSP address space.
+ */
+DSP_STATUS PROC_UnReserveMemory(void *hProcessor, void *pRsvAddr,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct DMM_OBJECT *hDmmMgr;
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProcessor;
+	struct DMM_RSV_OBJECT *rsv_obj;
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	status = DMM_GetHandle(pProcObject, &hDmmMgr);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	status = DMM_UnReserveMemory(hDmmMgr, (u32) pRsvAddr);
+	if (status != DSP_SOK)
+		goto func_end;
+
+	/*
+	 * A successful unreserve should be followed by removal of rsv_obj
+	 * from dmm_rsv_list, so that reserved memory resource tracking
+	 * remains uptodate
+	 */
+	spin_lock(&pr_ctxt->dmm_rsv_lock);
+	list_for_each_entry(rsv_obj, &pr_ctxt->dmm_rsv_list, link) {
+		if (rsv_obj->dsp_reserved_addr == (u32)pRsvAddr) {
+			list_del(&rsv_obj->link);
+			kfree(rsv_obj);
+			break;
+		}
+	}
+	spin_unlock(&pr_ctxt->dmm_rsv_lock);
+
+func_end:
+	dev_dbg(bridge, "%s: hProcessor: 0x%p pRsvAddr: 0x%p status: 0x%x\n",
+					__func__, hProcessor, pRsvAddr, status);
+	return status;
+}
+
+/*
+ *  ======== = PROC_Monitor ======== ==
+ *  Purpose:
+ *      Place the Processor in Monitor State. This is an internal
+ *      function and a requirement before Processor is loaded.
+ *      This does a WMD_BRD_Stop, DEV_Destroy2 and WMD_BRD_Monitor.
+ *      In DEV_Destroy2 we delete the node manager.
+ *  Parameters:
+ *      pProcObject:    Pointer to Processor Object
+ *  Returns:
+ *      DSP_SOK:	Processor placed in monitor mode.
+ *      !DSP_SOK:       Failed to place processor in monitor mode.
+ *  Requires:
+ *      Valid Processor Handle
+ *  Ensures:
+ *      Success:	ProcObject state is PROC_IDLE
+ */
+static DSP_STATUS PROC_Monitor(struct PROC_OBJECT *pProcObject)
+{
+	DSP_STATUS status = DSP_EFAIL;
+	struct MSG_MGR *hMsgMgr;
+	int uBrdState;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
+
+	/* This is needed only when Device is loaded when it is
+	 * already 'ACTIVE' */
+	/* Destory the Node Manager, MSG Manager */
+	if (DSP_SUCCEEDED(DEV_Destroy2(pProcObject->hDevObject))) {
+		/* Destroy the MSG by calling MSG_Delete */
+		DEV_GetMsgMgr(pProcObject->hDevObject, &hMsgMgr);
+		if (hMsgMgr) {
+			MSG_Delete(hMsgMgr);
+			DEV_SetMsgMgr(pProcObject->hDevObject, NULL);
+		}
+	}
+	/* Place the Board in the Monitor State */
+	if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdMonitor)
+	   (pProcObject->hWmdContext))) {
+		status = DSP_SOK;
+		if (DSP_SUCCEEDED((*pProcObject->pIntfFxns->pfnBrdStatus)
+		   (pProcObject->hWmdContext, &uBrdState)))
+			DBC_Assert(uBrdState == BRD_IDLE);
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && uBrdState == BRD_IDLE) ||
+		  DSP_FAILED(status));
+	return status;
+}
+
+/*
+ *  ======== GetEnvpCount ========
+ *  Purpose:
+ *      Return the number of elements in the envp array, including the
+ *      terminating NULL element.
+ */
+static s32 GetEnvpCount(char **envp)
+{
+	s32 cRetval = 0;
+	if (envp) {
+		while (*envp++)
+			cRetval++;
+
+		cRetval += 1;	/* Include the terminating NULL in the count. */
+	}
+
+	return cRetval;
+}
+
+/*
+ *  ======== PrependEnvp ========
+ *  Purpose:
+ *      Prepend an environment variable=value pair to the new envp array, and
+ *      copy in the existing var=value pairs in the old envp array.
+ */
+static char **PrependEnvp(char **newEnvp, char **envp, s32 cEnvp, s32 cNewEnvp,
+			 char *szVar)
+{
+	char **ppEnvp = newEnvp;
+
+	DBC_Require(newEnvp);
+
+	/* Prepend new environ var=value string */
+	*newEnvp++ = szVar;
+
+	/* Copy user's environment into our own. */
+	while (cEnvp--)
+		*newEnvp++ = *envp++;
+
+	/* Ensure NULL terminates the new environment strings array. */
+	if (cEnvp == 0)
+		*newEnvp = NULL;
+
+	return ppEnvp;
+}
+
+/*
+ *  ======== PROC_NotifyClients ========
+ *  Purpose:
+ *      Notify the processor the events.
+ */
+DSP_STATUS PROC_NotifyClients(void *hProc, u32 uEvents)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+
+	DBC_Require(MEM_IsValidHandle(pProcObject, PROC_SIGNATURE));
+	DBC_Require(IsValidProcEvent(uEvents));
+	DBC_Require(cRefs > 0);
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	NTFY_Notify(pProcObject->hNtfy, uEvents);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== PROC_NotifyAllClients ========
+ *  Purpose:
+ *      Notify the processor the events. This includes notifying all clients
+ *      attached to a particulat DSP.
+ */
+DSP_STATUS PROC_NotifyAllClients(void *hProc, u32 uEvents)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+
+	DBC_Require(IsValidProcEvent(uEvents));
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(pProcObject, PROC_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	DEV_NotifyClients(pProcObject->hDevObject, uEvents);
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== PROC_GetProcessorId ========
+ *  Purpose:
+ *      Retrieves the processor ID.
+ */
+DSP_STATUS PROC_GetProcessorId(void *hProc, u32 *procID)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct PROC_OBJECT *pProcObject = (struct PROC_OBJECT *)hProc;
+
+	if (MEM_IsValidHandle(pProcObject, PROC_SIGNATURE))
+		*procID = pProcObject->uProcessor;
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
diff --git a/drivers/dsp/bridge/rmgr/pwr.c b/drivers/dsp/bridge/rmgr/pwr.c
new file mode 100644
index 0000000..3e58da2
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/pwr.c
@@ -0,0 +1,169 @@
+/*
+ * pwr.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * PWR API for controlling DSP power states.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/pwr.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/devdefs.h>
+#include <dspbridge/drv.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmdioctl.h>
+
+/*
+ *  ======== PWR_SleepDSP ========
+ *    Send command to DSP to enter sleep state.
+ */
+DSP_STATUS PWR_SleepDSP(IN CONST u32 sleepCode, IN CONST u32 timeout)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct WMD_DEV_CONTEXT *dwContext;
+	DSP_STATUS status = DSP_EFAIL;
+	struct DEV_OBJECT *hDevObject = NULL;
+	u32 ioctlcode = 0;
+	u32 arg = timeout;
+
+	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+			  hDevObject != NULL;
+			hDevObject =
+				(struct DEV_OBJECT *)DRV_GetNextDevObject
+				((u32)hDevObject)) {
+		if (DSP_FAILED(DEV_GetWMDContext(hDevObject,
+		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+			continue;
+		}
+		if (DSP_FAILED(DEV_GetIntfFxns(hDevObject,
+		   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
+			continue;
+		}
+		if (sleepCode == PWR_DEEPSLEEP)
+			ioctlcode = WMDIOCTL_DEEPSLEEP;
+		else if (sleepCode == PWR_EMERGENCYDEEPSLEEP)
+			ioctlcode = WMDIOCTL_EMERGENCYSLEEP;
+		else
+			status = DSP_EINVALIDARG;
+
+		if (status != DSP_EINVALIDARG) {
+			status = (*pIntfFxns->pfnDevCntrl)(dwContext,
+				 ioctlcode, (void *)&arg);
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== PWR_WakeDSP ========
+ *    Send command to DSP to wake it from sleep.
+ */
+DSP_STATUS PWR_WakeDSP(IN CONST u32 timeout)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct WMD_DEV_CONTEXT *dwContext;
+	DSP_STATUS status = DSP_EFAIL;
+	struct DEV_OBJECT *hDevObject = NULL;
+	u32 arg = timeout;
+
+	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	     hDevObject != NULL;
+	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
+			  ((u32)hDevObject)) {
+		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
+		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
+			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
+				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
+					 WMDIOCTL_WAKEUP, (void *)&arg);
+			}
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== PWR_PM_PreScale========
+ *    Sends pre-notification message to DSP.
+ */
+DSP_STATUS PWR_PM_PreScale(IN u16 voltage_domain, u32 level)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct WMD_DEV_CONTEXT *dwContext;
+	DSP_STATUS status = DSP_EFAIL;
+	struct DEV_OBJECT *hDevObject = NULL;
+	u32 arg[2];
+
+	arg[0] = voltage_domain;
+	arg[1] = level;
+
+	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	    hDevObject != NULL;
+	    hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
+			 ((u32)hDevObject)) {
+		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
+		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
+			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
+				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
+					 WMDIOCTL_PRESCALE_NOTIFY,
+					 (void *)&arg);
+			}
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== PWR_PM_PostScale========
+ *    Sends post-notification message to DSP.
+ */
+DSP_STATUS PWR_PM_PostScale(IN u16 voltage_domain, u32 level)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct WMD_DEV_CONTEXT *dwContext;
+	DSP_STATUS status = DSP_EFAIL;
+	struct DEV_OBJECT *hDevObject = NULL;
+	u32 arg[2];
+
+	arg[0] = voltage_domain;
+	arg[1] = level;
+
+	for (hDevObject = (struct DEV_OBJECT *)DRV_GetFirstDevObject();
+	     hDevObject != NULL;
+	     hDevObject = (struct DEV_OBJECT *)DRV_GetNextDevObject
+			  ((u32)hDevObject)) {
+		if (DSP_SUCCEEDED(DEV_GetWMDContext(hDevObject,
+		   (struct WMD_DEV_CONTEXT **)&dwContext))) {
+			if (DSP_SUCCEEDED(DEV_GetIntfFxns(hDevObject,
+			   (struct WMD_DRV_INTERFACE **)&pIntfFxns))) {
+				status = (*pIntfFxns->pfnDevCntrl)(dwContext,
+					WMDIOCTL_POSTSCALE_NOTIFY,
+					(void *)&arg);
+			}
+		}
+	}
+	return status;
+
+}
+
+
diff --git a/drivers/dsp/bridge/rmgr/rmm.c b/drivers/dsp/bridge/rmgr/rmm.c
new file mode 100644
index 0000000..506bc57
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/rmm.c
@@ -0,0 +1,537 @@
+/*
+ * rmm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *  This memory manager provides general heap management and arbitrary
+ *  alignment for any number of memory segments.
+ *
+ *  Notes:
+ *
+ *  Memory blocks are allocated from the end of the first free memory
+ *  block large enough to satisfy the request.  Alignment requirements
+ *  are satisfied by "sliding" the block forward until its base satisfies
+ *  the alignment specification; if this is not possible then the next
+ *  free block large enough to hold the request is tried.
+ *
+ *  Since alignment can cause the creation of a new free block - the
+ *  unused memory formed between the start of the original free block
+ *  and the start of the allocated block - the memory manager must free
+ *  this memory to prevent a memory leak.
+ *
+ *  Overlay memory is managed by reserving through RMM_alloc, and freeing
+ *  it through RMM_free. The memory manager prevents DSP code/data that is
+ *  overlayed from being overwritten as long as the memory it runs at has
+ *  been allocated, and not yet freed.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/rmm.h>
+
+#define RMM_TARGSIGNATURE   0x544d4d52	/* "TMMR" */
+
+/*
+ *  ======== RMM_Header ========
+ *  This header is used to maintain a list of free memory blocks.
+ */
+struct RMM_Header {
+	struct RMM_Header *next;	/* form a free memory link list */
+	u32 size;		/* size of the free memory */
+	u32 addr;		/* DSP address of memory block */
+} ;
+
+/*
+ *  ======== RMM_OvlySect ========
+ *  Keeps track of memory occupied by overlay section.
+ */
+struct RMM_OvlySect {
+	struct list_head listElem;
+	u32 addr;		/* Start of memory section */
+	u32 size;		/* Length (target MAUs) of section */
+	s32 page;		/* Memory page */
+};
+
+/*
+ *  ======== RMM_TargetObj ========
+ */
+struct RMM_TargetObj {
+	u32 dwSignature;
+	struct RMM_Segment *segTab;
+	struct RMM_Header **freeList;
+	u32 numSegs;
+	struct LST_LIST *ovlyList;	/* List of overlay memory in use */
+};
+
+static u32 cRefs;		/* module reference count */
+
+static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
+		      u32 align, u32 *dspAddr);
+static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
+		     u32 size);
+
+/*
+ *  ======== RMM_alloc ========
+ */
+DSP_STATUS RMM_alloc(struct RMM_TargetObj *target, u32 segid, u32 size,
+		    u32 align, u32 *dspAddr, bool reserve)
+{
+	struct RMM_OvlySect *sect;
+	struct RMM_OvlySect *prevSect = NULL;
+	struct RMM_OvlySect *newSect;
+	u32 addr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+	DBC_Require(dspAddr != NULL);
+	DBC_Require(size > 0);
+	DBC_Require(reserve || (target->numSegs > 0));
+	DBC_Require(cRefs > 0);
+
+	if (!reserve) {
+		if (!allocBlock(target, segid, size, align, dspAddr)) {
+			status = DSP_EMEMORY;
+		} else {
+			/* Increment the number of allocated blocks in this
+			 * segment */
+			target->segTab[segid].number++;
+		}
+		goto func_end;
+	}
+	/* An overlay section - See if block is already in use. If not,
+	 * insert into the list in ascending address size.  */
+	addr = *dspAddr;
+	sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+	/*  Find place to insert new list element. List is sorted from
+	 *  smallest to largest address. */
+	while (sect != NULL) {
+		if (addr <= sect->addr) {
+			/* Check for overlap with sect */
+			if ((addr + size > sect->addr) || (prevSect &&
+			   (prevSect->addr + prevSect->size > addr))) {
+				status = DSP_EOVERLAYMEMORY;
+			}
+			break;
+		}
+		prevSect = sect;
+		sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
+			(struct list_head *)sect);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* No overlap - allocate list element for new section. */
+		newSect = MEM_Calloc(sizeof(struct RMM_OvlySect), MEM_PAGED);
+		if (newSect == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			LST_InitElem((struct list_head *)newSect);
+			newSect->addr = addr;
+			newSect->size = size;
+			newSect->page = segid;
+			if (sect == NULL) {
+				/* Put new section at the end of the list */
+				LST_PutTail(target->ovlyList,
+					   (struct list_head *)newSect);
+			} else {
+				/* Put new section just before sect */
+				LST_InsertBefore(target->ovlyList,
+						(struct list_head *)newSect,
+						(struct list_head *)sect);
+			}
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== RMM_create ========
+ */
+DSP_STATUS RMM_create(struct RMM_TargetObj **pTarget,
+		     struct RMM_Segment segTab[], u32 numSegs)
+{
+	struct RMM_Header *hptr;
+	struct RMM_Segment *sptr, *tmp;
+	struct RMM_TargetObj *target;
+	s32 i;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(pTarget != NULL);
+	DBC_Require(numSegs == 0 || segTab != NULL);
+
+	/* Allocate DBL target object */
+	MEM_AllocObject(target, struct RMM_TargetObj, RMM_TARGSIGNATURE);
+
+	if (target == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	target->numSegs = numSegs;
+	if (!(numSegs > 0))
+		goto func_cont;
+
+	/* Allocate the memory for freelist from host's memory */
+	target->freeList = MEM_Calloc(numSegs * sizeof(struct RMM_Header *),
+				     MEM_PAGED);
+	if (target->freeList == NULL) {
+		status = DSP_EMEMORY;
+	} else {
+		/* Allocate headers for each element on the free list */
+		for (i = 0; i < (s32) numSegs; i++) {
+			target->freeList[i] =
+					MEM_Calloc(sizeof(struct RMM_Header),
+					MEM_PAGED);
+			if (target->freeList[i] == NULL) {
+				status = DSP_EMEMORY;
+				break;
+			}
+		}
+		/* Allocate memory for initial segment table */
+		target->segTab = MEM_Calloc(numSegs *
+				 sizeof(struct RMM_Segment), MEM_PAGED);
+		if (target->segTab == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			/* Initialize segment table and free list */
+			sptr = target->segTab;
+			for (i = 0, tmp = segTab; numSegs > 0; numSegs--, i++) {
+				*sptr = *tmp;
+				hptr = target->freeList[i];
+				hptr->addr = tmp->base;
+				hptr->size = tmp->length;
+				hptr->next = NULL;
+				tmp++;
+				sptr++;
+			}
+		}
+	}
+func_cont:
+	/* Initialize overlay memory list */
+	if (DSP_SUCCEEDED(status)) {
+		target->ovlyList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
+		if (target->ovlyList == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			INIT_LIST_HEAD(&target->ovlyList->head);
+		}
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		*pTarget = target;
+	} else {
+		*pTarget = NULL;
+		if (target)
+			RMM_delete(target);
+
+	}
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && MEM_IsValidHandle((*pTarget),
+		  RMM_TARGSIGNATURE)) || (DSP_FAILED(status) && *pTarget ==
+		  NULL));
+
+	return status;
+}
+
+/*
+ *  ======== RMM_delete ========
+ */
+void RMM_delete(struct RMM_TargetObj *target)
+{
+	struct RMM_OvlySect *pSect;
+	struct RMM_Header *hptr;
+	struct RMM_Header *next;
+	u32 i;
+
+	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+
+	kfree(target->segTab);
+
+	if (target->ovlyList) {
+		while ((pSect = (struct RMM_OvlySect *)LST_GetHead
+		      (target->ovlyList))) {
+			kfree(pSect);
+		}
+		DBC_Assert(LST_IsEmpty(target->ovlyList));
+		kfree(target->ovlyList);
+	}
+
+	if (target->freeList != NULL) {
+		/* Free elements on freelist */
+		for (i = 0; i < target->numSegs; i++) {
+			hptr = next = target->freeList[i];
+			while (next) {
+				hptr = next;
+				next = hptr->next;
+				kfree(hptr);
+			}
+		}
+		kfree(target->freeList);
+	}
+
+	MEM_FreeObject(target);
+}
+
+/*
+ *  ======== RMM_exit ========
+ */
+void RMM_exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== RMM_free ========
+ */
+bool RMM_free(struct RMM_TargetObj *target, u32 segid, u32 addr, u32 size,
+	bool reserved)
+
+{
+	struct RMM_OvlySect *sect;
+	bool retVal = true;
+
+	DBC_Require(MEM_IsValidHandle(target, RMM_TARGSIGNATURE));
+
+	DBC_Require(reserved || segid < target->numSegs);
+	DBC_Require(reserved || (addr >= target->segTab[segid].base &&
+		   (addr + size) <= (target->segTab[segid].base +
+		   target->segTab[segid].length)));
+
+	/*
+	 *  Free or unreserve memory.
+	 */
+	if (!reserved) {
+		retVal = freeBlock(target, segid, addr, size);
+		if (retVal)
+			target->segTab[segid].number--;
+
+	} else {
+		/* Unreserve memory */
+		sect = (struct RMM_OvlySect *)LST_First(target->ovlyList);
+		while (sect != NULL) {
+			if (addr == sect->addr) {
+				DBC_Assert(size == sect->size);
+				/* Remove from list */
+				LST_RemoveElem(target->ovlyList,
+					      (struct list_head *)sect);
+				kfree(sect);
+				break;
+			}
+			sect = (struct RMM_OvlySect *)LST_Next(target->ovlyList,
+			       (struct list_head *)sect);
+		}
+		if (sect == NULL)
+			retVal = false;
+
+	}
+	return retVal;
+}
+
+/*
+ *  ======== RMM_init ========
+ */
+bool RMM_init(void)
+{
+	DBC_Require(cRefs >= 0);
+
+	cRefs++;
+
+	return true;
+}
+
+/*
+ *  ======== RMM_stat ========
+ */
+bool RMM_stat(struct RMM_TargetObj *target, enum DSP_MEMTYPE segid,
+	     struct DSP_MEMSTAT *pMemStatBuf)
+{
+	struct RMM_Header *head;
+	bool retVal = false;
+	u32 maxFreeSize = 0;
+	u32 totalFreeSize = 0;
+	u32 freeBlocks = 0;
+
+	DBC_Require(pMemStatBuf != NULL);
+	DBC_Assert(target != NULL);
+
+	if ((u32) segid < target->numSegs) {
+		head = target->freeList[segid];
+
+		/* Collect data from freeList */
+		while (head != NULL) {
+			maxFreeSize = max(maxFreeSize, head->size);
+			totalFreeSize += head->size;
+			freeBlocks++;
+			head = head->next;
+		}
+
+		/* ulSize */
+		pMemStatBuf->ulSize = target->segTab[segid].length;
+
+		/* ulNumFreeBlocks */
+		pMemStatBuf->ulNumFreeBlocks = freeBlocks;
+
+		/* ulTotalFreeSize */
+		pMemStatBuf->ulTotalFreeSize = totalFreeSize;
+
+		/* ulLenMaxFreeBlock */
+		pMemStatBuf->ulLenMaxFreeBlock = maxFreeSize;
+
+		/* ulNumAllocBlocks */
+		pMemStatBuf->ulNumAllocBlocks = target->segTab[segid].number;
+
+		retVal = true;
+	}
+
+	return retVal;
+}
+
+/*
+ *  ======== balloc ========
+ *  This allocation function allocates memory from the lowest addresses
+ *  first.
+ */
+static bool allocBlock(struct RMM_TargetObj *target, u32 segid, u32 size,
+		      u32 align, u32 *dspAddr)
+{
+	struct RMM_Header *head;
+	struct RMM_Header *prevhead = NULL;
+	struct RMM_Header *next;
+	u32 tmpalign;
+	u32 alignbytes;
+	u32 hsize;
+	u32 allocsize;
+	u32 addr;
+
+	alignbytes = (align == 0) ? 1 : align;
+	prevhead = NULL;
+	head = target->freeList[segid];
+
+	do {
+		hsize = head->size;
+		next = head->next;
+
+		addr = head->addr;	/* alloc from the bottom */
+
+		/* align allocation */
+		(tmpalign = (u32) addr % alignbytes);
+		if (tmpalign != 0)
+			tmpalign = alignbytes - tmpalign;
+
+		allocsize = size + tmpalign;
+
+		if (hsize >= allocsize) {	/* big enough */
+			if (hsize == allocsize && prevhead != NULL) {
+				prevhead->next = next;
+				kfree(head);
+			} else {
+				head->size = hsize - allocsize;
+				head->addr += allocsize;
+			}
+
+			/* free up any hole created by alignment */
+			if (tmpalign)
+				freeBlock(target, segid, addr, tmpalign);
+
+			*dspAddr = addr + tmpalign;
+			return true;
+		}
+
+		prevhead = head;
+		head = next;
+
+	} while (head != NULL);
+
+	return false;
+}
+
+/*
+ *  ======== freeBlock ========
+ *  TO DO: freeBlock() allocates memory, which could result in failure.
+ *  Could allocate an RMM_Header in RMM_alloc(), to be kept in a pool.
+ *  freeBlock() could use an RMM_Header from the pool, freeing as blocks
+ *  are coalesced.
+ */
+static bool freeBlock(struct RMM_TargetObj *target, u32 segid, u32 addr,
+		     u32 size)
+{
+	struct RMM_Header *head;
+	struct RMM_Header *thead;
+	struct RMM_Header *rhead;
+	bool retVal = true;
+
+	/* Create a memory header to hold the newly free'd block. */
+	rhead = MEM_Calloc(sizeof(struct RMM_Header), MEM_PAGED);
+	if (rhead == NULL) {
+		retVal = false;
+	} else {
+		/* search down the free list to find the right place for addr */
+		head = target->freeList[segid];
+
+		if (addr >= head->addr) {
+			while (head->next != NULL && addr > head->next->addr)
+				head = head->next;
+
+			thead = head->next;
+
+			head->next = rhead;
+			rhead->next = thead;
+			rhead->addr = addr;
+			rhead->size = size;
+		} else {
+			*rhead = *head;
+			head->next = rhead;
+			head->addr = addr;
+			head->size = size;
+			thead = rhead->next;
+		}
+
+		/* join with upper block, if possible */
+		if (thead != NULL && (rhead->addr + rhead->size) ==
+		   thead->addr) {
+			head->next = rhead->next;
+			thead->size = size + thead->size;
+			thead->addr = addr;
+			kfree(rhead);
+			rhead = thead;
+		}
+
+		/* join with the lower block, if possible */
+		if ((head->addr + head->size) == rhead->addr) {
+			head->next = rhead->next;
+			head->size = head->size + rhead->size;
+			kfree(rhead);
+		}
+	}
+
+	return retVal;
+}
+
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
new file mode 100644
index 0000000..370a44d
--- /dev/null
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -0,0 +1,854 @@
+/*
+ * strm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * DSP/BIOS Bridge Stream Manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Mini Driver */
+#include <dspbridge/wmd.h>
+
+/*  ----------------------------------- Resource Manager */
+#include <dspbridge/nodepriv.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/cmm.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/strm.h>
+
+#include <dspbridge/cfg.h>
+#include <dspbridge/resourcecleanup.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define STRM_SIGNATURE      0x4d525453	/* "MRTS" */
+#define STRMMGR_SIGNATURE   0x5254534d	/* "RTSM" */
+
+#define DEFAULTTIMEOUT      10000
+#define DEFAULTNUMBUFS      2
+
+/*
+ *  ======== STRM_MGR ========
+ *  The STRM_MGR contains device information needed to open the underlying
+ *  channels of a stream.
+ */
+struct STRM_MGR {
+	u32 dwSignature;
+	struct DEV_OBJECT *hDev;	/* Device for this processor */
+	struct CHNL_MGR *hChnlMgr;	/* Channel manager */
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD */
+	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
+} ;
+
+/*
+ *  ======== STRM_OBJECT ========
+ *  This object is allocated in STRM_Open().
+ */
+ struct STRM_OBJECT {
+	u32 dwSignature;
+	struct STRM_MGR *hStrmMgr;
+	struct CHNL_OBJECT *hChnl;
+	u32 uDir;		/* DSP_TONODE or DSP_FROMNODE */
+	u32 uTimeout;
+	u32 uNumBufs;		/* Max # of bufs allowed in stream */
+	u32 uNBufsInStrm;	/* Current # of bufs in stream */
+	u32 ulNBytes;		/* bytes transferred since idled */
+	enum DSP_STREAMSTATE strmState;	/* STREAM_IDLE, STREAM_READY, ... */
+	HANDLE hUserEvent;	/* Saved for STRM_GetInfo() */
+	enum DSP_STRMMODE lMode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
+	u32 uDMAChnlId;	/* DMA chnl id */
+	u32 uDMAPriority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
+	u32 uSegment;		/* >0 is SM segment.=0 is local heap */
+	u32 uAlignment;	/* Alignment for stream bufs */
+	struct CMM_XLATOROBJECT *hXlator;  /* Stream's SM address translator */
+} ;
+
+/*  ----------------------------------- Globals */
+static u32 cRefs;		/* module reference count */
+
+/*  ----------------------------------- Function Prototypes */
+static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm);
+static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr);
+
+/*
+ *  ======== STRM_AllocateBuffer ========
+ *  Purpose:
+ *      Allocates buffers for a stream.
+ */
+DSP_STATUS STRM_AllocateBuffer(struct STRM_OBJECT *hStrm, u32 uSize,
+				OUT u8 **apBuffer, u32 uNumBufs,
+				struct PROCESS_CONTEXT *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 uAllocated = 0;
+	u32 i;
+
+	HANDLE hSTRMRes;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(apBuffer != NULL);
+
+	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		/*
+		 * Allocate from segment specified at time of stream open.
+		 */
+		if (uSize == 0)
+			status = DSP_ESIZE;
+
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	for (i = 0; i < uNumBufs; i++) {
+		DBC_Assert(hStrm->hXlator != NULL);
+		(void)CMM_XlatorAllocBuf(hStrm->hXlator, &apBuffer[i], uSize);
+		if (apBuffer[i] == NULL) {
+			status = DSP_EMEMORY;
+			uAllocated = i;
+			break;
+		}
+	}
+	if (DSP_FAILED(status))
+		STRM_FreeBuffer(hStrm, apBuffer, uAllocated, pr_ctxt);
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND)
+		DRV_ProcUpdateSTRMRes(uNumBufs, hSTRMRes);
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== STRM_Close ========
+ *  Purpose:
+ *      Close a stream opened with STRM_Open().
+ */
+DSP_STATUS STRM_Close(struct STRM_OBJECT *hStrm,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct CHNL_INFO chnlInfo;
+	DSP_STATUS status = DSP_SOK;
+
+	HANDLE	      hSTRMRes;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		/* Have all buffers been reclaimed? If not, return
+		 * DSP_EPENDING */
+		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+		status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
+		DBC_Assert(DSP_SUCCEEDED(status));
+
+		if (chnlInfo.cIOCs > 0 || chnlInfo.cIOReqs > 0)
+			status = DSP_EPENDING;
+		else
+			status = DeleteStrm(hStrm);
+	}
+
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (DRV_GetSTRMResElement(hStrm, &hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND)
+		DRV_ProcRemoveSTRMResElement(hSTRMRes, pr_ctxt);
+func_end:
+	DBC_Ensure(status == DSP_SOK || status == DSP_EHANDLE ||
+		  status == DSP_EPENDING || status == DSP_EFAIL);
+
+	dev_dbg(bridge, "%s: hStrm: %p, status 0x%x\n", __func__,
+							hStrm, status);
+	return status;
+}
+
+/*
+ *  ======== STRM_Create ========
+ *  Purpose:
+ *      Create a STRM manager object.
+ */
+DSP_STATUS STRM_Create(OUT struct STRM_MGR **phStrmMgr, struct DEV_OBJECT *hDev)
+{
+	struct STRM_MGR *pStrmMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phStrmMgr != NULL);
+	DBC_Require(hDev != NULL);
+
+	*phStrmMgr = NULL;
+	/* Allocate STRM manager object */
+	MEM_AllocObject(pStrmMgr, struct STRM_MGR, STRMMGR_SIGNATURE);
+	if (pStrmMgr == NULL)
+		status = DSP_EMEMORY;
+	else
+		pStrmMgr->hDev = hDev;
+
+	/* Get Channel manager and WMD function interface */
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetChnlMgr(hDev, &(pStrmMgr->hChnlMgr));
+		if (DSP_SUCCEEDED(status)) {
+			(void) DEV_GetIntfFxns(hDev, &(pStrmMgr->pIntfFxns));
+			DBC_Assert(pStrmMgr->pIntfFxns != NULL);
+		}
+	}
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_InitializeCS(&pStrmMgr->hSync);
+
+	if (DSP_SUCCEEDED(status))
+		*phStrmMgr = pStrmMgr;
+	else
+		DeleteStrmMgr(pStrmMgr);
+
+	DBC_Ensure(DSP_SUCCEEDED(status) &&
+		  (MEM_IsValidHandle((*phStrmMgr), STRMMGR_SIGNATURE) ||
+		  (DSP_FAILED(status) && *phStrmMgr == NULL)));
+
+	return status;
+}
+
+/*
+ *  ======== STRM_Delete ========
+ *  Purpose:
+ *      Delete the STRM Manager Object.
+ */
+void STRM_Delete(struct STRM_MGR *hStrmMgr)
+{
+	DBC_Require(cRefs > 0);
+	DBC_Require(MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+
+	DeleteStrmMgr(hStrmMgr);
+
+	DBC_Ensure(!MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE));
+}
+
+/*
+ *  ======== STRM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of STRM module.
+ */
+void STRM_Exit(void)
+{
+	DBC_Require(cRefs > 0);
+
+	cRefs--;
+
+	DBC_Ensure(cRefs >= 0);
+}
+
+/*
+ *  ======== STRM_FreeBuffer ========
+ *  Purpose:
+ *      Frees the buffers allocated for a stream.
+ */
+DSP_STATUS STRM_FreeBuffer(struct STRM_OBJECT *hStrm, u8 **apBuffer,
+		u32 uNumBufs, struct PROCESS_CONTEXT *pr_ctxt)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 i = 0;
+
+	HANDLE hSTRMRes = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(apBuffer != NULL);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE))
+		status = DSP_EHANDLE;
+
+	if (DSP_SUCCEEDED(status)) {
+		for (i = 0; i < uNumBufs; i++) {
+			DBC_Assert(hStrm->hXlator != NULL);
+			status = CMM_XlatorFreeBuf(hStrm->hXlator, apBuffer[i]);
+			if (DSP_FAILED(status))
+				break;
+			apBuffer[i] = NULL;
+		}
+	}
+	if (DRV_GetSTRMResElement(hStrm, hSTRMRes, pr_ctxt) !=
+			DSP_ENOTFOUND)
+		DRV_ProcUpdateSTRMRes(uNumBufs-i, hSTRMRes);
+
+	return status;
+}
+
+/*
+ *  ======== STRM_GetInfo ========
+ *  Purpose:
+ *      Retrieves information about a stream.
+ */
+DSP_STATUS STRM_GetInfo(struct STRM_OBJECT *hStrm,
+			OUT struct STRM_INFO *pStreamInfo,
+			u32 uStreamInfoSize)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct CHNL_INFO chnlInfo;
+	DSP_STATUS status = DSP_SOK;
+	void *pVirtBase = NULL;	/* NULL if no SM used */
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pStreamInfo != NULL);
+	DBC_Require(uStreamInfoSize >= sizeof(struct STRM_INFO));
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		if (uStreamInfoSize < sizeof(struct STRM_INFO)) {
+			/* size of users info */
+			status = DSP_ESIZE;
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+	status = (*pIntfFxns->pfnChnlGetInfo) (hStrm->hChnl, &chnlInfo);
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (hStrm->hXlator) {
+		/* We have a translator */
+		DBC_Assert(hStrm->uSegment > 0);
+		CMM_XlatorInfo(hStrm->hXlator, (u8 **)&pVirtBase, 0,
+			      hStrm->uSegment, false);
+	}
+	pStreamInfo->uSegment = hStrm->uSegment;
+	pStreamInfo->lMode = hStrm->lMode;
+	pStreamInfo->pVirtBase = pVirtBase;
+	pStreamInfo->pUser->uNumberBufsAllowed = hStrm->uNumBufs;
+	pStreamInfo->pUser->uNumberBufsInStream = chnlInfo.cIOCs +
+						 chnlInfo.cIOReqs;
+	/* # of bytes transferred since last call to DSPStream_Idle() */
+	pStreamInfo->pUser->ulNumberBytes = chnlInfo.cPosition;
+	pStreamInfo->pUser->hSyncObjectHandle = chnlInfo.hEvent;
+	/* Determine stream state based on channel state and info */
+	if (chnlInfo.dwState & CHNL_STATEEOS) {
+		pStreamInfo->pUser->ssStreamState = STREAM_DONE;
+	} else {
+		if (chnlInfo.cIOCs > 0)
+			pStreamInfo->pUser->ssStreamState = STREAM_READY;
+		else if (chnlInfo.cIOReqs > 0)
+			pStreamInfo->pUser->ssStreamState = STREAM_PENDING;
+		else
+			pStreamInfo->pUser->ssStreamState = STREAM_IDLE;
+
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== STRM_Idle ========
+ *  Purpose:
+ *      Idles a particular stream.
+ */
+DSP_STATUS STRM_Idle(struct STRM_OBJECT *hStrm, bool fFlush)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+
+		status = (*pIntfFxns->pfnChnlIdle) (hStrm->hChnl,
+			 hStrm->uTimeout, fFlush);
+	}
+
+	dev_dbg(bridge, "%s: hStrm: %p fFlush: 0x%x status: 0x%x\n",
+					__func__, hStrm, fFlush, status);
+	return status;
+}
+
+/*
+ *  ======== STRM_Init ========
+ *  Purpose:
+ *      Initialize the STRM module.
+ */
+bool STRM_Init(void)
+{
+	bool fRetVal = true;
+
+	DBC_Require(cRefs >= 0);
+
+	if (fRetVal)
+		cRefs++;
+
+	DBC_Ensure((fRetVal && (cRefs > 0)) || (!fRetVal && (cRefs >= 0)));
+
+	return fRetVal;
+}
+
+/*
+ *  ======== STRM_Issue ========
+ *  Purpose:
+ *      Issues a buffer on a stream
+ */
+DSP_STATUS STRM_Issue(struct STRM_OBJECT *hStrm, IN u8 *pBuf, u32 ulBytes,
+		     u32 ulBufSize, u32 dwArg)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+	void *pTmpBuf = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBuf != NULL);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else {
+		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+
+		if (hStrm->uSegment != 0) {
+			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
+					(void *)pBuf, CMM_VA2DSPPA);
+			if (pTmpBuf == NULL)
+				status = DSP_ETRANSLATE;
+
+		}
+		if (DSP_SUCCEEDED(status)) {
+			status = (*pIntfFxns->pfnChnlAddIOReq)
+				 (hStrm->hChnl, pBuf, ulBytes, ulBufSize,
+				 (u32) pTmpBuf, dwArg);
+		}
+		if (status == CHNL_E_NOIORPS)
+			status = DSP_ESTREAMFULL;
+	}
+
+	dev_dbg(bridge, "%s: hStrm: %p pBuf: %p ulBytes: 0x%x dwArg: 0x%x "
+					"status: 0x%x\n", __func__, hStrm, pBuf,
+					ulBytes, dwArg, status);
+	return status;
+}
+
+/*
+ *  ======== STRM_Open ========
+ *  Purpose:
+ *      Open a stream for sending/receiving data buffers to/from a task or
+ *      XDAIS socket node on the DSP.
+ */
+DSP_STATUS STRM_Open(struct NODE_OBJECT *hNode, u32 uDir, u32 uIndex,
+		IN struct STRM_ATTR *pAttr,
+		OUT struct STRM_OBJECT **phStrm,
+		struct PROCESS_CONTEXT *pr_ctxt)
+{
+	struct STRM_MGR *hStrmMgr;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	u32 ulChnlId;
+	struct STRM_OBJECT *pStrm = NULL;
+	short int uMode;
+	struct CHNL_ATTRS chnlAttrs;
+	DSP_STATUS status = DSP_SOK;
+	struct CMM_OBJECT *hCmmMgr = NULL;	/* Shared memory manager hndl */
+
+	HANDLE hSTRMRes;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(phStrm != NULL);
+	DBC_Require(pAttr != NULL);
+	*phStrm = NULL;
+	if (uDir != DSP_TONODE && uDir != DSP_FROMNODE) {
+		status = DSP_EDIRECTION;
+	} else {
+		/* Get the channel id from the node (set in NODE_Connect()) */
+		status = NODE_GetChannelId(hNode, uDir, uIndex, &ulChnlId);
+	}
+	if (DSP_SUCCEEDED(status))
+		status = NODE_GetStrmMgr(hNode, &hStrmMgr);
+
+	if (DSP_SUCCEEDED(status)) {
+		MEM_AllocObject(pStrm, struct STRM_OBJECT, STRM_SIGNATURE);
+		if (pStrm == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			pStrm->hStrmMgr = hStrmMgr;
+			pStrm->uDir = uDir;
+			pStrm->strmState = STREAM_IDLE;
+			pStrm->hUserEvent = pAttr->hUserEvent;
+			if (pAttr->pStreamAttrIn != NULL) {
+				pStrm->uTimeout = pAttr->pStreamAttrIn->
+						  uTimeout;
+				pStrm->uNumBufs = pAttr->pStreamAttrIn->
+						  uNumBufs;
+				pStrm->lMode = pAttr->pStreamAttrIn->lMode;
+				pStrm->uSegment = pAttr->pStreamAttrIn->
+						  uSegment;
+				pStrm->uAlignment = pAttr->pStreamAttrIn->
+						    uAlignment;
+				pStrm->uDMAChnlId = pAttr->pStreamAttrIn->
+						    uDMAChnlId;
+				pStrm->uDMAPriority = pAttr->pStreamAttrIn->
+						      uDMAPriority;
+				chnlAttrs.uIOReqs = pAttr->pStreamAttrIn->
+						    uNumBufs;
+			} else {
+				pStrm->uTimeout = DEFAULTTIMEOUT;
+				pStrm->uNumBufs = DEFAULTNUMBUFS;
+				pStrm->lMode = STRMMODE_PROCCOPY;
+				pStrm->uSegment = 0;	/* local memory */
+				pStrm->uAlignment = 0;
+				pStrm->uDMAChnlId = 0;
+				pStrm->uDMAPriority = 0;
+				chnlAttrs.uIOReqs = DEFAULTNUMBUFS;
+			}
+			chnlAttrs.hReserved1 = NULL;
+			/* DMA chnl flush timeout */
+			chnlAttrs.hReserved2 = pStrm->uTimeout;
+			chnlAttrs.hEvent = NULL;
+			if (pAttr->hUserEvent != NULL)
+				chnlAttrs.hEvent = pAttr->hUserEvent;
+
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_cont;
+
+	if ((pAttr->pVirtBase == NULL) || !(pAttr->ulVirtSize > 0))
+		goto func_cont;
+
+	DBC_Assert(pStrm->lMode != STRMMODE_LDMA);	/* no System DMA */
+	/* Get the shared mem mgr for this streams dev object */
+	status = DEV_GetCmmMgr(hStrmMgr->hDev, &hCmmMgr);
+	if (DSP_SUCCEEDED(status)) {
+		/*Allocate a SM addr translator for this strm.*/
+		status = CMM_XlatorCreate(&pStrm->hXlator, hCmmMgr, NULL);
+		if (DSP_SUCCEEDED(status)) {
+			DBC_Assert(pStrm->uSegment > 0);
+			/*  Set translators Virt Addr attributes */
+			status = CMM_XlatorInfo(pStrm->hXlator,
+				 (u8 **)&pAttr->pVirtBase, pAttr->ulVirtSize,
+				 pStrm->uSegment, true);
+		}
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status)) {
+		/* Open channel */
+		uMode = (uDir == DSP_TONODE) ?
+			CHNL_MODETODSP : CHNL_MODEFROMDSP;
+		pIntfFxns = hStrmMgr->pIntfFxns;
+		status = (*pIntfFxns->pfnChnlOpen) (&(pStrm->hChnl),
+			 hStrmMgr->hChnlMgr, uMode, ulChnlId, &chnlAttrs);
+		if (DSP_FAILED(status)) {
+			/*
+			 * over-ride non-returnable status codes so we return
+			 * something documented
+			 */
+			if (status != DSP_EMEMORY && status !=
+			   DSP_EINVALIDARG && status != DSP_EFAIL) {
+				/*
+				 * We got a status that's not return-able.
+				 * Assert that we got something we were
+				 * expecting (DSP_EHANDLE isn't acceptable,
+				 * hStrmMgr->hChnlMgr better be valid or we
+				 * assert here), and then return DSP_EFAIL.
+				 */
+				DBC_Assert(status == CHNL_E_OUTOFSTREAMS ||
+					   status == CHNL_E_BADCHANID ||
+					   status == CHNL_E_CHANBUSY ||
+					   status == CHNL_E_NOIORPS);
+				status = DSP_EFAIL;
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		*phStrm = pStrm;
+		DRV_ProcInsertSTRMResElement(*phStrm, &hSTRMRes, pr_ctxt);
+	} else {
+		(void)DeleteStrm(pStrm);
+	}
+
+	 /* ensure we return a documented error code */
+	DBC_Ensure((DSP_SUCCEEDED(status) &&
+		  MEM_IsValidHandle((*phStrm), STRM_SIGNATURE)) ||
+		  (*phStrm == NULL && (status == DSP_EHANDLE ||
+		  status == DSP_EDIRECTION || status == DSP_EVALUE ||
+		  status == DSP_EFAIL)));
+
+	dev_dbg(bridge, "%s: hNode: %p uDir: 0x%x uIndex: 0x%x pAttr: %p "
+				"phStrm: %p status: 0x%x\n", __func__,
+				hNode, uDir, uIndex, pAttr, phStrm, status);
+	return status;
+}
+
+/*
+ *  ======== STRM_Reclaim ========
+ *  Purpose:
+ *      Relcaims a buffer from a stream.
+ */
+DSP_STATUS STRM_Reclaim(struct STRM_OBJECT *hStrm, OUT u8 **pBufPtr,
+			u32 *pulBytes, u32 *pulBufSize, u32 *pdwArg)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct CHNL_IOC chnlIOC;
+	DSP_STATUS status = DSP_SOK;
+	void *pTmpBuf = NULL;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(pBufPtr != NULL);
+	DBC_Require(pulBytes != NULL);
+	DBC_Require(pdwArg != NULL);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+
+	status = (*pIntfFxns->pfnChnlGetIOC)(hStrm->hChnl, hStrm->uTimeout,
+		 &chnlIOC);
+	if (DSP_SUCCEEDED(status)) {
+		*pulBytes = chnlIOC.cBytes;
+		if (pulBufSize)
+			*pulBufSize = chnlIOC.cBufSize;
+
+		*pdwArg = chnlIOC.dwArg;
+		if (!CHNL_IsIOComplete(chnlIOC)) {
+			if (CHNL_IsTimedOut(chnlIOC)) {
+				status = DSP_ETIMEOUT;
+			} else {
+				/* Allow reclaims after idle to succeed */
+				if (!CHNL_IsIOCancelled(chnlIOC))
+					status = DSP_EFAIL;
+
+			}
+		}
+		/* Translate zerocopy buffer if channel not canceled. */
+		if (DSP_SUCCEEDED(status) && (!CHNL_IsIOCancelled(chnlIOC)) &&
+		   (hStrm->lMode == STRMMODE_ZEROCOPY)) {
+			/*
+			 *  This is a zero-copy channel so chnlIOC.pBuf
+			 *  contains the DSP address of SM. We need to
+			 *  translate it to a virtual address for the user
+			 *  thread to access.
+			 *  Note: Could add CMM_DSPPA2VA to CMM in the future.
+			 */
+			pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
+					chnlIOC.pBuf, CMM_DSPPA2PA);
+			if (pTmpBuf != NULL) {
+				/* now convert this GPP Pa to Va */
+				pTmpBuf = CMM_XlatorTranslate(hStrm->hXlator,
+					  pTmpBuf, CMM_PA2VA);
+			}
+			if (pTmpBuf == NULL)
+				status = DSP_ETRANSLATE;
+
+			chnlIOC.pBuf = pTmpBuf;
+		}
+		*pBufPtr = chnlIOC.pBuf;
+	}
+func_end:
+	/* ensure we return a documented return code */
+	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		  status == DSP_EFAIL);
+
+	dev_dbg(bridge, "%s: hStrm: %p pBufPtr: %p pulBytes: %p pdwArg: %p "
+					"status 0x%x\n", __func__, hStrm,
+					pBufPtr, pulBytes, pdwArg, status);
+	return status;
+}
+
+/*
+ *  ======== STRM_RegisterNotify ========
+ *  Purpose:
+ *      Register to be notified on specific events for this stream.
+ */
+DSP_STATUS STRM_RegisterNotify(struct STRM_OBJECT *hStrm, u32 uEventMask,
+			      u32 uNotifyType, struct DSP_NOTIFICATION
+			      *hNotification)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(hNotification != NULL);
+
+	if (!MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else if ((uEventMask & ~((DSP_STREAMIOCOMPLETION) |
+		 DSP_STREAMDONE)) != 0) {
+		status = DSP_EVALUE;
+	} else {
+		if (uNotifyType != DSP_SIGNALEVENT)
+			status = DSP_ENOTIMPL;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+
+		status = (*pIntfFxns->pfnChnlRegisterNotify)(hStrm->hChnl,
+			 uEventMask, uNotifyType, hNotification);
+	}
+	/* ensure we return a documented return code */
+	DBC_Ensure(DSP_SUCCEEDED(status) || status == DSP_EHANDLE ||
+		  status == DSP_ETIMEOUT || status == DSP_ETRANSLATE ||
+		  status == DSP_ENOTIMPL || status == DSP_EFAIL);
+	return status;
+}
+
+/*
+ *  ======== STRM_Select ========
+ *  Purpose:
+ *      Selects a ready stream.
+ */
+DSP_STATUS STRM_Select(IN struct STRM_OBJECT **aStrmTab, u32 nStrms,
+		      OUT u32 *pMask, u32 uTimeout)
+{
+	u32 uIndex;
+	struct CHNL_INFO chnlInfo;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct SYNC_OBJECT **hSyncEvents = NULL;
+	u32 i;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(cRefs > 0);
+	DBC_Require(aStrmTab != NULL);
+	DBC_Require(pMask != NULL);
+	DBC_Require(nStrms > 0);
+
+	*pMask = 0;
+	for (i = 0; i < nStrms; i++) {
+		if (!MEM_IsValidHandle(aStrmTab[i], STRM_SIGNATURE)) {
+			status = DSP_EHANDLE;
+			break;
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	/* Determine which channels have IO ready */
+	for (i = 0; i < nStrms; i++) {
+		pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
+		status = (*pIntfFxns->pfnChnlGetInfo)(aStrmTab[i]->hChnl,
+			 &chnlInfo);
+		if (DSP_FAILED(status)) {
+			break;
+		} else {
+			if (chnlInfo.cIOCs > 0)
+				*pMask |= (1 << i);
+
+		}
+	}
+	if (DSP_SUCCEEDED(status) && uTimeout > 0 && *pMask == 0) {
+		/* Non-zero timeout */
+		hSyncEvents = (struct SYNC_OBJECT **)MEM_Alloc(nStrms *
+			      sizeof(struct SYNC_OBJECT *), MEM_PAGED);
+		if (hSyncEvents == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			for (i = 0; i < nStrms; i++) {
+				pIntfFxns = aStrmTab[i]->hStrmMgr->pIntfFxns;
+				status = (*pIntfFxns->pfnChnlGetInfo)
+					 (aStrmTab[i]->hChnl, &chnlInfo);
+				if (DSP_FAILED(status))
+					break;
+				else
+					hSyncEvents[i] = chnlInfo.hSyncEvent;
+
+			}
+		}
+		if (DSP_SUCCEEDED(status)) {
+			status = SYNC_WaitOnMultipleEvents(hSyncEvents, nStrms,
+				uTimeout, &uIndex);
+			if (DSP_SUCCEEDED(status)) {
+				/* Since we waited on the event, we have to
+				 * reset it */
+				SYNC_SetEvent(hSyncEvents[uIndex]);
+				*pMask = 1 << uIndex;
+			}
+		}
+	}
+func_end:
+	kfree(hSyncEvents);
+
+	DBC_Ensure((DSP_SUCCEEDED(status) && (*pMask != 0 || uTimeout == 0)) ||
+		  (DSP_FAILED(status) && *pMask == 0));
+
+	return status;
+}
+
+/*
+ *  ======== DeleteStrm ========
+ *  Purpose:
+ *      Frees the resources allocated for a stream.
+ */
+static DSP_STATUS DeleteStrm(struct STRM_OBJECT *hStrm)
+{
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	DSP_STATUS status = DSP_SOK;
+
+	if (MEM_IsValidHandle(hStrm, STRM_SIGNATURE)) {
+		if (hStrm->hChnl) {
+			pIntfFxns = hStrm->hStrmMgr->pIntfFxns;
+			/* Channel close can fail only if the channel handle
+			 * is invalid. */
+			status = (*pIntfFxns->pfnChnlClose) (hStrm->hChnl);
+			/* Free all SM address translator resources */
+			if (DSP_SUCCEEDED(status)) {
+				if (hStrm->hXlator) {
+					/* force free */
+					(void)CMM_XlatorDelete(hStrm->hXlator,
+					true);
+				}
+			}
+		}
+		MEM_FreeObject(hStrm);
+	} else {
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== DeleteStrmMgr ========
+ *  Purpose:
+ *      Frees stream manager.
+ */
+static void DeleteStrmMgr(struct STRM_MGR *hStrmMgr)
+{
+	if (MEM_IsValidHandle(hStrmMgr, STRMMGR_SIGNATURE)) {
+
+		if (hStrmMgr->hSync)
+			SYNC_DeleteCS(hStrmMgr->hSync);
+
+		MEM_FreeObject(hStrmMgr);
+	}
+}
+
diff --git a/drivers/dsp/bridge/services/cfg.c b/drivers/dsp/bridge/services/cfg.c
new file mode 100644
index 0000000..4f8896a
--- /dev/null
+++ b/drivers/dsp/bridge/services/cfg.c
@@ -0,0 +1,309 @@
+/*
+ * cfg.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation of platform specific config services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/reg.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/cfg.h>
+
+struct DRV_EXT {
+	struct list_head link;
+	char szString[MAXREGPATHLENGTH];
+};
+
+/*
+ *  ======== CFG_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the CFG module.
+ */
+void CFG_Exit(void)
+{
+	/* Do nothing */
+}
+
+/*
+ *  ======== CFG_GetAutoStart ========
+ *  Purpose:
+ *      Retreive the autostart mask, if any, for this board.
+ */
+DSP_STATUS CFG_GetAutoStart(struct CFG_DEVNODE *hDevNode,
+			    OUT u32 *pdwAutoStart)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 dwBufSize;
+
+	dwBufSize = sizeof(*pdwAutoStart);
+	if (!hDevNode)
+		status = CFG_E_INVALIDHDEVNODE;
+	if (!pdwAutoStart)
+		status = CFG_E_INVALIDPOINTER;
+	if (DSP_SUCCEEDED(status)) {
+		status = REG_GetValue(AUTOSTART, (u8 *)pdwAutoStart,
+				      &dwBufSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
+	}
+
+	DBC_Ensure((status == DSP_SOK &&
+		(*pdwAutoStart == 0 || *pdwAutoStart == 1))
+		|| status != DSP_SOK);
+	return status;
+}
+
+/*
+ *  ======== CFG_GetDevObject ========
+ *  Purpose:
+ *      Retrieve the Device Object handle for a given devnode.
+ */
+DSP_STATUS CFG_GetDevObject(struct CFG_DEVNODE *hDevNode, OUT u32 *pdwValue)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 dwBufSize;
+
+	if (!hDevNode)
+		status = CFG_E_INVALIDHDEVNODE;
+
+	if (!pdwValue)
+		status = CFG_E_INVALIDHDEVNODE;
+
+	dwBufSize = sizeof(pdwValue);
+	if (DSP_SUCCEEDED(status)) {
+
+		/* check the device string and then call the REG_SetValue*/
+		if (!(strcmp((char *)((struct DRV_EXT *)hDevNode)->szString,
+							"TIOMAP1510")))
+			status = REG_GetValue("DEVICE_DSP", (u8 *)pdwValue,
+					      &dwBufSize);
+	}
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	return status;
+}
+
+/*
+ *  ======== CFG_GetDSPResources ========
+ *  Purpose:
+ *      Get the DSP resources available to a given device.
+ */
+DSP_STATUS CFG_GetDSPResources(struct CFG_DEVNODE *hDevNode,
+			       OUT struct CFG_DSPRES *pDSPResTable)
+{
+	DSP_STATUS status = DSP_SOK;	/* return value */
+	u32 dwResSize;
+
+	if (!hDevNode) {
+		status = CFG_E_INVALIDHDEVNODE;
+	} else if (!pDSPResTable) {
+		status = CFG_E_INVALIDPOINTER;
+	} else {
+		status = REG_GetValue(DSPRESOURCES, (u8 *)pDSPResTable,
+				     &dwResSize);
+	}
+	if (DSP_FAILED(status)) {
+		status = CFG_E_RESOURCENOTAVAIL;
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	}
+	/* assert that resource values are reasonable */
+	DBC_Assert(pDSPResTable->uChipType < 256);
+	DBC_Assert(pDSPResTable->uWordSize > 0);
+	DBC_Assert(pDSPResTable->uWordSize < 32);
+	DBC_Assert(pDSPResTable->cChips > 0);
+	DBC_Assert(pDSPResTable->cChips < 256);
+	return status;
+}
+
+/*
+ *  ======== CFG_GetExecFile ========
+ *  Purpose:
+ *      Retreive the default executable, if any, for this board.
+ */
+DSP_STATUS CFG_GetExecFile(struct CFG_DEVNODE *hDevNode, u32 ulBufSize,
+			   OUT char *pstrExecFile)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 cExecSize = ulBufSize;
+
+	if (!hDevNode)
+		status = CFG_E_INVALIDHDEVNODE;
+	else if (!pstrExecFile)
+		status = CFG_E_INVALIDPOINTER;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = REG_GetValue(DEFEXEC, (u8 *)pstrExecFile, &cExecSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
+		else if (cExecSize > ulBufSize)
+			status = DSP_ESIZE;
+
+	}
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	DBC_Ensure(((status == DSP_SOK) &&
+		(strlen(pstrExecFile) <= ulBufSize)) || (status != DSP_SOK));
+	return status;
+}
+
+/*
+ *  ======== CFG_GetHostResources ========
+ *  Purpose:
+ *      Get the Host allocated resources assigned to a given device.
+ */
+DSP_STATUS CFG_GetHostResources(struct CFG_DEVNODE *hDevNode,
+				OUT struct CFG_HOSTRES *pHostResTable)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 dwBufSize;
+
+	if (!hDevNode)
+		status = CFG_E_INVALIDHDEVNODE;
+
+	if (!pHostResTable)
+		status = CFG_E_INVALIDPOINTER;
+
+	if (DSP_SUCCEEDED(status)) {
+		dwBufSize = sizeof(struct CFG_HOSTRES);
+		if (DSP_FAILED(REG_GetValue(CURRENTCONFIG, (u8 *)pHostResTable,
+					    &dwBufSize))) {
+			status = CFG_E_RESOURCENOTAVAIL;
+		}
+	}
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s Failed, status 0x%x\n", __func__, status);
+	return status;
+}
+
+/*
+ *  ======== CFG_GetObject ========
+ *  Purpose:
+ *      Retrieve the Object handle from the Registry
+ */
+DSP_STATUS CFG_GetObject(OUT u32 *pdwValue, u32 dwType)
+{
+	DSP_STATUS status = DSP_EINVALIDARG;
+	u32 dwBufSize;
+	DBC_Require(pdwValue != NULL);
+
+	dwBufSize = sizeof(pdwValue);
+	switch (dwType) {
+	case (REG_DRV_OBJECT):
+		status = REG_GetValue(DRVOBJECT, (u8 *)pdwValue, &dwBufSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
+		break;
+	case (REG_MGR_OBJECT):
+		status = REG_GetValue(MGROBJECT, (u8 *)pdwValue, &dwBufSize);
+		if (DSP_FAILED(status))
+			status = CFG_E_RESOURCENOTAVAIL;
+		break;
+	default:
+		break;
+	}
+	if (DSP_FAILED(status)) {
+		*pdwValue = 0;
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	}
+	DBC_Ensure((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
+		   (DSP_FAILED(status) && *pdwValue == 0));
+	return status;
+}
+
+/*
+ *  ======== CFG_Init ========
+ *  Purpose:
+ *      Initialize the CFG module's private state.
+ */
+bool CFG_Init(void)
+{
+	struct CFG_DSPRES dspResources;
+
+	dspResources.uChipType = DSPTYPE_64;
+	dspResources.cChips = 1;
+	dspResources.uWordSize = DSPWORDSIZE;
+	dspResources.cMemTypes = 0;
+	dspResources.aMemDesc[0].uMemType = 0;
+	dspResources.aMemDesc[0].ulMin = 0;
+	dspResources.aMemDesc[0].ulMax = 0;
+	if (DSP_FAILED(REG_SetValue(DSPRESOURCES, (u8 *)&dspResources,
+				       sizeof(struct CFG_DSPRES))))
+		pr_err("Failed to initialize DSP resources in registry\n");
+
+	return true;
+}
+
+/*
+ *  ======== CFG_SetDevObject ========
+ *  Purpose:
+ *      Store the Device Object handle and devNode pointer for a given devnode.
+ */
+DSP_STATUS CFG_SetDevObject(struct CFG_DEVNODE *hDevNode, u32 dwValue)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 dwBuffSize;
+
+	if (!hDevNode)
+		status = CFG_E_INVALIDHDEVNODE;
+
+	dwBuffSize = sizeof(dwValue);
+	if (DSP_SUCCEEDED(status)) {
+		/* Store the WCD device object in the Registry */
+
+		if (!(strcmp((char *)hDevNode, "TIOMAP1510"))) {
+			status = REG_SetValue("DEVICE_DSP", (u8 *)&dwValue,
+						dwBuffSize);
+		}
+	}
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+
+	return status;
+}
+
+/*
+ *  ======== CFG_SetObject ========
+ *  Purpose:
+ *      Store the Driver Object handle
+ */
+DSP_STATUS CFG_SetObject(u32 dwValue, u32 dwType)
+{
+	DSP_STATUS status = DSP_EINVALIDARG;
+	u32 dwBuffSize;
+
+	dwBuffSize = sizeof(dwValue);
+	switch (dwType) {
+	case (REG_DRV_OBJECT):
+		status = REG_SetValue(DRVOBJECT, (u8 *)&dwValue, dwBuffSize);
+		break;
+	case (REG_MGR_OBJECT):
+		status = REG_SetValue(MGROBJECT, (u8 *) &dwValue, dwBuffSize);
+		break;
+	default:
+		break;
+	}
+	if (DSP_FAILED(status))
+		pr_err("%s: Failed, status 0x%x\n", __func__, status);
+	return status;
+}
diff --git a/drivers/dsp/bridge/services/clk.c b/drivers/dsp/bridge/services/clk.c
new file mode 100644
index 0000000..4ef4290
--- /dev/null
+++ b/drivers/dsp/bridge/services/clk.c
@@ -0,0 +1,328 @@
+/*
+ * clk.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Clock and Timer services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/clk.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+
+typedef volatile unsigned long  REG_UWORD32;
+
+#define OMAP_SSI_OFFSET			0x58000
+#define OMAP_SSI_SIZE			0x1000
+#define OMAP_SSI_SYSCONFIG_OFFSET	0x10
+
+#define SSI_AUTOIDLE			(1 << 0)
+#define SSI_SIDLE_SMARTIDLE		(2 << 3)
+#define SSI_MIDLE_NOIDLE		(1 << 12)
+
+struct SERVICES_Clk_t {
+	struct clk *clk_handle;
+	const char *clk_name;
+	int id;
+};
+
+/* The row order of the below array needs to match with the clock enumerations
+ * 'SERVICES_ClkId' provided in the header file.. any changes in the
+ * enumerations needs to be fixed in the array as well */
+static struct SERVICES_Clk_t SERVICES_Clks[] = {
+	{NULL, "iva2_ck", -1},
+	{NULL, "mailboxes_ick", -1},
+	{NULL, "gpt5_fck", -1},
+	{NULL, "gpt5_ick", -1},
+	{NULL, "gpt6_fck", -1},
+	{NULL, "gpt6_ick", -1},
+	{NULL, "gpt7_fck", -1},
+	{NULL, "gpt7_ick", -1},
+	{NULL, "gpt8_fck", -1},
+	{NULL, "gpt8_ick", -1},
+	{NULL, "wdt_fck", 3},
+	{NULL, "wdt_ick", 3},
+	{NULL, "mcbsp_fck", 1},
+	{NULL, "mcbsp_ick", 1},
+	{NULL, "mcbsp_fck", 2},
+	{NULL, "mcbsp_ick", 2},
+	{NULL, "mcbsp_fck", 3},
+	{NULL, "mcbsp_ick", 3},
+	{NULL, "mcbsp_fck", 4},
+	{NULL, "mcbsp_ick", 4},
+	{NULL, "mcbsp_fck", 5},
+	{NULL, "mcbsp_ick", 5},
+	{NULL, "ssi_ssr_sst_fck", -1},
+	{NULL, "ssi_ick", -1},
+	{NULL, "omap_32k_fck", -1},
+	{NULL, "sys_ck", -1},
+	{NULL, ""}
+};
+
+/* Generic TIMER object: */
+struct TIMER_OBJECT {
+	struct timer_list timer;
+};
+
+/*
+ *  ======== CLK_Exit ========
+ *  Purpose:
+ *      Cleanup CLK module.
+ */
+void CLK_Exit(void)
+{
+	int i = 0;
+
+	/* Relinquish the clock handles */
+	while (i < SERVICESCLK_NOT_DEFINED) {
+		if (SERVICES_Clks[i].clk_handle)
+			clk_put(SERVICES_Clks[i].clk_handle);
+
+		SERVICES_Clks[i].clk_handle = NULL;
+		i++;
+	}
+
+}
+
+/*
+ *  ======== CLK_Init ========
+ *  Purpose:
+ *      Initialize CLK module.
+ */
+bool CLK_Init(void)
+{
+	static struct platform_device dspbridge_device;
+	struct clk *clk_handle;
+	int i = 0;
+
+	dspbridge_device.dev.bus = &platform_bus_type;
+
+	/* Get the clock handles from base port and store locally */
+	while (i < SERVICESCLK_NOT_DEFINED) {
+		/* get the handle from BP */
+		dspbridge_device.id = SERVICES_Clks[i].id;
+
+		clk_handle = clk_get(&dspbridge_device.dev,
+			     SERVICES_Clks[i].clk_name);
+
+		if (!clk_handle) {
+			pr_err("%s: failed to get clk handle %s, dev id = %d\n",
+				  __func__, SERVICES_Clks[i].clk_name,
+				  SERVICES_Clks[i].id);
+			/* should we fail here?? */
+		}
+		SERVICES_Clks[i].clk_handle = clk_handle;
+		i++;
+	}
+
+	return true;
+}
+
+/*
+ *  ======== CLK_Enable ========
+ *  Purpose:
+ *      Enable Clock .
+ *
+*/
+DSP_STATUS CLK_Enable(IN enum SERVICES_ClkId clk_id)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct clk *pClk;
+
+	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	pClk = SERVICES_Clks[clk_id].clk_handle;
+	if (pClk) {
+		if (clk_enable(pClk)) {
+			pr_err("CLK_Enable: failed to Enable CLK %s, "
+					"CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
+			status = DSP_EFAIL;
+		}
+	} else {
+		pr_err("CLK_Enable: failed to get CLK %s, CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
+		status = DSP_EFAIL;
+	}
+	/* The SSI module need to configured not to have the Forced idle for
+	 * master interface. If it is set to forced idle, the SSI module is
+	 * transitioning to standby thereby causing the client in the DSP hang
+	 * waiting for the SSI module to be active after enabling the clocks
+	 */
+	if (clk_id == SERVICESCLK_ssi_fck)
+		SSI_Clk_Prepare(true);
+
+	return status;
+}
+/*
+ *  ======== CLK_Set_32KHz ========
+ *  Purpose:
+ *      To Set parent of a clock to 32KHz.
+ */
+
+DSP_STATUS CLK_Set_32KHz(IN enum SERVICES_ClkId clk_id)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct clk *pClk;
+	struct clk *pClkParent;
+	pClkParent =  SERVICES_Clks[SERVICESCLK_sys_32k_ck].clk_handle;
+
+	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	pClk = SERVICES_Clks[clk_id].clk_handle;
+	if (pClk) {
+		if (!(clk_set_parent(pClk, pClkParent) == 0x0)) {
+			pr_err("%s: failed for %s, dev id = %d\n", __func__,
+				SERVICES_Clks[clk_id].clk_name,
+				SERVICES_Clks[clk_id].id);
+			status = DSP_EFAIL;
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== CLK_Disable ========
+ *  Purpose:
+ *      Disable the clock.
+ *
+*/
+DSP_STATUS CLK_Disable(IN enum SERVICES_ClkId clk_id)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct clk *pClk;
+	s32 clkUseCnt;
+
+	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	pClk = SERVICES_Clks[clk_id].clk_handle;
+
+	clkUseCnt = CLK_Get_UseCnt(clk_id);
+	if (clkUseCnt == -1) {
+		pr_err("CLK_Disable: failed to get CLK Use count for CLK %s,"
+				"CLK dev id = %d\n",
+				SERVICES_Clks[clk_id].clk_name,
+				SERVICES_Clks[clk_id].id);
+	} else if (clkUseCnt == 0) {
+		return status;
+	}
+	if (clk_id == SERVICESCLK_ssi_ick)
+		SSI_Clk_Prepare(false);
+
+		if (pClk) {
+			clk_disable(pClk);
+		} else {
+			pr_err("CLK_Disable: failed to get CLK %s,"
+					"CLK dev id = %d\n",
+					SERVICES_Clks[clk_id].clk_name,
+					SERVICES_Clks[clk_id].id);
+			status = DSP_EFAIL;
+		}
+	return status;
+}
+
+/*
+ *  ======== CLK_GetRate ========
+ *  Purpose:
+ *      GetClock Speed.
+ *
+ */
+
+DSP_STATUS CLK_GetRate(IN enum SERVICES_ClkId clk_id, u32 *speedKhz)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct clk *pClk;
+	u32 clkSpeedHz;
+
+	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+	*speedKhz = 0x0;
+
+	pClk = SERVICES_Clks[clk_id].clk_handle;
+	if (pClk) {
+		clkSpeedHz = clk_get_rate(pClk);
+		*speedKhz = clkSpeedHz / 1000;
+		dev_dbg(bridge, "%s: clkSpeedHz = %d, speedinKhz = %d\n",
+					__func__, clkSpeedHz, *speedKhz);
+	} else {
+		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
+						SERVICES_Clks[clk_id].clk_name,
+						SERVICES_Clks[clk_id].id);
+		status = DSP_EFAIL;
+	}
+	return status;
+}
+
+s32 CLK_Get_UseCnt(IN enum SERVICES_ClkId clk_id)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct clk *pClk;
+	s32 useCount = -1;
+	DBC_Require(clk_id < SERVICESCLK_NOT_DEFINED);
+
+	pClk = SERVICES_Clks[clk_id].clk_handle;
+
+	if (pClk) {
+		/* FIXME: usecount shouldn't be used */
+		useCount = pClk->usecount;
+	} else {
+		pr_err("%s: failed to get %s, dev Id = %d\n", __func__,
+						SERVICES_Clks[clk_id].clk_name,
+						SERVICES_Clks[clk_id].id);
+		status = DSP_EFAIL;
+	}
+	return useCount;
+}
+
+void SSI_Clk_Prepare(bool FLAG)
+{
+	void __iomem *ssi_base;
+	unsigned int value;
+
+	ssi_base = ioremap(L4_34XX_BASE + OMAP_SSI_OFFSET, OMAP_SSI_SIZE);
+	if (!ssi_base) {
+		pr_err("%s: error, SSI not configured\n", __func__);
+		return;
+	}
+
+	if (FLAG) {
+		/* Set Autoidle, SIDLEMode to smart idle, and MIDLEmode to
+		 * no idle
+		 */
+		value = SSI_AUTOIDLE | SSI_SIDLE_SMARTIDLE | SSI_MIDLE_NOIDLE;
+	} else {
+		/* Set Autoidle, SIDLEMode to forced idle, and MIDLEmode to
+		 * forced idle
+		 */
+		value = SSI_AUTOIDLE;
+	}
+
+	__raw_writel(value, ssi_base + OMAP_SSI_SYSCONFIG_OFFSET);
+	iounmap(ssi_base);
+}
diff --git a/drivers/dsp/bridge/services/mem.c b/drivers/dsp/bridge/services/mem.c
new file mode 100644
index 0000000..5ecc08c
--- /dev/null
+++ b/drivers/dsp/bridge/services/mem.c
@@ -0,0 +1,267 @@
+/*
+ * mem.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation of platform specific memory services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/mem.h>
+#include <dspbridge/list.h>
+
+/*  ----------------------------------- Defines */
+#define MEM_512MB   0x1fffffff
+
+/*  ----------------------------------- Globals */
+static bool extPhysMemPoolEnabled;
+
+struct extPhysMemPool {
+	u32 physMemBase;
+	u32 physMemSize;
+	u32 virtMemBase;
+	u32 nextPhysAllocPtr;
+};
+
+static struct extPhysMemPool extMemPool;
+
+void MEM_ExtPhysPoolInit(u32 poolPhysBase, u32 poolSize)
+{
+	u32 poolVirtBase;
+
+	/* get the virtual address for the physical memory pool passed */
+	poolVirtBase = (u32)ioremap(poolPhysBase, poolSize);
+
+	if ((void **)poolVirtBase == NULL) {
+		pr_err("%s: external physical memory map failed\n", __func__);
+		extPhysMemPoolEnabled = false;
+	} else {
+		extMemPool.physMemBase = poolPhysBase;
+		extMemPool.physMemSize = poolSize;
+		extMemPool.virtMemBase = poolVirtBase;
+		extMemPool.nextPhysAllocPtr = poolPhysBase;
+		extPhysMemPoolEnabled = true;
+	}
+}
+
+void MEM_ExtPhysPoolRelease(void)
+{
+	if (extPhysMemPoolEnabled) {
+		iounmap((void *)(extMemPool.virtMemBase));
+		extPhysMemPoolEnabled = false;
+	}
+}
+
+/*
+ *  ======== MEM_ExtPhysMemAlloc ========
+ *  Purpose:
+ *     Allocate physically contiguous, uncached memory from external memory pool
+ */
+
+static void *MEM_ExtPhysMemAlloc(u32 bytes, u32 align, OUT u32 *pPhysAddr)
+{
+	u32 newAllocPtr;
+	u32 offset;
+	u32 virtAddr;
+
+	if (align == 0)
+		align = 1;
+
+	if (bytes > ((extMemPool.physMemBase + extMemPool.physMemSize)
+	    - extMemPool.nextPhysAllocPtr)) {
+		pPhysAddr = NULL;
+		return NULL;
+	} else {
+		offset = (extMemPool.nextPhysAllocPtr & (align - 1));
+		if (offset == 0)
+			newAllocPtr = extMemPool.nextPhysAllocPtr;
+		else
+			newAllocPtr = (extMemPool.nextPhysAllocPtr) +
+				      (align - offset);
+		if ((newAllocPtr + bytes) <=
+		    (extMemPool.physMemBase + extMemPool.physMemSize)) {
+			/* we can allocate */
+			*pPhysAddr = newAllocPtr;
+			extMemPool.nextPhysAllocPtr = newAllocPtr + bytes;
+			virtAddr = extMemPool.virtMemBase + (newAllocPtr -
+				   extMemPool.physMemBase);
+			return (void *)virtAddr;
+		} else {
+			*pPhysAddr = 0;
+			return NULL;
+		}
+	}
+}
+
+/*
+ *  ======== MEM_Alloc ========
+ *  Purpose:
+ *      Allocate memory from the paged or non-paged pools.
+ */
+void *MEM_Alloc(u32 cBytes, enum MEM_POOLATTRS type)
+{
+	void *pMem = NULL;
+
+	if (cBytes > 0) {
+		switch (type) {
+		case MEM_NONPAGED:
+		/* If non-paged memory required, see note at top of file. */
+		case MEM_PAGED:
+			pMem = kmalloc(cBytes,
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			break;
+		case MEM_LARGEVIRTMEM:
+			pMem = vmalloc(cBytes);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	return pMem;
+}
+
+/*
+ *  ======== MEM_AllocPhysMem ========
+ *  Purpose:
+ *      Allocate physically contiguous, uncached memory
+ */
+void *MEM_AllocPhysMem(u32 cBytes, u32 ulAlign, OUT u32 *pPhysicalAddress)
+{
+	void *pVaMem = NULL;
+	dma_addr_t paMem;
+
+	if (cBytes > 0) {
+		if (extPhysMemPoolEnabled) {
+			pVaMem = MEM_ExtPhysMemAlloc(cBytes, ulAlign,
+						    (u32 *)&paMem);
+		} else
+			pVaMem = dma_alloc_coherent(NULL, cBytes, &paMem,
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+		if (pVaMem == NULL) {
+			*pPhysicalAddress = 0;
+		} else {
+			*pPhysicalAddress = paMem;
+		}
+	}
+	return pVaMem;
+}
+
+/*
+ *  ======== MEM_Calloc ========
+ *  Purpose:
+ *      Allocate zero-initialized memory from the paged or non-paged pools.
+ */
+void *MEM_Calloc(u32 cBytes, enum MEM_POOLATTRS type)
+{
+	void *pMem = NULL;
+
+	if (cBytes > 0) {
+		switch (type) {
+		case MEM_NONPAGED:
+		/* If non-paged memory required, see note at top of file. */
+		case MEM_PAGED:
+			pMem = kzalloc(cBytes,
+				(in_atomic()) ? GFP_ATOMIC : GFP_KERNEL);
+			break;
+		case MEM_LARGEVIRTMEM:
+			pMem = __vmalloc(cBytes,
+				GFP_KERNEL | __GFP_HIGHMEM | __GFP_ZERO,
+				PAGE_KERNEL);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return pMem;
+}
+
+/*
+ *  ======== MEM_Exit ========
+ *  Purpose:
+ *      Discontinue usage of the MEM module.
+ */
+void MEM_Exit(void)
+{
+}
+
+/*
+ *  ======== MEM_FlushCache ========
+ *  Purpose:
+ *      Flush cache
+ */
+void MEM_FlushCache(void *pMemBuf, u32 cBytes, s32 FlushType)
+{
+	if (!pMemBuf)
+		return;
+
+	switch (FlushType) {
+	/* invalidate only */
+	case PROC_INVALIDATE_MEM:
+		dmac_inv_range(pMemBuf, pMemBuf + cBytes);
+		outer_inv_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
+				cBytes));
+	break;
+	/* writeback only */
+	case PROC_WRITEBACK_MEM:
+		dmac_clean_range(pMemBuf, pMemBuf + cBytes);
+		outer_clean_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
+				  cBytes));
+	break;
+	/* writeback and invalidate */
+	case PROC_WRITEBACK_INVALIDATE_MEM:
+		dmac_flush_range(pMemBuf, pMemBuf + cBytes);
+		outer_flush_range(__pa((u32)pMemBuf), __pa((u32)pMemBuf +
+				  cBytes));
+	break;
+	}
+
+}
+
+/*
+ *  ======== MEM_FreePhysMem ========
+ *  Purpose:
+ *      Free the given block of physically contiguous memory.
+ */
+void MEM_FreePhysMem(void *pVirtualAddress, u32 pPhysicalAddress,
+		     u32 cBytes)
+{
+	DBC_Require(pVirtualAddress != NULL);
+
+	if (!extPhysMemPoolEnabled)
+		dma_free_coherent(NULL, cBytes, pVirtualAddress,
+				 pPhysicalAddress);
+}
+
+/*
+ *  ======== MEM_Init ========
+ *  Purpose:
+ *      Initialize MEM module private state.
+ */
+bool MEM_Init(void)
+{
+	return true;
+}
diff --git a/drivers/dsp/bridge/services/ntfy.c b/drivers/dsp/bridge/services/ntfy.c
new file mode 100644
index 0000000..4e73c5f
--- /dev/null
+++ b/drivers/dsp/bridge/services/ntfy.c
@@ -0,0 +1,296 @@
+/*
+ * ntfy.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Manage lists of notification events.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/ntfy.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define NTFY_SIGNATURE      0x5946544e	/* "YFTN" */
+
+/*
+ *  ======== NTFY_OBJECT ========
+ */
+struct NTFY_OBJECT {
+	u32 dwSignature;	/* For object validation */
+	struct LST_LIST *notifyList;	/* List of NOTIFICATION objects */
+	struct SYNC_CSOBJECT *hSync;	/* For critical sections */
+};
+
+/*
+ *  ======== NOTIFICATION ========
+ *  This object will be created when a client registers for events.
+ */
+struct NOTIFICATION {
+	struct list_head listElem;
+	u32 uEventMask;	/* Events to be notified about */
+	u32 uNotifyType;	/* Type of notification to be sent */
+
+	/*
+	 *  We keep a copy of the event name to check if the event has
+	 *  already been registered. (SYNC also keeps a copy of the name).
+	 */
+	char *pstrName;		/* Name of event */
+	HANDLE hEvent;		/* Handle for notification */
+	struct SYNC_OBJECT *hSync;
+};
+
+/*  ----------------------------------- Function Prototypes */
+static void DeleteNotify(struct NOTIFICATION *pNotify);
+
+/*
+ *  ======== NTFY_Create ========
+ *  Purpose:
+ *      Create an empty list of notifications.
+ */
+DSP_STATUS NTFY_Create(struct NTFY_OBJECT **phNtfy)
+{
+	struct NTFY_OBJECT *pNtfy;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(phNtfy != NULL);
+
+	*phNtfy = NULL;
+	MEM_AllocObject(pNtfy, struct NTFY_OBJECT, NTFY_SIGNATURE);
+
+	if (pNtfy) {
+
+		status = SYNC_InitializeDPCCS(&pNtfy->hSync);
+		if (DSP_SUCCEEDED(status)) {
+			pNtfy->notifyList = MEM_Calloc(sizeof(struct LST_LIST),
+							MEM_NONPAGED);
+			if (pNtfy->notifyList == NULL) {
+				(void) SYNC_DeleteCS(pNtfy->hSync);
+				MEM_FreeObject(pNtfy);
+				status = DSP_EMEMORY;
+			} else {
+				INIT_LIST_HEAD(&pNtfy->notifyList->head);
+				*phNtfy = pNtfy;
+			}
+		}
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	DBC_Ensure((DSP_FAILED(status) && *phNtfy == NULL) ||
+		  (DSP_SUCCEEDED(status) && MEM_IsValidHandle((*phNtfy),
+		  NTFY_SIGNATURE)));
+
+	return status;
+}
+
+/*
+ *  ======== NTFY_Delete ========
+ *  Purpose:
+ *      Free resources allocated in NTFY_Create.
+ */
+void NTFY_Delete(struct NTFY_OBJECT *hNtfy)
+{
+	struct NOTIFICATION *pNotify;
+
+	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+
+	/* Remove any elements remaining in list */
+	if (hNtfy->notifyList) {
+		while ((pNotify = (struct NOTIFICATION *)LST_GetHead(hNtfy->
+								notifyList))) {
+			DeleteNotify(pNotify);
+		}
+		DBC_Assert(LST_IsEmpty(hNtfy->notifyList));
+		kfree(hNtfy->notifyList);
+	}
+	if (hNtfy->hSync)
+		(void)SYNC_DeleteCS(hNtfy->hSync);
+
+	MEM_FreeObject(hNtfy);
+}
+
+/*
+ *  ======== NTFY_Exit ========
+ *  Purpose:
+ *      Discontinue usage of NTFY module.
+ */
+void NTFY_Exit(void)
+{
+	/* Do nothing */
+}
+
+/*
+ *  ======== NTFY_Init ========
+ *  Purpose:
+ *      Initialize the NTFY module.
+ */
+bool NTFY_Init(void)
+{
+	return true;
+}
+
+/*
+ *  ======== NTFY_Notify ========
+ *  Purpose:
+ *      Execute notify function (signal event) for every
+ *      element in the notification list that is to be notified about the
+ *      event specified in uEventMask.
+ */
+void NTFY_Notify(struct NTFY_OBJECT *hNtfy, u32 uEventMask)
+{
+	struct NOTIFICATION *pNotify;
+
+	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+
+	/*
+	 *  Go through notifyList and notify all clients registered for
+	 *  uEventMask events.
+	 */
+
+	(void) SYNC_EnterCS(hNtfy->hSync);
+
+	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
+	while (pNotify != NULL) {
+		if (pNotify->uEventMask & uEventMask) {
+			/* Notify */
+			if (pNotify->uNotifyType == DSP_SIGNALEVENT)
+				(void)SYNC_SetEvent(pNotify->hSync);
+
+		}
+		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
+			  (struct list_head *)pNotify);
+	}
+
+	(void) SYNC_LeaveCS(hNtfy->hSync);
+}
+
+/*
+ *  ======== NTFY_Register ========
+ *  Purpose:
+ *      Add a notification element to the list. If the notification is already
+ *      registered, and uEventMask != 0, the notification will get posted for
+ *      events specified in the new event mask. If the notification is already
+ *      registered and uEventMask == 0, the notification will be unregistered.
+ */
+DSP_STATUS NTFY_Register(struct NTFY_OBJECT *hNtfy,
+			 struct DSP_NOTIFICATION *hNotification,
+			 u32 uEventMask, u32 uNotifyType)
+{
+	struct NOTIFICATION *pNotify;
+	struct SYNC_ATTRS syncAttrs;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(MEM_IsValidHandle(hNtfy, NTFY_SIGNATURE));
+
+	if (hNotification == NULL)
+		status = DSP_EHANDLE;
+
+	/* Return DSP_ENOTIMPL if uNotifyType is not supported */
+	if (DSP_SUCCEEDED(status)) {
+		if (!IsValidNotifyMask(uNotifyType))
+			status = DSP_ENOTIMPL;
+
+	}
+
+	if (DSP_FAILED(status))
+		return status;
+
+	(void)SYNC_EnterCS(hNtfy->hSync);
+
+	pNotify = (struct NOTIFICATION *)LST_First(hNtfy->notifyList);
+	while (pNotify != NULL) {
+		/* If there is more than one notification type, each
+		 * type may require its own handler code.  */
+
+		if (hNotification->handle == pNotify->hSync) {
+			/* found */
+			break;
+		}
+		pNotify = (struct NOTIFICATION *)LST_Next(hNtfy->notifyList,
+			  (struct list_head *)pNotify);
+	}
+	if (pNotify == NULL) {
+		/* Not registered */
+		if (uEventMask == 0) {
+			status = DSP_EVALUE;
+		} else {
+			/* Allocate NOTIFICATION object, add to list */
+			pNotify = MEM_Calloc(sizeof(struct NOTIFICATION),
+					     MEM_PAGED);
+			if (pNotify == NULL)
+				status = DSP_EMEMORY;
+
+		}
+		if (DSP_SUCCEEDED(status)) {
+			LST_InitElem((struct list_head *)pNotify);
+			 /* If there is more than one notification type, each
+			 * type may require its own handler code. */
+			status = SYNC_OpenEvent(&pNotify->hSync, &syncAttrs);
+			hNotification->handle = pNotify->hSync;
+
+			if (DSP_SUCCEEDED(status)) {
+				pNotify->uEventMask = uEventMask;
+				pNotify->uNotifyType = uNotifyType;
+				LST_PutTail(hNtfy->notifyList,
+					   (struct list_head *)pNotify);
+			} else {
+				DeleteNotify(pNotify);
+			}
+		}
+	} else {
+		/* Found in list */
+		if (uEventMask == 0) {
+			/* Remove from list and free */
+			LST_RemoveElem(hNtfy->notifyList,
+				      (struct list_head *)pNotify);
+			DeleteNotify(pNotify);
+		} else {
+			/* Update notification mask (type shouldn't change) */
+			pNotify->uEventMask = uEventMask;
+		}
+	}
+	(void)SYNC_LeaveCS(hNtfy->hSync);
+	return status;
+}
+
+/*
+ *  ======== DeleteNotify ========
+ *  Purpose:
+ *      Free the notification object.
+ */
+static void DeleteNotify(struct NOTIFICATION *pNotify)
+{
+	if (pNotify->hSync)
+		(void) SYNC_CloseEvent(pNotify->hSync);
+
+	kfree(pNotify->pstrName);
+
+	kfree(pNotify);
+}
+
diff --git a/drivers/dsp/bridge/services/reg.c b/drivers/dsp/bridge/services/reg.c
new file mode 100644
index 0000000..2187aed
--- /dev/null
+++ b/drivers/dsp/bridge/services/reg.c
@@ -0,0 +1,143 @@
+/*
+ * reg.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide registry functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/reg.h>
+#include <regsup.h>
+
+/*
+ *  ======== REG_DeleteValue ========
+ *  Deletes a registry entry value.  NOTE:  A registry entry value is not the
+ *  same as *  a registry key.
+ */
+DSP_STATUS REG_DeleteValue(IN CONST char *pstrValue)
+{
+	DSP_STATUS status;
+	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+
+	status = regsupDeleteValue(pstrValue);
+
+	return status;
+}
+
+/*
+ *  ======== REG_EnumValue ========
+ *  Enumerates a registry key and retrieve values stored under the key.
+ *  We will assume the input pdwValueSize is smaller than
+ *  REG_MAXREGPATHLENGTH for implementation purposes.
+ */
+DSP_STATUS REG_EnumValue(IN u32 dwIndex,
+			 IN CONST char *pstrKey, IN OUT char *pstrValue,
+			 IN OUT u32 *pdwValueSize, IN OUT char *pstrData,
+			 IN OUT u32 *pdwDataSize)
+{
+	DSP_STATUS status;
+
+	DBC_Require(pstrKey && pstrValue && pdwValueSize && pstrData &&
+		    pdwDataSize);
+	DBC_Require(*pdwValueSize <= REG_MAXREGPATHLENGTH);
+       DBC_Require(strlen(pstrKey) < REG_MAXREGPATHLENGTH);
+
+	status = regsupEnumValue(dwIndex, pstrKey, pstrValue, pdwValueSize,
+				 pstrData, pdwDataSize);
+
+	return status;
+}
+
+/*
+ *  ======== REG_Exit ========
+ *  Discontinue usage of the REG module.
+ */
+void REG_Exit(void)
+{
+	regsupExit();
+}
+
+/*
+ *  ======== REG_GetValue ========
+ *  Retrieve a value from the registry.
+ */
+DSP_STATUS REG_GetValue(IN CONST char *pstrValue, OUT u8 *pbData,
+			IN OUT u32 *pdwDataSize)
+{
+	DSP_STATUS status;
+
+	DBC_Require(pstrValue && pbData);
+       DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+
+	/*  We need to use regsup calls...  */
+	/*  ...for now we don't need the key handle or  */
+	/*  the subkey, all we need is the value to lookup.  */
+	if (regsupGetValue((char *)pstrValue, pbData, pdwDataSize) == DSP_SOK)
+		status = DSP_SOK;
+	else
+		status = DSP_EFAIL;
+
+	return status;
+}
+
+/*
+ *  ======== REG_Init ========
+ *  Initialize the REG module's private state.
+ */
+bool REG_Init(void)
+{
+	bool fInit;
+
+	fInit = regsupInit();
+
+	return fInit;
+}
+
+/*
+ *  ======== REG_SetValue ========
+ *  Set a value in the registry.
+ */
+DSP_STATUS REG_SetValue(IN CONST char *pstrValue, IN u8 *pbData,
+			IN u32 dwDataSize)
+{
+	DSP_STATUS status;
+
+	DBC_Require(pstrValue && pbData);
+	DBC_Require(dwDataSize > 0);
+	DBC_Require(strlen(pstrValue) < REG_MAXREGPATHLENGTH);
+
+	/*
+	 * We need to use regsup calls
+	 * for now we don't need the key handle or
+	 * the subkey, all we need is the value to lookup.
+	 */
+	status = regsupSetValue((char *)pstrValue, pbData, dwDataSize);
+
+	return status;
+}
+
diff --git a/drivers/dsp/bridge/services/regsup.c b/drivers/dsp/bridge/services/regsup.c
new file mode 100644
index 0000000..8df6fec
--- /dev/null
+++ b/drivers/dsp/bridge/services/regsup.c
@@ -0,0 +1,246 @@
+/*
+ * regsup.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide registry support functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/list.h>
+
+/*  ----------------------------------- This */
+#include <regsup.h>
+
+struct RegValue {
+	struct list_head link;	/* Make it linked to a list */
+	char name[MAXREGPATHLENGTH];   /*  Name of a given value entry  */
+	u32 dataSize;		/*  Size of the data  */
+	void *pData;		/*  Pointer to the actual data  */
+};
+
+/*  Pointer to the registry support key  */
+static struct LST_LIST regKey, *pRegKey = &regKey;
+
+/*
+ *  ======== regsupInit ========
+ *  Purpose:
+ *      Initialize the Registry Support module's private state.
+ */
+bool regsupInit(void)
+{
+	INIT_LIST_HEAD(&pRegKey->head);
+	return true;
+}
+
+/*
+ *  ======== regsupExit ========
+ *  Purpose:
+ *      Release all registry support allocations.
+ */
+void regsupExit(void)
+{
+	struct RegValue *rv;
+	/*  Now go through each entry and free all resources.  */
+	while (!LST_IsEmpty(pRegKey)) {
+		rv = (struct RegValue *) LST_GetHead(pRegKey);
+
+		kfree(rv->pData);
+		kfree(rv);
+	}
+}
+
+/*
+ *  ======== regsupGetValue ========
+ *  Purpose:
+ *      Get the value of the entry having the given name.
+ */
+DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize)
+{
+	DSP_STATUS retVal = DSP_EFAIL;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+
+	/*  Need to search through the entries looking for the right one.  */
+	while (rv) {
+		/*  See if the name matches.  */
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
+			/*  We have a match!  Copy out the data.  */
+			memcpy(pBuf, rv->pData, rv->dataSize);
+
+			/*  Get the size for the caller.  */
+			*dataSize = rv->dataSize;
+
+			/*  Set our status to good and exit.  */
+			retVal = DSP_SOK;
+			break;
+		}
+		rv = (struct RegValue *) LST_Next(pRegKey,
+						(struct list_head *) rv);
+	}
+
+	dev_dbg(bridge, "REG: get %s, status = 0x%x\n", valName, retVal);
+
+	return retVal;
+}
+
+/*
+ *  ======== regsupSetValue ========
+ *  Purpose:
+ *      Sets the value of the entry having the given name.
+ */
+DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize)
+{
+	DSP_STATUS retVal = DSP_EFAIL;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+
+	/*  Need to search through the entries looking for the right one.  */
+	while (rv) {
+		/*  See if the name matches.  */
+		if (strncmp(rv->name, valName, MAXREGPATHLENGTH) == 0) {
+			/*  Make sure the new data size is the same.  */
+			if (dataSize != rv->dataSize) {
+				/*  The caller needs a different data size!  */
+				kfree(rv->pData);
+				rv->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
+				if (rv->pData == NULL)
+					break;
+			}
+
+			/*  We have a match!  Copy out the data.  */
+			memcpy(rv->pData, pBuf, dataSize);
+
+			/* Reset datasize - overwrite if new or same */
+			rv->dataSize = dataSize;
+
+			/*  Set our status to good and exit.  */
+			retVal = DSP_SOK;
+			break;
+		}
+	       rv = (struct RegValue *) LST_Next(pRegKey,
+					(struct list_head *) rv);
+	}
+
+	/*  See if we found a match or if this is a new entry  */
+	if (!rv) {
+		/*  No match, need to make a new entry  */
+		struct RegValue *new = MEM_Calloc(sizeof(struct RegValue),
+						MEM_NONPAGED);
+
+		strncat(new->name, valName, MAXREGPATHLENGTH - 1);
+		new->pData = MEM_Alloc(dataSize, MEM_NONPAGED);
+		if (new->pData != NULL) {
+			memcpy(new->pData, pBuf, dataSize);
+			new->dataSize = dataSize;
+			LST_PutTail(pRegKey, (struct list_head *) new);
+			retVal = DSP_SOK;
+		}
+	}
+
+	dev_dbg(bridge, "REG: set %s, status = 0x%x", valName, retVal);
+
+	return retVal;
+}
+
+/*
+ *  ======== regsupEnumValue ========
+ *  Purpose:
+ *      Returns registry "values" and their "data" under a (sub)key.
+ */
+DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
+			   IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
+			   IN OUT char *pstrData, IN OUT u32 *pdwDataSize)
+{
+	DSP_STATUS retVal = REG_E_INVALIDSUBKEY;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+       u32 dwKeyLen;
+	u32 count = 0;
+
+       DBC_Require(pstrKey);
+       dwKeyLen = strlen(pstrKey);
+
+	/*  Need to search through the entries looking for the right one.  */
+	while (rv) {
+		/*  See if the name matches.  */
+		if (strncmp(rv->name, pstrKey, dwKeyLen) == 0 &&
+			count++ == dwIndex) {
+			/*  We have a match!  Copy out the data.  */
+			memcpy(pstrData, rv->pData, rv->dataSize);
+			/*  Get the size for the caller.  */
+			*pdwDataSize = rv->dataSize;
+			*pdwValueSize = strlen(&(rv->name[dwKeyLen]));
+			strncpy(pstrValue, &(rv->name[dwKeyLen]),
+				    *pdwValueSize + 1);
+			/*  Set our status to good and exit.  */
+			retVal = DSP_SOK;
+			break;
+		}
+	       rv = (struct RegValue *) LST_Next(pRegKey,
+						(struct list_head *) rv);
+	}
+
+	if (count && DSP_FAILED(retVal))
+		retVal = REG_E_NOMOREITEMS;
+
+	dev_dbg(bridge, "REG: enum Key %s, Value %s, status = 0x%x",
+					pstrKey, pstrValue, retVal);
+
+	return retVal;
+}
+
+/*
+ *  ======== regsupDeleteValue ========
+ */
+DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue)
+{
+	DSP_STATUS retVal = DSP_EFAIL;
+	struct RegValue *rv = (struct RegValue *) LST_First(pRegKey);
+
+	while (rv) {
+		/*  See if the name matches.  */
+		if (strncmp(rv->name, pstrValue, MAXREGPATHLENGTH) == 0) {
+			/* We have a match!  Delete this key.  To delete a
+			 * key, we free all resources associated with this
+			 * key and, if we're not already the last entry in
+			 * the array, we copy that entry into this deleted
+			 * key.
+			 */
+			LST_RemoveElem(pRegKey, (struct list_head *)rv);
+			kfree(rv->pData);
+			kfree(rv);
+
+			/*  Set our status to good and exit...  */
+			retVal = DSP_SOK;
+			break;
+		}
+		rv = (struct RegValue *)LST_Next(pRegKey,
+				(struct list_head *)rv);
+	}
+
+	dev_dbg(bridge, "REG: del %s, status = 0x%x", pstrValue, retVal);
+
+	return retVal;
+
+}
+
diff --git a/drivers/dsp/bridge/services/regsup.h b/drivers/dsp/bridge/services/regsup.h
new file mode 100644
index 0000000..7e09c51
--- /dev/null
+++ b/drivers/dsp/bridge/services/regsup.h
@@ -0,0 +1,47 @@
+/*
+ * regsup.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _REGSUP_H_
+#define _REGSUP_H_
+
+/*  Init function. MUST be called BEFORE any calls are  */
+/*  made into this psuedo-registry!!!  Returns TRUE/FALSE for SUCCESS/ERROR  */
+extern bool regsupInit(void);
+
+/*  Release all registry support allocations.  */
+extern void regsupExit(void);
+
+/*
+ *  ======== regsupDeleteValue ========
+ */
+extern DSP_STATUS regsupDeleteValue(IN CONST char *pstrValue);
+
+/*  Get the value of the entry having the given name.  Returns DSP_SOK  */
+/*  if an entry was found and the value retrieved.  Returns DSP_EFAIL
+ *  otherwise.*/
+extern DSP_STATUS regsupGetValue(char *valName, void *pBuf, u32 *dataSize);
+
+/*  Sets the value of the entry having the given name.  Returns DSP_SOK  */
+/*  if an entry was found and the value set.  Returns DSP_EFAIL otherwise.  */
+extern DSP_STATUS regsupSetValue(char *valName, void *pBuf, u32 dataSize);
+
+/*  Returns registry "values" and their "data" under a (sub)key. */
+extern DSP_STATUS regsupEnumValue(IN u32 dwIndex, IN CONST char *pstrKey,
+			IN OUT char *pstrValue, IN OUT u32 *pdwValueSize,
+			IN OUT char *pstrData, IN OUT u32 *pdwDataSize);
+
+#endif
+
diff --git a/drivers/dsp/bridge/services/services.c b/drivers/dsp/bridge/services/services.c
new file mode 100644
index 0000000..dac0b39
--- /dev/null
+++ b/drivers/dsp/bridge/services/services.c
@@ -0,0 +1,100 @@
+/*
+ * services.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Provide SERVICES loading.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/reg.h>
+#include <dspbridge/sync.h>
+#include <dspbridge/clk.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/services.h>
+
+/*
+ *  ======== SERVICES_Exit ========
+ *  Purpose:
+ *      Discontinue usage of module; free resources when reference count
+ *      reaches 0.
+ */
+void SERVICES_Exit(void)
+{
+	/* Uninitialize all SERVICES modules here */
+	NTFY_Exit();
+	SYNC_Exit();
+	CLK_Exit();
+	REG_Exit();
+	CFG_Exit();
+	MEM_Exit();
+}
+
+/*
+ *  ======== SERVICES_Init ========
+ *  Purpose:
+ *      Initializes SERVICES modules.
+ */
+bool SERVICES_Init(void)
+{
+	bool fInit = true;
+	bool fCFG, fMEM;
+	bool fREG, fSYNC, fCLK, fNTFY;
+
+	/* Perform required initialization of SERVICES modules. */
+	fMEM = MEM_Init();
+	fREG = REG_Init();
+	fCFG = CFG_Init();
+	fSYNC = SYNC_Init();
+	fCLK  = CLK_Init();
+	fNTFY = NTFY_Init();
+
+	fInit = fCFG && fMEM && fREG && fSYNC && fCLK;
+
+	if (!fInit) {
+		if (fNTFY)
+			NTFY_Exit();
+
+		if (fSYNC)
+			SYNC_Exit();
+
+		if (fCLK)
+			CLK_Exit();
+
+		if (fREG)
+			REG_Exit();
+
+		if (fCFG)
+			CFG_Exit();
+
+		if (fMEM)
+			MEM_Exit();
+
+	}
+
+	return fInit;
+}
+
diff --git a/drivers/dsp/bridge/services/sync.c b/drivers/dsp/bridge/services/sync.c
new file mode 100644
index 0000000..bd07938
--- /dev/null
+++ b/drivers/dsp/bridge/services/sync.c
@@ -0,0 +1,453 @@
+/*
+ * sync.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Synchronization services.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- This */
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define SIGNATURE       0x434e5953	/* "SYNC" (in reverse) */
+
+enum wait_state {
+	wo_waiting,
+	wo_signalled
+} ;
+
+enum sync_state {
+	so_reset,
+	so_signalled
+} ;
+
+struct WAIT_OBJECT {
+	enum wait_state state;
+	struct SYNC_OBJECT *signalling_event;
+	struct semaphore sem;
+};
+
+/* Generic SYNC object: */
+struct SYNC_OBJECT {
+	u32 dwSignature;	/* Used for object validation. */
+	enum sync_state state;
+	spinlock_t sync_lock;
+	struct WAIT_OBJECT *pWaitObj;
+};
+
+struct SYNC_DPCCSOBJECT {
+	u32 dwSignature;	/* used for object validation */
+	spinlock_t sync_dpccs_lock;
+	s32 count;
+} ;
+
+static int test_and_set(volatile void *ptr, int val)
+{
+	int ret = val;
+	asm volatile (" swp %0, %0, [%1]" : "+r" (ret) : "r"(ptr) : "memory");
+	return ret;
+}
+
+static void timeout_callback(unsigned long hWaitObj);
+
+/*
+ *  ======== SYNC_CloseEvent ========
+ *  Purpose:
+ *      Close an existing SYNC event object.
+ */
+DSP_STATUS SYNC_CloseEvent(struct SYNC_OBJECT *hEvent)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+
+	DBC_Require(pEvent != NULL && pEvent->pWaitObj == NULL);
+
+	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
+		if (pEvent->pWaitObj)
+			status = DSP_EFAIL;
+
+		MEM_FreeObject(pEvent);
+
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_Exit ========
+ *  Purpose:
+ *      Cleanup SYNC module.
+ */
+void SYNC_Exit(void)
+{
+	/* Do nothing */
+}
+
+/*
+ *  ======== SYNC_Init ========
+ *  Purpose:
+ *      Initialize SYNC module.
+ */
+bool SYNC_Init(void)
+{
+	return true;
+}
+
+/*
+ *  ======== SYNC_OpenEvent ========
+ *  Purpose:
+ *      Open a new synchronization event object.
+ */
+DSP_STATUS SYNC_OpenEvent(OUT struct SYNC_OBJECT **phEvent,
+			  IN OPTIONAL struct SYNC_ATTRS *pAttrs)
+{
+	struct SYNC_OBJECT *pEvent = NULL;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(phEvent != NULL);
+
+	/* Allocate memory for sync object */
+	MEM_AllocObject(pEvent, struct SYNC_OBJECT, SIGNATURE);
+	if (pEvent != NULL) {
+		pEvent->state = so_reset;
+		pEvent->pWaitObj = NULL;
+		spin_lock_init(&pEvent->sync_lock);
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	*phEvent = pEvent;
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_ResetEvent ========
+ *  Purpose:
+ *      Reset an event to non-signalled.
+ */
+DSP_STATUS SYNC_ResetEvent(struct SYNC_OBJECT *hEvent)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+
+	if (MEM_IsValidHandle(hEvent, SIGNATURE))
+		pEvent->state = so_reset;
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_SetEvent ========
+ *  Purpose:
+ *      Set an event to signaled and unblock one waiting thread.
+ *
+ *  This function is called from ISR, DPC and user context. Hence interrupts
+ *  are disabled to ensure atomicity.
+ */
+
+DSP_STATUS SYNC_SetEvent(struct SYNC_OBJECT *hEvent)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	unsigned long flags;
+
+	if (MEM_IsValidHandle(hEvent, SIGNATURE)) {
+		spin_lock_irqsave(&hEvent->sync_lock, flags);
+
+		if (pEvent->pWaitObj != NULL &&
+		   test_and_set(&pEvent->pWaitObj->state,
+		   wo_signalled) == wo_waiting) {
+			pEvent->state = so_reset;
+			pEvent->pWaitObj->signalling_event = pEvent;
+			up(&pEvent->pWaitObj->sem);
+		} else {
+			pEvent->state = so_signalled;
+		}
+		spin_unlock_irqrestore(&hEvent->sync_lock, flags);
+	} else {
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== SYNC_WaitOnEvent ========
+ *  Purpose:
+ *      Wait for an event to be signalled, up to the specified timeout.
+ *      Note: dwTimeOut must be 0xffffffff to signal infinite wait.
+ */
+DSP_STATUS SYNC_WaitOnEvent(struct SYNC_OBJECT *hEvent, u32 dwTimeout)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_OBJECT *pEvent = (struct SYNC_OBJECT *)hEvent;
+	u32 temp;
+
+	if (MEM_IsValidHandle(hEvent, SIGNATURE))
+		status = SYNC_WaitOnMultipleEvents(&pEvent, 1, dwTimeout,
+						  &temp);
+	else
+		status = DSP_EHANDLE;
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_WaitOnMultipleEvents ========
+ *  Purpose:
+ *      Wait for any of an array of events to be signalled, up to the
+ *      specified timeout.
+ */
+DSP_STATUS SYNC_WaitOnMultipleEvents(struct SYNC_OBJECT **hSyncEvents,
+				     u32 uCount, u32 dwTimeout,
+				     OUT u32 *puIndex)
+{
+	u32 i;
+	DSP_STATUS status = DSP_SOK;
+	u32 curr;
+	struct WAIT_OBJECT *Wp;
+
+	DBC_Require(uCount > 0);
+	DBC_Require(hSyncEvents != NULL);
+	DBC_Require(puIndex != NULL);
+
+	for (i = 0; i < uCount; i++)
+		DBC_Require(MEM_IsValidHandle(hSyncEvents[i], SIGNATURE));
+
+	Wp = MEM_Calloc(sizeof(struct WAIT_OBJECT), MEM_NONPAGED);
+	if (Wp == NULL)
+		return DSP_EMEMORY;
+
+	Wp->state = wo_waiting;
+	Wp->signalling_event = NULL;
+	init_MUTEX_LOCKED(&(Wp->sem));
+
+	for (curr = 0; curr < uCount; curr++) {
+		hSyncEvents[curr]->pWaitObj = Wp;
+		if (hSyncEvents[curr]->state == so_signalled) {
+			if (test_and_set(&(Wp->state), wo_signalled) ==
+			   wo_waiting) {
+				hSyncEvents[curr]->state = so_reset;
+				Wp->signalling_event = hSyncEvents[curr];
+			}
+		curr++;	/* Will try optimizing later */
+		break;
+		}
+	}
+
+	curr--;			/* Will try optimizing later */
+	if (Wp->state != wo_signalled && dwTimeout > 0) {
+		struct timer_list timeout;
+		if (dwTimeout != SYNC_INFINITE) {
+			init_timer_on_stack(&timeout);
+			timeout.function = timeout_callback;
+			timeout.data = (unsigned long)Wp;
+			timeout.expires = jiffies + dwTimeout * HZ / 1000;
+			add_timer(&timeout);
+		}
+		if (down_interruptible(&(Wp->sem))) {
+			/*
+			 * Most probably we are interrupted by a fake signal
+			 * from freezer. Return -ERESTARTSYS so that this
+			 * ioctl is restarted, and user space doesn't notice
+			 * it.
+			 */
+			status = -ERESTARTSYS;
+		}
+		if (dwTimeout != SYNC_INFINITE) {
+			if (in_interrupt()) {
+				del_timer(&timeout);
+			} else {
+				del_timer_sync(&timeout);
+			}
+		}
+	}
+	for (i = 0; i <= curr; i++) {
+		if (MEM_IsValidHandle(hSyncEvents[i], SIGNATURE)) {
+			/*  Memory corruption here if hSyncEvents[i] is
+			 *  freed before following statememt. */
+			hSyncEvents[i]->pWaitObj = NULL;
+		}
+		if (hSyncEvents[i] == Wp->signalling_event)
+			*puIndex = i;
+
+	}
+	if (Wp->signalling_event == NULL && DSP_SUCCEEDED(status))
+		status = DSP_ETIMEOUT;
+	kfree(Wp);
+	return status;
+}
+
+static void timeout_callback(unsigned long hWaitObj)
+{
+	struct WAIT_OBJECT *pWaitObj = (struct WAIT_OBJECT *)hWaitObj;
+	if (test_and_set(&pWaitObj->state, wo_signalled) == wo_waiting)
+		up(&pWaitObj->sem);
+
+}
+
+/*
+ *  ======== SYNC_DeleteCS ========
+ */
+DSP_STATUS SYNC_DeleteCS(struct SYNC_CSOBJECT *hCSObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
+
+	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
+		if (down_trylock(&pCSObj->sem) != 0)
+			DBC_Assert(0);
+
+		MEM_FreeObject(hCSObj);
+	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
+		struct SYNC_DPCCSOBJECT *pDPCCSObj =
+					 (struct SYNC_DPCCSOBJECT *)hCSObj;
+		if (pDPCCSObj->count != 1)
+			DBC_Assert(0);
+
+		MEM_FreeObject(pDPCCSObj);
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_EnterCS ========
+ */
+DSP_STATUS SYNC_EnterCS(struct SYNC_CSOBJECT *hCSObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
+
+	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
+		if (in_interrupt()) {
+			status = DSP_EFAIL;
+			DBC_Assert(0);
+		} else if (down_interruptible(&pCSObj->sem)) {
+			status = DSP_EFAIL;
+		}
+	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
+		struct SYNC_DPCCSOBJECT *pDPCCSObj =
+					(struct SYNC_DPCCSOBJECT *)hCSObj;
+		spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
+		pDPCCSObj->count--;
+		if (pDPCCSObj->count != 0) {
+			/* FATAL ERROR : Failed to acquire DPC CS */
+			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
+			DBC_Assert(0);
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_InitializeCS ========
+ */
+DSP_STATUS SYNC_InitializeCS(OUT struct SYNC_CSOBJECT **phCSObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_CSOBJECT *pCSObj = NULL;
+
+	/* Allocate memory for sync CS object */
+	MEM_AllocObject(pCSObj, struct SYNC_CSOBJECT, SIGNATURECS);
+	if (pCSObj != NULL)
+		init_MUTEX(&pCSObj->sem);
+	else
+		status = DSP_EMEMORY;
+
+	/* return CS object */
+	*phCSObj = pCSObj;
+	DBC_Assert(DSP_FAILED(status) || (pCSObj));
+	return status;
+}
+
+DSP_STATUS SYNC_InitializeDPCCS(OUT struct SYNC_CSOBJECT **phCSObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_DPCCSOBJECT *pCSObj = NULL;
+
+	DBC_Require(phCSObj);
+
+	if (phCSObj) {
+		/* Allocate memory for sync CS object */
+		MEM_AllocObject(pCSObj, struct SYNC_DPCCSOBJECT,
+				SIGNATUREDPCCS);
+		if (pCSObj != NULL) {
+			pCSObj->count = 1;
+			spin_lock_init(&pCSObj->sync_dpccs_lock);
+		} else {
+			status = DSP_EMEMORY;
+		}
+
+		/* return CS object */
+		*phCSObj = (struct SYNC_CSOBJECT *)pCSObj;
+	} else {
+		status = DSP_EPOINTER;
+	}
+
+	DBC_Assert(DSP_FAILED(status) || (pCSObj));
+
+	return status;
+}
+
+/*
+ *  ======== SYNC_LeaveCS ========
+ */
+DSP_STATUS SYNC_LeaveCS(struct SYNC_CSOBJECT *hCSObj)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct SYNC_CSOBJECT *pCSObj = (struct SYNC_CSOBJECT *)hCSObj;
+
+	if (MEM_IsValidHandle(hCSObj, SIGNATURECS)) {
+		up(&pCSObj->sem);
+	} else if (MEM_IsValidHandle(hCSObj, SIGNATUREDPCCS)) {
+		struct SYNC_DPCCSOBJECT *pDPCCSObj =
+					(struct SYNC_DPCCSOBJECT *)hCSObj;
+		pDPCCSObj->count++;
+		if (pDPCCSObj->count != 1) {
+			/* FATAL ERROR : Invalid DPC CS count */
+			spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
+			DBC_Assert(0);
+			spin_lock_bh(&pDPCCSObj->sync_dpccs_lock);
+		}
+		spin_unlock_bh(&pDPCCSObj->sync_dpccs_lock);
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/wmd/_cmm.h b/drivers/dsp/bridge/wmd/_cmm.h
new file mode 100644
index 0000000..60784fd
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_cmm.h
@@ -0,0 +1,45 @@
+/*
+ * _cmm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private header file defining CMM manager objects and defines needed
+ * by IO manager to register shared memory regions when DSP base image
+ * is loaded(WMD_IO_OnLoaded).
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _CMM_
+#define _CMM_
+
+/*
+ *  These target side symbols define the beginning and ending addresses
+ *  of the section of shared memory used for shared memory manager CMM.
+ *  They are defined in the *cfg.cmd file by cdb code.
+ */
+#define SHM0_SHARED_BASE_SYM             "_SHM0_BEG"
+#define SHM0_SHARED_END_SYM              "_SHM0_END"
+#define SHM0_SHARED_RESERVED_BASE_SYM    "_SHM0_RSVDSTRT"
+
+/*
+ *  Shared Memory Region #0(SHMSEG0) is used in the following way:
+ *
+ *  |(_SHM0_BEG)                  | (_SHM0_RSVDSTRT)           | (_SHM0_END)
+ *  V                             V                            V
+ *  ------------------------------------------------------------
+ *  |     DSP-side allocations    |    GPP-side allocations    |
+ *  ------------------------------------------------------------
+ *
+ *
+ */
+
+#endif				/* _CMM_ */
diff --git a/drivers/dsp/bridge/wmd/_deh.h b/drivers/dsp/bridge/wmd/_deh.h
new file mode 100644
index 0000000..aadb9fa
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_deh.h
@@ -0,0 +1,38 @@
+/*
+ * _deh.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private header for DEH module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _DEH_
+#define _DEH_
+
+#include <dspbridge/ntfy.h>
+#include <dspbridge/wmd.h>
+
+#define SIGNATURE       0x5f484544	/* "DEH_" backwards */
+
+/* DEH Manager: only one created per board: */
+struct DEH_MGR {
+	u32 dwSignature;	/* Used for object validation.  */
+	struct WMD_DEV_CONTEXT *hWmdContext;	/* WMD device context. */
+	struct NTFY_OBJECT *hNtfy;	/* NTFY object                  */
+	struct DSP_ERRORINFO errInfo;	/* DSP exception info.          */
+
+	/* MMU Fault DPC */
+	struct tasklet_struct dpc_tasklet;
+} ;
+
+#endif				/* _DEH_ */
diff --git a/drivers/dsp/bridge/wmd/_msg_sm.h b/drivers/dsp/bridge/wmd/_msg_sm.h
new file mode 100644
index 0000000..7de632b
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_msg_sm.h
@@ -0,0 +1,143 @@
+/*
+ * _msg_sm.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Private header file defining MSG manager objects and defines needed
+ * by IO manager.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _MSG_SM_
+#define _MSG_SM_
+
+#include <dspbridge/list.h>
+#include <dspbridge/msgdefs.h>
+
+/*
+ *  These target side symbols define the beginning and ending addresses
+ *  of the section of shared memory used for messages. They are
+ *  defined in the *cfg.cmd file by cdb code.
+ */
+#define MSG_SHARED_BUFFER_BASE_SYM      "_MSG_BEG"
+#define MSG_SHARED_BUFFER_LIMIT_SYM     "_MSG_END"
+
+#ifndef _CHNL_WORDSIZE
+#define _CHNL_WORDSIZE 4	/* default _CHNL_WORDSIZE is 2 bytes/word */
+#endif
+
+/*
+ *  ======== MSG ========
+ *  There is a control structure for messages to the DSP, and a control
+ *  structure for messages from the DSP. The shared memory region for
+ *  transferring messages is partitioned as follows:
+ *
+ *  ----------------------------------------------------------
+ *  |Control | Messages from DSP | Control | Messages to DSP |
+ *  ----------------------------------------------------------
+ *
+ *  MSG control structure for messages to the DSP is used in the following
+ *  way:
+ *
+ *  bufEmpty -      This flag is set to FALSE by the GPP after it has output
+ *                  messages for the DSP. The DSP host driver sets it to
+ *                  TRUE after it has copied the messages.
+ *  postSWI -       Set to 1 by the GPP after it has written the messages,
+ *                  set the size, and set bufEmpty to FALSE.
+ *                  The DSP Host driver uses SWI_andn of the postSWI field
+ *                  when a host interrupt occurs. The host driver clears
+ *                  this after posting the SWI.
+ *  size -          Number of messages to be read by the DSP.
+ *
+ *  For messages from the DSP:
+ *  bufEmpty -      This flag is set to FALSE by the DSP after it has output
+ *                  messages for the GPP. The DPC on the GPP sets it to
+ *                  TRUE after it has copied the messages.
+ *  postSWI -       Set to 1 the DPC on the GPP after copying the messages.
+ *  size -          Number of messages to be read by the GPP.
+ */
+struct MSG {
+	u32 bufEmpty;	/* to/from DSP buffer is empty */
+	u32 postSWI;	/* Set to "1" to post MSG SWI */
+	u32 size;	/* Number of messages to/from the DSP */
+	u32 resvd;
+} ;
+
+/*
+ *  ======== MSG_MGR ========
+ *  The MSG_MGR maintains a list of all MSG_QUEUEs. Each NODE object can
+ *  have MSG_QUEUE to hold all messages that come up from the corresponding
+ *  node on the DSP. The MSG_MGR also has a shared queue of messages
+ *  ready to go to the DSP.
+ */
+struct MSG_MGR {
+	/* The first two fields must match those in msgobj.h */
+	u32 dwSignature;
+	struct WMD_DRV_INTERFACE *pIntfFxns;	/* Function interface to WMD. */
+
+	struct IO_MGR *hIOMgr;	/* IO manager */
+	struct LST_LIST *queueList;	/* List of MSG_QUEUEs */
+	struct SYNC_CSOBJECT *hSyncCS;	/* For critical sections */
+	/* Signalled when MsgFrame is available */
+	struct SYNC_OBJECT *hSyncEvent;
+	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
+	struct LST_LIST *msgUsedList;	/* MsgFrames ready to go to DSP */
+	u32 uMsgsPending;	/* # of queued messages to go to DSP */
+	u32 uMaxMsgs;	/* Max # of msgs that fit in buffer */
+	MSG_ONEXIT onExit;	/* called when RMS_EXIT is received */
+} ;
+
+/*
+ *  ======== MSG_QUEUE ========
+ *  Each NODE has a MSG_QUEUE for receiving messages from the
+ *  corresponding node on the DSP. The MSG_QUEUE object maintains a list
+ *  of messages that have been sent to the host, but not yet read (MSG_Get),
+ *  and a list of free frames that can be filled when new messages arrive
+ *  from the DSP.
+ *  The MSG_QUEUE's hSynEvent gets posted when a message is ready.
+ */
+struct MSG_QUEUE {
+	struct list_head listElem;
+	u32 dwSignature;
+	struct MSG_MGR *hMsgMgr;
+	u32 uMaxMsgs;	/* Node message depth */
+	u32 dwId;	/* Node environment pointer */
+	struct LST_LIST *msgFreeList;	/* Free MsgFrames ready to be filled */
+	/* Filled MsgFramess waiting to be read */
+	struct LST_LIST *msgUsedList;
+	HANDLE hArg;	/* Handle passed to mgr onExit callback */
+	struct SYNC_OBJECT *hSyncEvent;	/* Signalled when message is ready */
+	struct SYNC_OBJECT *hSyncDone;	/* For synchronizing cleanup */
+	struct SYNC_OBJECT *hSyncDoneAck;	/* For synchronizing cleanup */
+	struct NTFY_OBJECT *hNtfy;	/* For notification of message ready */
+	bool fDone;	/* TRUE <==> deleting the object */
+	u32 refCount;	/* Number of pending MSG_get/put calls */
+};
+
+/*
+ *  ======== MSG_DSPMSG ========
+ */
+struct MSG_DSPMSG {
+	struct DSP_MSG msg;
+	u32 dwId;	/* Identifies the node the message goes to */
+} ;
+
+/*
+ *  ======== MSG_FRAME ========
+ */
+struct MSG_FRAME {
+	struct list_head listElem;
+	struct MSG_DSPMSG msgData;
+} ;
+
+#endif				/* _MSG_SM_ */
+
diff --git a/drivers/dsp/bridge/wmd/_tiomap.h b/drivers/dsp/bridge/wmd/_tiomap.h
new file mode 100644
index 0000000..6ea9ec9
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_tiomap.h
@@ -0,0 +1,360 @@
+/*
+ * _tiomap.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions and types private to this WMD.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TIOMAP_
+#define _TIOMAP_
+
+#include <dspbridge/devdefs.h>
+#include <hw_defs.h>
+#include <hw_mbox.h>
+#include <dspbridge/wmdioctl.h>		/* for WMDIOCTL_EXTPROC defn */
+#include <dspbridge/sync.h>
+#include <dspbridge/clk.h>
+
+struct MAP_L4PERIPHERAL {
+	u32 physAddr;
+	u32 dspVirtAddr;
+} ;
+
+#define ARM_MAILBOX_START               0xfffcf000
+#define ARM_MAILBOX_LENGTH              0x800
+
+/* New Registers in OMAP3.1 */
+
+#define TESTBLOCK_ID_START              0xfffed400
+#define TESTBLOCK_ID_LENGTH             0xff
+
+/* ID Returned by OMAP1510 */
+#define TBC_ID_VALUE                    0xB47002F
+
+#define SPACE_LENGTH                    0x2000
+#define API_CLKM_DPLL_DMA               0xfffec000
+#define ARM_INTERRUPT_OFFSET            0xb00
+
+#define BIOS_24XX
+
+#define L4_PERIPHERAL_NULL          0x0
+#define DSPVA_PERIPHERAL_NULL       0x0
+
+#define MAX_LOCK_TLB_ENTRIES 15
+
+#define L4_PERIPHERAL_PRM        0x48306000  /*PRM L4 Peripheral */
+#define DSPVA_PERIPHERAL_PRM     0x1181e000
+#define L4_PERIPHERAL_SCM        0x48002000  /*SCM L4 Peripheral */
+#define DSPVA_PERIPHERAL_SCM     0x1181f000
+#define L4_PERIPHERAL_MMU        0x5D000000  /*MMU L4 Peripheral */
+#define DSPVA_PERIPHERAL_MMU     0x11820000
+#define L4_PERIPHERAL_CM        0x48004000       /* Core L4, Clock Management */
+#define DSPVA_PERIPHERAL_CM     0x1181c000
+#define L4_PERIPHERAL_PER        0x48005000       /*  PER */
+#define DSPVA_PERIPHERAL_PER     0x1181d000
+
+#define L4_PERIPHERAL_GPIO1       0x48310000
+#define DSPVA_PERIPHERAL_GPIO1    0x11809000
+#define L4_PERIPHERAL_GPIO2       0x49050000
+#define DSPVA_PERIPHERAL_GPIO2    0x1180a000
+#define L4_PERIPHERAL_GPIO3       0x49052000
+#define DSPVA_PERIPHERAL_GPIO3    0x1180b000
+#define L4_PERIPHERAL_GPIO4       0x49054000
+#define DSPVA_PERIPHERAL_GPIO4    0x1180c000
+#define L4_PERIPHERAL_GPIO5       0x49056000
+#define DSPVA_PERIPHERAL_GPIO5    0x1180d000
+
+#define L4_PERIPHERAL_IVA2WDT      0x49030000
+#define DSPVA_PERIPHERAL_IVA2WDT   0x1180e000
+
+#define L4_PERIPHERAL_DISPLAY     0x48050000
+#define DSPVA_PERIPHERAL_DISPLAY  0x1180f000
+
+#define L4_PERIPHERAL_SSI         0x48058000
+#define DSPVA_PERIPHERAL_SSI      0x11804000
+#define L4_PERIPHERAL_GDD         0x48059000
+#define DSPVA_PERIPHERAL_GDD      0x11805000
+#define L4_PERIPHERAL_SS1         0x4805a000
+#define DSPVA_PERIPHERAL_SS1      0x11806000
+#define L4_PERIPHERAL_SS2         0x4805b000
+#define DSPVA_PERIPHERAL_SS2      0x11807000
+
+#define L4_PERIPHERAL_CAMERA      0x480BC000
+#define DSPVA_PERIPHERAL_CAMERA   0x11819000
+
+#define L4_PERIPHERAL_SDMA        0x48056000
+#define DSPVA_PERIPHERAL_SDMA     0x11810000 /*0x1181d000 conflicts with PER */
+
+#define L4_PERIPHERAL_UART1             0x4806a000
+#define DSPVA_PERIPHERAL_UART1          0x11811000
+#define L4_PERIPHERAL_UART2             0x4806c000
+#define DSPVA_PERIPHERAL_UART2          0x11812000
+#define L4_PERIPHERAL_UART3             0x49020000
+#define DSPVA_PERIPHERAL_UART3    0x11813000
+
+#define L4_PERIPHERAL_MCBSP1      0x48074000
+#define DSPVA_PERIPHERAL_MCBSP1   0x11814000
+#define L4_PERIPHERAL_MCBSP2      0x49022000
+#define DSPVA_PERIPHERAL_MCBSP2   0x11815000
+#define L4_PERIPHERAL_MCBSP3      0x49024000
+#define DSPVA_PERIPHERAL_MCBSP3   0x11816000
+#define L4_PERIPHERAL_MCBSP4      0x49026000
+#define DSPVA_PERIPHERAL_MCBSP4   0x11817000
+#define L4_PERIPHERAL_MCBSP5      0x48096000
+#define DSPVA_PERIPHERAL_MCBSP5   0x11818000
+
+#define L4_PERIPHERAL_GPTIMER5    0x49038000
+#define DSPVA_PERIPHERAL_GPTIMER5 0x11800000
+#define L4_PERIPHERAL_GPTIMER6    0x4903a000
+#define DSPVA_PERIPHERAL_GPTIMER6 0x11801000
+#define L4_PERIPHERAL_GPTIMER7    0x4903c000
+#define DSPVA_PERIPHERAL_GPTIMER7 0x11802000
+#define L4_PERIPHERAL_GPTIMER8    0x4903e000
+#define DSPVA_PERIPHERAL_GPTIMER8 0x11803000
+
+#define L4_PERIPHERAL_SPI1      0x48098000
+#define DSPVA_PERIPHERAL_SPI1   0x1181a000
+#define L4_PERIPHERAL_SPI2      0x4809a000
+#define DSPVA_PERIPHERAL_SPI2   0x1181b000
+
+#define L4_PERIPHERAL_MBOX        0x48094000
+#define DSPVA_PERIPHERAL_MBOX     0x11808000
+
+#define PM_GRPSEL_BASE 			0x48307000
+#define DSPVA_GRPSEL_BASE 		0x11821000
+
+#define L4_PERIPHERAL_SIDETONE_MCBSP2        0x49028000
+#define DSPVA_PERIPHERAL_SIDETONE_MCBSP2 0x11824000
+#define L4_PERIPHERAL_SIDETONE_MCBSP3        0x4902a000
+#define DSPVA_PERIPHERAL_SIDETONE_MCBSP3 0x11825000
+
+/* define a static array with L4 mappings */
+static const struct MAP_L4PERIPHERAL L4PeripheralTable[] = {
+	{L4_PERIPHERAL_MBOX, DSPVA_PERIPHERAL_MBOX},
+	{L4_PERIPHERAL_SCM, DSPVA_PERIPHERAL_SCM},
+	{L4_PERIPHERAL_MMU, DSPVA_PERIPHERAL_MMU},
+	{L4_PERIPHERAL_GPTIMER5, DSPVA_PERIPHERAL_GPTIMER5},
+	{L4_PERIPHERAL_GPTIMER6, DSPVA_PERIPHERAL_GPTIMER6},
+	{L4_PERIPHERAL_GPTIMER7, DSPVA_PERIPHERAL_GPTIMER7},
+	{L4_PERIPHERAL_GPTIMER8, DSPVA_PERIPHERAL_GPTIMER8},
+	{L4_PERIPHERAL_GPIO1, DSPVA_PERIPHERAL_GPIO1},
+	{L4_PERIPHERAL_GPIO2, DSPVA_PERIPHERAL_GPIO2},
+	{L4_PERIPHERAL_GPIO3, DSPVA_PERIPHERAL_GPIO3},
+	{L4_PERIPHERAL_GPIO4, DSPVA_PERIPHERAL_GPIO4},
+	{L4_PERIPHERAL_GPIO5, DSPVA_PERIPHERAL_GPIO5},
+	{L4_PERIPHERAL_IVA2WDT, DSPVA_PERIPHERAL_IVA2WDT},
+	{L4_PERIPHERAL_DISPLAY, DSPVA_PERIPHERAL_DISPLAY},
+	{L4_PERIPHERAL_SSI, DSPVA_PERIPHERAL_SSI},
+	{L4_PERIPHERAL_GDD, DSPVA_PERIPHERAL_GDD},
+	{L4_PERIPHERAL_SS1, DSPVA_PERIPHERAL_SS1},
+	{L4_PERIPHERAL_SS2, DSPVA_PERIPHERAL_SS2},
+	{L4_PERIPHERAL_UART1, DSPVA_PERIPHERAL_UART1},
+	{L4_PERIPHERAL_UART2, DSPVA_PERIPHERAL_UART2},
+	{L4_PERIPHERAL_UART3, DSPVA_PERIPHERAL_UART3},
+	{L4_PERIPHERAL_MCBSP1, DSPVA_PERIPHERAL_MCBSP1},
+	{L4_PERIPHERAL_MCBSP2, DSPVA_PERIPHERAL_MCBSP2},
+	{L4_PERIPHERAL_MCBSP3, DSPVA_PERIPHERAL_MCBSP3},
+	{L4_PERIPHERAL_MCBSP4, DSPVA_PERIPHERAL_MCBSP4},
+	{L4_PERIPHERAL_MCBSP5, DSPVA_PERIPHERAL_MCBSP5},
+	{L4_PERIPHERAL_CAMERA, DSPVA_PERIPHERAL_CAMERA},
+	{L4_PERIPHERAL_SPI1, DSPVA_PERIPHERAL_SPI1},
+	{L4_PERIPHERAL_SPI2, DSPVA_PERIPHERAL_SPI2},
+	{L4_PERIPHERAL_PRM, DSPVA_PERIPHERAL_PRM},
+	{L4_PERIPHERAL_CM, DSPVA_PERIPHERAL_CM},
+	{L4_PERIPHERAL_PER, DSPVA_PERIPHERAL_PER},
+	{PM_GRPSEL_BASE, DSPVA_GRPSEL_BASE},
+	{L4_PERIPHERAL_SIDETONE_MCBSP2, DSPVA_PERIPHERAL_SIDETONE_MCBSP2},
+	{L4_PERIPHERAL_SIDETONE_MCBSP3, DSPVA_PERIPHERAL_SIDETONE_MCBSP3},
+	{L4_PERIPHERAL_NULL, DSPVA_PERIPHERAL_NULL}
+};
+
+/*
+ *   15         10                  0
+ *   ---------------------------------
+ *  |0|0|1|0|0|0|c|c|c|i|i|i|i|i|i|i|
+ *  ---------------------------------
+ *  |  (class)  | (module specific) |
+ *
+ *  where  c -> Externel Clock Command: Clk & Autoidle Disable/Enable
+ *  i -> External Clock ID Timers 5,6,7,8, McBSP1,2 and WDT3
+ */
+
+/* MBX_PM_CLK_IDMASK: DSP External clock id mask. */
+#define MBX_PM_CLK_IDMASK   0x7F
+
+/* MBX_PM_CLK_CMDSHIFT: DSP External clock command shift. */
+#define MBX_PM_CLK_CMDSHIFT 7
+
+/* MBX_PM_CLK_CMDMASK: DSP External clock command mask. */
+#define MBX_PM_CLK_CMDMASK 7
+
+/* MBX_PM_MAX_RESOURCES: CORE 1 Clock resources. */
+#define MBX_CORE1_RESOURCES 7
+
+/* MBX_PM_MAX_RESOURCES: CORE 2 Clock Resources. */
+#define MBX_CORE2_RESOURCES 1
+
+/* MBX_PM_MAX_RESOURCES: TOTAL Clock Reosurces. */
+#define MBX_PM_MAX_RESOURCES 11
+
+/*  Power Management Commands */
+#define BPWR_DisableClock	0
+#define BPWR_EnableClock	1
+
+/* OMAP242x specific resources */
+enum BPWR_ExtClockId {
+	BPWR_GPTimer5 = 0x10,
+	BPWR_GPTimer6,
+	BPWR_GPTimer7,
+	BPWR_GPTimer8,
+	BPWR_WDTimer3,
+	BPWR_MCBSP1,
+	BPWR_MCBSP2,
+	BPWR_MCBSP3,
+	BPWR_MCBSP4,
+	BPWR_MCBSP5,
+	BPWR_SSI = 0x20
+} ;
+
+static const u32 BPWR_CLKID[] = {
+	(u32) BPWR_GPTimer5,
+	(u32) BPWR_GPTimer6,
+	(u32) BPWR_GPTimer7,
+	(u32) BPWR_GPTimer8,
+	(u32) BPWR_WDTimer3,
+	(u32) BPWR_MCBSP1,
+	(u32) BPWR_MCBSP2,
+	(u32) BPWR_MCBSP3,
+	(u32) BPWR_MCBSP4,
+	(u32) BPWR_MCBSP5,
+	(u32) BPWR_SSI
+};
+
+struct BPWR_Clk_t {
+	u32 clkId;
+	enum SERVICES_ClkId funClk;
+	enum SERVICES_ClkId intClk;
+} ;
+
+static const struct BPWR_Clk_t BPWR_Clks[] = {
+	{(u32) BPWR_GPTimer5, SERVICESCLK_gpt5_fck, SERVICESCLK_gpt5_ick},
+	{(u32) BPWR_GPTimer6, SERVICESCLK_gpt6_fck, SERVICESCLK_gpt6_ick},
+	{(u32) BPWR_GPTimer7, SERVICESCLK_gpt7_fck, SERVICESCLK_gpt7_ick},
+	{(u32) BPWR_GPTimer8, SERVICESCLK_gpt8_fck, SERVICESCLK_gpt8_ick},
+	{(u32) BPWR_WDTimer3, SERVICESCLK_wdt3_fck, SERVICESCLK_wdt3_ick},
+	{(u32) BPWR_MCBSP1, SERVICESCLK_mcbsp1_fck, SERVICESCLK_mcbsp1_ick},
+	{(u32) BPWR_MCBSP2, SERVICESCLK_mcbsp2_fck, SERVICESCLK_mcbsp2_ick},
+	{(u32) BPWR_MCBSP3, SERVICESCLK_mcbsp3_fck, SERVICESCLK_mcbsp3_ick},
+	{(u32) BPWR_MCBSP4, SERVICESCLK_mcbsp4_fck, SERVICESCLK_mcbsp4_ick},
+	{(u32) BPWR_MCBSP5, SERVICESCLK_mcbsp5_fck, SERVICESCLK_mcbsp5_ick},
+	{(u32) BPWR_SSI, SERVICESCLK_ssi_fck, SERVICESCLK_ssi_ick}
+};
+
+/* Interrupt Register Offsets */
+#define INTH_IT_REG_OFFSET              0x00	/* Interrupt register offset  */
+#define INTH_MASK_IT_REG_OFFSET         0x04	/* Mask Interrupt reg offset  */
+
+#define   DSP_MAILBOX1_INT              10
+/*
+ *  Bit definition of  Interrupt  Level  Registers
+ */
+
+/* Mail Box defines */
+#define MB_ARM2DSP1_REG_OFFSET          0x00
+
+#define MB_ARM2DSP1B_REG_OFFSET         0x04
+
+#define MB_DSP2ARM1B_REG_OFFSET         0x0C
+
+#define MB_ARM2DSP1_FLAG_REG_OFFSET     0x18
+
+#define MB_ARM2DSP_FLAG                 0x0001
+
+#define MBOX_ARM2DSP HW_MBOX_ID_0
+#define MBOX_DSP2ARM HW_MBOX_ID_1
+#define MBOX_ARM HW_MBOX_U0_ARM
+#define MBOX_DSP HW_MBOX_U1_DSP1
+
+#define ENABLE                          true
+#define DISABLE                         false
+
+#define HIGH_LEVEL                      true
+#define LOW_LEVEL                       false
+
+/* Macro's */
+#define REG16(A)    (*(REG_UWORD16 *)(A))
+
+#define ClearBit(reg, mask)             (reg &= ~mask)
+#define SetBit(reg, mask)               (reg |= mask)
+
+#define SetGroupBits16(reg, position, width, value) \
+	do {\
+		reg &= ~((0xFFFF >> (16 - (width))) << (position)) ; \
+		reg |= ((value & (0xFFFF >> (16 - (width)))) << (position)); \
+	} while (0);
+
+#define ClearBitIndex(reg, index)   (reg &= ~(1 << (index)))
+
+/* This mini driver's device context: */
+struct WMD_DEV_CONTEXT {
+	struct DEV_OBJECT *hDevObject;	/* Handle to WCD device object. */
+	u32 dwDspBaseAddr; 		/* Arm's API to DSP virt base addr */
+	/*
+	 * DSP External memory prog address as seen virtually by the OS on
+	 * the host side.
+	 */
+	u32 dwDspExtBaseAddr;		/* See the comment above */
+	u32 dwAPIRegBase;		/* API mem map'd registers */
+	void __iomem *dwDSPMmuBase;	/* DSP MMU Mapped registers */
+	u32 dwMailBoxBase;		/* Mail box mapped registers */
+	u32 dwAPIClkBase;		/* CLK Registers */
+	u32 dwDSPClkM2Base;		/* DSP Clock Module m2 */
+	u32 dwPublicRhea;		/* Pub Rhea */
+	u32 dwIntAddr;			/* MB INTR reg */
+	u32 dwTCEndianism;		/* TC Endianism register */
+	u32 dwTestBase;			/* DSP MMU Mapped registers */
+	u32 dwSelfLoop;			/* Pointer to the selfloop */
+	u32 dwDSPStartAdd;		/* API Boot vector */
+	u32 dwInternalSize;		/* Internal memory size */
+
+	/*
+	 * Processor specific info is set when prog loaded and read from DCD.
+	 * [See WMD_BRD_Ctrl()]  PROC info contains DSP-MMU TLB entries.
+	 */
+	/* DMMU TLB entries */
+	struct WMDIOCTL_EXTPROC aTLBEntry[WMDIOCTL_NUMOFMMUTLB];
+	u32 dwBrdState;			/* Last known board state. */
+	u32 ulIntMask;			/* int mask */
+	u16 ioBase;			/* Board I/O base */
+	u32 numTLBEntries;		/* DSP MMU TLB entry counter */
+	u32 fixedTLBEntries;		/* Fixed DSPMMU TLB entry count */
+
+	/* TC Settings */
+	bool tcWordSwapOn;		/* Traffic Controller Word Swap */
+	struct PgTableAttrs *pPtAttrs;
+	u32 uDspPerClks;
+} ;
+
+	/*
+	 * ======== WMD_TLB_DspVAToMpuPA ========
+	 *     Given a DSP virtual address, traverse the page table and return
+	 *     a corresponding MPU physical address and size.
+	 */
+extern DSP_STATUS WMD_TLB_DspVAToMpuPA(struct WMD_DEV_CONTEXT *pDevContext,
+				       IN u32 ulVirtAddr,
+				       OUT u32 *ulPhysAddr,
+				       OUT u32 *sizeTlb);
+
+#endif				/* _TIOMAP_ */
+
diff --git a/drivers/dsp/bridge/wmd/_tiomap_mmu.h b/drivers/dsp/bridge/wmd/_tiomap_mmu.h
new file mode 100644
index 0000000..b605847
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_tiomap_mmu.h
@@ -0,0 +1,41 @@
+/*
+ * _tiomap_mmu.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions and types for the DSP MMU modules.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TIOMAP_MMU_
+#define _TIOMAP_MMU_
+
+#include "_tiomap.h"
+
+/*
+ *  ======== configureDspMmu ========
+ *
+ *  Make DSP MMu page table entries.
+ *  Note: Not utilizing Coarse / Fine page tables.
+ *  SECTION = 1MB, LARGE_PAGE = 64KB, SMALL_PAGE = 4KB, TINY_PAGE = 1KB.
+ *  DSP Byte address 0x40_0000 is word addr 0x20_0000.
+ */
+extern void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext,
+			    u32 dataBasePhys,
+			    u32 dspBaseVirt,
+			    u32 sizeInBytes,
+			    s32 nEntryStart,
+			    enum HW_Endianism_t endianism,
+			    enum HW_ElementSize_t elemSize,
+			    enum HW_MMUMixedSize_t mixedSize);
+
+#endif				/* _TIOMAP_MMU_ */
diff --git a/drivers/dsp/bridge/wmd/_tiomap_pwr.h b/drivers/dsp/bridge/wmd/_tiomap_pwr.h
new file mode 100644
index 0000000..da2e7d9
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_tiomap_pwr.h
@@ -0,0 +1,93 @@
+/*
+ * _tiomap_pwr.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions and types for the DSP wake/sleep routines.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TIOMAP_PWR_
+#define _TIOMAP_PWR_
+
+/*
+ * ======== WakeDSP =========
+ * Wakes up the DSP from DeepSleep
+ */
+extern DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+
+/*
+ * ======== SleepDSP =========
+ * Places the DSP in DeepSleep.
+ */
+extern DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext,
+			   IN u32 dwCmd, IN void *pArgs);
+/*
+ *  ========InterruptDSP========
+ *  	  Sends an interrupt to DSP unconditionally.
+ */
+extern void InterruptDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u16 wMbVal);
+
+/*
+ * ======== WakeDSP =========
+ * Wakes up the DSP from DeepSleep
+ */
+extern DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
+				       IN void *pArgs);
+/*
+ *  ======== handle_hibernation_fromDSP ========
+ *  	Handle Hibernation requested from DSP
+ */
+DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext);
+/*
+ *  ======== PostScale_DSP ========
+ *  	Handle Post Scale notification to DSP
+ */
+DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+/*
+ *  ======== PreScale_DSP ========
+ *  	Handle Pre Scale notification to DSP
+ */
+DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs);
+/*
+ *  ======== handle_constraints_set ========
+ *  	Handle constraints request from DSP
+ */
+DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
+				 IN void *pArgs);
+/*
+ *  ======== DSP_PeripheralClocks_Disable ========
+ *  	This function disables all the peripheral clocks that
+ *	were enabled by DSP. Call this function only when
+ *	DSP is entering Hibernation or when DSP is in
+ *	Error state
+ */
+DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
+					IN void *pArgs);
+
+/*
+ *  ======== DSP_PeripheralClocks_Enable ========
+ *  	This function enables all the peripheral clocks that
+ *	were requested by DSP.
+ */
+DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
+				       IN void *pArgs);
+
+/*
+ *  ======== DSPClkWakeupEventCtrl ========
+ *     This function sets the group selction bits for while
+ *     enabling/disabling.
+ */
+void DSPClkWakeupEventCtrl(u32 ClkId, bool enable);
+
+#endif				/* _TIOMAP_PWR_ */
+
diff --git a/drivers/dsp/bridge/wmd/_tiomap_util.h b/drivers/dsp/bridge/wmd/_tiomap_util.h
new file mode 100644
index 0000000..98fbbd4
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/_tiomap_util.h
@@ -0,0 +1,43 @@
+/*
+ * _tiomap_util.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions and types for the utility routines.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TIOMAP_UTIL_
+#define _TIOMAP_UTIL_
+
+/* Time out Values in uSeconds*/
+#define TIHELEN_ACKTIMEOUT  10000
+
+/*
+ * Time out for power state transition (in msecs), due to system
+ * latencies and HZ resolution this timer can vary.
+ */
+#define PWRSTST_TIMEOUT		200
+
+/*  Time delay for HOM->SAM transition. */
+#define  WAIT_SAM   1000000	/* in usec (1000 millisec) */
+
+/*
+ *  ======== WaitForStart ========
+ *  Wait for the singal from DSP that it has started, or time out.
+ *  The argument dwSyncAddr is set to 1 before releasing the DSP.
+ *  If the DSP starts running, it will clear this location.
+ */
+extern bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr);
+
+#endif				/* _TIOMAP_UTIL_ */
+
diff --git a/drivers/dsp/bridge/wmd/chnl_sm.c b/drivers/dsp/bridge/wmd/chnl_sm.c
new file mode 100644
index 0000000..0d15a88
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -0,0 +1,982 @@
+/*
+ * chnl_sm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implements upper edge functions for WMD channel module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ *      The lower edge functions must be implemented by the WMD writer, and
+ *      are declared in chnl_sm.h.
+ *
+ *      Care is taken in this code to prevent simulataneous access to channel
+ *      queues from
+ *      1. Threads.
+ *      2. IO_DPC(), scheduled from the IO_ISR() as an event.
+ *
+ *      This is done primarily by:
+ *      - Semaphores.
+ *      - state flags in the channel object; and
+ *      - ensuring the IO_Dispatch() routine, which is called from both
+ *        CHNL_AddIOReq() and the DPC(if implemented), is not re-entered.
+ *
+ *  Channel Invariant:
+ *      There is an important invariant condition which must be maintained per
+ *      channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
+ *      which may cause timeouts and/or failure offunction SYNC_WaitOnEvent.
+ *      This invariant condition is:
+ *
+ *          LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is reset
+ *      and
+ *          !LST_Empty(pChnl->pIOCompletions) ==> pChnl->hSyncEvent is set.
+ */
+
+/*  ----------------------------------- OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/cfg.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Mini-Driver */
+#include <dspbridge/wmd.h>
+#include <dspbridge/wmdchnl.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/io_sm.h>
+
+/*  ----------------------------------- Define for This */
+#define USERMODE_ADDR   PAGE_OFFSET
+
+#define MAILBOX_IRQ INT_MAIL_MPU_IRQ
+
+/*  ----------------------------------- Function Prototypes */
+static struct LST_LIST *CreateChirpList(u32 uChirps);
+
+static void FreeChirpList(struct LST_LIST *pList);
+
+static struct CHNL_IRP *MakeNewChirp(void);
+
+static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
+				   OUT u32 *pdwChnl);
+
+/*
+ *  ======== WMD_CHNL_AddIOReq ========
+ *      Enqueue an I/O request for data transfer on a channel to the DSP.
+ *      The direction (mode) is specified in the channel object. Note the DSP
+ *      address is specified for channels opened in direct I/O mode.
+ */
+DSP_STATUS WMD_CHNL_AddIOReq(struct CHNL_OBJECT *hChnl, void *pHostBuf,
+			    u32 cBytes, u32 cBufSize,
+			    OPTIONAL u32 dwDspAddr, u32 dwArg)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	struct CHNL_IRP *pChirp = NULL;
+	u32 dwState;
+	bool fIsEOS;
+	struct CHNL_MGR *pChnlMgr = pChnl->pChnlMgr;
+	u8 *pHostSysBuf = NULL;
+	bool fSchedDPC = false;
+	u16 wMbVal = 0;
+
+	fIsEOS = (cBytes == 0);
+
+	/* Validate args */
+	if (!pHostBuf) {
+		status = DSP_EPOINTER;
+	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else if (fIsEOS && CHNL_IsInput(pChnl->uMode)) {
+		status = CHNL_E_NOEOS;
+	} else {
+		/*
+		 * Check the channel state: only queue chirp if channel state
+		 * allows it.
+		 */
+		dwState = pChnl->dwState;
+		if (dwState != CHNL_STATEREADY) {
+			if (dwState & CHNL_STATECANCEL)
+				status = CHNL_E_CANCELLED;
+			else if ((dwState & CHNL_STATEEOS) &&
+						CHNL_IsOutput(pChnl->uMode))
+				status = CHNL_E_EOS;
+			else
+				/* No other possible states left */
+				DBC_Assert(0);
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1 && pHostBuf) {
+		if (!(pHostBuf < (void *)USERMODE_ADDR)) {
+			pHostSysBuf = pHostBuf;
+			goto func_cont;
+		}
+		/* if addr in user mode, then copy to kernel space */
+		pHostSysBuf = MEM_Alloc(cBufSize, MEM_NONPAGED);
+		if (pHostSysBuf == NULL) {
+			status = DSP_EMEMORY;
+			goto func_end;
+		}
+		if (CHNL_IsOutput(pChnl->uMode)) {
+			status = copy_from_user(pHostSysBuf, pHostBuf,
+						cBufSize);
+			if (status) {
+				kfree(pHostSysBuf);
+				pHostSysBuf = NULL;
+				status = DSP_EPOINTER;
+				goto func_end;
+			}
+		}
+	}
+func_cont:
+	/* Mailbox IRQ is disabled to avoid race condition with DMA/ZCPY
+	 * channels. DPCCS is held to avoid race conditions with PCPY channels.
+	 * If DPC is scheduled in process context (IO_Schedule) and any
+	 * non-mailbox interrupt occurs, that DPC will run and break CS. Hence
+	 * we disable ALL DPCs. We will try to disable ONLY IO DPC later.  */
+	SYNC_EnterCS(pChnlMgr->hCSObj);
+	disable_irq(MAILBOX_IRQ);
+	if (pChnl->uChnlType == CHNL_PCPY) {
+		/* This is a processor-copy channel. */
+		if (DSP_SUCCEEDED(status) && CHNL_IsOutput(pChnl->uMode)) {
+			/* Check buffer size on output channels for fit. */
+			if (cBytes > IO_BufSize(pChnl->pChnlMgr->hIOMgr))
+				status = CHNL_E_BUFSIZE;
+
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Get a free chirp: */
+		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pFreeList);
+		if (pChirp == NULL)
+			status = CHNL_E_NOIORPS;
+
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Enqueue the chirp on the chnl's IORequest queue: */
+		pChirp->pHostUserBuf = pChirp->pHostSysBuf = pHostBuf;
+		if (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)
+			pChirp->pHostSysBuf = pHostSysBuf;
+
+		/*
+		 * Note: for dma chans dwDspAddr contains dsp address
+		 * of SM buffer.
+		 */
+		DBC_Assert(pChnlMgr->uWordSize != 0);
+		/* DSP address */
+		pChirp->uDspAddr = dwDspAddr / pChnlMgr->uWordSize;
+		pChirp->cBytes = cBytes;
+		pChirp->cBufSize = cBufSize;
+		/* Only valid for output channel */
+		pChirp->dwArg = dwArg;
+		pChirp->status = (fIsEOS ? CHNL_IOCSTATEOS :
+						CHNL_IOCSTATCOMPLETE);
+		LST_PutTail(pChnl->pIORequests, (struct list_head *)pChirp);
+		pChnl->cIOReqs++;
+		DBC_Assert(pChnl->cIOReqs <= pChnl->cChirps);
+		/*
+		 * If end of stream, update the channel state to prevent
+		 * more IOR's.
+		 */
+		if (fIsEOS)
+			pChnl->dwState |= CHNL_STATEEOS;
+
+		/* Legacy DSM Processor-Copy */
+		DBC_Assert(pChnl->uChnlType == CHNL_PCPY);
+		/* Request IO from the DSP */
+		IO_RequestChnl(pChnlMgr->hIOMgr, pChnl,
+			(CHNL_IsInput(pChnl->uMode) ? IO_INPUT : IO_OUTPUT),
+								&wMbVal);
+		fSchedDPC = true;
+
+
+	}
+	enable_irq(MAILBOX_IRQ);
+	SYNC_LeaveCS(pChnlMgr->hCSObj);
+	if (wMbVal != 0)
+		IO_IntrDSP2(pChnlMgr->hIOMgr, wMbVal);
+
+	/* Schedule a DPC, to do the actual data transfer */
+	if (fSchedDPC)
+		IO_Schedule(pChnlMgr->hIOMgr);
+
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_CancelIO ========
+ *      Return all I/O requests to the client which have not yet been
+ *      transferred.  The channel's I/O completion object is
+ *      signalled, and all the I/O requests are queued as IOC's, with the
+ *      status field set to CHNL_IOCSTATCANCEL.
+ *      This call is typically used in abort situations, and is a prelude to
+ *      CHNL_Close();
+ */
+DSP_STATUS WMD_CHNL_CancelIO(struct CHNL_OBJECT *hChnl)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	u32 iChnl = -1;
+	short int uMode;
+	struct CHNL_IRP *pChirp;
+	struct CHNL_MGR *pChnlMgr = NULL;
+
+	/* Check args: */
+	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) && pChnl->pChnlMgr) {
+		iChnl = pChnl->uId;
+		uMode = pChnl->uMode;
+		pChnlMgr = pChnl->pChnlMgr;
+	} else {
+		status = DSP_EHANDLE;
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	 /*  Mark this channel as cancelled, to prevent further IORequests or
+	 *  IORequests or dispatching.  */
+	SYNC_EnterCS(pChnlMgr->hCSObj);
+	pChnl->dwState |= CHNL_STATECANCEL;
+	if (LST_IsEmpty(pChnl->pIORequests))
+		goto func_cont;
+
+	if (pChnl->uChnlType == CHNL_PCPY) {
+		/* Indicate we have no more buffers available for transfer: */
+		if (CHNL_IsInput(pChnl->uMode)) {
+			IO_CancelChnl(pChnlMgr->hIOMgr, iChnl);
+		} else {
+			/* Record that we no longer have output buffers
+			 * available: */
+			pChnlMgr->dwOutputMask &= ~(1 << iChnl);
+		}
+	}
+	/* Move all IOR's to IOC queue:  */
+	while (!LST_IsEmpty(pChnl->pIORequests)) {
+		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
+		if (pChirp) {
+			pChirp->cBytes = 0;
+			pChirp->status |= CHNL_IOCSTATCANCEL;
+			LST_PutTail(pChnl->pIOCompletions,
+				   (struct list_head *)pChirp);
+			pChnl->cIOCs++;
+			pChnl->cIOReqs--;
+			DBC_Assert(pChnl->cIOReqs >= 0);
+		}
+	}
+func_cont:
+		SYNC_LeaveCS(pChnlMgr->hCSObj);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_Close ========
+ *  Purpose:
+ *      Ensures all pending I/O on this channel is cancelled, discards all
+ *      queued I/O completion notifications, then frees the resources allocated
+ *      for this channel, and makes the corresponding logical channel id
+ *      available for subsequent use.
+ */
+DSP_STATUS WMD_CHNL_Close(struct CHNL_OBJECT *hChnl)
+{
+	DSP_STATUS status;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+
+	/* Check args: */
+	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_cont;
+	}
+	{
+		/* Cancel IO: this ensures no further IO requests or
+		 * notifications.*/
+		status = WMD_CHNL_CancelIO(hChnl);
+	}
+func_cont:
+	if (DSP_SUCCEEDED(status)) {
+		/* Assert I/O on this channel is now cancelled: Protects
+		 * from IO_DPC. */
+		DBC_Assert((pChnl->dwState & CHNL_STATECANCEL));
+		/* Invalidate channel object: Protects from
+		 * CHNL_GetIOCompletion(). */
+		pChnl->dwSignature = 0x0000;
+		/* Free the slot in the channel manager: */
+		pChnl->pChnlMgr->apChannel[pChnl->uId] = NULL;
+		pChnl->pChnlMgr->cOpenChannels -= 1;
+		if (pChnl->hNtfy) {
+			NTFY_Delete(pChnl->hNtfy);
+			pChnl->hNtfy = NULL;
+		}
+		/* Reset channel event: (NOTE: hUserEvent freed in user
+		 * context.). */
+		if (pChnl->hSyncEvent) {
+			SYNC_ResetEvent(pChnl->hSyncEvent);
+			SYNC_CloseEvent(pChnl->hSyncEvent);
+			pChnl->hSyncEvent = NULL;
+		}
+		/* Free I/O request and I/O completion queues:  */
+		if (pChnl->pIOCompletions) {
+			FreeChirpList(pChnl->pIOCompletions);
+			pChnl->pIOCompletions = NULL;
+			pChnl->cIOCs = 0;
+		}
+		if (pChnl->pIORequests) {
+			FreeChirpList(pChnl->pIORequests);
+			pChnl->pIORequests = NULL;
+			pChnl->cIOReqs = 0;
+		}
+		if (pChnl->pFreeList) {
+			FreeChirpList(pChnl->pFreeList);
+			pChnl->pFreeList = NULL;
+		}
+		/* Release channel object. */
+		MEM_FreeObject(pChnl);
+		pChnl = NULL;
+	}
+	DBC_Ensure(DSP_FAILED(status) ||
+		  !MEM_IsValidHandle(pChnl, CHNL_SIGNATURE));
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_Create ========
+ *      Create a channel manager object, responsible for opening new channels
+ *      and closing old ones for a given board.
+ */
+DSP_STATUS WMD_CHNL_Create(OUT struct CHNL_MGR **phChnlMgr,
+			  struct DEV_OBJECT *hDevObject,
+			  IN CONST struct CHNL_MGRATTRS *pMgrAttrs)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_MGR *pChnlMgr = NULL;
+	s32 cChannels;
+
+	/* Check DBC requirements:  */
+	DBC_Require(phChnlMgr != NULL);
+	DBC_Require(pMgrAttrs != NULL);
+	DBC_Require(pMgrAttrs->cChannels > 0);
+	DBC_Require(pMgrAttrs->cChannels <= CHNL_MAXCHANNELS);
+	DBC_Require(pMgrAttrs->uWordSize != 0);
+
+	/* Allocate channel manager object */
+	MEM_AllocObject(pChnlMgr, struct CHNL_MGR, CHNL_MGRSIGNATURE);
+	if (pChnlMgr) {
+		/*
+		 * The cChannels attr must equal the # of supported chnls for
+		 * each transport(# chnls for PCPY = DDMA = ZCPY): i.e.
+		 * 	pMgrAttrs->cChannels = CHNL_MAXCHANNELS =
+		 * 			 DDMA_MAXDDMACHNLS = DDMA_MAXZCPYCHNLS.
+		 */
+		DBC_Assert(pMgrAttrs->cChannels == CHNL_MAXCHANNELS);
+		cChannels = CHNL_MAXCHANNELS + CHNL_MAXCHANNELS * CHNL_PCPY;
+		/* Create array of channels */
+		pChnlMgr->apChannel = MEM_Calloc(
+				sizeof(struct CHNL_OBJECT *) *
+				cChannels, MEM_NONPAGED);
+		if (pChnlMgr->apChannel) {
+			/* Initialize CHNL_MGR object */
+			pChnlMgr->dwType = CHNL_TYPESM;
+			pChnlMgr->uWordSize = pMgrAttrs->uWordSize;
+			/* Total # chnls supported */
+			pChnlMgr->cChannels = cChannels;
+			pChnlMgr->cOpenChannels = 0;
+			pChnlMgr->dwOutputMask = 0;
+			pChnlMgr->dwLastOutput = 0;
+			pChnlMgr->hDevObject = hDevObject;
+			if (DSP_SUCCEEDED(status))
+				status = SYNC_InitializeDPCCS(
+							&pChnlMgr->hCSObj);
+		} else {
+			status = DSP_EMEMORY;
+		}
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	if (DSP_FAILED(status)) {
+		WMD_CHNL_Destroy(pChnlMgr);
+		*phChnlMgr = NULL;
+	} else {
+		/* Return channel manager object to caller... */
+		*phChnlMgr = pChnlMgr;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_Destroy ========
+ *  Purpose:
+ *      Close all open channels, and destroy the channel manager.
+ */
+DSP_STATUS WMD_CHNL_Destroy(struct CHNL_MGR *hChnlMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_MGR *pChnlMgr = hChnlMgr;
+	u32 iChnl;
+
+	if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+		/* Close all open channels: */
+		for (iChnl = 0; iChnl < pChnlMgr->cChannels; iChnl++) {
+			status = WMD_CHNL_Close(pChnlMgr->apChannel[iChnl]);
+			if (DSP_FAILED(status))
+				dev_dbg(bridge, "%s: Error status 0x%x\n",
+							__func__, status);
+		}
+		/* release critical section */
+		if (pChnlMgr->hCSObj)
+			SYNC_DeleteCS(pChnlMgr->hCSObj);
+
+		/* Free channel manager object: */
+		kfree(pChnlMgr->apChannel);
+
+		/* Set hChnlMgr to NULL in device object. */
+		DEV_SetChnlMgr(pChnlMgr->hDevObject, NULL);
+		/* Free this Chnl Mgr object: */
+		MEM_FreeObject(hChnlMgr);
+	} else {
+		status = DSP_EHANDLE;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_FlushIO ========
+ *  purpose:
+ *      Flushes all the outstanding data requests on a channel.
+ */
+DSP_STATUS WMD_CHNL_FlushIO(struct CHNL_OBJECT *hChnl, u32 dwTimeOut)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	short int uMode = -1;
+	struct CHNL_MGR *pChnlMgr;
+	struct CHNL_IOC chnlIOC;
+	/* Check args:  */
+	if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+		if ((dwTimeOut == CHNL_IOCNOWAIT)
+		    && CHNL_IsOutput(pChnl->uMode)) {
+			status = DSP_EINVALIDARG;
+		} else {
+			uMode = pChnl->uMode;
+			pChnlMgr = pChnl->pChnlMgr;
+		}
+	} else {
+		status = DSP_EHANDLE;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Note: Currently, if another thread continues to add IO
+		 * requests to this channel, this function will continue to
+		 * flush all such queued IO requests.  */
+		if (CHNL_IsOutput(uMode) && (pChnl->uChnlType == CHNL_PCPY)) {
+			/* Wait for IO completions, up to the specified
+			 * timeout: */
+			while (!LST_IsEmpty(pChnl->pIORequests) &&
+			      DSP_SUCCEEDED(status)) {
+				status = WMD_CHNL_GetIOC(hChnl, dwTimeOut,
+							 &chnlIOC);
+				if (DSP_FAILED(status))
+					continue;
+
+				if (chnlIOC.status & CHNL_IOCSTATTIMEOUT)
+					status = CHNL_E_WAITTIMEOUT;
+
+			}
+		} else {
+			status = WMD_CHNL_CancelIO(hChnl);
+			/* Now, leave the channel in the ready state: */
+			pChnl->dwState &= ~CHNL_STATECANCEL;
+		}
+	}
+	DBC_Ensure(DSP_FAILED(status) || LST_IsEmpty(pChnl->pIORequests));
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_GetInfo ========
+ *  Purpose:
+ *      Retrieve information related to a channel.
+ */
+DSP_STATUS WMD_CHNL_GetInfo(struct CHNL_OBJECT *hChnl,
+			   OUT struct CHNL_INFO *pInfo)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	if (pInfo != NULL) {
+		if (MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+			/* Return the requested information:  */
+			pInfo->hChnlMgr = pChnl->pChnlMgr;
+			pInfo->hEvent = pChnl->hUserEvent;
+			pInfo->dwID = pChnl->uId;
+			pInfo->dwMode = pChnl->uMode;
+			pInfo->cPosition = pChnl->cBytesMoved;
+			pInfo->hProcess = pChnl->hProcess;
+			pInfo->hSyncEvent = pChnl->hSyncEvent;
+			pInfo->cIOCs = pChnl->cIOCs;
+			pInfo->cIOReqs = pChnl->cIOReqs;
+			pInfo->dwState = pChnl->dwState;
+		} else {
+			status = DSP_EHANDLE;
+		}
+	} else {
+		status = DSP_EPOINTER;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_GetIOC ========
+ *      Optionally wait for I/O completion on a channel.  Dequeue an I/O
+ *      completion record, which contains information about the completed
+ *      I/O request.
+ *      Note: Ensures Channel Invariant (see notes above).
+ */
+DSP_STATUS WMD_CHNL_GetIOC(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
+			  OUT struct CHNL_IOC *pIOC)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_OBJECT *pChnl = (struct CHNL_OBJECT *)hChnl;
+	struct CHNL_IRP *pChirp;
+	DSP_STATUS statSync;
+	bool fDequeueIOC = true;
+	struct CHNL_IOC ioc = { NULL, 0, 0, 0, 0 };
+	u8 *pHostSysBuf = NULL;
+
+	/* Check args: */
+	if (pIOC == NULL) {
+		status = DSP_EPOINTER;
+	} else if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) {
+		status = DSP_EHANDLE;
+	} else if (dwTimeOut == CHNL_IOCNOWAIT) {
+		if (LST_IsEmpty(pChnl->pIOCompletions))
+			status = CHNL_E_NOIOC;
+
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	ioc.status = CHNL_IOCSTATCOMPLETE;
+	if (dwTimeOut != CHNL_IOCNOWAIT && LST_IsEmpty(pChnl->pIOCompletions)) {
+		if (dwTimeOut == CHNL_IOCINFINITE)
+			dwTimeOut = SYNC_INFINITE;
+
+		statSync = SYNC_WaitOnEvent(pChnl->hSyncEvent, dwTimeOut);
+		if (statSync == DSP_ETIMEOUT) {
+			/* No response from DSP */
+			ioc.status |= CHNL_IOCSTATTIMEOUT;
+			fDequeueIOC = false;
+		} else if (statSync == DSP_EFAIL) {
+			/* This can occur when the user mode thread is
+			 * aborted (^C), or when _VWIN32_WaitSingleObject()
+			 * fails due to unkown causes.  */
+			/* Even though Wait failed, there may be something in
+			 * the Q: */
+			if (LST_IsEmpty(pChnl->pIOCompletions)) {
+				ioc.status |= CHNL_IOCSTATCANCEL;
+				fDequeueIOC = false;
+			}
+		}
+	}
+	/* See comment in AddIOReq */
+	SYNC_EnterCS(pChnl->pChnlMgr->hCSObj);
+	disable_irq(MAILBOX_IRQ);
+	if (fDequeueIOC) {
+		/* Dequeue IOC and set pIOC; */
+		DBC_Assert(!LST_IsEmpty(pChnl->pIOCompletions));
+		pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIOCompletions);
+		/* Update pIOC from channel state and chirp: */
+		if (pChirp) {
+			pChnl->cIOCs--;
+			/*  If this is a zero-copy channel, then set IOC's pBuf
+			 *  to the DSP's address. This DSP address will get
+			 *  translated to user's virtual addr later.  */
+			{
+				pHostSysBuf = pChirp->pHostSysBuf;
+				ioc.pBuf = pChirp->pHostUserBuf;
+			}
+			ioc.cBytes = pChirp->cBytes;
+			ioc.cBufSize = pChirp->cBufSize;
+			ioc.dwArg = pChirp->dwArg;
+			ioc.status |= pChirp->status;
+			/* Place the used chirp on the free list: */
+			LST_PutTail(pChnl->pFreeList,
+					(struct list_head *)pChirp);
+		} else {
+			ioc.pBuf = NULL;
+			ioc.cBytes = 0;
+		}
+	} else {
+		ioc.pBuf = NULL;
+		ioc.cBytes = 0;
+		ioc.dwArg = 0;
+		ioc.cBufSize = 0;
+	}
+	/* Ensure invariant: If any IOC's are queued for this channel... */
+	if (!LST_IsEmpty(pChnl->pIOCompletions)) {
+		/*  Since DSPStream_Reclaim() does not take a timeout
+		 *  parameter, we pass the stream's timeout value to
+		 *  WMD_CHNL_GetIOC. We cannot determine whether or not
+		 *  we have waited in User mode. Since the stream's timeout
+		 *  value may be non-zero, we still have to set the event.
+		 *  Therefore, this optimization is taken out.
+		 *
+		 *  if (dwTimeOut == CHNL_IOCNOWAIT) {
+		 *    ... ensure event is set..
+		 *      SYNC_SetEvent(pChnl->hSyncEvent);
+		 *  } */
+		SYNC_SetEvent(pChnl->hSyncEvent);
+	} else {
+		/* else, if list is empty, ensure event is reset. */
+		SYNC_ResetEvent(pChnl->hSyncEvent);
+	}
+	enable_irq(MAILBOX_IRQ);
+	SYNC_LeaveCS(pChnl->pChnlMgr->hCSObj);
+	if (fDequeueIOC && (pChnl->uChnlType == CHNL_PCPY && pChnl->uId > 1)) {
+		if (!(ioc.pBuf < (void *) USERMODE_ADDR))
+			goto func_cont;
+
+		/* If the addr is in user mode, then copy it */
+		if (!pHostSysBuf || !ioc.pBuf) {
+			status = DSP_EPOINTER;
+			goto func_cont;
+		}
+		if (!CHNL_IsInput(pChnl->uMode))
+			goto func_cont1;
+
+		/*pHostUserBuf */
+		status = copy_to_user(ioc.pBuf, pHostSysBuf, ioc.cBytes);
+		if (status) {
+			if (current->flags & PF_EXITING)
+				status = 0;
+		}
+		if (status)
+			status = DSP_EPOINTER;
+func_cont1:
+		kfree(pHostSysBuf);
+	}
+func_cont:
+	/* Update User's IOC block: */
+	*pIOC = ioc;
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_GetMgrInfo ========
+ *      Retrieve information related to the channel manager.
+ */
+DSP_STATUS WMD_CHNL_GetMgrInfo(struct CHNL_MGR *hChnlMgr, u32 uChnlID,
+			      OUT struct CHNL_MGRINFO *pMgrInfo)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_MGR *pChnlMgr = (struct CHNL_MGR *)hChnlMgr;
+
+	if (pMgrInfo != NULL) {
+		if (uChnlID <= CHNL_MAXCHANNELS) {
+			if (MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+				/* Return the requested information:  */
+				pMgrInfo->hChnl = pChnlMgr->apChannel[uChnlID];
+				pMgrInfo->cOpenChannels = pChnlMgr->
+							  cOpenChannels;
+				pMgrInfo->dwType = pChnlMgr->dwType;
+				/* total # of chnls */
+				pMgrInfo->cChannels = pChnlMgr->cChannels;
+			} else {
+				status = DSP_EHANDLE;
+			}
+		} else {
+			status = CHNL_E_BADCHANID;
+		}
+	} else {
+		status = DSP_EPOINTER;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_Idle ========
+ *      Idles a particular channel.
+ */
+DSP_STATUS WMD_CHNL_Idle(struct CHNL_OBJECT *hChnl, u32 dwTimeOut,
+			 bool fFlush)
+{
+	short int uMode;
+	struct CHNL_MGR *pChnlMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(MEM_IsValidHandle(hChnl, CHNL_SIGNATURE));
+
+	uMode = hChnl->uMode;
+	pChnlMgr = hChnl->pChnlMgr;
+
+	if (CHNL_IsOutput(uMode) && !fFlush) {
+		/* Wait for IO completions, up to the specified timeout: */
+		status = WMD_CHNL_FlushIO(hChnl, dwTimeOut);
+	} else {
+		status = WMD_CHNL_CancelIO(hChnl);
+
+		/* Reset the byte count and put channel back in ready state. */
+		hChnl->cBytesMoved = 0;
+		hChnl->dwState &= ~CHNL_STATECANCEL;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_Open ========
+ *      Open a new half-duplex channel to the DSP board.
+ */
+DSP_STATUS WMD_CHNL_Open(OUT struct CHNL_OBJECT **phChnl,
+			 struct CHNL_MGR *hChnlMgr, short int uMode,
+			 u32 uChnlId, CONST IN struct CHNL_ATTRS *pAttrs)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct CHNL_MGR *pChnlMgr = hChnlMgr;
+	struct CHNL_OBJECT *pChnl = NULL;
+	struct SYNC_ATTRS *pSyncAttrs = NULL;
+	struct SYNC_OBJECT *hSyncEvent = NULL;
+	/* Ensure DBC requirements:  */
+	DBC_Require(phChnl != NULL);
+	DBC_Require(pAttrs != NULL);
+	DBC_Require(hChnlMgr != NULL);
+	*phChnl = NULL;
+	/* Validate Args:  */
+	if (pAttrs->uIOReqs == 0) {
+		status = DSP_EINVALIDARG;
+	} else {
+		if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE)) {
+			status = DSP_EHANDLE;
+		} else {
+			if (uChnlId != CHNL_PICKFREE) {
+				if (uChnlId >= pChnlMgr->cChannels)
+					status = CHNL_E_BADCHANID;
+				else if (pChnlMgr->apChannel[uChnlId] != NULL)
+					status = CHNL_E_CHANBUSY;
+			} else {
+				/* Check for free channel */
+				status = SearchFreeChannel(pChnlMgr, &uChnlId);
+			}
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	DBC_Assert(uChnlId < pChnlMgr->cChannels);
+	/* Create channel object:  */
+	MEM_AllocObject(pChnl, struct CHNL_OBJECT, 0x0000);
+	if (!pChnl) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	/* Protect queues from IO_DPC: */
+	pChnl->dwState = CHNL_STATECANCEL;
+	/* Allocate initial IOR and IOC queues: */
+	pChnl->pFreeList = CreateChirpList(pAttrs->uIOReqs);
+	pChnl->pIORequests = CreateChirpList(0);
+	pChnl->pIOCompletions = CreateChirpList(0);
+	pChnl->cChirps = pAttrs->uIOReqs;
+	pChnl->cIOCs = 0;
+	pChnl->cIOReqs = 0;
+	status = SYNC_OpenEvent(&hSyncEvent, pSyncAttrs);
+	if (DSP_SUCCEEDED(status))
+		status = NTFY_Create(&pChnl->hNtfy);
+
+	if (DSP_SUCCEEDED(status)) {
+		if (pChnl->pIOCompletions && pChnl->pIORequests &&
+		   pChnl->pFreeList) {
+			/* Initialize CHNL object fields:    */
+			pChnl->pChnlMgr = pChnlMgr;
+			pChnl->uId = uChnlId;
+			pChnl->uMode = uMode;
+			pChnl->hUserEvent = hSyncEvent;	/* for Linux */
+			pChnl->hSyncEvent = hSyncEvent;
+			/* Get the process handle */
+			pChnl->hProcess = current->tgid;
+			pChnl->pCBArg = 0;
+			pChnl->cBytesMoved = 0;
+			/* Default to proc-copy */
+			pChnl->uChnlType = CHNL_PCPY;
+		} else {
+			status = DSP_EMEMORY;
+		}
+	}
+
+	if (DSP_FAILED(status)) {
+		/* Free memory */
+		if (pChnl->pIOCompletions) {
+			FreeChirpList(pChnl->pIOCompletions);
+			pChnl->pIOCompletions = NULL;
+			pChnl->cIOCs = 0;
+		}
+		if (pChnl->pIORequests) {
+			FreeChirpList(pChnl->pIORequests);
+			pChnl->pIORequests = NULL;
+		}
+		if (pChnl->pFreeList) {
+			FreeChirpList(pChnl->pFreeList);
+			pChnl->pFreeList = NULL;
+		}
+		if (hSyncEvent) {
+			SYNC_CloseEvent(hSyncEvent);
+			hSyncEvent = NULL;
+		}
+		if (pChnl->hNtfy) {
+			NTFY_Delete(pChnl->hNtfy);
+			pChnl->hNtfy = NULL;
+		}
+		MEM_FreeObject(pChnl);
+	} else {
+		/* Insert channel object in channel manager: */
+		pChnlMgr->apChannel[pChnl->uId] = pChnl;
+		SYNC_EnterCS(pChnlMgr->hCSObj);
+		pChnlMgr->cOpenChannels++;
+		SYNC_LeaveCS(pChnlMgr->hCSObj);
+		/* Return result... */
+		pChnl->dwSignature = CHNL_SIGNATURE;
+		pChnl->dwState = CHNL_STATEREADY;
+		*phChnl = pChnl;
+	}
+func_end:
+	DBC_Ensure((DSP_SUCCEEDED(status) &&
+		  MEM_IsValidHandle(pChnl, CHNL_SIGNATURE)) ||
+		  (*phChnl == NULL));
+	return status;
+}
+
+/*
+ *  ======== WMD_CHNL_RegisterNotify ========
+ *      Registers for events on a particular channel.
+ */
+DSP_STATUS WMD_CHNL_RegisterNotify(struct CHNL_OBJECT *hChnl, u32 uEventMask,
+				  u32 uNotifyType,
+				  struct DSP_NOTIFICATION *hNotification)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Assert(!(uEventMask & ~(DSP_STREAMDONE | DSP_STREAMIOCOMPLETION)));
+
+	status = NTFY_Register(hChnl->hNtfy, hNotification, uEventMask,
+			      uNotifyType);
+
+	return status;
+}
+
+/*
+ *  ======== CreateChirpList ========
+ *  Purpose:
+ *      Initialize a queue of channel I/O Request/Completion packets.
+ *  Parameters:
+ *      uChirps:    Number of Chirps to allocate.
+ *  Returns:
+ *      Pointer to queue of IRPs, or NULL.
+ *  Requires:
+ *  Ensures:
+ */
+static struct LST_LIST *CreateChirpList(u32 uChirps)
+{
+	struct LST_LIST *pChirpList;
+	struct CHNL_IRP *pChirp;
+	u32 i;
+
+	pChirpList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
+
+	if (pChirpList) {
+		INIT_LIST_HEAD(&pChirpList->head);
+		/* Make N chirps and place on queue. */
+		for (i = 0; (i < uChirps) && ((pChirp = MakeNewChirp()) !=
+		    NULL); i++) {
+			LST_PutTail(pChirpList, (struct list_head *)pChirp);
+		}
+
+		/* If we couldn't allocate all chirps, free those allocated: */
+		if (i != uChirps) {
+			FreeChirpList(pChirpList);
+			pChirpList = NULL;
+		}
+	}
+
+	return pChirpList;
+}
+
+/*
+ *  ======== FreeChirpList ========
+ *  Purpose:
+ *      Free the queue of Chirps.
+ */
+static void FreeChirpList(struct LST_LIST *pChirpList)
+{
+	DBC_Require(pChirpList != NULL);
+
+	while (!LST_IsEmpty(pChirpList))
+		kfree(LST_GetHead(pChirpList));
+
+	kfree(pChirpList);
+}
+
+/*
+ *  ======== MakeNewChirp ========
+ *      Allocate the memory for a new channel IRP.
+ */
+static struct CHNL_IRP *MakeNewChirp(void)
+{
+	struct CHNL_IRP *pChirp;
+
+	pChirp = (struct CHNL_IRP *)MEM_Calloc(
+		 sizeof(struct CHNL_IRP), MEM_NONPAGED);
+	if (pChirp != NULL) {
+		/* LST_InitElem only resets the list's member values. */
+		LST_InitElem(&pChirp->link);
+	}
+
+	return pChirp;
+}
+
+/*
+ *  ======== SearchFreeChannel ========
+ *      Search for a free channel slot in the array of channel pointers.
+ */
+static DSP_STATUS SearchFreeChannel(struct CHNL_MGR *pChnlMgr,
+				   OUT u32 *pdwChnl)
+{
+	DSP_STATUS status = CHNL_E_OUTOFSTREAMS;
+	u32 i;
+
+	DBC_Require(MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE));
+
+	for (i = 0; i < pChnlMgr->cChannels; i++) {
+		if (pChnlMgr->apChannel[i] == NULL) {
+			status = DSP_SOK;
+			*pdwChnl = i;
+			break;
+		}
+	}
+
+	return status;
+}
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
new file mode 100644
index 0000000..c96fb38
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -0,0 +1,2002 @@
+/*
+ * io_sm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * IO dispatcher for a shared memory channel driver.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*
+ * Channel Invariant:
+ * There is an important invariant condition which must be maintained per
+ * channel outside of WMD_CHNL_GetIOC() and IO_Dispatch(), violation of
+ * which may cause timeouts and/or failure of the SYNC_WaitOnEvent
+ * function.
+ */
+
+/* Host OS */
+#include <dspbridge/host_os.h>
+#include <linux/workqueue.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/* Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/* Services Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/sync.h>
+#include <dspbridge/reg.h>
+
+/* Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/* Mini Driver */
+#include <dspbridge/wmddeh.h>
+#include <dspbridge/wmdio.h>
+#include <dspbridge/wmdioctl.h>
+#include <_tiomap.h>
+#include <tiomap_io.h>
+#include <_tiomap_pwr.h>
+
+/* Platform Manager */
+#include <dspbridge/cod.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/chnl_sm.h>
+
+/* Others */
+#include <dspbridge/rms_sh.h>
+#include <dspbridge/mgr.h>
+#include <dspbridge/drv.h>
+#include "_cmm.h"
+
+/* This */
+#include <dspbridge/io_sm.h>
+#include "_msg_sm.h"
+
+/* Defines, Data Structures, Typedefs */
+#define OUTPUTNOTREADY  0xffff
+#define NOTENABLED      0xffff	/* Channel(s) not enabled */
+
+#define EXTEND      "_EXT_END"
+
+#define SwapWord(x)     (x)
+#define ulPageAlignSize 0x10000   /* Page Align Size */
+
+#define MAX_PM_REQS 32
+
+/* IO Manager: only one created per board */
+struct IO_MGR {
+	/* These four fields must be the first fields in a IO_MGR_ struct */
+	u32 dwSignature; 	/* Used for object validation */
+	struct WMD_DEV_CONTEXT *hWmdContext; 	/* WMD device context */
+	struct WMD_DRV_INTERFACE *pIntfFxns; 	/* Function interface to WMD */
+	struct DEV_OBJECT *hDevObject; 	/* Device this board represents */
+
+	/* These fields initialized in WMD_IO_Create() */
+	struct CHNL_MGR *hChnlMgr;
+	struct SHM *pSharedMem; 	/* Shared Memory control */
+	u8 *pInput; 		/* Address of input channel */
+	u8 *pOutput; 		/* Address of output channel */
+	struct MSG_MGR *hMsgMgr; 	/* Message manager */
+	struct MSG *pMsgInputCtrl; 	/* Msg control for from DSP messages */
+	struct MSG *pMsgOutputCtrl; 	/* Msg control for to DSP messages */
+	u8 *pMsgInput; 	/* Address of input messages */
+	u8 *pMsgOutput; 	/* Address of output messages */
+	u32 uSMBufSize; 	/* Size of a shared memory I/O channel */
+	bool fSharedIRQ; 	/* Is this IRQ shared? */
+	struct SYNC_CSOBJECT *hCSObj; 	/* Critical section object handle */
+	u32 uWordSize; 	/* Size in bytes of DSP word */
+	u16 wIntrVal; 		/* Interrupt value */
+	/* Private extnd proc info; mmu setup */
+	struct MGR_PROCESSOREXTINFO extProcInfo;
+	struct CMM_OBJECT *hCmmMgr; 	/* Shared Mem Mngr */
+	struct work_struct io_workq;     /* workqueue */
+	u32 dQuePowerMbxVal[MAX_PM_REQS];
+	u32 iQuePowerHead;
+	u32 iQuePowerTail;
+#ifndef DSP_TRACEBUF_DISABLED
+	u32 ulTraceBufferBegin; 	/* Trace message start address */
+	u32 ulTraceBufferEnd; 	/* Trace message end address */
+	u32 ulTraceBufferCurrent; 	/* Trace message current address */
+	u32 ulGPPReadPointer; 	/* GPP Read pointer to Trace buffer */
+	u8 *pMsg;
+	u32 ulGppVa;
+	u32 ulDspVa;
+#endif
+	/* IO Dpc */
+	u32 dpc_req;				/* Number of requested DPC's. */
+	u32 dpc_sched;				/* Number of executed DPC's. */
+	struct tasklet_struct dpc_tasklet;
+	spinlock_t dpc_lock;
+
+} ;
+
+/* Function Prototypes */
+static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
+			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode);
+static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
+static void IO_DispatchPM(struct work_struct *work);
+static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
+				struct CHNL_IRP *pChirp);
+static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+			u32 iMode);
+static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+			u32 iMode);
+static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
+static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr);
+static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
+			     struct CHNL_OBJECT *pChnl, u32 dwMask);
+static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
+			void *pSrc, u32 uSize);
+static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
+			void *pSrc, u32 uSize);
+static struct workqueue_struct *bridge_workqueue;
+#ifndef DSP_TRACEBUF_DISABLED
+void PrintDSPDebugTrace(struct IO_MGR *hIOMgr);
+#endif
+
+/* Bus Addr (cached kernel) */
+static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
+				  struct COD_MANAGER *hCodMan,
+				  u32 dwGPPBasePA);
+
+#ifdef CONFIG_BRIDGE_DVFS
+/* The maximum number of OPPs that are supported */
+extern s32 dsp_max_opps;
+/* The Vdd1 opp table information */
+extern u32 vdd1_dsp_freq[6][4] ;
+#endif
+
+/*
+ *  ======== WMD_IO_Create ========
+ *      Create an IO manager object.
+ */
+DSP_STATUS WMD_IO_Create(OUT struct IO_MGR **phIOMgr,
+			 struct DEV_OBJECT *hDevObject,
+			 IN CONST struct IO_ATTRS *pMgrAttrs)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct IO_MGR *pIOMgr = NULL;
+	struct SHM *pSharedMem = NULL;
+	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
+	struct CFG_HOSTRES hostRes;
+	struct CFG_DEVNODE *hDevNode;
+	struct CHNL_MGR *hChnlMgr;
+	static int ref_count;
+	u32 devType;
+	/* Check requirements */
+	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->uWordSize == 0) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	DEV_GetChnlMgr(hDevObject, &hChnlMgr);
+	if (!hChnlMgr || hChnlMgr->hIOMgr) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	/*
+	 * Message manager will be created when a file is loaded, since
+	 * size of message buffer in shared memory is configurable in
+	 * the base image.
+	 */
+	DEV_GetWMDContext(hDevObject, &hWmdContext);
+	if (!hWmdContext) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	DEV_GetDevType(hDevObject, &devType);
+	/*
+	 * DSP shared memory area will get set properly when
+	 * a program is loaded. They are unknown until a COFF file is
+	 * loaded. I chose the value -1 because it was less likely to be
+	 * a valid address than 0.
+	 */
+	pSharedMem = (struct SHM *) -1;
+
+	/* Create a Single Threaded Work Queue */
+	if (ref_count == 0)
+		bridge_workqueue = create_workqueue("bridge_work-queue");
+
+	if (bridge_workqueue <= 0)
+		dev_dbg(bridge, "%s: Workque Create failed %p\n", __func__,
+							bridge_workqueue);
+
+	/* Allocate IO manager object */
+	MEM_AllocObject(pIOMgr, struct IO_MGR, IO_MGRSIGNATURE);
+	if (pIOMgr == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	/* Intializing Work Element */
+	if (ref_count == 0) {
+		INIT_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
+		ref_count = 1;
+	} else {
+		PREPARE_WORK(&pIOMgr->io_workq, (void *)IO_DispatchPM);
+	}
+
+	/* Initialize CHNL_MGR object */
+#ifndef DSP_TRACEBUF_DISABLED
+	pIOMgr->pMsg = NULL;
+#endif
+	pIOMgr->hChnlMgr = hChnlMgr;
+	pIOMgr->uWordSize = pMgrAttrs->uWordSize;
+	pIOMgr->pSharedMem = pSharedMem;
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_InitializeCS(&pIOMgr->hCSObj);
+
+	if (devType == DSP_UNIT) {
+		/* Create an IO DPC */
+		tasklet_init(&pIOMgr->dpc_tasklet, IO_DPC, (u32)pIOMgr);
+
+		/* Initialize DPC counters */
+		pIOMgr->dpc_req = 0;
+		pIOMgr->dpc_sched = 0;
+
+		spin_lock_init(&pIOMgr->dpc_lock);
+
+		if (DSP_SUCCEEDED(status))
+			status = DEV_GetDevNode(hDevObject, &hDevNode);
+
+		pIOMgr->iQuePowerHead = 0;
+		pIOMgr->iQuePowerTail = 0;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = CFG_GetHostResources((struct CFG_DEVNODE *)
+				DRV_GetFirstDevExtension() , &hostRes);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		pIOMgr->hWmdContext = hWmdContext;
+		pIOMgr->fSharedIRQ = pMgrAttrs->fShared;
+		IO_DisableInterrupt(hWmdContext);
+		if (devType == DSP_UNIT) {
+			HW_MBOX_initSettings(hostRes.dwMboxBase);
+			/* Plug the channel ISR */
+			if ((request_irq(INT_MAIL_MPU_IRQ, IO_ISR, 0,
+			  "DspBridge\tmailbox", (void *)pIOMgr)) != 0)
+				status = CHNL_E_ISR;
+		}
+	} else {
+		status = CHNL_E_ISR;
+	}
+func_end:
+	if (DSP_FAILED(status)) {
+		/* Cleanup */
+		WMD_IO_Destroy(pIOMgr);
+		if (phIOMgr)
+			*phIOMgr = NULL;
+	} else {
+		/* Return IO manager object to caller... */
+		hChnlMgr->hIOMgr = pIOMgr;
+		*phIOMgr = pIOMgr;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_IO_Destroy ========
+ *  Purpose:
+ *      Disable interrupts, destroy the IO manager.
+ */
+DSP_STATUS WMD_IO_Destroy(struct IO_MGR *hIOMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *hWmdContext;
+	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE)) {
+		/* Disable interrupts from the board */
+		status = DEV_GetWMDContext(hIOMgr->hDevObject, &hWmdContext);
+		if (DSP_SUCCEEDED(status))
+			(void)CHNLSM_DisableInterrupt(hWmdContext);
+
+		destroy_workqueue(bridge_workqueue);
+		/* Linux function to uninstall ISR */
+		free_irq(INT_MAIL_MPU_IRQ, (void *)hIOMgr);
+
+		/* Free IO DPC object */
+		tasklet_kill(&hIOMgr->dpc_tasklet);
+
+#ifndef DSP_TRACEBUF_DISABLED
+		kfree(hIOMgr->pMsg);
+#endif
+		SYNC_DeleteCS(hIOMgr->hCSObj); 	/* Leak Fix. */
+		/* Free this IO manager object */
+		MEM_FreeObject(hIOMgr);
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_IO_OnLoaded ========
+ *  Purpose:
+ *      Called when a new program is loaded to get shared memory buffer
+ *      parameters from COFF file. ulSharedBufferBase and ulSharedBufferLimit
+ *      are in DSP address units.
+ */
+DSP_STATUS WMD_IO_OnLoaded(struct IO_MGR *hIOMgr)
+{
+	struct COD_MANAGER *hCodMan;
+	struct CHNL_MGR *hChnlMgr;
+	struct MSG_MGR *hMsgMgr;
+	u32 ulShmBase;
+	u32 ulShmBaseOffset;
+	u32 ulShmLimit;
+	u32 ulShmLength = -1;
+	u32 ulMemLength = -1;
+	u32 ulMsgBase;
+	u32 ulMsgLimit;
+	u32 ulMsgLength = -1;
+	u32 ulExtEnd;
+	u32 ulGppPa = 0;
+	u32 ulGppVa = 0;
+	u32 ulDspVa = 0;
+	u32 ulSegSize = 0;
+	u32 ulPadSize = 0;
+	u32 i;
+	DSP_STATUS status = DSP_SOK;
+	u32 uNumProcs = 0;
+	s32 ndx = 0;
+	/* DSP MMU setup table */
+	struct WMDIOCTL_EXTPROC aEProc[WMDIOCTL_NUMOFMMUTLB];
+	struct CFG_HOSTRES hostRes;
+	u32 mapAttrs;
+	u32 ulShm0End;
+	u32 ulDynExtBase;
+	u32 ulSeg1Size = 0;
+	u32 paCurr = 0;
+	u32 vaCurr = 0;
+	u32 gppVaCurr = 0;
+	u32 numBytes = 0;
+	u32 allBits = 0;
+	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
+			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
+
+	status = DEV_GetCodMgr(hIOMgr->hDevObject, &hCodMan);
+	if (DSP_FAILED(status))
+		goto func_end;
+	hChnlMgr = hIOMgr->hChnlMgr;
+	/* The message manager is destroyed when the board is stopped. */
+	DEV_GetMsgMgr(hIOMgr->hDevObject, &hIOMgr->hMsgMgr);
+	hMsgMgr = hIOMgr->hMsgMgr;
+	if (!MEM_IsValidHandle(hChnlMgr, CHNL_MGRSIGNATURE) ||
+	   !MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE)) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+	if (hIOMgr->pSharedMem)
+		hIOMgr->pSharedMem = NULL;
+
+	/* Get start and length of channel part of shared memory */
+	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_BASE_SYM,
+				 &ulShmBase);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	status = COD_GetSymValue(hCodMan, CHNL_SHARED_BUFFER_LIMIT_SYM,
+				&ulShmLimit);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	if (ulShmLimit <= ulShmBase) {
+		status = CHNL_E_INVALIDMEMBASE;
+		goto func_end;
+	}
+	/* Get total length in bytes */
+	ulShmLength = (ulShmLimit - ulShmBase + 1) * hIOMgr->uWordSize;
+	/* Calculate size of a PROCCOPY shared memory region */
+	dev_dbg(bridge, "%s: (proc)proccopy shmmem size: 0x%x bytes\n",
+				__func__, (ulShmLength - sizeof(struct SHM)));
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Get start and length of message part of shared memory */
+		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_BASE_SYM,
+					&ulMsgBase);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_GetSymValue(hCodMan, MSG_SHARED_BUFFER_LIMIT_SYM,
+					&ulMsgLimit);
+		if (DSP_SUCCEEDED(status)) {
+			if (ulMsgLimit <= ulMsgBase) {
+				status = CHNL_E_INVALIDMEMBASE;
+			} else {
+				/*
+				 * Length (bytes) of messaging part of shared
+				 * memory.
+				 */
+				ulMsgLength = (ulMsgLimit - ulMsgBase + 1) *
+					      hIOMgr->uWordSize;
+				/*
+				 * Total length (bytes) of shared memory:
+				 * chnl + msg.
+				 */
+				ulMemLength = ulShmLength + ulMsgLength;
+			}
+		} else {
+			status = CHNL_E_NOMEMMAP;
+		}
+	} else {
+		status = CHNL_E_NOMEMMAP;
+	}
+	if (DSP_SUCCEEDED(status)) {
+#ifndef DSP_TRACEBUF_DISABLED
+		status = COD_GetSymValue(hCodMan, DSP_TRACESEC_END, &ulShm0End);
+#else
+		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
+					 &ulShm0End);
+#endif
+		if (DSP_FAILED(status))
+			status = CHNL_E_NOMEMMAP;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_GetSymValue(hCodMan, DYNEXTBASE, &ulDynExtBase);
+		if (DSP_FAILED(status))
+			status = CHNL_E_NOMEMMAP;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		status = COD_GetSymValue(hCodMan, EXTEND, &ulExtEnd);
+		if (DSP_FAILED(status))
+			status = CHNL_E_NOMEMMAP;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Get memory reserved in host resources */
+		(void)MGR_EnumProcessorInfo(0,
+			(struct DSP_PROCESSORINFO *)&hIOMgr->extProcInfo,
+			sizeof(struct MGR_PROCESSOREXTINFO), &uNumProcs);
+		CFG_GetHostResources((
+			struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&hostRes);
+		/* The first MMU TLB entry(TLB_0) in DCD is ShmBase. */
+		ndx = 0;
+		ulGppPa = hostRes.dwMemPhys[1];
+		ulGppVa = hostRes.dwMemBase[1];
+		/* This is the virtual uncached ioremapped address!!! */
+		/* Why can't we directly take the DSPVA from the symbols? */
+		ulDspVa = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt;
+		ulSegSize = (ulShm0End - ulDspVa) * hIOMgr->uWordSize;
+		ulSeg1Size = (ulExtEnd - ulDynExtBase) * hIOMgr->uWordSize;
+		ulSeg1Size = (ulSeg1Size + 0xFFF) & (~0xFFFUL); /* 4K align*/
+		ulSegSize = (ulSegSize + 0xFFFF) & (~0xFFFFUL); /* 64K align*/
+		ulPadSize = ulPageAlignSize - ((ulGppPa + ulSeg1Size) %
+			     ulPageAlignSize);
+			if (ulPadSize == ulPageAlignSize)
+				ulPadSize = 0x0;
+
+		 dev_dbg(bridge, "%s: ulGppPa %x, ulGppVa %x, ulDspVa %x, "
+				"ulShm0End %x, ulDynExtBase %x, ulExtEnd %x, "
+				"ulSegSize %x ulSeg1Size %x \n", __func__,
+				ulGppPa, ulGppVa, ulDspVa, ulShm0End,
+				ulDynExtBase, ulExtEnd, ulSegSize, ulSeg1Size);
+
+		if ((ulSegSize + ulSeg1Size + ulPadSize) >
+		   hostRes.dwMemLength[1]) {
+			pr_err("%s: SHM Error, reserved 0x%x required 0x%x\n",
+					__func__, hostRes.dwMemLength[1],
+					ulSegSize + ulSeg1Size + ulPadSize);
+			status = DSP_EMEMORY;
+		}
+	}
+	if (DSP_FAILED(status))
+		goto func_end;
+
+	paCurr = ulGppPa;
+	vaCurr = ulDynExtBase * hIOMgr->uWordSize;
+	gppVaCurr = ulGppVa;
+	numBytes = ulSeg1Size;
+
+	/*
+	 * Try to fit into TLB entries. If not possible, push them to page
+	 * tables. It is quite possible that if sections are not on
+	 * bigger page boundary, we may end up making several small pages.
+	 * So, push them onto page tables, if that is the case.
+	 */
+	mapAttrs = 0x00000000;
+	mapAttrs = DSP_MAPLITTLEENDIAN;
+	mapAttrs |= DSP_MAPPHYSICALADDR;
+	mapAttrs |= DSP_MAPELEMSIZE32;
+	mapAttrs |= DSP_MAPDONOTLOCK;
+
+	while (numBytes) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
+		allBits = paCurr | vaCurr;
+		dev_dbg(bridge, "allBits %x, paCurr %x, vaCurr %x, "
+			 "numBytes %x\n", allBits, paCurr, vaCurr, numBytes);
+		for (i = 0; i < 4; i++) {
+			if ((numBytes >= pgSize[i]) && ((allBits &
+			   (pgSize[i] - 1)) == 0)) {
+				status = hIOMgr->pIntfFxns->pfnBrdMemMap
+					(hIOMgr->hWmdContext, paCurr, vaCurr,
+					pgSize[i], mapAttrs);
+				if (DSP_FAILED(status))
+					goto func_end;
+				paCurr += pgSize[i];
+				vaCurr += pgSize[i];
+				gppVaCurr += pgSize[i];
+				numBytes -= pgSize[i];
+				/*
+				 * Don't try smaller sizes. Hopefully we have
+				 * reached an address aligned to a bigger page
+				 * size.
+				 */
+				break;
+			}
+		}
+	}
+	paCurr += ulPadSize;
+	vaCurr += ulPadSize;
+	gppVaCurr += ulPadSize;
+
+	/* Configure the TLB entries for the next cacheable segment */
+	numBytes = ulSegSize;
+	vaCurr = ulDspVa * hIOMgr->uWordSize;
+	while (numBytes) {
+		/*
+		 * To find the max. page size with which both PA & VA are
+		 * aligned.
+		 */
+		allBits = paCurr | vaCurr;
+		dev_dbg(bridge, "allBits for Seg1 %x, paCurr %x, "
+			 "vaCurr %x, numBytes %x\n", allBits, paCurr, vaCurr,
+			 numBytes);
+		for (i = 0; i < 4; i++) {
+			if (!(numBytes >= pgSize[i]) ||
+			   !((allBits & (pgSize[i]-1)) == 0))
+				continue;
+			if (ndx < MAX_LOCK_TLB_ENTRIES) {
+				/*
+				 * This is the physical address written to
+				 * DSP MMU.
+				 */
+				aEProc[ndx].ulGppPa = paCurr;
+				/*
+				 * This is the virtual uncached ioremapped
+				 * address!!!
+				 */
+				aEProc[ndx].ulGppVa = gppVaCurr;
+				aEProc[ndx].ulDspVa = vaCurr / hIOMgr->
+						      uWordSize;
+				aEProc[ndx].ulSize = pgSize[i];
+				aEProc[ndx].endianism = HW_LITTLE_ENDIAN;
+				aEProc[ndx].elemSize = HW_ELEM_SIZE_16BIT;
+				aEProc[ndx].mixedMode = HW_MMU_CPUES;
+				dev_dbg(bridge, "SHM MMU TLB entry PA %x"
+					 " VA %x DSP_VA %x Size %x\n",
+					 aEProc[ndx].ulGppPa,
+					 aEProc[ndx].ulGppVa,
+					 aEProc[ndx].ulDspVa *
+					 hIOMgr->uWordSize, pgSize[i]);
+				ndx++;
+			} else {
+				status = hIOMgr->pIntfFxns->pfnBrdMemMap(
+				hIOMgr->hWmdContext, paCurr, vaCurr, pgSize[i],
+					mapAttrs);
+				dev_dbg(bridge, "SHM MMU PTE entry PA %x"
+					 " VA %x DSP_VA %x Size %x\n",
+					 aEProc[ndx].ulGppPa,
+					 aEProc[ndx].ulGppVa,
+					 aEProc[ndx].ulDspVa *
+					 hIOMgr->uWordSize, pgSize[i]);
+				if (DSP_FAILED(status)) {
+					goto func_end;
+				}
+			}
+			paCurr += pgSize[i];
+			vaCurr += pgSize[i];
+			gppVaCurr += pgSize[i];
+			numBytes -= pgSize[i];
+			/*
+			 * Don't try smaller sizes. Hopefully we have reached
+			 * an address aligned to a bigger page size.
+			 */
+			break;
+		}
+	}
+
+	/*
+	 * Copy remaining entries from CDB. All entries are 1 MB and
+	 * should not conflict with SHM entries on MPU or DSP side.
+	 */
+	for (i = 3; i < 7 && ndx < WMDIOCTL_NUMOFMMUTLB; i++) {
+		if (hIOMgr->extProcInfo.tyTlb[i].ulGppPhys == 0)
+			continue;
+
+		if ((hIOMgr->extProcInfo.tyTlb[i].ulGppPhys > ulGppPa - 0x100000
+			&& hIOMgr->extProcInfo.tyTlb[i].ulGppPhys <=
+				ulGppPa + ulSegSize)
+			|| (hIOMgr->extProcInfo.tyTlb[i].ulDspVirt > ulDspVa -
+				0x100000 / hIOMgr->uWordSize && hIOMgr->
+				extProcInfo.tyTlb[i].ulDspVirt
+				<= ulDspVa + ulSegSize / hIOMgr->uWordSize)) {
+			dev_dbg(bridge, "CDB MMU entry %d conflicts with "
+				 "SHM.\n\tCDB: GppPa %x, DspVa %x.\n\tSHM: "
+				 "GppPa %x, DspVa %x, Bytes %x.\n", i,
+				 hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
+				 hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
+				 ulGppPa, ulDspVa, ulSegSize);
+			status = DSP_EFAIL;
+		} else {
+			if (ndx < MAX_LOCK_TLB_ENTRIES) {
+				aEProc[ndx].ulDspVa = hIOMgr->extProcInfo.
+					tyTlb[i].ulDspVirt;
+				aEProc[ndx].ulGppPa = hIOMgr->extProcInfo.
+					tyTlb[i].ulGppPhys;
+				aEProc[ndx].ulGppVa = 0;
+				/* Can't convert, so set to zero */
+				aEProc[ndx].ulSize = 0x100000; 	/* 1 MB */
+				dev_dbg(bridge, "SHM MMU entry PA %x "
+					 "DSP_VA 0x%x\n", aEProc[ndx].ulGppPa,
+					aEProc[ndx].ulDspVa);
+				ndx++;
+			} else {
+				status = hIOMgr->pIntfFxns->pfnBrdMemMap
+					(hIOMgr->hWmdContext,
+					hIOMgr->extProcInfo.tyTlb[i].ulGppPhys,
+					hIOMgr->extProcInfo.tyTlb[i].ulDspVirt,
+					0x100000, mapAttrs);
+			}
+		}
+		if (DSP_FAILED(status))
+			goto func_end;
+	}
+
+	mapAttrs = 0x00000000;
+	mapAttrs = DSP_MAPLITTLEENDIAN;
+	mapAttrs |= DSP_MAPPHYSICALADDR;
+	mapAttrs |= DSP_MAPELEMSIZE32;
+	mapAttrs |= DSP_MAPDONOTLOCK;
+
+	/* Map the L4 peripherals */
+	i = 0;
+	while (L4PeripheralTable[i].physAddr) {
+		status = hIOMgr->pIntfFxns->pfnBrdMemMap
+			(hIOMgr->hWmdContext, L4PeripheralTable[i].physAddr,
+			L4PeripheralTable[i].dspVirtAddr, HW_PAGE_SIZE_4KB,
+			mapAttrs);
+		if (DSP_FAILED(status))
+			goto func_end;
+		i++;
+	}
+
+
+	for (i = ndx; i < WMDIOCTL_NUMOFMMUTLB; i++) {
+		aEProc[i].ulDspVa = 0;
+		aEProc[i].ulGppPa = 0;
+		aEProc[i].ulGppVa = 0;
+		aEProc[i].ulSize = 0;
+	}
+	/*
+	 * Set the SHM physical address entry (grayed out in CDB file)
+	 * to the virtual uncached ioremapped address of SHM reserved
+	 * on MPU.
+	 */
+	hIOMgr->extProcInfo.tyTlb[0].ulGppPhys = (ulGppVa + ulSeg1Size +
+						 ulPadSize);
+
+	/*
+	 * Need SHM Phys addr. IO supports only one DSP for now:
+	 * uNumProcs = 1.
+	 */
+	if (!hIOMgr->extProcInfo.tyTlb[0].ulGppPhys || uNumProcs != 1) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	} else {
+		if (aEProc[0].ulDspVa > ulShmBase) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* ulShmBase may not be at ulDspVa address */
+		ulShmBaseOffset = (ulShmBase - aEProc[0].ulDspVa) *
+				hIOMgr->uWordSize;
+		/*
+		 * WMD_BRD_Ctrl() will set dev context dsp-mmu info. In
+		 * _BRD_Start() the MMU will be re-programed with MMU
+		 * DSPVa-GPPPa pair info while DSP is in a known
+		 * (reset) state.
+		 */
+
+		status = hIOMgr->pIntfFxns->pfnDevCntrl(hIOMgr->hWmdContext,
+						WMDIOCTL_SETMMUCONFIG, aEProc);
+		if (DSP_FAILED(status))
+			goto func_end;
+		ulShmBase = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
+		ulShmBase += ulShmBaseOffset;
+		ulShmBase = (u32)MEM_LinearAddress((void *)ulShmBase,
+				    ulMemLength);
+		if (ulShmBase == 0) {
+			status = DSP_EPOINTER;
+			goto func_end;
+		}
+		/* Register SM */
+		status = registerSHMSegs(hIOMgr, hCodMan, aEProc[0].ulGppPa);
+	}
+
+	hIOMgr->pSharedMem = (struct SHM *)ulShmBase;
+	hIOMgr->pInput = (u8 *)hIOMgr->pSharedMem + sizeof(struct SHM);
+	hIOMgr->pOutput = hIOMgr->pInput + (ulShmLength -
+						sizeof(struct SHM)) / 2;
+	hIOMgr->uSMBufSize = hIOMgr->pOutput - hIOMgr->pInput;
+
+	 /*  Set up Shared memory addresses for messaging. */
+	hIOMgr->pMsgInputCtrl = (struct MSG *)((u8 *)hIOMgr->pSharedMem
+							+ ulShmLength);
+	hIOMgr->pMsgInput = (u8 *)hIOMgr->pMsgInputCtrl + sizeof(struct MSG);
+	hIOMgr->pMsgOutputCtrl = (struct MSG *)((u8 *)hIOMgr->pMsgInputCtrl
+							+ ulMsgLength / 2);
+	hIOMgr->pMsgOutput = (u8 *)hIOMgr->pMsgOutputCtrl + sizeof(struct MSG);
+	hMsgMgr->uMaxMsgs = ((u8 *)hIOMgr->pMsgOutputCtrl - hIOMgr->pMsgInput)
+						/ sizeof(struct MSG_DSPMSG);
+	dev_dbg(bridge, "IO MGR SHM details: pSharedMem %p, pInput %p, "
+			"pOutput %p, pMsgInputCtrl %p, pMsgInput %p, "
+			"pMsgOutputCtrl %p, pMsgOutput %p\n",
+			(u8 *)hIOMgr->pSharedMem, hIOMgr->pInput,
+			hIOMgr->pOutput, (u8 *)hIOMgr->pMsgInputCtrl,
+			hIOMgr->pMsgInput, (u8 *)hIOMgr->pMsgOutputCtrl,
+			hIOMgr->pMsgOutput);
+	dev_dbg(bridge, "(proc) Mas msgs in shared memory: 0x%x\n",
+							hMsgMgr->uMaxMsgs);
+	memset((void *) hIOMgr->pSharedMem, 0, sizeof(struct SHM));
+
+#ifndef DSP_TRACEBUF_DISABLED
+	/* Get the start address of trace buffer */
+	status = COD_GetSymValue(hCodMan, SYS_PUTCBEG,
+				 &hIOMgr->ulTraceBufferBegin);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+
+	hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin =
+		(ulGppVa + ulSeg1Size + ulPadSize) +
+		(hIOMgr->ulTraceBufferBegin - ulDspVa);
+	/* Get the end address of trace buffer */
+	status = COD_GetSymValue(hCodMan, SYS_PUTCEND,
+						&hIOMgr->ulTraceBufferEnd);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hIOMgr->ulTraceBufferEnd = (ulGppVa + ulSeg1Size + ulPadSize) +
+				   (hIOMgr->ulTraceBufferEnd - ulDspVa);
+	/* Get the current address of DSP write pointer */
+	status = COD_GetSymValue(hCodMan, BRIDGE_SYS_PUTC_current,
+					 &hIOMgr->ulTraceBufferCurrent);
+	if (DSP_FAILED(status)) {
+		status = CHNL_E_NOMEMMAP;
+		goto func_end;
+	}
+	hIOMgr->ulTraceBufferCurrent = (ulGppVa + ulSeg1Size + ulPadSize) +
+				(hIOMgr->ulTraceBufferCurrent - ulDspVa);
+	/* Calculate the size of trace buffer */
+	kfree(hIOMgr->pMsg);
+	hIOMgr->pMsg = MEM_Alloc(((hIOMgr->ulTraceBufferEnd -
+				hIOMgr->ulTraceBufferBegin) *
+				hIOMgr->uWordSize) + 2, MEM_NONPAGED);
+	if (!hIOMgr->pMsg)
+		status = DSP_EMEMORY;
+
+	hIOMgr->ulDspVa = ulDspVa;
+	hIOMgr->ulGppVa = (ulGppVa + ulSeg1Size + ulPadSize);
+
+#endif
+	IO_EnableInterrupt(hIOMgr->hWmdContext);
+func_end:
+	return status;
+}
+
+/*
+ *  ======== IO_BufSize ========
+ *      Size of shared memory I/O channel.
+ */
+u32 IO_BufSize(struct IO_MGR *hIOMgr)
+{
+	if (MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		return hIOMgr->uSMBufSize;
+	else
+		return 0;
+}
+
+/*
+ *  ======== IO_CancelChnl ========
+ *      Cancel IO on a given PCPY channel.
+ */
+void IO_CancelChnl(struct IO_MGR *hIOMgr, u32 ulChnl)
+{
+	struct IO_MGR *pIOMgr = (struct IO_MGR *)hIOMgr;
+	struct SHM *sm;
+
+	if (!MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
+	sm = hIOMgr->pSharedMem;
+
+	/* Inform DSP that we have no more buffers on this channel */
+	IO_AndValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
+		   (~(1 << ulChnl)));
+
+	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+func_end:
+	return;
+}
+
+/*
+ *  ======== IO_DispatchChnl ========
+ *      Proc-copy chanl dispatch.
+ */
+static void IO_DispatchChnl(IN struct IO_MGR *pIOMgr,
+			   IN OUT struct CHNL_OBJECT *pChnl, u32 iMode)
+{
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
+
+	/* See if there is any data available for transfer */
+	if (iMode != IO_SERVICE)
+		goto func_end;
+
+	/* Any channel will do for this mode */
+	InputChnl(pIOMgr, pChnl, iMode);
+	OutputChnl(pIOMgr, pChnl, iMode);
+func_end:
+	return;
+}
+
+/*
+ *  ======== IO_DispatchMsg ========
+ *      Performs I/O dispatch on message queues.
+ */
+static void IO_DispatchMsg(IN struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+{
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
+
+	/* We are performing both input and output processing. */
+	InputMsg(pIOMgr, hMsgMgr);
+	OutputMsg(pIOMgr, hMsgMgr);
+func_end:
+	return;
+}
+
+/*
+ *  ======== IO_DispatchPM ========
+ *      Performs I/O dispatch on PM related messages from DSP
+ */
+static void IO_DispatchPM(struct work_struct *work)
+{
+	struct IO_MGR *pIOMgr = container_of(work, struct IO_MGR, io_workq);
+	DSP_STATUS status;
+	u32 pArg[2];
+
+	/* Perform Power message processing here */
+	while (pIOMgr->iQuePowerHead != pIOMgr->iQuePowerTail) {
+		pArg[0] = *(u32 *)&(pIOMgr->dQuePowerMbxVal[pIOMgr->
+			  iQuePowerTail]);
+
+		/* Send the command to the WMD clk/pwr manager to handle */
+		if (pArg[0] ==  MBX_PM_HIBERNATE_EN) {
+			dev_dbg(bridge, "PM: Hibernate command\n");
+			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
+				 hWmdContext, WMDIOCTL_PWR_HIBERNATE, pArg);
+			if (DSP_FAILED(status))
+				pr_err("%s: hibernate cmd failed 0x%x\n",
+							__func__, status);
+		} else if (pArg[0] == MBX_PM_OPP_REQ) {
+			pArg[1] = pIOMgr->pSharedMem->oppRequest.rqstOppPt;
+			dev_dbg(bridge, "PM: Requested OPP = 0x%x\n", pArg[1]);
+			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
+				 hWmdContext, WMDIOCTL_CONSTRAINT_REQUEST,
+				 pArg);
+			if (DSP_FAILED(status)) {
+				dev_dbg(bridge, "PM: Failed to set constraint "
+							"= 0x%x \n", pArg[1]);
+			}
+
+		} else {
+			dev_dbg(bridge, "PM: clk control value of msg = 0x%x\n",
+								pArg[0]);
+			status = pIOMgr->pIntfFxns->pfnDevCntrl(pIOMgr->
+				 hWmdContext, WMDIOCTL_CLK_CTRL, pArg);
+			if (DSP_FAILED(status))
+				dev_dbg(bridge, "PM: Failed to ctrl the DSP clk"
+							"= 0x%x\n", *pArg);
+		}
+		/* Increment the tail count here */
+		pIOMgr->iQuePowerTail++;
+		if (pIOMgr->iQuePowerTail >= MAX_PM_REQS)
+			pIOMgr->iQuePowerTail = 0;
+	}
+}
+
+/*
+ *  ======== IO_DPC ========
+ *      Deferred procedure call for shared memory channel driver ISR.  Carries
+ *      out the dispatch of I/O as a non-preemptible event.It can only be
+ *      pre-empted      by an ISR.
+ */
+void IO_DPC(IN OUT unsigned long pRefData)
+{
+	struct IO_MGR *pIOMgr = (struct IO_MGR *)pRefData;
+	struct CHNL_MGR *pChnlMgr;
+	struct MSG_MGR *pMsgMgr;
+	struct DEH_MGR *hDehMgr;
+	u32 requested;
+	u32 serviced;
+
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		goto func_end;
+	pChnlMgr = pIOMgr->hChnlMgr;
+	DEV_GetMsgMgr(pIOMgr->hDevObject, &pMsgMgr);
+	DEV_GetDehMgr(pIOMgr->hDevObject, &hDehMgr);
+	if (!MEM_IsValidHandle(pChnlMgr, CHNL_MGRSIGNATURE))
+		goto func_end;
+
+	requested = pIOMgr->dpc_req;
+	serviced = pIOMgr->dpc_sched;
+
+	if (serviced == requested)
+		goto func_end;
+
+	/* Process pending DPC's */
+	do {
+		/* Check value of interrupt reg to ensure it's a valid error */
+		if ((pIOMgr->wIntrVal > DEH_BASE) &&
+		   (pIOMgr->wIntrVal < DEH_LIMIT)) {
+			/* Notify DSP/BIOS exception */
+			if (hDehMgr)
+				WMD_DEH_Notify(hDehMgr, DSP_SYSERROR,
+						pIOMgr->wIntrVal);
+		}
+		IO_DispatchChnl(pIOMgr, NULL, IO_SERVICE);
+#ifdef CHNL_MESSAGES
+		if (MEM_IsValidHandle(pMsgMgr, MSGMGR_SIGNATURE))
+			IO_DispatchMsg(pIOMgr, pMsgMgr);
+#endif
+#ifndef DSP_TRACEBUF_DISABLED
+	if (pIOMgr->wIntrVal & MBX_DBG_SYSPRINTF) {
+		/* Notify DSP Trace message */
+		PrintDSPDebugTrace(pIOMgr);
+	}
+#endif
+		serviced++;
+	} while (serviced != requested);
+	pIOMgr->dpc_sched = requested;
+func_end:
+	return;
+}
+
+/*
+ *  ======== IO_ISR ========
+ *      Main interrupt handler for the shared memory IO manager.
+ *      Calls the WMD's CHNL_ISR to determine if this interrupt is ours, then
+ *      schedules a DPC to dispatch I/O.
+ */
+irqreturn_t IO_ISR(int irq, IN void *pRefData)
+{
+	struct IO_MGR *hIOMgr = (struct IO_MGR *)pRefData;
+	bool fSchedDPC;
+	unsigned long flags;
+
+	if (irq != INT_MAIL_MPU_IRQ ||
+	   !MEM_IsValidHandle(hIOMgr, IO_MGRSIGNATURE))
+		return IRQ_NONE;
+
+	/* Call WMD's CHNLSM_ISR() to see if interrupt is ours, and process. */
+	if (IO_CALLISR(hIOMgr->hWmdContext, &fSchedDPC, &hIOMgr->wIntrVal)) {
+		if (hIOMgr->wIntrVal & MBX_PM_CLASS) {
+			hIOMgr->dQuePowerMbxVal[hIOMgr->iQuePowerHead] =
+				hIOMgr->wIntrVal;
+			hIOMgr->iQuePowerHead++;
+			if (hIOMgr->iQuePowerHead >= MAX_PM_REQS)
+				hIOMgr->iQuePowerHead = 0;
+
+			queue_work(bridge_workqueue, &hIOMgr->io_workq);
+		}
+		if (hIOMgr->wIntrVal == MBX_DEH_RESET) {
+			hIOMgr->wIntrVal = 0;
+		} else if (fSchedDPC) {
+			/*
+			 * PROC-COPY defer i/o.
+			 * Increment count of DPC's pending.
+			 */
+			spin_lock_irqsave(&hIOMgr->dpc_lock, flags);
+			hIOMgr->dpc_req++;
+			spin_unlock_irqrestore(&hIOMgr->dpc_lock, flags);
+
+			/* Schedule DPC */
+			tasklet_schedule(&hIOMgr->dpc_tasklet);
+		}
+	} else {
+		/* Ensure that, if WMD didn't claim it, the IRQ is shared. */
+		DBC_Ensure(hIOMgr->fSharedIRQ);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *  ======== IO_RequestChnl ========
+ *  Purpose:
+ *      Request chanenel I/O from the DSP. Sets flags in shared memory, then
+ *      interrupts the DSP.
+ */
+void IO_RequestChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+		   u32 iMode, OUT u16 *pwMbVal)
+{
+	struct CHNL_MGR *pChnlMgr;
+	struct SHM *sm;
+
+	if (!pChnl || !pwMbVal)
+		goto func_end;
+	pChnlMgr = pIOMgr->hChnlMgr;
+	sm = pIOMgr->pSharedMem;
+	if (iMode == IO_INPUT) {
+		/*
+		 * Assertion fires if CHNL_AddIOReq() called on a stream
+		 * which was cancelled, or attached to a dead board.
+		 */
+		DBC_Assert((pChnl->dwState == CHNL_STATEREADY) ||
+			  (pChnl->dwState == CHNL_STATEEOS));
+		/* Indicate to the DSP we have a buffer available for input */
+		IO_OrValue(pIOMgr->hWmdContext, struct SHM, sm, hostFreeMask,
+			  (1 << pChnl->uId));
+		*pwMbVal = MBX_PCPY_CLASS;
+	} else if (iMode == IO_OUTPUT) {
+		/*
+		 * This assertion fails if CHNL_AddIOReq() was called on a
+		 * stream which was cancelled, or attached to a dead board.
+		 */
+		DBC_Assert((pChnl->dwState & ~CHNL_STATEEOS) ==
+			  CHNL_STATEREADY);
+		/*
+		 * Record the fact that we have a buffer available for
+		 * output.
+		 */
+		pChnlMgr->dwOutputMask |= (1 << pChnl->uId);
+	} else {
+		DBC_Assert(iMode); 	/* Shouldn't get here. */
+	}
+func_end:
+	return;
+}
+
+/*
+ *  ======== IO_Schedule ========
+ *      Schedule DPC for IO.
+ */
+void IO_Schedule(struct IO_MGR *pIOMgr)
+{
+	unsigned long flags;
+
+	if (!MEM_IsValidHandle(pIOMgr, IO_MGRSIGNATURE))
+		return;
+
+	/* Increment count of DPC's pending. */
+	spin_lock_irqsave(&pIOMgr->dpc_lock, flags);
+	pIOMgr->dpc_req++;
+	spin_unlock_irqrestore(&pIOMgr->dpc_lock, flags);
+
+	/* Schedule DPC */
+	tasklet_schedule(&pIOMgr->dpc_tasklet);
+}
+
+/*
+ *  ======== FindReadyOutput ========
+ *      Search for a host output channel which is ready to send.  If this is
+ *      called as a result of servicing the DPC, then implement a round
+ *      robin search; otherwise, this was called by a client thread (via
+ *      IO_Dispatch()), so just start searching from the current channel id.
+ */
+static u32 FindReadyOutput(struct CHNL_MGR *pChnlMgr,
+			     struct CHNL_OBJECT *pChnl, u32 dwMask)
+{
+	u32 uRetval = OUTPUTNOTREADY;
+	u32 id, startId;
+	u32 shift;
+
+	id = (pChnl != NULL ? pChnl->uId : (pChnlMgr->dwLastOutput + 1));
+	id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
+	if (id >= CHNL_MAXCHANNELS)
+		goto func_end;
+	if (dwMask) {
+		shift = (1 << id);
+		startId = id;
+		do {
+			if (dwMask & shift) {
+				uRetval = id;
+				if (pChnl == NULL)
+					pChnlMgr->dwLastOutput = id;
+				break;
+			}
+			id = id + 1;
+			id = ((id == CHNL_MAXCHANNELS) ? 0 : id);
+			shift = (1 << id);
+		} while (id != startId);
+	}
+func_end:
+	return uRetval;
+}
+
+/*
+ *  ======== InputChnl ========
+ *      Dispatch a buffer on an input channel.
+ */
+static void InputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+		      u32 iMode)
+{
+	struct CHNL_MGR *pChnlMgr;
+	struct SHM *sm;
+	u32 chnlId;
+	u32 uBytes;
+	struct CHNL_IRP *pChirp = NULL;
+	u32 dwArg;
+	bool fClearChnl = false;
+	bool fNotifyClient = false;
+
+	sm = pIOMgr->pSharedMem;
+	pChnlMgr = pIOMgr->hChnlMgr;
+
+	/* Attempt to perform input */
+	if (!IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull))
+		goto func_end;
+
+	uBytes = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputSize) *
+			    pChnlMgr->uWordSize;
+	chnlId = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, inputId);
+	dwArg = IO_GetLong(pIOMgr->hWmdContext, struct SHM, sm, arg);
+	if (chnlId >= CHNL_MAXCHANNELS) {
+		/* Shouldn't be here: would indicate corrupted SHM. */
+		DBC_Assert(chnlId);
+		goto func_end;
+	}
+	pChnl = pChnlMgr->apChannel[chnlId];
+	if ((pChnl != NULL) && CHNL_IsInput(pChnl->uMode)) {
+		if ((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY) {
+			if (!pChnl->pIORequests)
+				goto func_end;
+			/* Get the I/O request, and attempt a transfer */
+			pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->
+				 pIORequests);
+			if (pChirp) {
+				pChnl->cIOReqs--;
+				if (pChnl->cIOReqs < 0)
+					goto func_end;
+				/*
+				 * Ensure we don't overflow the client's
+				 * buffer.
+				 */
+				uBytes = min(uBytes, pChirp->cBytes);
+				/* Transfer buffer from DSP side */
+				uBytes = ReadData(pIOMgr->hWmdContext,
+						pChirp->pHostSysBuf,
+						pIOMgr->pInput, uBytes);
+				pChnl->cBytesMoved += uBytes;
+				pChirp->cBytes = uBytes;
+				pChirp->dwArg = dwArg;
+				pChirp->status = CHNL_IOCSTATCOMPLETE;
+
+				if (uBytes == 0) {
+					/*
+					 * This assertion fails if the DSP
+					 * sends EOS more than once on this
+					 * channel.
+					 */
+					if (pChnl->dwState & CHNL_STATEEOS)
+						goto func_end;
+					/*
+					 * Zero bytes indicates EOS. Update
+					 * IOC status for this chirp, and also
+					 * the channel state.
+					 */
+					pChirp->status |= CHNL_IOCSTATEOS;
+					pChnl->dwState |= CHNL_STATEEOS;
+					/*
+					 * Notify that end of stream has
+					 * occurred.
+					 */
+					NTFY_Notify(pChnl->hNtfy,
+						   DSP_STREAMDONE);
+				}
+				/* Tell DSP if no more I/O buffers available */
+				if (!pChnl->pIORequests)
+					goto func_end;
+				if (LST_IsEmpty(pChnl->pIORequests)) {
+					IO_AndValue(pIOMgr->hWmdContext,
+						   struct SHM, sm, hostFreeMask,
+						   ~(1 << pChnl->uId));
+				}
+				fClearChnl = true;
+				fNotifyClient = true;
+			} else {
+				/*
+				 * Input full for this channel, but we have no
+				 * buffers available.  The channel must be
+				 * "idling". Clear out the physical input
+				 * channel.
+				 */
+				fClearChnl = true;
+			}
+		} else {
+			/* Input channel cancelled: clear input channel */
+			fClearChnl = true;
+		}
+	} else {
+		/* DPC fired after host closed channel: clear input channel */
+		fClearChnl = true;
+	}
+	if (fClearChnl) {
+		/* Indicate to the DSP we have read the input */
+		IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, inputFull, 0);
+		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	}
+	if (fNotifyClient) {
+		/* Notify client with IO completion record */
+		NotifyChnlComplete(pChnl, pChirp);
+	}
+func_end:
+	return;
+}
+
+/*
+ *  ======== InputMsg ========
+ *      Copies messages from shared memory to the message queues.
+ */
+static void InputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+{
+	u32 uMsgs;
+	u32 i;
+	u8 *pMsgInput;
+	struct MSG_QUEUE *hMsgQueue;
+	struct MSG_FRAME *pMsg;
+	struct MSG_DSPMSG msg;
+	struct MSG *pCtrl;
+	u32 fInputEmpty;
+	u32 addr;
+
+	pCtrl = pIOMgr->pMsgInputCtrl;
+	/* Get the number of input messages to be read */
+	fInputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				 bufEmpty);
+	uMsgs = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, size);
+	if (fInputEmpty)
+		goto func_end;
+
+	pMsgInput = pIOMgr->pMsgInput;
+	for (i = 0; i < uMsgs; i++) {
+		/* Read the next message */
+		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwCmd);
+		msg.msg.dwCmd = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
+		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg1);
+		msg.msg.dwArg1 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
+		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->msg.dwArg2);
+		msg.msg.dwArg2 = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
+		addr = (u32)&(((struct MSG_DSPMSG *)pMsgInput)->dwId);
+		msg.dwId = ReadExt32BitDspData(pIOMgr->hWmdContext, addr);
+		pMsgInput += sizeof(struct MSG_DSPMSG);
+		if (!hMsgMgr->queueList)
+			goto func_end;
+
+		/* Determine which queue to put the message in */
+		hMsgQueue = (struct MSG_QUEUE *)LST_First(hMsgMgr->queueList);
+		dev_dbg(bridge, "input msg: dwCmd=0x%x dwArg1=0x%x "
+			 "dwArg2=0x%x dwId=0x%x \n", msg.msg.dwCmd,
+			 msg.msg.dwArg1, msg.msg.dwArg2, msg.dwId);
+		/*
+		 * Interrupt may occur before shared memory and message
+		 * input locations have been set up. If all nodes were
+		 * cleaned up, hMsgMgr->uMaxMsgs should be 0.
+		 */
+		while (hMsgQueue != NULL) {
+			if (msg.dwId == hMsgQueue->dwId) {
+				/* Found it */
+				if (msg.msg.dwCmd == RMS_EXITACK) {
+					/*
+					 * Call the node exit notification.
+					 * The exit message does not get
+					 * queued.
+					 */
+					(*hMsgMgr->onExit)((HANDLE)hMsgQueue->
+						hArg, msg.msg.dwArg1);
+				} else {
+					/*
+					 * Not an exit acknowledgement, queue
+					 * the message.
+					 */
+					if (!hMsgQueue->msgFreeList)
+						goto func_end;
+					pMsg = (struct MSG_FRAME *)LST_GetHead
+						(hMsgQueue->msgFreeList);
+					if (hMsgQueue->msgUsedList && pMsg) {
+						pMsg->msgData = msg;
+						LST_PutTail(hMsgQueue->
+						    msgUsedList,
+						    (struct list_head *)pMsg);
+						NTFY_Notify(hMsgQueue->hNtfy,
+							DSP_NODEMESSAGEREADY);
+						SYNC_SetEvent(hMsgQueue->
+							hSyncEvent);
+					} else {
+						/*
+						 * No free frame to copy the
+						 * message into.
+						 */
+						pr_err("%s: no free msg frames,"
+							" discarding msg\n",
+							__func__);
+					}
+				}
+				break;
+			}
+
+			if (!hMsgMgr->queueList || !hMsgQueue)
+				goto func_end;
+			hMsgQueue = (struct MSG_QUEUE *)LST_Next(hMsgMgr->
+				    queueList, (struct list_head *)hMsgQueue);
+		}
+	}
+	/* Set the post SWI flag */
+	if (uMsgs > 0) {
+		/* Tell the DSP we've read the messages */
+		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, bufEmpty,
+			   true);
+		IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl, postSWI,
+			   true);
+		CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	}
+func_end:
+	return;
+}
+
+/*
+ *  ======== NotifyChnlComplete ========
+ *  Purpose:
+ *      Signal the channel event, notifying the client that I/O has completed.
+ */
+static void NotifyChnlComplete(struct CHNL_OBJECT *pChnl,
+			      struct CHNL_IRP *pChirp)
+{
+	bool fSignalEvent;
+
+	if (!MEM_IsValidHandle(pChnl, CHNL_SIGNATURE) || !pChnl->hSyncEvent ||
+	   !pChnl->pIOCompletions || !pChirp)
+		goto func_end;
+
+	/*
+	 * Note: we signal the channel event only if the queue of IO
+	 * completions is empty.  If it is not empty, the event is sure to be
+	 * signalled by the only IO completion list consumer:
+	 * WMD_CHNL_GetIOC().
+	 */
+	fSignalEvent = LST_IsEmpty(pChnl->pIOCompletions);
+	/* Enqueue the IO completion info for the client */
+	LST_PutTail(pChnl->pIOCompletions, (struct list_head *)pChirp);
+	pChnl->cIOCs++;
+
+	if (pChnl->cIOCs > pChnl->cChirps)
+		goto func_end;
+	/* Signal the channel event (if not already set) that IO is complete */
+	if (fSignalEvent)
+		SYNC_SetEvent(pChnl->hSyncEvent);
+
+	/* Notify that IO is complete */
+	NTFY_Notify(pChnl->hNtfy, DSP_STREAMIOCOMPLETION);
+func_end:
+	return;
+}
+
+/*
+ *  ======== OutputChnl ========
+ *  Purpose:
+ *      Dispatch a buffer on an output channel.
+ */
+static void OutputChnl(struct IO_MGR *pIOMgr, struct CHNL_OBJECT *pChnl,
+			u32 iMode)
+{
+	struct CHNL_MGR *pChnlMgr;
+	struct SHM *sm;
+	u32 chnlId;
+	struct CHNL_IRP *pChirp;
+	u32 dwDspFMask;
+
+	pChnlMgr = pIOMgr->hChnlMgr;
+	sm = pIOMgr->pSharedMem;
+	/* Attempt to perform output */
+	if (IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull))
+		goto func_end;
+
+	if (pChnl && !((pChnl->dwState & ~CHNL_STATEEOS) == CHNL_STATEREADY))
+		goto func_end;
+
+	/* Look to see if both a PC and DSP output channel are ready */
+	dwDspFMask = IO_GetValue(pIOMgr->hWmdContext, struct SHM, sm,
+				 dspFreeMask);
+	chnlId = FindReadyOutput(pChnlMgr, pChnl, (pChnlMgr->dwOutputMask &
+				 dwDspFMask));
+	if (chnlId == OUTPUTNOTREADY)
+		goto func_end;
+
+	pChnl = pChnlMgr->apChannel[chnlId];
+	if (!pChnl || !pChnl->pIORequests) {
+		/* Shouldn't get here */
+		goto func_end;
+	}
+	/* Get the I/O request, and attempt a transfer */
+	pChirp = (struct CHNL_IRP *)LST_GetHead(pChnl->pIORequests);
+	if (!pChirp)
+		goto func_end;
+
+	pChnl->cIOReqs--;
+	if (pChnl->cIOReqs < 0 || !pChnl->pIORequests)
+		goto func_end;
+
+	/* Record fact that no more I/O buffers available */
+	if (LST_IsEmpty(pChnl->pIORequests))
+		pChnlMgr->dwOutputMask &= ~(1 << chnlId);
+
+	/* Transfer buffer to DSP side */
+	pChirp->cBytes = WriteData(pIOMgr->hWmdContext, pIOMgr->pOutput,
+			pChirp->pHostSysBuf, min(pIOMgr->uSMBufSize, pChirp->
+			cBytes));
+	pChnl->cBytesMoved += pChirp->cBytes;
+	/* Write all 32 bits of arg */
+	IO_SetLong(pIOMgr->hWmdContext, struct SHM, sm, arg, pChirp->dwArg);
+#if _CHNL_WORDSIZE == 2
+	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId,
+		   (u16)chnlId);
+	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
+		   (u16)(pChirp->cBytes + (pChnlMgr->uWordSize-1)) /
+		   (u16)pChnlMgr->uWordSize);
+#else
+	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputId, chnlId);
+	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputSize,
+		   (pChirp->cBytes + (pChnlMgr->uWordSize - 1)) / pChnlMgr->
+		   uWordSize);
+#endif
+	IO_SetValue(pIOMgr->hWmdContext, struct SHM, sm, outputFull, 1);
+	/* Indicate to the DSP we have written the output */
+	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, MBX_PCPY_CLASS);
+	/* Notify client with IO completion record (keep EOS) */
+	pChirp->status &= CHNL_IOCSTATEOS;
+	NotifyChnlComplete(pChnl, pChirp);
+	/* Notify if stream is done. */
+	if (pChirp->status & CHNL_IOCSTATEOS)
+		NTFY_Notify(pChnl->hNtfy, DSP_STREAMDONE);
+
+func_end:
+	return;
+}
+/*
+ *  ======== OutputMsg ========
+ *      Copies messages from the message queues to the shared memory.
+ */
+static void OutputMsg(struct IO_MGR *pIOMgr, struct MSG_MGR *hMsgMgr)
+{
+	u32 uMsgs = 0;
+	u32 i;
+	u8 *pMsgOutput;
+	struct MSG_FRAME *pMsg;
+	struct MSG *pCtrl;
+	u32 fOutputEmpty;
+	u32 val;
+	u32 addr;
+
+	pCtrl = pIOMgr->pMsgOutputCtrl;
+
+	/* Check if output has been cleared */
+	fOutputEmpty = IO_GetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				  bufEmpty);
+	if (fOutputEmpty) {
+		uMsgs = (hMsgMgr->uMsgsPending > hMsgMgr->uMaxMsgs) ?
+			 hMsgMgr->uMaxMsgs : hMsgMgr->uMsgsPending;
+		pMsgOutput = pIOMgr->pMsgOutput;
+		/* Copy uMsgs messages into shared memory */
+		for (i = 0; i < uMsgs; i++) {
+			if (!hMsgMgr->msgUsedList) {
+				pMsg = NULL;
+				goto func_end;
+			} else {
+				pMsg = (struct MSG_FRAME *)LST_GetHead(
+					hMsgMgr->msgUsedList);
+			}
+			if (pMsg != NULL) {
+				val = (pMsg->msgData).dwId;
+				addr = (u32)&(((struct MSG_DSPMSG *)
+					pMsgOutput)->dwId);
+				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
+						     val);
+				val = (pMsg->msgData).msg.dwCmd;
+				addr = (u32)&((((struct MSG_DSPMSG *)
+					pMsgOutput)->msg).dwCmd);
+				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
+						     val);
+				val = (pMsg->msgData).msg.dwArg1;
+				addr =
+					(u32)&((((struct MSG_DSPMSG *)
+					pMsgOutput)->msg).dwArg1);
+				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
+						    val);
+				val = (pMsg->msgData).msg.dwArg2;
+				addr =
+					(u32)&((((struct MSG_DSPMSG *)
+					pMsgOutput)->msg).dwArg2);
+				WriteExt32BitDspData(pIOMgr->hWmdContext, addr,
+						    val);
+				pMsgOutput += sizeof(struct MSG_DSPMSG);
+				if (!hMsgMgr->msgFreeList)
+					goto func_end;
+				LST_PutTail(hMsgMgr->msgFreeList,
+					   (struct list_head *)pMsg);
+				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+			}
+		}
+
+		if (uMsgs > 0) {
+			hMsgMgr->uMsgsPending -= uMsgs;
+#if _CHNL_WORDSIZE == 2
+			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				   size, (u16)uMsgs);
+#else
+			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				   size, uMsgs);
+#endif
+			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				   bufEmpty, false);
+			/* Set the post SWI flag */
+			IO_SetValue(pIOMgr->hWmdContext, struct MSG, pCtrl,
+				   postSWI, true);
+			/* Tell the DSP we have written the output. */
+			CHNLSM_InterruptDSP2(pIOMgr->hWmdContext,
+						MBX_PCPY_CLASS);
+		}
+	}
+func_end:
+	return;
+}
+
+/*
+ *  ======== registerSHMSegs ========
+ *  purpose:
+ *      Registers GPP SM segment with CMM.
+ */
+static DSP_STATUS registerSHMSegs(struct IO_MGR *hIOMgr,
+				 struct COD_MANAGER *hCodMan,
+				 u32 dwGPPBasePA)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 ulShm0_Base = 0;
+	u32 ulShm0_End = 0;
+	u32 ulShm0_RsrvdStart = 0;
+	u32 ulRsrvdSize = 0;
+	u32 ulGppPhys;
+	u32 ulDspVirt;
+	u32 ulShmSegId0 = 0;
+	u32 dwOffset, dwGPPBaseVA, ulDSPSize;
+
+	/*
+	 * Read address and size info for first SM region.
+	 * Get start of 1st SM Heap region.
+	 */
+	status = COD_GetSymValue(hCodMan, SHM0_SHARED_BASE_SYM, &ulShm0_Base);
+	if (ulShm0_Base == 0) {
+		status = DSP_EFAIL;
+		goto func_end;
+	}
+	/* Get end of 1st SM Heap region */
+	if (DSP_SUCCEEDED(status)) {
+		/* Get start and length of message part of shared memory */
+		status = COD_GetSymValue(hCodMan, SHM0_SHARED_END_SYM,
+					 &ulShm0_End);
+		if (ulShm0_End == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+	}
+	/* Start of Gpp reserved region */
+	if (DSP_SUCCEEDED(status)) {
+		/* Get start and length of message part of shared memory */
+		status = COD_GetSymValue(hCodMan, SHM0_SHARED_RESERVED_BASE_SYM,
+					&ulShm0_RsrvdStart);
+		if (ulShm0_RsrvdStart == 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+	}
+	/* Register with CMM */
+	if (DSP_SUCCEEDED(status)) {
+		status = DEV_GetCmmMgr(hIOMgr->hDevObject, &hIOMgr->hCmmMgr);
+		if (DSP_SUCCEEDED(status)) {
+			status = CMM_UnRegisterGPPSMSeg(hIOMgr->hCmmMgr,
+				 CMM_ALLSEGMENTS);
+		}
+	}
+	/* Register new SM region(s) */
+	if (DSP_SUCCEEDED(status) && (ulShm0_End - ulShm0_Base) > 0) {
+		/* Calc size (bytes) of SM the GPP can alloc from */
+		ulRsrvdSize = (ulShm0_End - ulShm0_RsrvdStart + 1) * hIOMgr->
+			      uWordSize;
+		if (ulRsrvdSize <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* Calc size of SM DSP can alloc from */
+		ulDSPSize = (ulShm0_RsrvdStart - ulShm0_Base) * hIOMgr->
+			uWordSize;
+		if (ulDSPSize <= 0) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/* First TLB entry reserved for Bridge SM use.*/
+		ulGppPhys = hIOMgr->extProcInfo.tyTlb[0].ulGppPhys;
+		/* Get size in bytes */
+		ulDspVirt = hIOMgr->extProcInfo.tyTlb[0].ulDspVirt * hIOMgr->
+			uWordSize;
+		/*
+		 * Calc byte offset used to convert GPP phys <-> DSP byte
+		 * address.
+		 */
+		if (dwGPPBasePA > ulDspVirt)
+			dwOffset = dwGPPBasePA - ulDspVirt;
+		else
+			dwOffset = ulDspVirt - dwGPPBasePA;
+
+		if (ulShm0_RsrvdStart * hIOMgr->uWordSize < ulDspVirt) {
+			status = DSP_EFAIL;
+			goto func_end;
+		}
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is actually uncached kernel virtual address.
+		 */
+		dwGPPBaseVA = ulGppPhys + ulShm0_RsrvdStart * hIOMgr->uWordSize
+				- ulDspVirt;
+		/*
+		 * Calc Gpp phys base of SM region.
+		 * This is the physical address.
+		 */
+		dwGPPBasePA = dwGPPBasePA + ulShm0_RsrvdStart * hIOMgr->
+			      uWordSize - ulDspVirt;
+		/* Register SM Segment 0.*/
+		status = CMM_RegisterGPPSMSeg(hIOMgr->hCmmMgr, dwGPPBasePA,
+			 ulRsrvdSize, dwOffset, (dwGPPBasePA > ulDspVirt) ?
+			 CMM_ADDTODSPPA : CMM_SUBFROMDSPPA,
+			 (u32)(ulShm0_Base * hIOMgr->uWordSize),
+			 ulDSPSize, &ulShmSegId0, dwGPPBaseVA);
+		/* First SM region is segId = 1 */
+		if (ulShmSegId0 != 1)
+			status = DSP_EFAIL;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== ReadData ========
+ *      Copies buffers from the shared memory to the host buffer.
+ */
+static u32 ReadData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
+		     void *pSrc, u32 uSize)
+{
+	memcpy(pDest, pSrc, uSize);
+	return uSize;
+}
+
+/*
+ *  ======== WriteData ========
+ *      Copies buffers from the host side buffer to the shared memory.
+ */
+static u32 WriteData(struct WMD_DEV_CONTEXT *hDevContext, void *pDest,
+			void *pSrc, u32 uSize)
+{
+	memcpy(pDest, pSrc, uSize);
+	return uSize;
+}
+
+/* ZCPY IO routines. */
+void IO_IntrDSP2(IN struct IO_MGR *pIOMgr, IN u16 wMbVal)
+{
+	CHNLSM_InterruptDSP2(pIOMgr->hWmdContext, wMbVal);
+}
+
+/*
+ *  ======== IO_SHMcontrol ========
+ *      Sets the requested SHM setting.
+ */
+DSP_STATUS IO_SHMsetting(struct IO_MGR *hIOMgr, u8 desc, void *pArgs)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	u32 i;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+
+	switch (desc) {
+	case SHM_CURROPP:
+		/* Update the shared memory with requested OPP information */
+		if (pArgs != NULL)
+			hIOMgr->pSharedMem->oppTableStruct.currOppPt =
+				*(u32 *)pArgs;
+		else
+			return DSP_EFAIL;
+		break;
+	case SHM_OPPINFO:
+		/*
+		 * Update the shared memory with the voltage, frequency,
+		 * min and max frequency values for an OPP.
+		 */
+		for (i = 0; i <= dsp_max_opps; i++) {
+			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].voltage =
+				vdd1_dsp_freq[i][0];
+			dev_dbg(bridge, "OPP-SHM: voltage: %d\n",
+							vdd1_dsp_freq[i][0]);
+			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].
+				frequency = vdd1_dsp_freq[i][1];
+			dev_dbg(bridge, "OPP-SHM: frequency: %d\n",
+							vdd1_dsp_freq[i][1]);
+			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].minFreq =
+				vdd1_dsp_freq[i][2];
+			dev_dbg(bridge, "OPP-SHM: min freq: %d\n",
+							vdd1_dsp_freq[i][2]);
+			hIOMgr->pSharedMem->oppTableStruct.oppPoint[i].maxFreq =
+				vdd1_dsp_freq[i][3];
+			dev_dbg(bridge, "OPP-SHM: max freq: %d\n",
+							vdd1_dsp_freq[i][3]);
+		}
+		hIOMgr->pSharedMem->oppTableStruct.numOppPts = dsp_max_opps;
+		dev_dbg(bridge, "OPP-SHM: max OPP number: %d\n", dsp_max_opps);
+		/* Update the current OPP number */
+		if (pdata->dsp_get_opp)
+			i = (*pdata->dsp_get_opp)();
+		hIOMgr->pSharedMem->oppTableStruct.currOppPt = i;
+		dev_dbg(bridge, "OPP-SHM: value programmed = %d\n", i);
+		break;
+	case SHM_GETOPP:
+		/* Get the OPP that DSP has requested */
+		*(u32 *)pArgs = hIOMgr->pSharedMem->oppRequest.rqstOppPt;
+		break;
+	default:
+		break;
+	}
+#endif
+	return DSP_SOK;
+}
+
+/*
+ *  ======== WMD_IO_GetProcLoad ========
+ *      Gets the Processor's Load information
+ */
+DSP_STATUS WMD_IO_GetProcLoad(IN struct IO_MGR *hIOMgr,
+			     OUT struct DSP_PROCLOADSTAT *pProcStat)
+{
+	pProcStat->uCurrLoad = hIOMgr->pSharedMem->loadMonInfo.currDspLoad;
+	pProcStat->uPredictedLoad = hIOMgr->pSharedMem->loadMonInfo.predDspLoad;
+	pProcStat->uCurrDspFreq = hIOMgr->pSharedMem->loadMonInfo.currDspFreq;
+	pProcStat->uPredictedFreq = hIOMgr->pSharedMem->loadMonInfo.predDspFreq;
+
+	dev_dbg(bridge, "Curr Load = %d, Pred Load = %d, Curr Freq = %d, "
+			     "Pred Freq = %d\n", pProcStat->uCurrLoad,
+			     pProcStat->uPredictedLoad, pProcStat->uCurrDspFreq,
+			     pProcStat->uPredictedFreq);
+	return DSP_SOK;
+}
+
+#ifndef DSP_TRACEBUF_DISABLED
+void PrintDSPDebugTrace(struct IO_MGR *hIOMgr)
+{
+	u32 ulNewMessageLength = 0, ulGPPCurPointer;
+
+	while (true) {
+		/* Get the DSP current pointer */
+		ulGPPCurPointer = *(u32 *) (hIOMgr->ulTraceBufferCurrent);
+		ulGPPCurPointer = hIOMgr->ulGppVa + (ulGPPCurPointer -
+				  hIOMgr->ulDspVa);
+
+		/* No new debug messages available yet */
+		if (ulGPPCurPointer == hIOMgr->ulGPPReadPointer) {
+			break;
+		} else if (ulGPPCurPointer > hIOMgr->ulGPPReadPointer) {
+			/* Continuous data */
+			ulNewMessageLength = ulGPPCurPointer - hIOMgr->
+					     ulGPPReadPointer;
+
+			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
+				ulNewMessageLength);
+			hIOMgr->pMsg[ulNewMessageLength] = '\0';
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
+			hIOMgr->ulGPPReadPointer += ulNewMessageLength;
+			/* Print the trace messages */
+			pr_info("DSPTrace: %s\n", hIOMgr->pMsg);
+		} else if (ulGPPCurPointer < hIOMgr->ulGPPReadPointer) {
+			/* Handle trace buffer wraparound */
+			memcpy(hIOMgr->pMsg, (char *)hIOMgr->ulGPPReadPointer,
+				hIOMgr->ulTraceBufferEnd -
+				hIOMgr->ulGPPReadPointer);
+			ulNewMessageLength = ulGPPCurPointer -
+				hIOMgr->ulTraceBufferBegin;
+			memcpy(&hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
+				hIOMgr->ulGPPReadPointer],
+				(char *)hIOMgr->ulTraceBufferBegin,
+				ulNewMessageLength);
+			hIOMgr->pMsg[hIOMgr->ulTraceBufferEnd -
+				hIOMgr->ulGPPReadPointer +
+				ulNewMessageLength] = '\0';
+			/*
+			 * Advance the GPP trace pointer to DSP current
+			 * pointer.
+			 */
+			hIOMgr->ulGPPReadPointer = hIOMgr->ulTraceBufferBegin +
+						   ulNewMessageLength;
+			/* Print the trace messages */
+			pr_info("DSPTrace: %s\n", hIOMgr->pMsg);
+		}
+	}
+}
+#endif
+
+/*
+ *  ======== PackTraceBuffer ========
+ *      Removes extra nulls from the trace buffer returned from the DSP.
+ *      Works even on buffers that already are packed (null removed); but has
+ *      one bug in that case -- loses the last character (replaces with '\0').
+ *      Continues through conversion for full set of nBytes input characters.
+ *  Parameters:
+ *    lpBuf:            Pointer to input/output buffer
+ *    nBytes:           Number of characters in the buffer
+ *    ulNumWords:       Number of DSP words in the buffer.  Indicates potential
+ *                      number of extra carriage returns to generate.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Unable to allocate memory.
+ *  Requires:
+ *      lpBuf must be a fully allocated writable block of at least nBytes.
+ *      There are no more than ulNumWords extra characters needed (the number of
+ *      linefeeds minus the number of NULLS in the input buffer).
+ */
+static DSP_STATUS PackTraceBuffer(char *lpBuf, u32 nBytes, u32 ulNumWords)
+{
+	DSP_STATUS status = DSP_SOK;
+	char *lpTmpBuf;
+	char *lpBufStart;
+	char *lpTmpStart;
+	u32 nCnt;
+	char thisChar;
+
+	/* Tmp workspace, 1 KB longer than input buf */
+	lpTmpBuf = MEM_Calloc((nBytes + ulNumWords), MEM_PAGED);
+	if (lpTmpBuf == NULL)
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status)) {
+		lpBufStart = lpBuf;
+		lpTmpStart = lpTmpBuf;
+		for (nCnt = nBytes; nCnt > 0; nCnt--) {
+			thisChar = *lpBuf++;
+			switch (thisChar) {
+			case '\0':      /* Skip null bytes */
+				break;
+			case '\n':      /* Convert \n to \r\n */
+				/*
+				 * NOTE: do not reverse order; Some OS
+				 * editors control doesn't understand "\n\r"
+				 */
+				*lpTmpBuf++ = '\r';
+				*lpTmpBuf++ = '\n';
+				break;
+			default:	 /* Copy in the actual ascii byte */
+				*lpTmpBuf++ = thisChar;
+				break;
+			}
+		}
+		*lpTmpBuf = '\0';    /* Make sure tmp buf is null terminated */
+		/* Cut output down to input buf size */
+		strncpy(lpBufStart, lpTmpStart, nBytes);
+		/* Make sure output is null terminated */
+		lpBufStart[nBytes - 1] = '\0';
+		kfree(lpTmpStart);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== PrintDspTraceBuffer ========
+ *      Prints the trace buffer returned from the DSP (if DBG_Trace is enabled).
+ *  Parameters:
+ *    hDehMgr:          Handle to DEH manager object
+ *                      number of extra carriage returns to generate.
+ *  Returns:
+ *      DSP_SOK:        Success.
+ *      DSP_EMEMORY:    Unable to allocate memory.
+ *  Requires:
+ *      hDehMgr muse be valid. Checked in WMD_DEH_Notify.
+ */
+DSP_STATUS PrintDspTraceBuffer(struct WMD_DEV_CONTEXT *hWmdContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct COD_MANAGER *hCodMgr;
+	u32 ulTraceEnd;
+	u32 ulTraceBegin;
+	u32 ulNumBytes = 0;
+	u32 ulNumWords = 0;
+	u32 ulWordSize = 2;
+	CONST u32 uMaxSize = 512;
+	char *pszBuf;
+	u16 *lpszBuf;
+
+	struct WMD_DEV_CONTEXT *pWmdContext = (struct WMD_DEV_CONTEXT *)
+						     hWmdContext;
+	struct WMD_DRV_INTERFACE *pIntfFxns;
+	struct DEV_OBJECT *pDevObject = (struct DEV_OBJECT *)
+					    pWmdContext->hDevObject;
+
+	status = DEV_GetCodMgr(pDevObject, &hCodMgr);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Look for SYS_PUTCBEG/SYS_PUTCEND */
+		status = COD_GetSymValue(hCodMgr, COD_TRACEBEG, &ulTraceBegin);
+	}
+	if (DSP_SUCCEEDED(status))
+		status = COD_GetSymValue(hCodMgr, COD_TRACEEND, &ulTraceEnd);
+
+	if (DSP_SUCCEEDED(status)) {
+		ulNumBytes = (ulTraceEnd - ulTraceBegin) * ulWordSize;
+		/*
+		 * If the chip type is 55 then the addresses will be
+		 * byte addresses; convert them to word addresses.
+		 */
+		if (ulNumBytes > uMaxSize)
+			ulNumBytes = uMaxSize;
+
+		/* Make sure the data we request fits evenly */
+		ulNumBytes = (ulNumBytes / ulWordSize) * ulWordSize;
+		ulNumWords = ulNumBytes * ulWordSize;
+		status = DEV_GetIntfFxns(pDevObject, &pIntfFxns);
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		pszBuf = MEM_Calloc(uMaxSize, MEM_NONPAGED);
+		lpszBuf = MEM_Calloc(ulNumBytes * 2, MEM_NONPAGED);
+		if (pszBuf != NULL) {
+			/* Read bytes from the DSP trace buffer... */
+			status = (*pIntfFxns->pfnBrdRead)(hWmdContext,
+				(u8 *)pszBuf, (u32)ulTraceBegin,
+				ulNumBytes, 0);
+
+			if (DSP_SUCCEEDED(status)) {
+				/* Pack and do newline conversion */
+				PackTraceBuffer(pszBuf, ulNumBytes, ulNumWords);
+				pr_info("%s:\n%s\n", __func__, pszBuf);
+			}
+			kfree(pszBuf);
+			kfree(lpszBuf);
+		} else {
+			  status = DSP_EMEMORY;
+		}
+	}
+	return status;
+}
+
+void IO_SM_init(void)
+{
+	/* Do nothing */
+}
diff --git a/drivers/dsp/bridge/wmd/mmu_fault.c b/drivers/dsp/bridge/wmd/mmu_fault.c
new file mode 100644
index 0000000..8cac1ef
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/mmu_fault.c
@@ -0,0 +1,142 @@
+/*
+ * mmu_fault.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implements DSP MMU fault handling functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/host_os.h>
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/drv.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmddeh.h>
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/*  ----------------------------------- This */
+#include "_deh.h"
+#include <dspbridge/cfg.h>
+#include "_tiomap_mmu.h"
+#include "_tiomap.h"
+#include "mmu_fault.h"
+
+static u32 dmmuEventMask;
+u32 faultAddr;
+
+static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext);
+
+/*
+ *  ======== MMU_FaultDpc ========
+ *      Deferred procedure call to handle DSP MMU fault.
+ */
+void MMU_FaultDpc(IN unsigned long pRefData)
+{
+	struct DEH_MGR *hDehMgr = (struct DEH_MGR *)pRefData;
+
+	if (hDehMgr)
+		WMD_DEH_Notify(hDehMgr, DSP_MMUFAULT, 0L);
+
+}
+
+/*
+ *  ======== MMU_FaultIsr ========
+ *      ISR to be triggered by a DSP MMU fault interrupt.
+ */
+irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData)
+{
+	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)pRefData;
+	struct WMD_DEV_CONTEXT *pDevContext;
+	struct CFG_HOSTRES resources;
+	DSP_STATUS status = DSP_SOK;
+
+	DBC_Require(irq == INT_DSP_MMU_IRQ);
+	DBC_Require(MEM_IsValidHandle(pDehMgr, SIGNATURE));
+
+	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+
+		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
+		status = CFG_GetHostResources(
+			 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			 &resources);
+		if (DSP_FAILED(status))
+			dev_dbg(bridge, "%s: Failed to get Host Resources\n",
+								__func__);
+		if (MMU_CheckIfFault(pDevContext)) {
+			printk(KERN_INFO "***** DSPMMU FAULT ***** IRQStatus "
+				"0x%x\n", dmmuEventMask);
+			printk(KERN_INFO "***** DSPMMU FAULT ***** faultAddr "
+				"0x%x\n", faultAddr);
+			/*
+			 * Schedule a DPC directly. In the future, it may be
+			 * necessary to check if DSP MMU fault is intended for
+			 * Bridge.
+			 */
+			tasklet_schedule(&pDehMgr->dpc_tasklet);
+
+			/* Reset errInfo structure before use. */
+			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
+			pDehMgr->errInfo.dwVal1 = faultAddr >> 16;
+			pDehMgr->errInfo.dwVal2 = faultAddr & 0xFFFF;
+			pDehMgr->errInfo.dwVal3 = 0L;
+			/* Disable the MMU events, else once we clear it will
+			 * start to raise INTs again */
+			HW_MMU_EventDisable(resources.dwDmmuBase,
+					    HW_MMU_TRANSLATION_FAULT);
+		} else {
+			HW_MMU_EventDisable(resources.dwDmmuBase,
+					    HW_MMU_ALL_INTERRUPTS);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+
+/*
+ *  ======== MMU_CheckIfFault ========
+ *      Check to see if MMU Fault is valid TLB miss from DSP
+ *  Note: This function is called from an ISR
+ */
+static bool MMU_CheckIfFault(struct WMD_DEV_CONTEXT *pDevContext)
+{
+
+
+	bool retVal = false;
+	DSP_STATUS status = DSP_SOK;
+	HW_STATUS hwStatus;
+	struct CFG_HOSTRES resources;
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		dev_dbg(bridge, "%s: Failed to get Host Resources in\n",
+								__func__);
+
+	hwStatus = HW_MMU_EventStatus(resources.dwDmmuBase, &dmmuEventMask);
+	if (dmmuEventMask  ==  HW_MMU_TRANSLATION_FAULT) {
+		HW_MMU_FaultAddrRead(resources.dwDmmuBase, &faultAddr);
+		retVal = true;
+	}
+	return retVal;
+}
diff --git a/drivers/dsp/bridge/wmd/mmu_fault.h b/drivers/dsp/bridge/wmd/mmu_fault.h
new file mode 100644
index 0000000..d3849b5
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/mmu_fault.h
@@ -0,0 +1,35 @@
+/*
+ * mmu_fault.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Defines DSP MMU fault handling functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef MMU_FAULT_
+#define MMU_FAULT_
+
+/*
+ *  ======== MMU_FaultDpc ========
+ *      Deferred procedure call to handle DSP MMU fault.
+ */
+	void MMU_FaultDpc(IN unsigned long pRefData);
+
+/*
+ *  ======== MMU_FaultIsr ========
+ *      ISR to be triggered by a DSP MMU fault interrupt.
+ */
+irqreturn_t  MMU_FaultIsr(int irq, IN void *pRefData);
+
+#endif				/* MMU_FAULT_ */
+
diff --git a/drivers/dsp/bridge/wmd/msg_sm.c b/drivers/dsp/bridge/wmd/msg_sm.c
new file mode 100644
index 0000000..b24ee37
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/msg_sm.c
@@ -0,0 +1,653 @@
+/*
+ * msg_sm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implements upper edge functions for WMD message module.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/list.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/sync.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+
+/*  ----------------------------------- Others */
+#include <dspbridge/io_sm.h>
+
+/*  ----------------------------------- This */
+#include <_msg_sm.h>
+#include <dspbridge/wmdmsg.h>
+
+/*  ----------------------------------- Defines, Data Structures, Typedefs */
+#define MSGQ_SIGNATURE      0x5147534d	/* "QGSM" */
+
+/*  ----------------------------------- Function Prototypes */
+static DSP_STATUS AddNewMsg(struct LST_LIST *msgList);
+static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr);
+static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP);
+static void FreeMsgList(struct LST_LIST *msgList);
+
+/*
+ *  ======== WMD_MSG_Create ========
+ *      Create an object to manage message queues. Only one of these objects
+ *      can exist per device object.
+ */
+DSP_STATUS WMD_MSG_Create(OUT struct MSG_MGR **phMsgMgr,
+			 struct DEV_OBJECT *hDevObject, MSG_ONEXIT msgCallback)
+{
+	struct MSG_MGR *pMsgMgr;
+	struct IO_MGR *hIOMgr;
+	DSP_STATUS status = DSP_SOK;
+
+	if (!phMsgMgr || !msgCallback || !hDevObject) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
+	DEV_GetIOMgr(hDevObject, &hIOMgr);
+	if (!hIOMgr) {
+		status = DSP_EPOINTER;
+		goto func_end;
+	}
+	*phMsgMgr = NULL;
+	/* Allocate MSG manager object */
+	MEM_AllocObject(pMsgMgr, struct MSG_MGR, MSGMGR_SIGNATURE);
+
+	if (pMsgMgr) {
+		pMsgMgr->onExit = msgCallback;
+		pMsgMgr->hIOMgr = hIOMgr;
+		/* List of MSG_QUEUEs */
+		pMsgMgr->queueList = MEM_Calloc(sizeof(struct LST_LIST),
+			MEM_NONPAGED);
+		 /*  Queues of message frames for messages to the DSP. Message
+		  * frames will only be added to the free queue when a
+		  * MSG_QUEUE object is created.  */
+		pMsgMgr->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST),
+					MEM_NONPAGED);
+		pMsgMgr->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST),
+					MEM_NONPAGED);
+		if (pMsgMgr->queueList == NULL ||
+		    pMsgMgr->msgFreeList == NULL ||
+		    pMsgMgr->msgUsedList == NULL) {
+			status = DSP_EMEMORY;
+		} else {
+			INIT_LIST_HEAD(&pMsgMgr->queueList->head);
+			INIT_LIST_HEAD(&pMsgMgr->msgFreeList->head);
+			INIT_LIST_HEAD(&pMsgMgr->msgUsedList->head);
+			status = SYNC_InitializeDPCCS(&pMsgMgr->hSyncCS);
+		}
+
+		 /*  Create an event to be used by WMD_MSG_Put() in waiting
+		 *  for an available free frame from the message manager.  */
+		if (DSP_SUCCEEDED(status))
+			status = SYNC_OpenEvent(&pMsgMgr->hSyncEvent, NULL);
+
+		if (DSP_SUCCEEDED(status))
+			*phMsgMgr = pMsgMgr;
+		else
+			DeleteMsgMgr(pMsgMgr);
+
+	} else {
+		status = DSP_EMEMORY;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_MSG_CreateQueue ========
+ *      Create a MSG_QUEUE for sending/receiving messages to/from a node
+ *      on the DSP.
+ */
+DSP_STATUS WMD_MSG_CreateQueue(struct MSG_MGR *hMsgMgr,
+			      OUT struct MSG_QUEUE **phMsgQueue,
+			      u32 dwId, u32 uMaxMsgs, HANDLE hArg)
+{
+	u32 i;
+	u32 uNumAllocated = 0;
+	struct MSG_QUEUE *pMsgQ;
+	DSP_STATUS status = DSP_SOK;
+
+	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE) ||
+	   phMsgQueue == NULL || !hMsgMgr->msgFreeList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	*phMsgQueue = NULL;
+	/* Allocate MSG_QUEUE object */
+	MEM_AllocObject(pMsgQ, struct MSG_QUEUE, MSGQ_SIGNATURE);
+	if (!pMsgQ) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	LST_InitElem((struct list_head *)pMsgQ);
+	pMsgQ->uMaxMsgs = uMaxMsgs;
+	pMsgQ->hMsgMgr = hMsgMgr;
+	pMsgQ->hArg = hArg;	/* Node handle */
+	pMsgQ->dwId = dwId;	/* Node env (not valid yet) */
+	/* Queues of Message frames for messages from the DSP */
+	pMsgQ->msgFreeList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
+	pMsgQ->msgUsedList = MEM_Calloc(sizeof(struct LST_LIST), MEM_NONPAGED);
+	if (pMsgQ->msgFreeList == NULL || pMsgQ->msgUsedList == NULL)
+		status = DSP_EMEMORY;
+	else {
+		INIT_LIST_HEAD(&pMsgQ->msgFreeList->head);
+		INIT_LIST_HEAD(&pMsgQ->msgUsedList->head);
+	}
+
+	 /*  Create event that will be signalled when a message from
+	 *  the DSP is available.  */
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_OpenEvent(&pMsgQ->hSyncEvent, NULL);
+
+	/* Create a notification list for message ready notification. */
+	if (DSP_SUCCEEDED(status))
+		status = NTFY_Create(&pMsgQ->hNtfy);
+
+	 /*  Create events that will be used to synchronize cleanup
+	 *  when the object is deleted. hSyncDone will be set to
+	 *  unblock threads in MSG_Put() or MSG_Get(). hSyncDoneAck
+	 *  will be set by the unblocked thread to signal that it
+	 *  is unblocked and will no longer reference the object.  */
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_OpenEvent(&pMsgQ->hSyncDone, NULL);
+
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_OpenEvent(&pMsgQ->hSyncDoneAck, NULL);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Enter critical section */
+		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+		/* Initialize message frames and put in appropriate queues */
+		for (i = 0; i < uMaxMsgs && DSP_SUCCEEDED(status); i++) {
+			status = AddNewMsg(hMsgMgr->msgFreeList);
+			if (DSP_SUCCEEDED(status)) {
+				uNumAllocated++;
+				status = AddNewMsg(pMsgQ->msgFreeList);
+			}
+		}
+		if (DSP_FAILED(status)) {
+			/*  Stay inside CS to prevent others from taking any
+			 *  of the newly allocated message frames.  */
+			DeleteMsgQueue(pMsgQ, uNumAllocated);
+		} else {
+			LST_PutTail(hMsgMgr->queueList,
+				   (struct list_head *)pMsgQ);
+			*phMsgQueue = pMsgQ;
+			/* Signal that free frames are now available */
+			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
+				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+
+		}
+		/* Exit critical section */
+		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+	} else {
+		DeleteMsgQueue(pMsgQ, 0);
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_MSG_Delete ========
+ *      Delete a MSG manager allocated in WMD_MSG_Create().
+ */
+void WMD_MSG_Delete(struct MSG_MGR *hMsgMgr)
+{
+	if (MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
+		DeleteMsgMgr(hMsgMgr);
+}
+
+/*
+ *  ======== WMD_MSG_DeleteQueue ========
+ *      Delete a MSG queue allocated in WMD_MSG_CreateQueue.
+ */
+void WMD_MSG_DeleteQueue(struct MSG_QUEUE *hMsgQueue)
+{
+	struct MSG_MGR *hMsgMgr;
+	u32 refCount;
+
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
+			!hMsgQueue->hMsgMgr)
+		goto func_end;
+
+	hMsgMgr = hMsgQueue->hMsgMgr;
+	hMsgQueue->fDone = true;
+	 /*  Unblock all threads blocked in MSG_Get() or MSG_Put().  */
+	refCount = hMsgQueue->refCount;
+	while (refCount) {
+		/* Unblock thread */
+		SYNC_SetEvent(hMsgQueue->hSyncDone);
+		/* Wait for acknowledgement */
+		SYNC_WaitOnEvent(hMsgQueue->hSyncDoneAck, SYNC_INFINITE);
+		refCount = hMsgQueue->refCount;
+	}
+	/* Remove message queue from hMsgMgr->queueList */
+	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+	LST_RemoveElem(hMsgMgr->queueList, (struct list_head *)hMsgQueue);
+	/* Free the message queue object */
+	DeleteMsgQueue(hMsgQueue, hMsgQueue->uMaxMsgs);
+	if (!hMsgMgr->msgFreeList)
+		goto func_cont;
+	if (LST_IsEmpty(hMsgMgr->msgFreeList))
+		SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+func_cont:
+	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+func_end:
+	return;
+}
+
+/*
+ *  ======== WMD_MSG_Get ========
+ *      Get a message from a MSG queue.
+ */
+DSP_STATUS WMD_MSG_Get(struct MSG_QUEUE *hMsgQueue,
+		      struct DSP_MSG *pMsg, u32 uTimeout)
+{
+	struct MSG_FRAME *pMsgFrame;
+	struct MSG_MGR *hMsgMgr;
+	bool fGotMsg = false;
+	struct SYNC_OBJECT *hSyncs[2];
+	u32 uIndex;
+	DSP_STATUS status = DSP_SOK;
+
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || pMsg == NULL) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	hMsgMgr = hMsgQueue->hMsgMgr;
+	if (!hMsgQueue->msgUsedList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	/* Enter critical section */
+	(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+	/* If a message is already there, get it */
+	if (!LST_IsEmpty(hMsgQueue->msgUsedList)) {
+		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgQueue->
+			    msgUsedList);
+		if (pMsgFrame != NULL) {
+			*pMsg = pMsgFrame->msgData.msg;
+			LST_PutTail(hMsgQueue->msgFreeList,
+				   (struct list_head *)pMsgFrame);
+			if (LST_IsEmpty(hMsgQueue->msgUsedList))
+				SYNC_ResetEvent(hMsgQueue->hSyncEvent);
+
+			fGotMsg = true;
+		}
+	} else {
+		if (hMsgQueue->fDone)
+			status = DSP_EFAIL;
+		else
+			hMsgQueue->refCount++;
+
+	}
+	/* Exit critical section */
+	(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+	if (DSP_SUCCEEDED(status) && !fGotMsg) {
+		/*  Wait til message is available, timeout, or done. We don't
+		 *  have to schedule the DPC, since the DSP will send messages
+		 *  when they are available.  */
+		hSyncs[0] = hMsgQueue->hSyncEvent;
+		hSyncs[1] = hMsgQueue->hSyncDone;
+		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
+			 &uIndex);
+		/* Enter critical section */
+		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+		if (hMsgQueue->fDone) {
+			hMsgQueue->refCount--;
+			/* Exit critical section */
+			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			 /*  Signal that we're not going to access hMsgQueue
+			  *  anymore, so it can be deleted.  */
+			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			status = DSP_EFAIL;
+		} else {
+			if (DSP_SUCCEEDED(status)) {
+				DBC_Assert(!LST_IsEmpty(hMsgQueue->
+					  msgUsedList));
+				/* Get msg from used list */
+				pMsgFrame = (struct MSG_FRAME *)
+					   LST_GetHead(hMsgQueue->msgUsedList);
+				/* Copy message into pMsg and put frame on the
+				 * free list */
+				if (pMsgFrame != NULL) {
+					*pMsg = pMsgFrame->msgData.msg;
+					LST_PutTail(hMsgQueue->msgFreeList,
+					(struct list_head *)pMsgFrame);
+				}
+			}
+			hMsgQueue->refCount--;
+			/* Reset the event if there are still queued messages */
+			if (!LST_IsEmpty(hMsgQueue->msgUsedList))
+				SYNC_SetEvent(hMsgQueue->hSyncEvent);
+
+			/* Exit critical section */
+			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_MSG_Put ========
+ *      Put a message onto a MSG queue.
+ */
+DSP_STATUS WMD_MSG_Put(struct MSG_QUEUE *hMsgQueue,
+		      IN CONST struct DSP_MSG *pMsg, u32 uTimeout)
+{
+	struct MSG_FRAME *pMsgFrame;
+	struct MSG_MGR *hMsgMgr;
+	bool fPutMsg = false;
+	struct SYNC_OBJECT *hSyncs[2];
+	u32 uIndex;
+	DSP_STATUS status = DSP_SOK;
+
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !pMsg ||
+						!hMsgQueue->hMsgMgr) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	hMsgMgr = hMsgQueue->hMsgMgr;
+	if (!hMsgMgr->msgFreeList) {
+		status = DSP_EHANDLE;
+		goto func_end;
+	}
+
+	(void) SYNC_EnterCS(hMsgMgr->hSyncCS);
+
+	/* If a message frame is available, use it */
+	if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
+		pMsgFrame = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
+			    msgFreeList);
+		if (pMsgFrame != NULL) {
+			pMsgFrame->msgData.msg = *pMsg;
+			pMsgFrame->msgData.dwId = hMsgQueue->dwId;
+			LST_PutTail(hMsgMgr->msgUsedList,
+					(struct list_head *)pMsgFrame);
+			hMsgMgr->uMsgsPending++;
+			fPutMsg = true;
+		}
+		if (LST_IsEmpty(hMsgMgr->msgFreeList))
+			SYNC_ResetEvent(hMsgMgr->hSyncEvent);
+
+		/* Release critical section before scheduling DPC */
+		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		/* Schedule a DPC, to do the actual data transfer: */
+		IO_Schedule(hMsgMgr->hIOMgr);
+	} else {
+		if (hMsgQueue->fDone)
+			status = DSP_EFAIL;
+		else
+			hMsgQueue->refCount++;
+
+		(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+	}
+	if (DSP_SUCCEEDED(status) && !fPutMsg) {
+		/* Wait til a free message frame is available, timeout,
+		 * or done */
+		hSyncs[0] = hMsgMgr->hSyncEvent;
+		hSyncs[1] = hMsgQueue->hSyncDone;
+		status = SYNC_WaitOnMultipleEvents(hSyncs, 2, uTimeout,
+			 &uIndex);
+		if (DSP_FAILED(status))
+			goto func_end;
+		/* Enter critical section */
+		(void)SYNC_EnterCS(hMsgMgr->hSyncCS);
+		if (hMsgQueue->fDone) {
+			hMsgQueue->refCount--;
+			/* Exit critical section */
+			(void)SYNC_LeaveCS(hMsgMgr->hSyncCS);
+			 /*  Signal that we're not going to access hMsgQueue
+			  *  anymore, so it can be deleted.  */
+			(void)SYNC_SetEvent(hMsgQueue->hSyncDoneAck);
+			status = DSP_EFAIL;
+		} else {
+			if (LST_IsEmpty(hMsgMgr->msgFreeList)) {
+				status = DSP_EPOINTER;
+				goto func_cont;
+			}
+			/* Get msg from free list */
+			pMsgFrame = (struct MSG_FRAME *)
+					    LST_GetHead(hMsgMgr->msgFreeList);
+			/*
+			 * Copy message into pMsg and put frame on the
+			 * used list.
+			 */
+			if (pMsgFrame) {
+				pMsgFrame->msgData.msg = *pMsg;
+				pMsgFrame->msgData.dwId = hMsgQueue->dwId;
+				LST_PutTail(hMsgMgr->msgUsedList,
+					   (struct list_head *)pMsgFrame);
+				hMsgMgr->uMsgsPending++;
+				/*
+				 * Schedule a DPC, to do the actual
+				 * data transfer.
+				*/
+				IO_Schedule(hMsgMgr->hIOMgr);
+			}
+
+			hMsgQueue->refCount--;
+			/* Reset event if there are still frames available */
+			if (!LST_IsEmpty(hMsgMgr->msgFreeList))
+				SYNC_SetEvent(hMsgMgr->hSyncEvent);
+func_cont:
+			/* Exit critical section */
+			(void) SYNC_LeaveCS(hMsgMgr->hSyncCS);
+		}
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_MSG_RegisterNotify ========
+ */
+DSP_STATUS WMD_MSG_RegisterNotify(struct MSG_QUEUE *hMsgQueue, u32 uEventMask,
+				  u32 uNotifyType,
+				  struct DSP_NOTIFICATION *hNotification)
+{
+	DSP_STATUS status = DSP_SOK;
+
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) || !hNotification) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	if (!(uEventMask == DSP_NODEMESSAGEREADY || uEventMask == 0)) {
+		status = DSP_ENODETYPE;
+		goto func_end;
+	}
+
+	if (uNotifyType != DSP_SIGNALEVENT) {
+		status = DSP_EWRONGSTATE;
+		goto func_end;
+	}
+
+	status = NTFY_Register(hMsgQueue->hNtfy, hNotification, uEventMask,
+			      uNotifyType);
+
+	if (status == DSP_EVALUE) {
+		/*  Not registered. Ok, since we couldn't have known. Node
+		 *  notifications are split between node state change handled
+		 *  by NODE, and message ready handled by MSG.  */
+		status = DSP_SOK;
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_MSG_SetQueueId ========
+ */
+void WMD_MSG_SetQueueId(struct MSG_QUEUE *hMsgQueue, u32 dwId)
+{
+	/*
+	 *  A message queue must be created when a node is allocated,
+	 *  so that NODE_RegisterNotify() can be called before the node
+	 *  is created. Since we don't know the node environment until the
+	 *  node is created, we need this function to set hMsgQueue->dwId
+	 *  to the node environment, after the node is created.
+	 */
+	if (MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE))
+		hMsgQueue->dwId = dwId;
+}
+
+/*
+ *  ======== AddNewMsg ========
+ *      Must be called in message manager critical section.
+ */
+static DSP_STATUS AddNewMsg(struct LST_LIST *msgList)
+{
+	struct MSG_FRAME *pMsg;
+	DSP_STATUS status = DSP_SOK;
+
+	pMsg = (struct MSG_FRAME *)MEM_Calloc(sizeof(struct MSG_FRAME),
+		MEM_PAGED);
+	if (pMsg != NULL) {
+		LST_InitElem((struct list_head *)pMsg);
+		LST_PutTail(msgList, (struct list_head *)pMsg);
+	} else {
+		status = DSP_EMEMORY;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== DeleteMsgMgr ========
+ */
+static void DeleteMsgMgr(struct MSG_MGR *hMsgMgr)
+{
+	if (!MEM_IsValidHandle(hMsgMgr, MSGMGR_SIGNATURE))
+		goto func_end;
+
+	if (hMsgMgr->queueList) {
+		if (LST_IsEmpty(hMsgMgr->queueList)) {
+			kfree(hMsgMgr->queueList);
+			hMsgMgr->queueList = NULL;
+		}
+	}
+
+	if (hMsgMgr->msgFreeList) {
+		FreeMsgList(hMsgMgr->msgFreeList);
+		hMsgMgr->msgFreeList = NULL;
+	}
+
+	if (hMsgMgr->msgUsedList) {
+		FreeMsgList(hMsgMgr->msgUsedList);
+		hMsgMgr->msgUsedList = NULL;
+	}
+
+	if (hMsgMgr->hSyncEvent)
+		SYNC_CloseEvent(hMsgMgr->hSyncEvent);
+
+	if (hMsgMgr->hSyncCS)
+		SYNC_DeleteCS(hMsgMgr->hSyncCS);
+
+	MEM_FreeObject(hMsgMgr);
+func_end:
+	return;
+}
+
+/*
+ *  ======== DeleteMsgQueue ========
+ */
+static void DeleteMsgQueue(struct MSG_QUEUE *hMsgQueue, u32 uNumToDSP)
+{
+       struct MSG_MGR *hMsgMgr;
+	struct MSG_FRAME *pMsg;
+	u32 i;
+
+	if (!MEM_IsValidHandle(hMsgQueue, MSGQ_SIGNATURE) ||
+	    !hMsgQueue->hMsgMgr || !hMsgQueue->hMsgMgr->msgFreeList)
+		goto func_end;
+
+	hMsgMgr = hMsgQueue->hMsgMgr;
+
+	/* Pull off uNumToDSP message frames from Msg manager and free */
+	for (i = 0; i < uNumToDSP; i++) {
+
+		if (!LST_IsEmpty(hMsgMgr->msgFreeList)) {
+			pMsg = (struct MSG_FRAME *)LST_GetHead(hMsgMgr->
+				msgFreeList);
+			kfree(pMsg);
+		} else {
+			/* Cannot free all of the message frames */
+			break;
+		}
+	}
+
+       if (hMsgQueue->msgFreeList) {
+		FreeMsgList(hMsgQueue->msgFreeList);
+		hMsgQueue->msgFreeList = NULL;
+       }
+
+       if (hMsgQueue->msgUsedList) {
+		FreeMsgList(hMsgQueue->msgUsedList);
+		hMsgQueue->msgUsedList = NULL;
+       }
+
+
+	if (hMsgQueue->hNtfy)
+		NTFY_Delete(hMsgQueue->hNtfy);
+
+	if (hMsgQueue->hSyncEvent)
+		SYNC_CloseEvent(hMsgQueue->hSyncEvent);
+
+	if (hMsgQueue->hSyncDone)
+		SYNC_CloseEvent(hMsgQueue->hSyncDone);
+
+	if (hMsgQueue->hSyncDoneAck)
+		SYNC_CloseEvent(hMsgQueue->hSyncDoneAck);
+
+	MEM_FreeObject(hMsgQueue);
+func_end:
+       return;
+
+}
+
+/*
+ *  ======== FreeMsgList ========
+ */
+static void FreeMsgList(struct LST_LIST *msgList)
+{
+	struct MSG_FRAME *pMsg;
+
+	if (!msgList)
+		goto func_end;
+
+	while ((pMsg = (struct MSG_FRAME *)LST_GetHead(msgList)) != NULL)
+		kfree(pMsg);
+
+	DBC_Assert(LST_IsEmpty(msgList));
+
+	kfree(msgList);
+func_end:
+	return;
+}
+
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
new file mode 100644
index 0000000..577c85c
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -0,0 +1,1916 @@
+/*
+ * tiomap.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Processor Manager Driver for TI OMAP3430 EVM.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+#include <linux/mm.h>
+#include <linux/mmzone.h>
+#include <mach-omap2/prm.h>
+#include <mach-omap2/cm.h>
+#include <mach-omap2/prm-regbits-34xx.h>
+#include <mach-omap2/cm-regbits-34xx.h>
+#include <mach/control.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/reg.h>
+#include <dspbridge/cfg.h>
+#include <dspbridge/drv.h>
+#include <dspbridge/sync.h>
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_dspssC64P.h>
+#include <hw_prcm.h>
+#include <hw_mmu.h>
+#include <hw_mbox.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmd.h>
+#include <dspbridge/wmdchnl.h>
+#include <dspbridge/wmddeh.h>
+#include <dspbridge/wmdio.h>
+#include <dspbridge/wmdmsg.h>
+#include <dspbridge/pwr.h>
+#include <dspbridge/chnl_sm.h>
+#include <dspbridge/io_sm.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/wcd.h>
+#include <dspbridge/dmm.h>
+
+/*  ----------------------------------- Local */
+#include "_tiomap.h"
+#include "_tiomap_pwr.h"
+#include "_tiomap_mmu.h"
+#include "_tiomap_util.h"
+#include "tiomap_io.h"
+
+
+/* Offset in shared mem to write to in order to synchronize start with DSP */
+#define SHMSYNCOFFSET 4		/* GPP byte offset */
+
+#define BUFFERSIZE 1024
+
+#define MMU_SECTION_ADDR_MASK    0xFFF00000
+#define MMU_SSECTION_ADDR_MASK   0xFF000000
+#define MMU_LARGE_PAGE_MASK      0xFFFF0000
+#define MMU_SMALL_PAGE_MASK      0xFFFFF000
+#define PAGES_II_LVL_TABLE   512
+#define phys_to_page(phys)      pfn_to_page((phys) >> PAGE_SHIFT)
+
+#define MMU_GFLUSH 0x60
+
+/* Forward Declarations: */
+static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *pDevContext);
+static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *pDevContext,
+			OUT u8 *pbHostBuf,
+			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
+static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *pDevContext,
+			u32 dwDSPAddr);
+static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *pDevContext,
+			int *pdwState);
+static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *pDevContext);
+static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *pDevContext,
+			IN u8 *pbHostBuf,
+			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType);
+static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
+			u32 ulBrdState);
+static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
+			u32 ulDspDestAddr, u32 ulDspSrcAddr,
+			u32 ulNumBytes, u32 ulMemType);
+static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *pDevContext,
+			IN u8 *pbHostBuf, u32 dwDSPAddr,
+			u32 ulNumBytes, u32 ulMemType);
+static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
+			u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
+			u32 ulMapAttr);
+static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
+			u32 ulVirtAddr, u32 ulNumBytes);
+static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
+			struct DEV_OBJECT *hDevObject,
+			IN CONST struct CFG_HOSTRES *pConfig,
+			IN CONST struct CFG_DSPRES *pDspConfig);
+static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
+			IN OUT void *pArgs);
+static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *pDevContext);
+static u32 user_va2pa(struct mm_struct *mm, u32 address);
+static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
+			u32 va, u32 size,
+			struct HW_MMUMapAttrs_t *mapAttrs);
+static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
+			u32 size, struct HW_MMUMapAttrs_t *attrs);
+static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *hDevContext,
+			u32 ulMpuAddr, u32 ulVirtAddr,
+			u32 ulNumBytes, struct HW_MMUMapAttrs_t *hwAttrs);
+
+#ifdef CONFIG_BRIDGE_DEBUG
+static void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+{
+	u32 temp;
+	temp = __raw_readl((cm_base) + 0x00);
+	dev_dbg(bridge, "CM_FCLKEN_IVA2 = 0x%x\n", temp);
+	temp = __raw_readl((cm_base) + 0x10);
+	dev_dbg(bridge, "CM_ICLKEN1_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x20);
+	dev_dbg(bridge, "CM_IDLEST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x48);
+	dev_dbg(bridge, "CM_CLKSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0x4c);
+	dev_dbg(bridge, "CM_CLKSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0x50);
+	dev_dbg(bridge, "RM_RSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0x58);
+	dev_dbg(bridge, "RM_RSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0xE0);
+	dev_dbg(bridge, "PM_PWSTCTRL_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((prm_base) + 0xE4);
+	dev_dbg(bridge, "PM_PWSTST_IVA2 = 0x%x \n", temp);
+	temp = __raw_readl((cm_base) + 0xA10);
+	dev_dbg(bridge, "CM_ICLKEN1_CORE = 0x%x \n", temp);
+}
+#else
+static inline void GetHWRegs(void __iomem *prm_base, void __iomem *cm_base)
+{
+}
+#endif
+
+/*  ----------------------------------- Globals */
+
+/* Attributes of L2 page tables for DSP MMU */
+struct PageInfo {
+	u32 numEntries;	/* Number of valid PTEs in the L2 PT */
+} ;
+
+/* Attributes used to manage the DSP MMU page tables */
+struct PgTableAttrs {
+	struct SYNC_CSOBJECT *hCSObj;	/* Critical section object handle */
+
+	u32 L1BasePa;		/* Physical address of the L1 PT */
+	u32 L1BaseVa;		/* Virtual  address of the L1 PT */
+	u32 L1size;		/* Size of the L1 PT */
+	u32 L1TblAllocPa;
+	/* Physical address of Allocated mem for L1 table. May not be aligned */
+	u32 L1TblAllocVa;
+	/* Virtual address of Allocated mem for L1 table. May not be aligned */
+	u32 L1TblAllocSz;
+	/* Size of consistent memory allocated for L1 table.
+	 * May not be aligned */
+
+	u32 L2BasePa;		/* Physical address of the L2 PT */
+	u32 L2BaseVa;		/* Virtual  address of the L2 PT */
+	u32 L2size;		/* Size of the L2 PT */
+	u32 L2TblAllocPa;
+	/* Physical address of Allocated mem for L2 table. May not be aligned */
+	u32 L2TblAllocVa;
+	/* Virtual address of Allocated mem for L2 table. May not be aligned */
+	u32 L2TblAllocSz;
+	/* Size of consistent memory allocated for L2 table.
+	 * May not be aligned */
+
+	u32 L2NumPages;	/* Number of allocated L2 PT */
+	struct PageInfo *pgInfo;  /* Array [L2NumPages] of L2 PT info structs */
+} ;
+
+/*
+ *  If dsp_debug is true, do not branch to the DSP entry point and wait for DSP
+ *  to boot
+ */
+extern s32 dsp_debug;
+
+/*
+ *  This mini driver's function interface table.
+ */
+static struct WMD_DRV_INTERFACE drvInterfaceFxns = {
+	WCD_MAJOR_VERSION,  /* WCD ver. for which this mini driver is built. */
+	WCD_MINOR_VERSION,
+	WMD_DEV_Create,
+	WMD_DEV_Destroy,
+	WMD_DEV_Ctrl,
+	WMD_BRD_Monitor,
+	WMD_BRD_Start,
+	WMD_BRD_Stop,
+	WMD_BRD_Status,
+	WMD_BRD_Read,
+	WMD_BRD_Write,
+	WMD_BRD_SetState,
+	WMD_BRD_MemCopy,
+	WMD_BRD_MemWrite,
+	WMD_BRD_MemMap,
+	WMD_BRD_MemUnMap,
+	/* The following CHNL functions are provided by chnl_io.lib: */
+	WMD_CHNL_Create,
+	WMD_CHNL_Destroy,
+	WMD_CHNL_Open,
+	WMD_CHNL_Close,
+	WMD_CHNL_AddIOReq,
+	WMD_CHNL_GetIOC,
+	WMD_CHNL_CancelIO,
+	WMD_CHNL_FlushIO,
+	WMD_CHNL_GetInfo,
+	WMD_CHNL_GetMgrInfo,
+	WMD_CHNL_Idle,
+	WMD_CHNL_RegisterNotify,
+	/* The following DEH functions are provided by tihelen_ue_deh.c */
+	WMD_DEH_Create,
+	WMD_DEH_Destroy,
+	WMD_DEH_Notify,
+	WMD_DEH_RegisterNotify,
+	WMD_DEH_GetInfo,
+	/* The following IO functions are provided by chnl_io.lib: */
+	WMD_IO_Create,
+	WMD_IO_Destroy,
+	WMD_IO_OnLoaded,
+	WMD_IO_GetProcLoad,
+	/* The following MSG functions are provided by chnl_io.lib: */
+	WMD_MSG_Create,
+	WMD_MSG_CreateQueue,
+	WMD_MSG_Delete,
+	WMD_MSG_DeleteQueue,
+	WMD_MSG_Get,
+	WMD_MSG_Put,
+	WMD_MSG_RegisterNotify,
+	WMD_MSG_SetQueueId,
+};
+
+static inline void tlb_flush_all(const void __iomem *base)
+{
+	__raw_writeb(__raw_readb(base + MMU_GFLUSH) | 1, base + MMU_GFLUSH);
+}
+
+static inline void flush_all(struct WMD_DEV_CONTEXT *pDevContext)
+{
+	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
+				pDevContext->dwBrdState == BRD_HIBERNATION)
+		WakeDSP(pDevContext, NULL);
+
+	tlb_flush_all(pDevContext->dwDSPMmuBase);
+}
+
+static void bad_page_dump(u32 pa, struct page *pg)
+{
+	pr_emerg("DSPBRIDGE: MAP function: COUNT 0 FOR PA 0x%x\n", pa);
+	pr_emerg("Bad page state in process '%s'\n"
+		"page:%p flags:0x%0*lx mapping:%p mapcount:%d count:%d\n"
+		"Backtrace:\n",
+		current->comm, pg, (int)(2*sizeof(unsigned long)),
+		(unsigned long)pg->flags, pg->mapping,
+		page_mapcount(pg), page_count(pg));
+	dump_stack();
+}
+
+/*
+ *  ======== WMD_DRV_Entry ========
+ *  purpose:
+ *      Mini Driver entry point.
+ */
+void WMD_DRV_Entry(OUT struct WMD_DRV_INTERFACE **ppDrvInterface,
+	      IN CONST char *pstrWMDFileName)
+{
+
+	DBC_Require(pstrWMDFileName != NULL);
+
+	IO_SM_init(); /* Initialization of io_sm module */
+
+	if (strcmp(pstrWMDFileName, "UMA") == 0)
+		*ppDrvInterface = &drvInterfaceFxns;
+	else
+		dev_dbg(bridge, "%s Unknown WMD file name", __func__);
+
+}
+
+/*
+ *  ======== WMD_BRD_Monitor ========
+ *  purpose:
+ *      This WMD_BRD_Monitor puts DSP into a Loadable state.
+ *      i.e Application can load and start the device.
+ *
+ *  Preconditions:
+ *      Device in 'OFF' state.
+ */
+static DSP_STATUS WMD_BRD_Monitor(struct WMD_DEV_CONTEXT *hDevContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	struct CFG_HOSTRES resources;
+	u32 temp;
+	enum HW_PwrState_t    pwrState;
+
+	status = CFG_GetHostResources(
+		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		goto error_return;
+
+	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &temp);
+	if ((temp & 0x03) != 0x03 || (temp & 0x03) != 0x02) {
+		/* IVA2 is not in ON state */
+		/* Read and set PM_PWSTCTRL_IVA2  to ON */
+		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
+					  HW_PWR_DOMAIN_DSP,
+					  HW_PWR_STATE_ON);
+		/* Set the SW supervised state transition */
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_WAKEUP);
+		/* Wait until the state has moved to ON */
+		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+				     &pwrState);
+		/* Disable Automatic transition */
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_AUTOTRANS_DIS);
+	}
+
+	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+	HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
+	CLK_Enable(SERVICESCLK_iva2_ck);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* set the device state to IDLE */
+		pDevContext->dwBrdState = BRD_IDLE;
+	}
+error_return:
+	GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_Read ========
+ *  purpose:
+ *      Reads buffers for DSP memory.
+ */
+static DSP_STATUS WMD_BRD_Read(struct WMD_DEV_CONTEXT *hDevContext,
+			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
+			       u32 ulNumBytes, u32 ulMemType)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	u32 offset;
+	u32 dspBaseAddr = hDevContext->dwDspBaseAddr;
+
+	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
+		status = DSP_EFAIL;
+		return status;
+	}
+	/* change here to account for the 3 bands of the DSP internal memory */
+	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
+	    pDevContext->dwInternalSize) {
+		offset = dwDSPAddr - pDevContext->dwDSPStartAdd;
+	} else {
+		status = ReadExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
+					ulNumBytes, ulMemType);
+		return status;
+	}
+	/* copy the data from  DSP memory, */
+	memcpy(pbHostBuf, (void *)(dspBaseAddr + offset), ulNumBytes);
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_SetState ========
+ *  purpose:
+ *      This routine updates the Board status.
+ */
+static DSP_STATUS WMD_BRD_SetState(struct WMD_DEV_CONTEXT *hDevContext,
+				   u32 ulBrdState)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+
+	pDevContext->dwBrdState = ulBrdState;
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_Start ========
+ *  purpose:
+ *      Initializes DSP MMU and Starts DSP.
+ *
+ *  Preconditions:
+ *  a) DSP domain is 'ACTIVE'.
+ *  b) DSP_RST1 is asserted.
+ *  b) DSP_RST2 is released.
+ */
+static DSP_STATUS WMD_BRD_Start(struct WMD_DEV_CONTEXT *hDevContext,
+				u32 dwDSPAddr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	u32 dwSyncAddr = 0;
+	u32 ulShmBase;	/* Gpp Phys SM base addr(byte) */
+	u32 ulShmBaseVirt;	/* Dsp Virt SM base addr */
+	u32 ulTLBBaseVirt;	/* Base of MMU TLB entry */
+	u32 ulShmOffsetVirt;	/* offset of ulShmBaseVirt from ulTLBBaseVirt */
+	s32 iEntryNdx;
+	s32 itmpEntryNdx = 0;	/* DSP-MMU TLB entry base address */
+	struct CFG_HOSTRES resources;
+	u32 temp;
+	u32 ulDspClkRate;
+	u32 ulDspClkAddr;
+	u32 ulBiosGpTimer;
+	u32 uClkCmd;
+	struct IO_MGR *hIOMgr;
+	u32 ulLoadMonitorTimer;
+	u32 extClkId = 0;
+	u32 tmpIndex;
+	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
+
+	/* The device context contains all the mmu setup info from when the
+	 * last dsp base image was loaded. The first entry is always
+	 * SHMMEM base. */
+	/* Get SHM_BEG - convert to byte address */
+	(void) DEV_GetSymbol(pDevContext->hDevObject, SHMBASENAME,
+			     &ulShmBaseVirt);
+	ulShmBaseVirt *= DSPWORDSIZE;
+	DBC_Assert(ulShmBaseVirt != 0);
+	/* DSP Virtual address */
+	ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa;
+	DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
+	ulShmOffsetVirt = ulShmBaseVirt - (ulTLBBaseVirt * DSPWORDSIZE);
+	/* Kernel logical address */
+	ulShmBase = pDevContext->aTLBEntry[0].ulGppVa + ulShmOffsetVirt;
+
+	DBC_Assert(ulShmBase != 0);
+	/* 2nd wd is used as sync field */
+	dwSyncAddr = ulShmBase + SHMSYNCOFFSET;
+	 /* Write a signature into the SHM base + offset; this will
+	 * get cleared when the DSP program starts.  */
+	if ((ulShmBaseVirt == 0) || (ulShmBase == 0)) {
+		pr_err("%s: Illegal SM base\n", __func__);
+		status = DSP_EFAIL;
+	} else
+		*((volatile u32 *)dwSyncAddr) = 0xffffffff;
+
+	if (DSP_SUCCEEDED(status)) {
+		status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+		/* Assert RST1 i.e only the RST only for DSP megacell  */
+		/* HW_RST_Reset(resources.dwPrcmBase, HW_RST1_IVA2);*/
+		if (DSP_SUCCEEDED(status)) {
+			HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+			if (dsp_debug) {
+				/* Set the bootmode to self loop  */
+				dev_dbg(bridge, "Set boot mode to self loop"
+						" for IVA2 Device\n");
+				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
+					HW_DSPSYSC_SELFLOOPBOOT, dwDSPAddr);
+			} else {
+				/* Set the bootmode to '0' - direct boot */
+				dev_dbg(bridge, "Set boot mode to direct boot"
+						" for IVA2 Device\n");
+				HW_DSPSS_BootModeSet(resources.dwSysCtrlBase,
+					HW_DSPSYSC_DIRECTBOOT, dwDSPAddr);
+			}
+		}
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Reset and Unreset the RST2, so that BOOTADDR is copied to
+		 * IVA2 SYSC register */
+		HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+		udelay(100);
+		HW_RST_UnReset(resources.dwPrmBase, HW_RST2_IVA2);
+		udelay(100);
+
+		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+		/* Disbale the DSP MMU */
+		HW_MMU_Disable(resources.dwDmmuBase);
+		/* Disable TWL */
+		HW_MMU_TWLDisable(resources.dwDmmuBase);
+
+		/* Only make TLB entry if both addresses are non-zero */
+		for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB;
+			iEntryNdx++) {
+			if ((pDevContext->aTLBEntry[iEntryNdx].ulGppPa != 0) &&
+			   (pDevContext->aTLBEntry[iEntryNdx].ulDspVa != 0)) {
+				dev_dbg(bridge, "(proc) MMU %d GppPa:"
+				    " 0x%x DspVa 0x%x Size 0x%x\n",
+				    itmpEntryNdx,
+				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulSize);
+				configureDspMmu(pDevContext,
+				    pDevContext->aTLBEntry[iEntryNdx].ulGppPa,
+				    pDevContext->aTLBEntry[iEntryNdx].ulDspVa *
+				    DSPWORDSIZE,
+				    pDevContext->aTLBEntry[iEntryNdx].ulSize,
+				    itmpEntryNdx,
+				    pDevContext->aTLBEntry[iEntryNdx].endianism,
+				    pDevContext->aTLBEntry[iEntryNdx].elemSize,
+				    pDevContext->aTLBEntry[iEntryNdx].
+				    mixedMode);
+				itmpEntryNdx++;
+			}
+		}		/* end for */
+	}
+
+	/* Lock the above TLB entries and get the BIOS and load monitor timer
+	 * information*/
+	if (DSP_SUCCEEDED(status)) {
+		HW_MMU_NumLockedSet(resources.dwDmmuBase, itmpEntryNdx);
+		HW_MMU_VictimNumSet(resources.dwDmmuBase, itmpEntryNdx);
+		HW_MMU_TTBSet(resources.dwDmmuBase,
+				pDevContext->pPtAttrs->L1BasePa);
+		HW_MMU_TWLEnable(resources.dwDmmuBase);
+		/* Enable the SmartIdle and AutoIdle bit for MMU_SYSCONFIG */
+
+
+		temp = __raw_readl((resources.dwDmmuBase) + 0x10);
+		temp = (temp & 0xFFFFFFEF) | 0x11;
+		__raw_writel(temp, (resources.dwDmmuBase) + 0x10);
+
+		/* Let the DSP MMU run */
+		HW_MMU_Enable(resources.dwDmmuBase);
+
+		/* Enable the BIOS clock  */
+		(void)DEV_GetSymbol(pDevContext->hDevObject,
+				BRIDGEINIT_BIOSGPTIMER, &ulBiosGpTimer);
+		(void)DEV_GetSymbol(pDevContext->hDevObject,
+				BRIDGEINIT_LOADMON_GPTIMER,
+				&ulLoadMonitorTimer);
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		if (ulLoadMonitorTimer != 0xFFFF) {
+			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
+						ulLoadMonitorTimer;
+
+			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+
+			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
+			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
+			     tmpIndex++) {
+				if (extClkId == BPWR_CLKID[tmpIndex]) {
+					clkIdIndex = tmpIndex;
+					break;
+				}
+			}
+
+			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
+				status =
+				    CLK_Set_32KHz(BPWR_Clks[clkIdIndex].funClk);
+			} else {
+				status = DSP_EFAIL;
+			}
+			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
+				  ulLoadMonitorTimer;
+
+			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+
+		} else {
+			dev_dbg(bridge, "Not able to get the symbol for Load "
+				  "Monitor Timer\n");
+		}
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		if (ulBiosGpTimer != 0xFFFF) {
+			uClkCmd = (BPWR_DisableClock << MBX_PM_CLK_CMDSHIFT) |
+								ulBiosGpTimer;
+
+			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+
+			extClkId = uClkCmd & MBX_PM_CLK_IDMASK;
+
+			for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES;
+			     tmpIndex++) {
+				if (extClkId == BPWR_CLKID[tmpIndex]) {
+					clkIdIndex = tmpIndex;
+					break;
+				}
+			}
+
+			if (clkIdIndex < MBX_PM_MAX_RESOURCES) {
+				status = CLK_Set_32KHz(
+						BPWR_Clks[clkIdIndex].funClk);
+			} else {
+				status = DSP_EFAIL;
+			}
+
+			uClkCmd = (BPWR_EnableClock << MBX_PM_CLK_CMDSHIFT) |
+				   ulBiosGpTimer;
+
+			DSPPeripheralClkCtrl(pDevContext, &uClkCmd);
+
+		} else {
+		dev_dbg(bridge, "Not able to get the symbol for BIOS Timer\n");
+		}
+	}
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Set the DSP clock rate */
+		(void)DEV_GetSymbol(pDevContext->hDevObject,
+					"_BRIDGEINIT_DSP_FREQ", &ulDspClkAddr);
+		/*Set Autoidle Mode for IVA2 PLL */
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwCmBase) + 0x34));
+		temp = (temp & 0xFFFFFFFE) | 0x1;
+		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x34)) =
+			(u32) temp;
+		if ((unsigned int *)ulDspClkAddr != NULL) {
+			/* Get the clock rate */
+			status = CLK_GetRate(SERVICESCLK_iva2_ck,
+				 &ulDspClkRate);
+			dev_dbg(bridge, "%s: DSP clock rate (KHZ): 0x%x \n",
+							__func__, ulDspClkRate);
+			(void)WMD_BRD_Write(pDevContext, (u8 *)&ulDspClkRate,
+				 ulDspClkAddr, sizeof(u32), 0);
+		}
+/*PM_IVA2GRPSEL_PER = 0xC0;*/
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerPmBase) + 0xA8));
+		temp = (temp & 0xFFFFFF30) | 0xC0;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8)) =
+			(u32) temp;
+
+/*PM_MPUGRPSEL_PER &= 0xFFFFFF3F;*/
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerPmBase) + 0xA4));
+		temp = (temp & 0xFFFFFF3F);
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4)) =
+			(u32) temp;
+/*CM_SLEEPDEP_PER |= 0x04;*/
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwPerBase) + 0x44));
+		temp = (temp & 0xFFFFFFFB) | 0x04;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerBase) + 0x44)) =
+			(u32) temp;
+
+/*CM_CLKSTCTRL_IVA2 = 0x00000003 -To Allow automatic transitions*/
+		temp = (u32) *((REG_UWORD32 *)
+			((u32) (resources.dwCmBase) + 0x48));
+		temp = (temp & 0xFFFFFFFC) | 0x03;
+		*((REG_UWORD32 *) ((u32) (resources.dwCmBase) + 0x48)) =
+			(u32) temp;
+
+		/* Enable Mailbox events and also drain any pending
+		 * stale messages */
+		(void)CHNLSM_EnableInterrupt(pDevContext);
+
+		/* Let DSP go */
+		dev_dbg(bridge, "%s Unreset\n", __func__);
+		/* Enable DSP MMU Interrupts */
+		HW_MMU_EventEnable(resources.dwDmmuBase,
+				HW_MMU_ALL_INTERRUPTS);
+		/* release the RST1, DSP starts executing now .. */
+		HW_RST_UnReset(resources.dwPrmBase, HW_RST1_IVA2);
+
+		dev_dbg(bridge, "Waiting for Sync @ 0x%x\n", dwSyncAddr);
+		dev_dbg(bridge, "DSP c_int00 Address =  0x%x\n", dwDSPAddr);
+		if (dsp_debug)
+			while (*((volatile u16 *)dwSyncAddr))
+				;
+
+		/* Wait for DSP to clear word in shared memory */
+		/* Read the Location */
+		if (!WaitForStart(pDevContext, dwSyncAddr))
+			status = WMD_E_TIMEOUT;
+
+		status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
+		if (DSP_SUCCEEDED(status)) {
+			IO_SHMsetting(hIOMgr, SHM_OPPINFO, NULL);
+			/* Write the synchronization bit to indicate the
+			 * completion of OPP table update to DSP
+			 */
+			*((volatile u32 *)dwSyncAddr) = 0XCAFECAFE;
+
+			/* update board state */
+			pDevContext->dwBrdState = BRD_RUNNING;
+			/* (void)CHNLSM_EnableInterrupt(pDevContext);*/
+		} else {
+			pDevContext->dwBrdState = BRD_UNKNOWN;
+		}
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_Stop ========
+ *  purpose:
+ *      Puts DSP in self loop.
+ *
+ *  Preconditions :
+ *  a) None
+ */
+static DSP_STATUS WMD_BRD_Stop(struct WMD_DEV_CONTEXT *hDevContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	struct CFG_HOSTRES resources;
+	struct PgTableAttrs *pPtAttrs;
+	u32 dspPwrState;
+	DSP_STATUS clk_status;
+
+	/* Disable the mail box interrupts */
+	(void)CHNLSM_DisableInterrupt(pDevContext);
+
+	if (pDevContext->dwBrdState == BRD_STOPPED)
+		return status;
+
+	/* as per TRM, it is advised to first drive the IVA2 to 'Standby' mode,
+	 * before turning off the clocks.. This is to ensure that there are no
+	 * pending L3 or other transactons from IVA2 */
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
+	HW_PWRST_IVA2RegGet(resources.dwPrmBase, &dspPwrState);
+	if (dspPwrState != HW_PWR_STATE_OFF) {
+		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPIDLE);
+		mdelay(10);
+		GetHWRegs(resources.dwPrmBase, resources.dwCmBase);
+		udelay(50);
+
+		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+
+		/* IVA2 is not in OFF state */
+		/* Set PM_PWSTCTRL_IVA2  to OFF */
+		HW_PWR_IVA2PowerStateSet(resources.dwPrmBase,
+					  HW_PWR_DOMAIN_DSP,
+					  HW_PWR_STATE_OFF);
+		/* Set the SW supervised state transition for Sleep */
+		HW_PWR_CLKCTRL_IVA2RegSet(resources.dwCmBase, HW_SW_SUP_SLEEP);
+	} else {
+		clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+	}
+	udelay(10);
+	/* Release the Ext Base virtual Address as the next DSP Program
+	 * may have a different load address */
+	if (pDevContext->dwDspExtBaseAddr)
+		pDevContext->dwDspExtBaseAddr = 0;
+
+	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
+
+	/* This is a good place to clear the MMU page tables as well */
+	if (pDevContext->pPtAttrs) {
+		pPtAttrs = pDevContext->pPtAttrs;
+		memset((u8 *) pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
+		memset((u8 *) pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
+		memset((u8 *) pPtAttrs->pgInfo, 0x00,
+		       (pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
+	}
+	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
+
+	return status;
+}
+
+
+/*
+ *  ======== WMD_BRD_Delete ========
+ *  purpose:
+ *      Puts DSP in Low power mode
+ *
+ *  Preconditions :
+ *  a) None
+ */
+static DSP_STATUS WMD_BRD_Delete(struct WMD_DEV_CONTEXT *hDevContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	struct CFG_HOSTRES resources;
+	struct PgTableAttrs *pPtAttrs;
+	DSP_STATUS clk_status;
+
+	/* Disable the mail box interrupts */
+	(void) CHNLSM_DisableInterrupt(pDevContext);
+
+	if (pDevContext->dwBrdState == BRD_STOPPED)
+		return status;
+
+	/* as per TRM, it is advised to first drive
+	 * the IVA2 to 'Standby' mode, before turning off the clocks.. This is
+	 * to ensure that there are no pending L3 or other transactons from
+	 * IVA2 */
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
+	status = SleepDSP(pDevContext, PWR_EMERGENCYDEEPSLEEP, NULL);
+	clk_status = CLK_Disable(SERVICESCLK_iva2_ck);
+
+	/* Release the Ext Base virtual Address as the next DSP Program
+	 * may have a different load address */
+	if (pDevContext->dwDspExtBaseAddr)
+		pDevContext->dwDspExtBaseAddr = 0;
+
+	pDevContext->dwBrdState = BRD_STOPPED;	/* update board state */
+
+	/* This is a good place to clear the MMU page tables as well */
+	if (pDevContext->pPtAttrs) {
+		pPtAttrs = pDevContext->pPtAttrs;
+		memset((u8 *)pPtAttrs->L1BaseVa, 0x00, pPtAttrs->L1size);
+		memset((u8 *)pPtAttrs->L2BaseVa, 0x00, pPtAttrs->L2size);
+		memset((u8 *)pPtAttrs->pgInfo, 0x00,
+			(pPtAttrs->L2NumPages * sizeof(struct PageInfo)));
+	}
+	HW_RST_Reset(resources.dwPrmBase, HW_RST1_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST2_IVA2);
+	HW_RST_Reset(resources.dwPrmBase, HW_RST3_IVA2);
+
+	return status;
+}
+
+
+/*
+ *  ======== WMD_BRD_Status ========
+ *      Returns the board status.
+ */
+static DSP_STATUS WMD_BRD_Status(struct WMD_DEV_CONTEXT *hDevContext,
+				 int *pdwState)
+{
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	*pdwState = pDevContext->dwBrdState;
+	return DSP_SOK;
+}
+
+/*
+ *  ======== WMD_BRD_Write ========
+ *      Copies the buffers to DSP internal or external memory.
+ */
+static DSP_STATUS WMD_BRD_Write(struct WMD_DEV_CONTEXT *hDevContext,
+				IN u8 *pbHostBuf, u32 dwDSPAddr,
+				u32 ulNumBytes, u32 ulMemType)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+
+	if (dwDSPAddr < pDevContext->dwDSPStartAdd) {
+		status = DSP_EFAIL;
+		return status;
+	}
+	if ((dwDSPAddr - pDevContext->dwDSPStartAdd) <
+	   pDevContext->dwInternalSize) {
+		status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
+			 ulNumBytes, ulMemType);
+	} else {
+		status = WriteExtDspData(pDevContext, pbHostBuf, dwDSPAddr,
+					 ulNumBytes, ulMemType, false);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_DEV_Create ========
+ *      Creates a driver object. Puts DSP in self loop.
+ */
+static DSP_STATUS WMD_DEV_Create(OUT struct WMD_DEV_CONTEXT **ppDevContext,
+				 struct DEV_OBJECT *hDevObject,
+				 IN CONST struct CFG_HOSTRES *pConfig,
+				 IN CONST struct CFG_DSPRES *pDspConfig)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = NULL;
+	s32 iEntryNdx;
+	s32 tcWordSwap;
+	u32 tcWordSwapSize = sizeof(tcWordSwap);
+	struct CFG_HOSTRES resources;
+	struct PgTableAttrs *pPtAttrs;
+	u32   pg_tbl_pa;
+	u32   pg_tbl_va;
+	u32   align_size;
+
+	 /* Allocate and initialize a data structure to contain the mini driver
+	 *  state, which becomes the context for later calls into this WMD.  */
+	pDevContext = MEM_Calloc(sizeof(struct WMD_DEV_CONTEXT), MEM_NONPAGED);
+	if (!pDevContext) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status)) {
+		status = DSP_EMEMORY;
+		goto func_end;
+	}
+
+	pDevContext->dwDSPStartAdd = (u32)OMAP_GEM_BASE;
+	pDevContext->dwSelfLoop = (u32)NULL;
+	pDevContext->uDspPerClks = 0;
+	pDevContext->dwInternalSize = OMAP_DSP_SIZE;
+	/*  Clear dev context MMU table entries.
+	 *  These get set on WMD_BRD_IOCTL() call after program loaded. */
+	for (iEntryNdx = 0; iEntryNdx < WMDIOCTL_NUMOFMMUTLB; iEntryNdx++) {
+		pDevContext->aTLBEntry[iEntryNdx].ulGppPa =
+			pDevContext->aTLBEntry[iEntryNdx].ulDspVa = 0;
+	}
+	pDevContext->numTLBEntries = 0;
+	pDevContext->dwDspBaseAddr = (u32)MEM_LinearAddress((void *)
+			(pConfig->dwMemBase[3]), pConfig->dwMemLength[3]);
+	if (!pDevContext->dwDspBaseAddr)
+		status = DSP_EFAIL;
+
+	pPtAttrs = MEM_Calloc(sizeof(struct PgTableAttrs), MEM_NONPAGED);
+	if (pPtAttrs != NULL) {
+		/* Assuming that we use only DSP's memory map
+		 * until 0x4000:0000 , we would need only 1024
+		 * L1 enties i.e L1 size = 4K */
+		pPtAttrs->L1size = 0x1000;
+		align_size = pPtAttrs->L1size;
+		/* Align sizes are expected to be power of 2 */
+		/* we like to get aligned on L1 table size */
+		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L1size,
+		    align_size, &pg_tbl_pa);
+
+		/* Check if the PA is aligned for us */
+		if ((pg_tbl_pa) & (align_size-1)) {
+			/* PA not aligned to page table size ,
+			 * try with more allocation and align */
+			MEM_FreePhysMem((void *)pg_tbl_va, pg_tbl_pa,
+					pPtAttrs->L1size);
+			/* we like to get aligned on L1 table size */
+			pg_tbl_va = (u32) MEM_AllocPhysMem((pPtAttrs->L1size)*2,
+					align_size, &pg_tbl_pa);
+			/* We should be able to get aligned table now */
+			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
+			pPtAttrs->L1TblAllocVa = pg_tbl_va;
+			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size * 2;
+			/* Align the PA to the next 'align'  boundary */
+			pPtAttrs->L1BasePa = ((pg_tbl_pa) + (align_size-1)) &
+				(~(align_size-1));
+			pPtAttrs->L1BaseVa = pg_tbl_va + (pPtAttrs->L1BasePa -
+				pg_tbl_pa);
+		} else {
+			/* We got aligned PA, cool */
+			pPtAttrs->L1TblAllocPa = pg_tbl_pa;
+			pPtAttrs->L1TblAllocVa = pg_tbl_va;
+			pPtAttrs->L1TblAllocSz = pPtAttrs->L1size;
+			pPtAttrs->L1BasePa = pg_tbl_pa;
+			pPtAttrs->L1BaseVa = pg_tbl_va;
+		}
+		if (pPtAttrs->L1BaseVa)
+			memset((u8 *)pPtAttrs->L1BaseVa, 0x00,
+				pPtAttrs->L1size);
+
+		/* number of L2 page tables = DMM pool used + SHMMEM +EXTMEM +
+		 * L4 pages */
+		pPtAttrs->L2NumPages = ((DMMPOOLSIZE >> 20) + 6);
+		pPtAttrs->L2size = HW_MMU_COARSE_PAGE_SIZE *
+				   pPtAttrs->L2NumPages;
+		align_size = 4; /* Make it u32 aligned  */
+		/* we like to get aligned on L1 table size */
+		pg_tbl_va = (u32)MEM_AllocPhysMem(pPtAttrs->L2size,
+			    align_size, &pg_tbl_pa);
+		pPtAttrs->L2TblAllocPa = pg_tbl_pa;
+		pPtAttrs->L2TblAllocVa = pg_tbl_va;
+		pPtAttrs->L2TblAllocSz = pPtAttrs->L2size;
+		pPtAttrs->L2BasePa = pg_tbl_pa;
+		pPtAttrs->L2BaseVa = pg_tbl_va;
+
+		if (pPtAttrs->L2BaseVa)
+			memset((u8 *)pPtAttrs->L2BaseVa, 0x00,
+				pPtAttrs->L2size);
+
+		pPtAttrs->pgInfo = MEM_Calloc(pPtAttrs->L2NumPages *
+				sizeof(struct PageInfo), MEM_NONPAGED);
+		dev_dbg(bridge, "L1 pa %x, va %x, size %x\n L2 pa %x, va "
+			 "%x, size %x\n", pPtAttrs->L1BasePa,
+			 pPtAttrs->L1BaseVa, pPtAttrs->L1size,
+			 pPtAttrs->L2BasePa, pPtAttrs->L2BaseVa,
+			 pPtAttrs->L2size);
+		dev_dbg(bridge, "pPtAttrs %p L2 NumPages %x pgInfo %p\n",
+			 pPtAttrs, pPtAttrs->L2NumPages, pPtAttrs->pgInfo);
+	}
+	if ((pPtAttrs != NULL) && (pPtAttrs->L1BaseVa != 0) &&
+	   (pPtAttrs->L2BaseVa != 0) && (pPtAttrs->pgInfo != NULL))
+		pDevContext->pPtAttrs = pPtAttrs;
+	else
+		status = DSP_EMEMORY;
+
+	if (DSP_SUCCEEDED(status))
+		status = SYNC_InitializeCS(&pPtAttrs->hCSObj);
+
+	if (DSP_SUCCEEDED(status)) {
+		/* Set the Endianism Register */ /* Need to set this */
+		/* Retrieve the TC u16 SWAP Option */
+		status = REG_GetValue(TCWORDSWAP, (u8 *)&tcWordSwap,
+				      &tcWordSwapSize);
+		/* Save the value */
+		pDevContext->tcWordSwapOn = tcWordSwap;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		/* Set the Clock Divisor for the DSP module */
+		status = CLK_Enable(SERVICESCLK_mailbox_ick);
+		udelay(5);
+		/* 24xx-Linux MMU address is obtained from the host
+		 * resources struct */
+		pDevContext->dwDSPMmuBase = resources.dwDmmuBase;
+	}
+	if (DSP_SUCCEEDED(status)) {
+		pDevContext->hDevObject = hDevObject;
+		pDevContext->ulIntMask = 0;
+		/* Store current board state. */
+		pDevContext->dwBrdState = BRD_STOPPED;
+		/* Return this ptr to our device state to the WCD for storage:*/
+		*ppDevContext = pDevContext;
+	} else {
+		if (pPtAttrs != NULL) {
+			if (pPtAttrs->hCSObj)
+				SYNC_DeleteCS(pPtAttrs->hCSObj);
+
+			kfree(pPtAttrs->pgInfo);
+
+			if (pPtAttrs->L2TblAllocVa) {
+				MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
+						pPtAttrs->L2TblAllocPa,
+						pPtAttrs->L2TblAllocSz);
+			}
+			if (pPtAttrs->L1TblAllocVa) {
+				MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
+						pPtAttrs->L1TblAllocPa,
+						pPtAttrs->L1TblAllocSz);
+			}
+		}
+		kfree(pPtAttrs);
+		kfree(pDevContext);
+	}
+func_end:
+	return status;
+}
+
+/*
+ *  ======== WMD_DEV_Ctrl ========
+ *      Receives device specific commands.
+ */
+static DSP_STATUS WMD_DEV_Ctrl(struct WMD_DEV_CONTEXT *pDevContext, u32 dwCmd,
+				IN OUT void *pArgs)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMDIOCTL_EXTPROC *paExtProc = (struct WMDIOCTL_EXTPROC *)pArgs;
+	s32 ndx;
+
+	switch (dwCmd) {
+	case WMDIOCTL_CHNLREAD:
+		break;
+	case WMDIOCTL_CHNLWRITE:
+		break;
+	case WMDIOCTL_SETMMUCONFIG:
+		/* store away dsp-mmu setup values for later use */
+		for (ndx = 0; ndx < WMDIOCTL_NUMOFMMUTLB; ndx++, paExtProc++)
+			pDevContext->aTLBEntry[ndx] = *paExtProc;
+		break;
+	case WMDIOCTL_DEEPSLEEP:
+	case WMDIOCTL_EMERGENCYSLEEP:
+		/* Currently only DSP Idle is supported Need to update for
+		 * later releases */
+		status = SleepDSP(pDevContext, PWR_DEEPSLEEP, pArgs);
+		break;
+	case WMDIOCTL_WAKEUP:
+		status = WakeDSP(pDevContext, pArgs);
+		break;
+	case WMDIOCTL_CLK_CTRL:
+		status = DSP_SOK;
+		/* Looking For Baseport Fix for Clocks */
+		status = DSPPeripheralClkCtrl(pDevContext, pArgs);
+		break;
+	case WMDIOCTL_PWR_HIBERNATE:
+		status = handle_hibernation_fromDSP(pDevContext);
+		break;
+	case WMDIOCTL_PRESCALE_NOTIFY:
+		status = PreScale_DSP(pDevContext, pArgs);
+		break;
+	case WMDIOCTL_POSTSCALE_NOTIFY:
+		status = PostScale_DSP(pDevContext, pArgs);
+		break;
+	case WMDIOCTL_CONSTRAINT_REQUEST:
+		status = handle_constraints_set(pDevContext, pArgs);
+		break;
+	default:
+		status = DSP_EFAIL;
+		break;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_DEV_Destroy ========
+ *      Destroys the driver object.
+ */
+static DSP_STATUS WMD_DEV_Destroy(struct WMD_DEV_CONTEXT *hDevContext)
+{
+	struct PgTableAttrs *pPtAttrs;
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = (struct WMD_DEV_CONTEXT *)
+						hDevContext;
+
+	/* It should never happen */
+	if (!hDevContext)
+		return DSP_EHANDLE;
+
+	/* first put the device to stop state */
+	WMD_BRD_Delete(pDevContext);
+	if (pDevContext->pPtAttrs) {
+		pPtAttrs = pDevContext->pPtAttrs;
+		if (pPtAttrs->hCSObj)
+			SYNC_DeleteCS(pPtAttrs->hCSObj);
+
+		kfree(pPtAttrs->pgInfo);
+
+		if (pPtAttrs->L2TblAllocVa) {
+			MEM_FreePhysMem((void *)pPtAttrs->L2TblAllocVa,
+					pPtAttrs->L2TblAllocPa, pPtAttrs->
+					L2TblAllocSz);
+		}
+		if (pPtAttrs->L1TblAllocVa) {
+			MEM_FreePhysMem((void *)pPtAttrs->L1TblAllocVa,
+					pPtAttrs->L1TblAllocPa, pPtAttrs->
+					L1TblAllocSz);
+		}
+		kfree(pPtAttrs);
+
+	}
+	/* Free the driver's device context: */
+	kfree((void *) hDevContext);
+	return status;
+}
+
+static DSP_STATUS WMD_BRD_MemCopy(struct WMD_DEV_CONTEXT *hDevContext,
+				  u32 ulDspDestAddr, u32 ulDspSrcAddr,
+				  u32 ulNumBytes, u32 ulMemType)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 srcAddr = ulDspSrcAddr;
+	u32 destAddr = ulDspDestAddr;
+	u32 copyBytes = 0;
+	u32 totalBytes = ulNumBytes;
+	u8 hostBuf[BUFFERSIZE];
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	while ((totalBytes > 0) && DSP_SUCCEEDED(status)) {
+		copyBytes = totalBytes > BUFFERSIZE ? BUFFERSIZE : totalBytes;
+		/* Read from External memory */
+		status = ReadExtDspData(hDevContext, hostBuf, srcAddr,
+					copyBytes, ulMemType);
+		if (DSP_SUCCEEDED(status)) {
+			if (destAddr < (pDevContext->dwDSPStartAdd +
+			    pDevContext->dwInternalSize)) {
+				/* Write to Internal memory */
+				status = WriteDspData(hDevContext, hostBuf,
+					 destAddr, copyBytes, ulMemType);
+			} else {
+				/* Write to External memory */
+				status = WriteExtDspData(hDevContext, hostBuf,
+					 destAddr, copyBytes, ulMemType, false);
+			}
+		}
+		totalBytes -= copyBytes;
+		srcAddr += copyBytes;
+		destAddr += copyBytes;
+	}
+	return status;
+}
+
+/* Mem Write does not halt the DSP to write unlike WMD_BRD_Write */
+static DSP_STATUS WMD_BRD_MemWrite(struct WMD_DEV_CONTEXT *hDevContext,
+				   IN u8 *pbHostBuf, u32 dwDSPAddr,
+				   u32 ulNumBytes, u32 ulMemType)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	u32 ulRemainBytes = 0;
+	u32 ulBytes = 0;
+	ulRemainBytes = ulNumBytes;
+	while (ulRemainBytes > 0 && DSP_SUCCEEDED(status)) {
+		ulBytes =
+			ulRemainBytes > BUFFERSIZE ? BUFFERSIZE : ulRemainBytes;
+		if (dwDSPAddr < (pDevContext->dwDSPStartAdd +
+		    pDevContext->dwInternalSize)) {
+			status = WriteDspData(hDevContext, pbHostBuf, dwDSPAddr,
+					      ulBytes, ulMemType);
+		} else {
+			status = WriteExtDspData(hDevContext, pbHostBuf,
+				 dwDSPAddr, ulBytes, ulMemType, true);
+		}
+		ulRemainBytes -= ulBytes;
+		dwDSPAddr += ulBytes;
+		pbHostBuf = pbHostBuf + ulBytes;
+	}
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_MemMap ========
+ *      This function maps MPU buffer to the DSP address space. It performs
+ *  linear to physical address translation if required. It translates each
+ *  page since linear addresses can be physically non-contiguous
+ *  All address & size arguments are assumed to be page aligned (in proc.c)
+ *
+ *  TODO: Disable MMU while updating the page tables (but that'll stall DSP)
+ */
+static DSP_STATUS WMD_BRD_MemMap(struct WMD_DEV_CONTEXT *hDevContext,
+				 u32 ulMpuAddr, u32 ulVirtAddr,
+				 u32 ulNumBytes, u32 ulMapAttr)
+{
+	u32 attrs;
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	struct HW_MMUMapAttrs_t hwAttrs;
+	struct vm_area_struct *vma;
+	struct mm_struct *mm = current->mm;
+	u32 write = 0;
+	u32 numUsrPgs = 0;
+	struct page *mappedPage, *pg;
+	s32 pgNum;
+	u32 va = ulVirtAddr;
+	struct task_struct *curr_task = current;
+	u32 pgI = 0;
+	u32 mpuAddr, pa;
+
+	dev_dbg(bridge, "%s hDevCtxt %p, pa %x, va %x, size %x, ulMapAttr %x\n",
+				__func__, hDevContext, ulMpuAddr, ulVirtAddr,
+				ulNumBytes, ulMapAttr);
+	if (ulNumBytes == 0)
+		return DSP_EINVALIDARG;
+
+	if (ulMapAttr != 0) {
+		attrs = ulMapAttr;
+	} else {
+		/* Assign default attributes */
+		attrs = DSP_MAPVIRTUALADDR | DSP_MAPELEMSIZE16;
+	}
+	/* Take mapping properties */
+	if (attrs & DSP_MAPBIGENDIAN)
+		hwAttrs.endianism = HW_BIG_ENDIAN;
+	else
+		hwAttrs.endianism = HW_LITTLE_ENDIAN;
+
+	hwAttrs.mixedSize = (enum HW_MMUMixedSize_t)
+			       ((attrs & DSP_MAPMIXEDELEMSIZE) >> 2);
+	/* Ignore elementSize if mixedSize is enabled */
+	if (hwAttrs.mixedSize == 0) {
+		if (attrs & DSP_MAPELEMSIZE8) {
+			/* Size is 8 bit */
+			hwAttrs.elementSize = HW_ELEM_SIZE_8BIT;
+		} else if (attrs & DSP_MAPELEMSIZE16) {
+			/* Size is 16 bit */
+			hwAttrs.elementSize = HW_ELEM_SIZE_16BIT;
+		} else if (attrs & DSP_MAPELEMSIZE32) {
+			/* Size is 32 bit */
+			hwAttrs.elementSize = HW_ELEM_SIZE_32BIT;
+		} else if (attrs & DSP_MAPELEMSIZE64) {
+			/* Size is 64 bit */
+			hwAttrs.elementSize = HW_ELEM_SIZE_64BIT;
+		} else {
+			/*
+			 * Mixedsize isn't enabled, so size can't be
+			 * zero here
+			 */
+			return DSP_EINVALIDARG;
+		}
+	}
+	if (attrs & DSP_MAPDONOTLOCK)
+		hwAttrs.donotlockmpupage = 1;
+	else
+		hwAttrs.donotlockmpupage = 0;
+
+	if (attrs & DSP_MAPVMALLOCADDR) {
+		return MemMapVmalloc(hDevContext, ulMpuAddr, ulVirtAddr,
+				       ulNumBytes, &hwAttrs);
+	}
+	/*
+	 * Do OS-specific user-va to pa translation.
+	 * Combine physically contiguous regions to reduce TLBs.
+	 * Pass the translated pa to PteUpdate.
+	 */
+	if ((attrs & DSP_MAPPHYSICALADDR)) {
+		status = PteUpdate(pDevContext, ulMpuAddr, ulVirtAddr,
+			 ulNumBytes, &hwAttrs);
+		goto func_cont;
+	}
+
+	/*
+	 * Important Note: ulMpuAddr is mapped from user application process
+	 * to current process - it must lie completely within the current
+	 * virtual memory address space in order to be of use to us here!
+	 */
+	down_read(&mm->mmap_sem);
+	vma = find_vma(mm, ulMpuAddr);
+	if (vma)
+		dev_dbg(bridge, "VMAfor UserBuf: ulMpuAddr=%x, ulNumBytes=%x, "
+				"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n",
+				ulMpuAddr, ulNumBytes, vma->vm_start,
+				vma->vm_end, vma->vm_flags);
+
+	/*
+	 * It is observed that under some circumstances, the user buffer is
+	 * spread across several VMAs. So loop through and check if the entire
+	 * user buffer is covered
+	 */
+	while ((vma) && (ulMpuAddr + ulNumBytes > vma->vm_end)) {
+		/* jump to the next VMA region */
+		vma = find_vma(mm, vma->vm_end + 1);
+		dev_dbg(bridge, "VMA for UserBuf ulMpuAddr=%x ulNumBytes=%x, "
+				"vm_start=%lx, vm_end=%lx, vm_flags=%lx\n",
+				ulMpuAddr, ulNumBytes, vma->vm_start,
+				vma->vm_end, vma->vm_flags);
+	}
+	if (!vma) {
+		pr_err("%s: Failed to get VMA region for 0x%x (%d)\n",
+					__func__, ulMpuAddr, ulNumBytes);
+		status = DSP_EINVALIDARG;
+		up_read(&mm->mmap_sem);
+		goto func_cont;
+	}
+
+	if (vma->vm_flags & VM_IO) {
+		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
+		mpuAddr = ulMpuAddr;
+
+		/* Get the physical addresses for user buffer */
+		for (pgI = 0; pgI < numUsrPgs; pgI++) {
+			pa = user_va2pa(mm, mpuAddr);
+			if (!pa) {
+				status = DSP_EFAIL;
+				pr_err("DSPBRIDGE: VM_IO mapping physical"
+						"address is invalid\n");
+				break;
+			}
+			if (pfn_valid(__phys_to_pfn(pa))) {
+				pg = phys_to_page(pa);
+				get_page(pg);
+				if (page_count(pg) < 1) {
+					pr_err("Bad page in VM_IO buffer\n");
+					bad_page_dump(pa, pg);
+				}
+			}
+			status = PteSet(pDevContext->pPtAttrs, pa,
+					va, HW_PAGE_SIZE_4KB, &hwAttrs);
+			if (DSP_FAILED(status))
+				break;
+
+			va += HW_PAGE_SIZE_4KB;
+			mpuAddr += HW_PAGE_SIZE_4KB;
+			pa += HW_PAGE_SIZE_4KB;
+		}
+	} else {
+		numUsrPgs =  ulNumBytes / PG_SIZE_4K;
+		if (vma->vm_flags & (VM_WRITE | VM_MAYWRITE))
+			write = 1;
+
+		for (pgI = 0; pgI < numUsrPgs; pgI++) {
+			pgNum = get_user_pages(curr_task, mm, ulMpuAddr, 1,
+						write, 1, &mappedPage, NULL);
+			if (pgNum > 0) {
+				if (page_count(mappedPage) < 1) {
+					pr_err("Bad page count after doing"
+							"get_user_pages on"
+							"user buffer\n");
+					bad_page_dump(page_to_phys(mappedPage),
+								mappedPage);
+				}
+				status = PteSet(pDevContext->pPtAttrs,
+					page_to_phys(mappedPage), va,
+					HW_PAGE_SIZE_4KB, &hwAttrs);
+				if (DSP_FAILED(status))
+					break;
+
+				va += HW_PAGE_SIZE_4KB;
+				ulMpuAddr += HW_PAGE_SIZE_4KB;
+			} else {
+				pr_err("DSPBRIDGE: get_user_pages FAILED,"
+						"MPU addr = 0x%x,"
+						"vma->vm_flags = 0x%lx,"
+						"get_user_pages Err"
+						"Value = %d, Buffer"
+						"size=0x%x\n", ulMpuAddr,
+						vma->vm_flags, pgNum,
+						ulNumBytes);
+				status = DSP_EFAIL;
+				break;
+			}
+		}
+	}
+	up_read(&mm->mmap_sem);
+func_cont:
+	/* Don't propogate Linux or HW status to upper layers */
+	if (DSP_SUCCEEDED(status)) {
+		status = DSP_SOK;
+	} else {
+		/*
+		 * Roll out the mapped pages incase it failed in middle of
+		 * mapping
+		 */
+		if (pgI) {
+			WMD_BRD_MemUnMap(pDevContext, ulVirtAddr,
+						(pgI * PG_SIZE_4K));
+		}
+		status = DSP_EFAIL;
+	}
+	/*
+	 * In any case, flush the TLB
+	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * repetition while mapping non-contiguous physical regions of a virtual
+	 * region
+	 */
+	flush_all(pDevContext);
+	dev_dbg(bridge, "%s status %x\n", __func__, status);
+	return status;
+}
+
+/*
+ *  ======== WMD_BRD_MemUnMap ========
+ *      Invalidate the PTEs for the DSP VA block to be unmapped.
+ *
+ *      PTEs of a mapped memory block are contiguous in any page table
+ *      So, instead of looking up the PTE address for every 4K block,
+ *      we clear consecutive PTEs until we unmap all the bytes
+ */
+static DSP_STATUS WMD_BRD_MemUnMap(struct WMD_DEV_CONTEXT *hDevContext,
+				   u32 ulVirtAddr, u32 ulNumBytes)
+{
+	u32 L1BaseVa;
+	u32 L2BaseVa;
+	u32 L2BasePa;
+	u32 L2PageNum;
+	u32 pteVal;
+	u32 pteSize;
+	u32 pteCount;
+	u32 pteAddrL1;
+	u32 pteAddrL2 = 0;
+	u32 remBytes;
+	u32 remBytesL2;
+	u32 vaCurr;
+	struct page *pg = NULL;
+	DSP_STATUS status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	struct PgTableAttrs *pt = pDevContext->pPtAttrs;
+	u32 temp;
+	u32 pAddr;
+	u32 numof4KPages = 0;
+
+	vaCurr = ulVirtAddr;
+	remBytes = ulNumBytes;
+	remBytesL2 = 0;
+	L1BaseVa = pt->L1BaseVa;
+	pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
+	dev_dbg(bridge, "%s hDevContext %p, va %x, NumBytes %x L1BaseVa %x, "
+			"pteAddrL1 %x\n", __func__, hDevContext, ulVirtAddr,
+			ulNumBytes, L1BaseVa, pteAddrL1);
+
+	while (remBytes && (DSP_SUCCEEDED(status))) {
+		u32 vaCurrOrig = vaCurr;
+		/* Find whether the L1 PTE points to a valid L2 PT */
+		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, vaCurr);
+		pteVal = *(u32 *)pteAddrL1;
+		pteSize = HW_MMU_PteSizeL1(pteVal);
+
+		if (pteSize != HW_MMU_COARSE_PAGE_SIZE)
+			goto skip_coarse_page;
+
+		/*
+		 * Get the L2 PA from the L1 PTE, and find
+		 * corresponding L2 VA
+		 */
+		L2BasePa = HW_MMU_PteCoarseL1(pteVal);
+		L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
+		L2PageNum = (L2BasePa - pt->L2BasePa) / HW_MMU_COARSE_PAGE_SIZE;
+		/*
+		 * Find the L2 PTE address from which we will start
+		 * clearing, the number of PTEs to be cleared on this
+		 * page, and the size of VA space that needs to be
+		 * cleared on this L2 page
+		 */
+		pteAddrL2 = HW_MMU_PteAddrL2(L2BaseVa, vaCurr);
+		pteCount = pteAddrL2 & (HW_MMU_COARSE_PAGE_SIZE - 1);
+		pteCount = (HW_MMU_COARSE_PAGE_SIZE - pteCount) / sizeof(u32);
+		if (remBytes < (pteCount * PG_SIZE_4K))
+			pteCount = remBytes / PG_SIZE_4K;
+		remBytesL2 = pteCount * PG_SIZE_4K;
+
+		/*
+		 * Unmap the VA space on this L2 PT. A quicker way
+		 * would be to clear pteCount entries starting from
+		 * pteAddrL2. However, below code checks that we don't
+		 * clear invalid entries or less than 64KB for a 64KB
+		 * entry. Similar checking is done for L1 PTEs too
+		 * below
+		 */
+		while (remBytesL2 && (DSP_SUCCEEDED(status))) {
+			pteVal = *(u32 *)pteAddrL2;
+			pteSize = HW_MMU_PteSizeL2(pteVal);
+			/* vaCurr aligned to pteSize? */
+			if (pteSize == 0 || remBytesL2 < pteSize ||
+						vaCurr & (pteSize - 1)) {
+				status = DSP_EFAIL;
+				break;
+			}
+
+			/* Collect Physical addresses from VA */
+			pAddr = (pteVal & ~(pteSize - 1));
+			if (pteSize == HW_PAGE_SIZE_64KB)
+				numof4KPages = 16;
+			else
+				numof4KPages = 1;
+			temp = 0;
+			while (temp++ < numof4KPages) {
+				if (!pfn_valid(__phys_to_pfn(pAddr))) {
+					pAddr += HW_PAGE_SIZE_4KB;
+					continue;
+				}
+				pg = phys_to_page(pAddr);
+				if (page_count(pg) < 1) {
+					pr_info("DSPBRIDGE: UNMAP function: "
+						"COUNT 0 FOR PA 0x%x, size = "
+						"0x%x\n", pAddr, ulNumBytes);
+					bad_page_dump(pAddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
+				}
+				pAddr += HW_PAGE_SIZE_4KB;
+			}
+			if (HW_MMU_PteClear(pteAddrL2, vaCurr, pteSize)
+							 == RET_FAIL) {
+				status = DSP_EFAIL;
+				goto EXIT_LOOP;
+			}
+
+			status = DSP_SOK;
+			remBytesL2 -= pteSize;
+			vaCurr += pteSize;
+			pteAddrL2 += (pteSize >> 12) * sizeof(u32);
+		}
+		SYNC_EnterCS(pt->hCSObj);
+		if (remBytesL2 == 0) {
+			pt->pgInfo[L2PageNum].numEntries -= pteCount;
+			if (pt->pgInfo[L2PageNum].numEntries == 0) {
+				/*
+				 * Clear the L1 PTE pointing to the L2 PT
+				 */
+				if (HW_MMU_PteClear(L1BaseVa, vaCurrOrig,
+					    HW_MMU_COARSE_PAGE_SIZE) == RET_OK)
+					status = DSP_SOK;
+				else {
+					status = DSP_EFAIL;
+					SYNC_LeaveCS(pt->hCSObj);
+					goto EXIT_LOOP;
+				}
+			}
+			remBytes -= pteCount * PG_SIZE_4K;
+		} else
+			status = DSP_EFAIL;
+
+		SYNC_LeaveCS(pt->hCSObj);
+		continue;
+skip_coarse_page:
+		/* vaCurr aligned to pteSize? */
+		/* pteSize = 1 MB or 16 MB */
+		if (pteSize == 0 || remBytes < pteSize ||
+						 vaCurr & (pteSize - 1)) {
+			status = DSP_EFAIL;
+			break;
+		}
+
+		if (pteSize == HW_PAGE_SIZE_1MB)
+			numof4KPages = 256;
+		else
+			numof4KPages = 4096;
+		temp = 0;
+		/* Collect Physical addresses from VA */
+		pAddr = (pteVal & ~(pteSize - 1));
+		while (temp++ < numof4KPages) {
+			if (pfn_valid(__phys_to_pfn(pAddr))) {
+				pg = phys_to_page(pAddr);
+				if (page_count(pg) < 1) {
+					pr_info("DSPBRIDGE: UNMAP function: "
+						"COUNT 0 FOR PA 0x%x, size = "
+						"0x%x\n", pAddr, ulNumBytes);
+					bad_page_dump(pAddr, pg);
+				} else {
+					SetPageDirty(pg);
+					page_cache_release(pg);
+				}
+			}
+			pAddr += HW_PAGE_SIZE_4KB;
+		}
+		if (HW_MMU_PteClear(L1BaseVa, vaCurr, pteSize) == RET_OK) {
+			status = DSP_SOK;
+			remBytes -= pteSize;
+			vaCurr += pteSize;
+		} else {
+			status = DSP_EFAIL;
+			goto EXIT_LOOP;
+		}
+	}
+	/*
+	 * It is better to flush the TLB here, so that any stale old entries
+	 * get flushed
+	 */
+EXIT_LOOP:
+	flush_all(pDevContext);
+	dev_dbg(bridge, "%s: vaCurr %x, pteAddrL1 %x pteAddrL2 %x remBytes %x,"
+		" remBytesL2 %x status %x\n", __func__, vaCurr, pteAddrL1,
+		pteAddrL2, remBytes, remBytesL2, status);
+	return status;
+}
+
+/*
+ *  ======== user_va2pa ========
+ *  Purpose:
+ *      This function walks through the Linux page tables to convert a userland
+ *      virtual address to physical address
+ */
+static u32 user_va2pa(struct mm_struct *mm, u32 address)
+{
+	pgd_t *pgd;
+	pmd_t *pmd;
+	pte_t *ptep, pte;
+
+	pgd = pgd_offset(mm, address);
+	if (!(pgd_none(*pgd) || pgd_bad(*pgd))) {
+		pmd = pmd_offset(pgd, address);
+		if (!(pmd_none(*pmd) || pmd_bad(*pmd))) {
+			ptep = pte_offset_map(pmd, address);
+			if (ptep) {
+				pte = *ptep;
+				if (pte_present(pte))
+					return pte & PAGE_MASK;
+			}
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ *  ======== PteUpdate ========
+ *      This function calculates the optimum page-aligned addresses and sizes
+ *      Caller must pass page-aligned values
+ */
+static DSP_STATUS PteUpdate(struct WMD_DEV_CONTEXT *hDevContext, u32 pa,
+			    u32 va, u32 size,
+			    struct HW_MMUMapAttrs_t *mapAttrs)
+{
+	u32 i;
+	u32 allBits;
+	u32 paCurr = pa;
+	u32 vaCurr = va;
+	u32 numBytes = size;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	DSP_STATUS status = DSP_SOK;
+	u32 pgSize[] = { HW_PAGE_SIZE_16MB, HW_PAGE_SIZE_1MB,
+			   HW_PAGE_SIZE_64KB, HW_PAGE_SIZE_4KB };
+
+	while (numBytes && DSP_SUCCEEDED(status)) {
+		/* To find the max. page size with which both PA & VA are
+		 * aligned */
+		allBits = paCurr | vaCurr;
+
+		for (i = 0; i < 4; i++) {
+			if ((numBytes >= pgSize[i]) && ((allBits &
+			   (pgSize[i] - 1)) == 0)) {
+				status = PteSet(pDevContext->pPtAttrs, paCurr,
+						vaCurr, pgSize[i], mapAttrs);
+				paCurr += pgSize[i];
+				vaCurr += pgSize[i];
+				numBytes -= pgSize[i];
+				 /* Don't try smaller sizes. Hopefully we have
+				 * reached an address aligned to a bigger page
+				 * size */
+				break;
+			}
+		}
+	}
+
+	return status;
+}
+
+/*
+ *  ======== PteSet ========
+ *      This function calculates PTE address (MPU virtual) to be updated
+ *      It also manages the L2 page tables
+ */
+static DSP_STATUS PteSet(struct PgTableAttrs *pt, u32 pa, u32 va,
+			 u32 size, struct HW_MMUMapAttrs_t *attrs)
+{
+	u32 i;
+	u32 pteVal;
+	u32 pteAddrL1;
+	u32 pteSize;
+	u32 pgTblVa;      /* Base address of the PT that will be updated */
+	u32 L1BaseVa;
+	/* Compiler warns that the next three variables might be used
+	 * uninitialized in this function. Doesn't seem so. Working around,
+	 * anyways.  */
+	u32 L2BaseVa = 0;
+	u32 L2BasePa = 0;
+	u32 L2PageNum = 0;
+	DSP_STATUS status = DSP_SOK;
+
+	L1BaseVa = pt->L1BaseVa;
+	pgTblVa = L1BaseVa;
+	if ((size == HW_PAGE_SIZE_64KB) || (size == HW_PAGE_SIZE_4KB)) {
+		/* Find whether the L1 PTE points to a valid L2 PT */
+		pteAddrL1 = HW_MMU_PteAddrL1(L1BaseVa, va);
+		if (pteAddrL1 <= (pt->L1BaseVa + pt->L1size)) {
+			pteVal = *(u32 *)pteAddrL1;
+			pteSize = HW_MMU_PteSizeL1(pteVal);
+		} else {
+			return DSP_EFAIL;
+		}
+		SYNC_EnterCS(pt->hCSObj);
+		if (pteSize == HW_MMU_COARSE_PAGE_SIZE) {
+			/* Get the L2 PA from the L1 PTE, and find
+			 * corresponding L2 VA */
+			L2BasePa = HW_MMU_PteCoarseL1(pteVal);
+			L2BaseVa = L2BasePa - pt->L2BasePa + pt->L2BaseVa;
+			L2PageNum = (L2BasePa - pt->L2BasePa) /
+				    HW_MMU_COARSE_PAGE_SIZE;
+		} else if (pteSize == 0) {
+			/* L1 PTE is invalid. Allocate a L2 PT and
+			 * point the L1 PTE to it */
+			/* Find a free L2 PT. */
+			for (i = 0; (i < pt->L2NumPages) &&
+			    (pt->pgInfo[i].numEntries != 0); i++)
+				;;
+			if (i < pt->L2NumPages) {
+				L2PageNum = i;
+				L2BasePa = pt->L2BasePa + (L2PageNum *
+					   HW_MMU_COARSE_PAGE_SIZE);
+				L2BaseVa = pt->L2BaseVa + (L2PageNum *
+					   HW_MMU_COARSE_PAGE_SIZE);
+				/* Endianness attributes are ignored for
+				 * HW_MMU_COARSE_PAGE_SIZE */
+				status = HW_MMU_PteSet(L1BaseVa, L2BasePa, va,
+					 HW_MMU_COARSE_PAGE_SIZE, attrs);
+			} else {
+				status = DSP_EMEMORY;
+			}
+		} else {
+			/* Found valid L1 PTE of another size.
+			 * Should not overwrite it. */
+			status = DSP_EFAIL;
+		}
+		if (DSP_SUCCEEDED(status)) {
+			pgTblVa = L2BaseVa;
+			if (size == HW_PAGE_SIZE_64KB)
+				pt->pgInfo[L2PageNum].numEntries += 16;
+			else
+				pt->pgInfo[L2PageNum].numEntries++;
+			dev_dbg(bridge, "PTE: L2 BaseVa %x, BasePa %x, PageNum "
+					"%x, numEntries %x\n", L2BaseVa,
+					L2BasePa, L2PageNum,
+					pt->pgInfo[L2PageNum].numEntries);
+		}
+		SYNC_LeaveCS(pt->hCSObj);
+	}
+	if (DSP_SUCCEEDED(status)) {
+		dev_dbg(bridge, "PTE: pgTblVa %x, pa %x, va %x, size %x\n",
+							pgTblVa, pa, va, size);
+		dev_dbg(bridge, "PTE: endianism %x, elementSize %x, "
+					"mixedSize %x\n", attrs->endianism,
+					attrs->elementSize, attrs->mixedSize);
+		status = HW_MMU_PteSet(pgTblVa, pa, va, size, attrs);
+	}
+
+	return status;
+}
+
+/* Memory map kernel VA -- memory allocated with vmalloc */
+static DSP_STATUS MemMapVmalloc(struct WMD_DEV_CONTEXT *pDevContext,
+				u32 ulMpuAddr, u32 ulVirtAddr, u32 ulNumBytes,
+				struct HW_MMUMapAttrs_t *hwAttrs)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct page *pPage[1];
+	u32 i;
+	u32 paCurr;
+	u32 paNext;
+	u32 vaCurr;
+	u32 sizeCurr;
+	u32 numPages;
+	u32 pa;
+	u32 numOf4KPages;
+	u32 temp = 0;
+
+	/*
+	 * Do Kernel va to pa translation.
+	 * Combine physically contiguous regions to reduce TLBs.
+	 * Pass the translated pa to PteUpdate.
+	 */
+	numPages = ulNumBytes / PAGE_SIZE; /* PAGE_SIZE = OS page size */
+	i = 0;
+	vaCurr = ulMpuAddr;
+	pPage[0] = vmalloc_to_page((void *)vaCurr);
+	paNext = page_to_phys(pPage[0]);
+	while (DSP_SUCCEEDED(status) && (i < numPages)) {
+		/*
+		 * Reuse paNext from the previous iteraion to avoid
+		 * an extra va2pa call
+		 */
+		paCurr = paNext;
+		sizeCurr = PAGE_SIZE;
+		/*
+		 * If the next page is physically contiguous,
+		 * map it with the current one by increasing
+		 * the size of the region to be mapped
+		 */
+		while (++i < numPages) {
+			pPage[0] = vmalloc_to_page((void *)(vaCurr + sizeCurr));
+			paNext = page_to_phys(pPage[0]);
+
+			if (paNext == (paCurr + sizeCurr))
+				sizeCurr += PAGE_SIZE;
+			else
+				break;
+
+		}
+		if (paNext == 0) {
+			status = DSP_EMEMORY;
+			break;
+		}
+		pa = paCurr;
+		numOf4KPages = sizeCurr / HW_PAGE_SIZE_4KB;
+		while (temp++ < numOf4KPages) {
+			get_page(phys_to_page(pa));
+			pa += HW_PAGE_SIZE_4KB;
+		}
+		status = PteUpdate(pDevContext, paCurr, ulVirtAddr +
+				  (vaCurr - ulMpuAddr), sizeCurr, hwAttrs);
+		vaCurr += sizeCurr;
+	}
+	/* Don't propogate Linux or HW status to upper layers */
+	if (DSP_SUCCEEDED(status))
+		status = DSP_SOK;
+	else
+		status = DSP_EFAIL;
+
+	/*
+	 * In any case, flush the TLB
+	 * This is called from here instead from PteUpdate to avoid unnecessary
+	 * repetition while mapping non-contiguous physical regions of a virtual
+	 * region
+	 */
+	flush_all(pDevContext);
+	dev_dbg(bridge, "%s status %x\n", __func__, status);
+	return status;
+}
+
+/*
+ *  ======== configureDspMmu ========
+ *      Make DSP MMU page table entries.
+ */
+void configureDspMmu(struct WMD_DEV_CONTEXT *pDevContext, u32 dataBasePhys,
+		    u32 dspBaseVirt, u32 sizeInBytes, s32 nEntryStart,
+		    enum HW_Endianism_t endianism,
+		    enum HW_ElementSize_t elemSize,
+		    enum HW_MMUMixedSize_t mixedSize)
+{
+	struct HW_MMUMapAttrs_t mapAttrs = { endianism, elemSize, mixedSize };
+
+	DBC_Require(sizeInBytes > 0);
+	dev_dbg(bridge, "%s: entry %x pa %x, va %x, bytes %x endianism %x, "
+			"elemSize %x, mixedSize %x", __func__, nEntryStart,
+			dataBasePhys, dspBaseVirt, sizeInBytes, endianism,
+			elemSize, mixedSize);
+
+	HW_MMU_TLBAdd(pDevContext->dwDSPMmuBase, dataBasePhys,
+				dspBaseVirt, sizeInBytes, nEntryStart,
+				&mapAttrs, HW_SET, HW_SET);
+}
+
+/*
+ *  ======== WaitForStart ========
+ *      Wait for the singal from DSP that it has started, or time out.
+ */
+bool WaitForStart(struct WMD_DEV_CONTEXT *pDevContext, u32 dwSyncAddr)
+{
+	u16 timeout = TIHELEN_ACKTIMEOUT;
+
+	/*  Wait for response from board */
+	while (*((volatile u16 *)dwSyncAddr) && --timeout)
+		udelay(10);
+
+	/*  If timed out: return FALSE */
+	if (!timeout) {
+		pr_err("%s: Timed out waiting DSP to Start\n", __func__);
+		return FALSE;
+	}
+	return TRUE;
+}
diff --git a/drivers/dsp/bridge/wmd/tiomap3430_pwr.c b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
new file mode 100644
index 0000000..13437ed
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/tiomap3430_pwr.c
@@ -0,0 +1,715 @@
+/*
+ * tiomap_pwr.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation of DSP wake/sleep routines.
+ *
+ * Copyright (C) 2007-2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+#include <dspbridge/cfg.h>
+#include <dspbridge/drv.h>
+#include <dspbridge/io_sm.h>
+#include <dspbridge/chnl_sm.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/brddefs.h>
+#include <dspbridge/dev.h>
+#include <dspbridge/iodefs.h>
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_dspssC64P.h>
+#include <hw_prcm.h>
+#include <hw_mmu.h>
+
+#include <dspbridge/pwr_sh.h>
+
+/*  ----------------------------------- Mini Driver */
+#include <dspbridge/wmddeh.h>
+
+/*  ----------------------------------- specific to this file */
+#include "_tiomap.h"
+#include "_tiomap_pwr.h"
+#include "_tiomap_util.h"
+#include <mach-omap2/prm-regbits-34xx.h>
+#include <mach-omap2/cm-regbits-34xx.h>
+
+#ifdef CONFIG_PM
+extern s32 dsp_test_sleepstate;
+#endif
+extern struct MAILBOX_CONTEXT mboxsetting;
+
+/*
+ *  ======== handle_constraints_set ========
+ *  	Sets new DSP constraint
+ */
+DSP_STATUS handle_constraints_set(struct WMD_DEV_CONTEXT *pDevContext,
+				  IN void *pArgs)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	u32 *pConstraintVal;
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
+
+	pConstraintVal = (u32 *)(pArgs);
+	/* Read the target value requested by DSP  */
+	dev_dbg(bridge, "OPP: %s opp requested = 0x%x\n", __func__,
+						(u32)*(pConstraintVal+1));
+
+	/* Set the new opp value */
+	if (pdata->dsp_set_min_opp)
+		(*pdata->dsp_set_min_opp)((u32)*(pConstraintVal+1));
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
+	return DSP_SOK;
+}
+
+/*
+ *  ======== handle_hibernation_fromDSP ========
+ *  	Handle Hibernation requested from DSP
+ */
+DSP_STATUS handle_hibernation_fromDSP(struct WMD_DEV_CONTEXT *pDevContext)
+{
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_PM
+	u16 timeout = PWRSTST_TIMEOUT / 10;
+	struct CFG_HOSTRES resources;
+	enum HW_PwrState_t pwrState;
+#ifdef CONFIG_BRIDGE_DVFS
+	u32 opplevel;
+	struct IO_MGR *hIOMgr;
+	struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+#endif
+
+	status = CFG_GetHostResources(
+		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return status;
+
+	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+			    &pwrState);
+	/* Wait for DSP to move into OFF state */
+	while ((pwrState != HW_PWR_STATE_OFF) && --timeout) {
+		if (msleep_interruptible(10)) {
+			pr_err("Waiting for DSP OFF mode interrupted\n");
+			return DSP_EFAIL;
+		}
+		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+				    &pwrState);
+	}
+	if (timeout == 0) {
+		pr_err("%s: Timed out waiting for DSP off mode\n", __func__);
+		status = WMD_E_TIMEOUT;
+		return status;
+	} else {
+
+		/* Save mailbox settings */
+		status = HW_MBOX_saveSettings(resources.dwMboxBase);
+
+		/* Turn off DSP Peripheral clocks and DSP Load monitor timer */
+		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
+
+		if (DSP_SUCCEEDED(status)) {
+			/* Update the Bridger Driver state */
+			pDevContext->dwBrdState = BRD_DSP_HIBERNATION;
+#ifdef CONFIG_BRIDGE_DVFS
+			status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
+			if (DSP_FAILED(status))
+				return status;
+			IO_SHMsetting(hIOMgr, SHM_GETOPP, &opplevel);
+
+			/*
+			 * Set the OPP to low level before moving to OFF
+			 * mode
+			 */
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+			status = DSP_SOK;
+#endif /* CONFIG_BRIDGE_DVFS */
+		}
+	}
+#endif
+	return status;
+}
+
+/*
+ *  ======== SleepDSP ========
+ *  	Put DSP in low power consuming state.
+ */
+DSP_STATUS SleepDSP(struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwCmd,
+		   IN void *pArgs)
+{
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_PM
+	struct CFG_HOSTRES resources;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
+	struct DEH_MGR *hDehMgr;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+	u16 timeout = PWRSTST_TIMEOUT / 10;
+	enum HW_PwrState_t pwrState, targetPwrState;
+
+	/* Check if sleep code is valid */
+	if ((dwCmd != PWR_DEEPSLEEP) && (dwCmd != PWR_EMERGENCYDEEPSLEEP))
+		return DSP_EINVALIDARG;
+
+	status = CFG_GetHostResources(
+		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return status;
+
+	switch (pDevContext->dwBrdState) {
+	case BRD_RUNNING:
+		status = HW_MBOX_saveSettings(resources.dwMboxBase);
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+			CHNLSM_InterruptDSP2(pDevContext,
+					     MBX_PM_DSPHIBERNATE);
+			dev_dbg(bridge, "PM: %s - sent hibernate cmd to DSP\n",
+								__func__);
+			targetPwrState = HW_PWR_STATE_OFF;
+		} else {
+			CHNLSM_InterruptDSP2(pDevContext,
+					     MBX_PM_DSPRETENTION);
+			targetPwrState = HW_PWR_STATE_RET;
+		}
+		break;
+	case BRD_RETENTION:
+		status = HW_MBOX_saveSettings(resources.dwMboxBase);
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF) {
+			CHNLSM_InterruptDSP2(pDevContext,
+					     MBX_PM_DSPHIBERNATE);
+			targetPwrState = HW_PWR_STATE_OFF;
+		} else
+			return DSP_SOK;
+		break;
+	case BRD_HIBERNATION:
+	case BRD_DSP_HIBERNATION:
+		/* Already in Hibernation, so just return */
+		dev_dbg(bridge, "PM: %s - DSP already in hibernation\n",
+								__func__);
+		return DSP_SOK;
+	case BRD_STOPPED:
+		dev_dbg(bridge, "PM: %s - Board in STOP state\n", __func__);
+		return DSP_SALREADYASLEEP;
+	default:
+		dev_dbg(bridge, "PM: %s - Bridge in Illegal state\n", __func__);
+			return DSP_EFAIL;
+	}
+
+	/* Get the PRCM DSP power domain status */
+	HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+			&pwrState);
+
+	/* Wait for DSP to move into target power state */
+	while ((pwrState != targetPwrState) && --timeout) {
+		if (msleep_interruptible(10)) {
+			pr_err("Waiting for DSP to Suspend interrupted\n");
+			return DSP_EFAIL;
+		}
+		HW_PWR_IVA2StateGet(resources.dwPrmBase, HW_PWR_DOMAIN_DSP,
+				    &pwrState);
+	}
+
+	if (!timeout) {
+		pr_err("%s: Timed out waiting for DSP off mode, state %x\n",
+							__func__, pwrState);
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
+		DEV_GetDehMgr(pDevContext->hDevObject, &hDehMgr);
+		WMD_DEH_Notify(hDehMgr, DSP_PWRERROR, 0);
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+		return WMD_E_TIMEOUT;
+	} else {
+		/* Update the Bridger Driver state */
+		if (dsp_test_sleepstate == HW_PWR_STATE_OFF)
+			pDevContext->dwBrdState = BRD_HIBERNATION;
+		else
+			pDevContext->dwBrdState = BRD_RETENTION;
+
+		/* Turn off DSP Peripheral clocks  */
+		status = DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		if (DSP_FAILED(status)) {
+			return status;
+		}
+#ifdef CONFIG_BRIDGE_DVFS
+		else if (targetPwrState == HW_PWR_STATE_OFF) {
+			struct dspbridge_platform_data *pdata =
+				omap_dspbridge_dev->dev.platform_data;
+			/*
+			 * Set the OPP to low level before moving to OFF mode
+			 */
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP1);
+		}
+#endif /* CONFIG_BRIDGE_DVFS */
+	}
+#endif /* CONFIG_PM */
+	return status;
+}
+
+
+/*
+ *  ======== WakeDSP ========
+ *  	Wake up DSP from sleep.
+ */
+DSP_STATUS WakeDSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+{
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_PM
+
+	/* Check the BRD/WMD state, if it is not 'SLEEP' then return failure */
+	if (pDevContext->dwBrdState == BRD_RUNNING ||
+	    pDevContext->dwBrdState == BRD_STOPPED) {
+		/* The Device is in 'RET' or 'OFF' state and WMD state is not
+		 * 'SLEEP', this means state inconsistency, so return  */
+		return DSP_SOK;
+	}
+
+	/* Send a wakeup message to DSP */
+	CHNLSM_InterruptDSP2(pDevContext, MBX_PM_DSPWAKEUP);
+
+	/* Set the device state to RUNNIG */
+	pDevContext->dwBrdState = BRD_RUNNING;
+#endif /* CONFIG_PM */
+	return status;
+}
+
+/*
+ *  ======== DSPPeripheralClkCtrl ========
+ *  	Enable/Disable the DSP peripheral clocks as needed..
+ */
+DSP_STATUS DSPPeripheralClkCtrl(struct WMD_DEV_CONTEXT *pDevContext,
+				IN void *pArgs)
+{
+	u32 extClk = 0;
+	u32 extClkId = 0;
+	u32 extClkCmd = 0;
+	u32 clkIdIndex = MBX_PM_MAX_RESOURCES;
+	u32 tmpIndex;
+	u32 dspPerClksBefore;
+	DSP_STATUS status = DSP_SOK;
+	DSP_STATUS status1 = DSP_SOK;
+	struct CFG_HOSTRES resources;
+	u32 value;
+
+	dspPerClksBefore = pDevContext->uDspPerClks;
+
+	extClk = (u32)*((u32 *)pArgs);
+
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
+	extClkId = extClk & MBX_PM_CLK_IDMASK;
+
+	/* process the power message -- TODO, keep it in a separate function */
+	for (tmpIndex = 0; tmpIndex < MBX_PM_MAX_RESOURCES; tmpIndex++) {
+		if (extClkId == BPWR_CLKID[tmpIndex]) {
+			clkIdIndex = tmpIndex;
+			break;
+		}
+	}
+	/* TODO -- Assert may be a too hard restriction here.. May be we should
+	 * just return with failure when the CLK ID does not match */
+	/* DBC_Assert(clkIdIndex < MBX_PM_MAX_RESOURCES);*/
+	if (clkIdIndex == MBX_PM_MAX_RESOURCES) {
+		/* return with a more meaningfull error code */
+		return DSP_EFAIL;
+	}
+	extClkCmd = (extClk >> MBX_PM_CLK_CMDSHIFT) & MBX_PM_CLK_CMDMASK;
+	switch (extClkCmd) {
+	case BPWR_DisableClock:
+		/* Call BP to disable the needed clock */
+		status1 = CLK_Disable(BPWR_Clks[clkIdIndex].intClk);
+		status = CLK_Disable(BPWR_Clks[clkIdIndex].funClk);
+		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+			/* clear MCBSP1_CLKS, on McBSP1 OFF */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value &= ~(1 << 2);
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			/* clear MCBSP2_CLKS, on McBSP2 OFF */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value &= ~(1 << 6);
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		}
+		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, false);
+		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
+			(pDevContext->uDspPerClks) &=
+				(~((u32) (1 << clkIdIndex)));
+		}
+		break;
+	case BPWR_EnableClock:
+		status1 = CLK_Enable(BPWR_Clks[clkIdIndex].intClk);
+		status = CLK_Enable(BPWR_Clks[clkIdIndex].funClk);
+		if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP1) {
+			/* set MCBSP1_CLKS, on McBSP1 ON */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value |= 1 << 2;
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		} else if (BPWR_CLKID[clkIdIndex] == BPWR_MCBSP2) {
+			/* set MCBSP2_CLKS, on McBSP2 ON */
+			value = __raw_readl(resources.dwSysCtrlBase + 0x274);
+			value |= 1 << 6;
+			__raw_writel(value, resources.dwSysCtrlBase + 0x274);
+		}
+		DSPClkWakeupEventCtrl(BPWR_Clks[clkIdIndex].clkId, true);
+		if ((DSP_SUCCEEDED(status)) && (DSP_SUCCEEDED(status1))) {
+			(pDevContext->uDspPerClks) |= (1 << clkIdIndex);
+		}
+		break;
+	default:
+		dev_dbg(bridge, "%s: Unsupported CMD\n", __func__);
+		/* unsupported cmd */
+		/* TODO -- provide support for AUTOIDLE Enable/Disable
+		 * commands */
+	}
+	return status;
+}
+
+/*
+ *  ========PreScale_DSP========
+ *  Sends prescale notification to DSP
+ *
+ */
+DSP_STATUS PreScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	u32 level;
+	u32 voltage_domain;
+
+	voltage_domain = *((u32 *)pArgs);
+	level = *((u32 *)pArgs + 1);
+
+	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
+					__func__, voltage_domain, level);
+	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
+			(pDevContext->dwBrdState == BRD_RETENTION) ||
+			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+		dev_dbg(bridge, "OPP: %s IVA in sleep. No message to DSP\n");
+		return DSP_SOK;
+	} else if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+		/* Send a prenotificatio to DSP */
+		dev_dbg(bridge, "OPP: %s sent notification to DSP\n", __func__);
+		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_SETPOINT_PRENOTIFY);
+		return DSP_SOK;
+	} else {
+		return DSP_EFAIL;
+	}
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
+	return DSP_SOK;
+}
+
+/*
+ *  ========PostScale_DSP========
+ *  Sends postscale notification to DSP
+ *
+ */
+DSP_STATUS PostScale_DSP(struct WMD_DEV_CONTEXT *pDevContext, IN void *pArgs)
+{
+	DSP_STATUS status = DSP_SOK;
+#ifdef CONFIG_BRIDGE_DVFS
+	u32 level;
+	u32 voltage_domain;
+	struct IO_MGR *hIOMgr;
+
+	status = DEV_GetIOMgr(pDevContext->hDevObject, &hIOMgr);
+	if (!hIOMgr)
+		return DSP_EHANDLE;
+
+	voltage_domain = *((u32 *)pArgs);
+	level = *((u32 *)pArgs + 1);
+	dev_dbg(bridge, "OPP: %s voltage_domain = %x, level = 0x%x\n",
+					__func__, voltage_domain, level);
+	if ((pDevContext->dwBrdState == BRD_HIBERNATION) ||
+			(pDevContext->dwBrdState == BRD_RETENTION) ||
+			(pDevContext->dwBrdState == BRD_DSP_HIBERNATION)) {
+		/* Update the OPP value in shared memory */
+		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
+		dev_dbg(bridge, "OPP: %s IVA in sleep. Wrote to SHM\n",
+								__func__);
+	} else  if ((pDevContext->dwBrdState == BRD_RUNNING)) {
+		/* Update the OPP value in shared memory */
+		IO_SHMsetting(hIOMgr, SHM_CURROPP, &level);
+		/* Send a post notification to DSP */
+		CHNLSM_InterruptDSP2(pDevContext, MBX_PM_SETPOINT_POSTNOTIFY);
+		dev_dbg(bridge, "OPP: %s wrote to SHM. Sent post notification "
+							"to DSP\n", __func__);
+	} else {
+		status = DSP_EFAIL;
+	}
+#endif /* #ifdef CONFIG_BRIDGE_DVFS */
+	return status;
+}
+
+/*
+ *  ========DSP_PeripheralClocks_Disable========
+ *  Disables all the peripheral clocks that were requested by DSP
+ */
+DSP_STATUS DSP_PeripheralClocks_Disable(struct WMD_DEV_CONTEXT *pDevContext,
+					IN void *pArgs)
+{
+	u32 clkIdx;
+	DSP_STATUS status = DSP_SOK;
+	struct CFG_HOSTRES resources;
+	u32 value;
+
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+
+	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
+		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+			/* Disables the interface clock of the peripheral */
+			status = CLK_Disable(BPWR_Clks[clkIdx].intClk);
+			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+				/* clear MCBSP1_CLKS, on McBSP1 OFF */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value &= ~(1 << 2);
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				/* clear MCBSP2_CLKS, on McBSP2 OFF */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value &= ~(1 << 6);
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			}
+
+			/* Disables the functional clock of the periphearl */
+			status = CLK_Disable(BPWR_Clks[clkIdx].funClk);
+		}
+	}
+	return status;
+}
+
+/*
+ *  ========DSP_PeripheralClocks_Enable========
+ *  Enables all the peripheral clocks that were requested by DSP
+ */
+DSP_STATUS DSP_PeripheralClocks_Enable(struct WMD_DEV_CONTEXT *pDevContext,
+				      IN void *pArgs)
+{
+	u32 clkIdx;
+	DSP_STATUS int_clk_status = DSP_EFAIL, fun_clk_status = DSP_EFAIL;
+	struct CFG_HOSTRES resources;
+	u32 value;
+
+	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+
+	for (clkIdx = 0; clkIdx < MBX_PM_MAX_RESOURCES; clkIdx++) {
+		if (((pDevContext->uDspPerClks) >> clkIdx) & 0x01) {
+			/* Enable the interface clock of the peripheral */
+			int_clk_status = CLK_Enable(BPWR_Clks[clkIdx].intClk);
+			if (BPWR_CLKID[clkIdx] == BPWR_MCBSP1) {
+				/* set MCBSP1_CLKS, on McBSP1 ON */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value |= 1 << 2;
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			} else if (BPWR_CLKID[clkIdx] == BPWR_MCBSP2) {
+				/* set MCBSP2_CLKS, on McBSP2 ON */
+				value = __raw_readl(resources.dwSysCtrlBase
+								+ 0x274);
+				value |= 1 << 6;
+				__raw_writel(value, resources.dwSysCtrlBase
+								+ 0x274);
+			}
+			/* Enable the functional clock of the periphearl */
+			fun_clk_status = CLK_Enable(BPWR_Clks[clkIdx].funClk);
+		}
+	}
+	if ((int_clk_status | fun_clk_status) != DSP_SOK)
+		return DSP_EFAIL;
+	return DSP_SOK;
+}
+
+void DSPClkWakeupEventCtrl(u32 ClkId, bool enable)
+{
+	struct CFG_HOSTRES resources;
+	DSP_STATUS status = DSP_SOK;
+	u32 iva2_grpsel;
+	u32 mpu_grpsel;
+
+	status = CFG_GetHostResources(
+		(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return;
+
+	switch (ClkId) {
+	case BPWR_GPTimer5:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT5;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT5;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT5;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT5;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+				= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+				= mpu_grpsel;
+	break;
+	case BPWR_GPTimer6:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT6;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT6;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT6;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT6;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_GPTimer7:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT7;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT7;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT7;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT7;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_GPTimer8:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_GPT8;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_GPT8;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_GPT8;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_GPT8;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP1:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP1;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP1;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP1;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP2:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP2;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP2;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP2;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP3:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP3;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP3;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP3;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP4:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwPerPmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP4;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP4;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP4;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwPerPmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	case BPWR_MCBSP5:
+		iva2_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA8));
+		mpu_grpsel = (u32) *((REG_UWORD32 *)
+				((u32) (resources.dwCorePmBase) + 0xA4));
+		if (enable) {
+			iva2_grpsel |= OMAP3430_GRPSEL_MCBSP5;
+			mpu_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
+		} else {
+			mpu_grpsel |= OMAP3430_GRPSEL_MCBSP5;
+			iva2_grpsel &= ~OMAP3430_GRPSEL_MCBSP5;
+		}
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA8))
+							= iva2_grpsel;
+		*((REG_UWORD32 *) ((u32) (resources.dwCorePmBase) + 0xA4))
+							= mpu_grpsel;
+	break;
+	}
+}
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.c b/drivers/dsp/bridge/wmd/tiomap_io.c
new file mode 100644
index 0000000..d107a3c
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/tiomap_io.c
@@ -0,0 +1,373 @@
+/*
+ * tiomap_io.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implementation for the io read/write routines.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/drv.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/mem.h>
+#include <dspbridge/cfg.h>
+
+/*  ----------------------------------- specific to this file */
+#include "_tiomap.h"
+#include "_tiomap_pwr.h"
+#include "tiomap_io.h"
+
+static u32 ulExtBase;
+static u32 ulExtEnd;
+
+static u32 ulShm0End;
+static u32 ulDynExtBase;
+static u32 ulTraceSecBeg;
+static u32 ulTraceSecEnd;
+static u32 ulShmBaseVirt;
+
+bool bSymbolsReloaded = true;
+
+/*
+ *  ======== ReadExtDspData ========
+ *      Copies DSP external memory buffers to the host side buffers.
+ */
+DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *hDevContext,
+			 OUT u8 *pbHostBuf, u32 dwDSPAddr,
+			 u32 ulNumBytes, u32 ulMemType)
+{
+	DSP_STATUS	status = DSP_SOK;
+	struct WMD_DEV_CONTEXT *pDevContext = hDevContext;
+	u32	offset;
+	u32	ulTLBBaseVirt = 0;
+	u32	ulShmOffsetVirt = 0;
+	u32	dwExtProgVirtMem;
+	u32	dwBaseAddr = pDevContext->dwDspExtBaseAddr;
+	bool	bTraceRead = false;
+
+	if (!ulShmBaseVirt) {
+		status = DEV_GetSymbol(pDevContext->hDevObject,
+		SHMBASENAME, &ulShmBaseVirt);
+	}
+	DBC_Assert(ulShmBaseVirt != 0);
+
+	/* Check if it is a read of Trace section */
+	if (DSP_SUCCEEDED(status) && !ulTraceSecBeg) {
+		status = DEV_GetSymbol(pDevContext->hDevObject,
+		DSP_TRACESEC_BEG, &ulTraceSecBeg);
+	}
+	DBC_Assert(ulTraceSecBeg != 0);
+
+	if (DSP_SUCCEEDED(status) && !ulTraceSecEnd) {
+		status = DEV_GetSymbol(pDevContext->hDevObject,
+		DSP_TRACESEC_END, &ulTraceSecEnd);
+	}
+	DBC_Assert(ulTraceSecEnd != 0);
+
+	if (DSP_SUCCEEDED(status)) {
+		if ((dwDSPAddr <= ulTraceSecEnd) &&
+			(dwDSPAddr >= ulTraceSecBeg))
+			bTraceRead = true;
+	}
+
+	/* If reading from TRACE, force remap/unmap */
+	if (bTraceRead && dwBaseAddr) {
+		dwBaseAddr = 0;
+		pDevContext->dwDspExtBaseAddr = 0;
+	}
+
+	if (!dwBaseAddr) {
+		/* Initialize ulExtBase and ulExtEnd */
+		ulExtBase = 0;
+		ulExtEnd = 0;
+
+		/* Get DYNEXT_BEG, EXT_BEG and EXT_END.*/
+		if (DSP_SUCCEEDED(status) && !ulDynExtBase) {
+			status = DEV_GetSymbol(pDevContext->hDevObject,
+					DYNEXTBASE, &ulDynExtBase);
+		}
+		DBC_Assert(ulDynExtBase != 0);
+
+		if (DSP_SUCCEEDED(status)) {
+			status = DEV_GetSymbol(pDevContext->hDevObject,
+				 EXTBASE, &ulExtBase);
+		}
+		DBC_Assert(ulExtBase != 0);
+
+		if (DSP_SUCCEEDED(status)) {
+			status = DEV_GetSymbol(pDevContext->hDevObject,
+					EXTEND,	&ulExtEnd);
+		}
+		DBC_Assert(ulExtEnd != 0);
+
+	/* Trace buffer is right after the SHM SEG0,
+	*  so set the base address to SHMBASE */
+		if (bTraceRead) {
+			ulExtBase = ulShmBaseVirt;
+			ulExtEnd = ulTraceSecEnd;
+		}
+
+		DBC_Assert(ulExtEnd != 0);
+		DBC_Assert(ulExtEnd > ulExtBase);
+
+		if (ulExtEnd < ulExtBase)
+			status = DSP_EFAIL;
+
+		if (DSP_SUCCEEDED(status)) {
+			ulTLBBaseVirt =
+			pDevContext->aTLBEntry[0].ulDspVa * DSPWORDSIZE;
+			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
+			dwExtProgVirtMem = pDevContext->aTLBEntry[0].ulGppVa;
+
+			if (!bTraceRead) {
+				ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
+				ulShmOffsetVirt += PG_ALIGN_HIGH(ulExtEnd -
+						ulDynExtBase + 1,
+						HW_PAGE_SIZE_64KB);
+				dwExtProgVirtMem -= ulShmOffsetVirt;
+				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
+				pDevContext->dwDspExtBaseAddr =
+						dwExtProgVirtMem;
+
+	/* This dwDspExtBaseAddr will get cleared only when the board is
+	* stopped. */
+				if (!pDevContext->dwDspExtBaseAddr)
+					status = DSP_EFAIL;
+			}
+
+			dwBaseAddr = dwExtProgVirtMem;
+		}
+	}
+
+	if (!dwBaseAddr || !ulExtBase || !ulExtEnd)
+		status = DSP_EFAIL;
+
+	offset = dwDSPAddr - ulExtBase;
+
+	if (DSP_SUCCEEDED(status))
+		memcpy(pbHostBuf, (u8 *)dwBaseAddr+offset, ulNumBytes);
+
+	return status;
+}
+/*
+ *  ======== WriteDspData ========
+ *  purpose:
+ *      Copies buffers to the DSP internal/external memory.
+ */
+DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *hDevContext, IN u8 *pbHostBuf,
+			u32 dwDSPAddr, u32 ulNumBytes, u32 ulMemType)
+{
+	u32 offset;
+	u32 dwBaseAddr = hDevContext->dwDspBaseAddr;
+	struct CFG_HOSTRES resources;
+	DSP_STATUS status;
+	u32 base1, base2, base3;
+	base1 = OMAP_DSP_MEM1_SIZE;
+	base2 = OMAP_DSP_MEM2_BASE - OMAP_DSP_MEM1_BASE;
+	base3 = OMAP_DSP_MEM3_BASE - OMAP_DSP_MEM1_BASE;
+
+	status =  CFG_GetHostResources(
+		 (struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+
+	if (DSP_FAILED(status))
+		return status;
+
+	offset = dwDSPAddr - hDevContext->dwDSPStartAdd;
+	if (offset < base1) {
+		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[2],
+						resources.dwMemLength[2]);
+	} else if (offset > base1 && offset < base2+OMAP_DSP_MEM2_SIZE) {
+		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[3],
+						resources.dwMemLength[3]);
+		offset = offset - base2;
+	} else if (offset >= base2+OMAP_DSP_MEM2_SIZE &&
+		offset < base3 + OMAP_DSP_MEM3_SIZE) {
+		dwBaseAddr = MEM_LinearAddress(resources.dwMemBase[4],
+						resources.dwMemLength[4]);
+		offset = offset - base3;
+	} else{
+		return DSP_EFAIL;
+	}
+	if (ulNumBytes)
+		memcpy((u8 *) (dwBaseAddr+offset), pbHostBuf, ulNumBytes);
+	else
+		*((u32 *) pbHostBuf) = dwBaseAddr+offset;
+
+	return status;
+}
+
+/*
+ *  ======== WriteExtDspData ========
+ *  purpose:
+ *      Copies buffers to the external memory.
+ *
+ */
+DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
+			  IN u8 *pbHostBuf, u32 dwDSPAddr, u32 ulNumBytes,
+			  u32 ulMemType, bool bDynamicLoad)
+{
+	u32 dwBaseAddr = pDevContext->dwDspExtBaseAddr;
+	u32 dwOffset = 0;
+	u8 bTempByte1, bTempByte2;
+	u8 remainByte[4];
+	s32 i;
+	DSP_STATUS retVal = DSP_SOK;
+	u32 dwExtProgVirtMem;
+	u32 ulTLBBaseVirt = 0;
+	u32 ulShmOffsetVirt = 0;
+	struct CFG_HOSTRES hostRes;
+	bool bTraceLoad = false;
+	bTempByte1 = 0x0;
+	bTempByte2 = 0x0;
+
+	  if (bSymbolsReloaded) {
+		/* Check if it is a load to Trace section */
+		retVal = DEV_GetSymbol(pDevContext->hDevObject,
+					DSP_TRACESEC_BEG, &ulTraceSecBeg);
+		if (DSP_SUCCEEDED(retVal))
+			retVal = DEV_GetSymbol(pDevContext->hDevObject,
+				 DSP_TRACESEC_END, &ulTraceSecEnd);
+	}
+	if (DSP_SUCCEEDED(retVal)) {
+		if ((dwDSPAddr <= ulTraceSecEnd) &&
+		   (dwDSPAddr >= ulTraceSecBeg))
+			bTraceLoad = true;
+	}
+
+	/* If dynamic, force remap/unmap */
+	if ((bDynamicLoad || bTraceLoad) && dwBaseAddr) {
+		dwBaseAddr = 0;
+		MEM_UnmapLinearAddress((void *)pDevContext->dwDspExtBaseAddr);
+		pDevContext->dwDspExtBaseAddr = 0x0;
+	}
+	if (!dwBaseAddr) {
+		if (bSymbolsReloaded)
+			/* Get SHM_BEG  EXT_BEG and EXT_END. */
+			retVal = DEV_GetSymbol(pDevContext->hDevObject,
+						SHMBASENAME, &ulShmBaseVirt);
+		DBC_Assert(ulShmBaseVirt != 0);
+		if (bDynamicLoad) {
+			if (DSP_SUCCEEDED(retVal)) {
+				if (bSymbolsReloaded)
+					retVal = DEV_GetSymbol(pDevContext->
+						hDevObject, DYNEXTBASE,
+						&ulExtBase);
+			}
+			DBC_Assert(ulExtBase != 0);
+			if (DSP_SUCCEEDED(retVal)) {
+				/* DR  OMAPS00013235 : DLModules array may be
+				 * in EXTMEM. It is expected that DYNEXTMEM and
+				 * EXTMEM are contiguous, so checking for the
+				 * upper bound at EXTEND should be Ok. */
+				if (bSymbolsReloaded)
+					retVal = DEV_GetSymbol(pDevContext->
+						hDevObject, EXTEND, &ulExtEnd);
+			}
+		} else {
+			if (bSymbolsReloaded) {
+				if (DSP_SUCCEEDED(retVal))
+					retVal = DEV_GetSymbol(pDevContext->
+						hDevObject, EXTBASE,
+						&ulExtBase);
+				DBC_Assert(ulExtBase != 0);
+				if (DSP_SUCCEEDED(retVal))
+					retVal = DEV_GetSymbol(pDevContext->
+						hDevObject, EXTEND, &ulExtEnd);
+			}
+		}
+		/* Trace buffer it right after the SHM SEG0, so set the
+		 * 	base address to SHMBASE */
+		if (bTraceLoad)
+			ulExtBase = ulShmBaseVirt;
+
+		DBC_Assert(ulExtEnd != 0);
+		DBC_Assert(ulExtEnd > ulExtBase);
+		if (ulExtEnd < ulExtBase)
+			retVal = DSP_EFAIL;
+
+		if (DSP_SUCCEEDED(retVal)) {
+			ulTLBBaseVirt = pDevContext->aTLBEntry[0].ulDspVa *
+					DSPWORDSIZE;
+			DBC_Assert(ulTLBBaseVirt <= ulShmBaseVirt);
+
+			if (bSymbolsReloaded) {
+				if (DSP_SUCCEEDED(retVal)) {
+					retVal = DEV_GetSymbol(pDevContext->
+						 hDevObject, DSP_TRACESEC_END,
+						 &ulShm0End);
+				}
+				if (DSP_SUCCEEDED(retVal)) {
+					retVal = DEV_GetSymbol(pDevContext->
+						 hDevObject, DYNEXTBASE,
+						 &ulDynExtBase);
+				}
+			}
+			ulShmOffsetVirt = ulShmBaseVirt - ulTLBBaseVirt;
+			if (bTraceLoad) {
+				dwExtProgVirtMem = pDevContext->aTLBEntry[0].
+						   ulGppVa;
+			} else {
+				CFG_GetHostResources(
+					(struct CFG_DEVNODE *)
+					DRV_GetFirstDevExtension(), &hostRes);
+				dwExtProgVirtMem = hostRes.dwMemBase[1];
+				dwExtProgVirtMem += (ulExtBase - ulDynExtBase);
+			}
+
+			pDevContext->dwDspExtBaseAddr =
+				(u32)MEM_LinearAddress((void *)dwExtProgVirtMem,
+					ulExtEnd - ulExtBase);
+			dwBaseAddr += pDevContext->dwDspExtBaseAddr;
+			/* This dwDspExtBaseAddr will get cleared only when
+			 * the board is stopped.  */
+			if (!pDevContext->dwDspExtBaseAddr)
+				retVal = DSP_EFAIL;
+		}
+	}
+	if (!dwBaseAddr || !ulExtBase || !ulExtEnd)
+		retVal = DSP_EFAIL;
+
+	if (DSP_SUCCEEDED(retVal)) {
+		for (i = 0; i < 4; i++)
+			remainByte[i] = 0x0;
+
+		dwOffset = dwDSPAddr - ulExtBase;
+		/* Also make sure the dwDSPAddr is < ulExtEnd */
+		if (dwDSPAddr > ulExtEnd || dwOffset > dwDSPAddr)
+			retVal = DSP_EFAIL;
+	}
+	if (DSP_SUCCEEDED(retVal)) {
+		if (ulNumBytes)
+			memcpy((u8 *) dwBaseAddr + dwOffset, pbHostBuf,
+				ulNumBytes);
+		else
+			*((u32 *) pbHostBuf) = dwBaseAddr+dwOffset;
+	}
+	/* Unmap here to force remap for other Ext loads */
+	if ((bDynamicLoad || bTraceLoad) && pDevContext->dwDspExtBaseAddr) {
+		MEM_UnmapLinearAddress((void *) pDevContext->dwDspExtBaseAddr);
+		pDevContext->dwDspExtBaseAddr = 0x0;
+	}
+	bSymbolsReloaded = false;
+	return retVal;
+}
+
diff --git a/drivers/dsp/bridge/wmd/tiomap_io.h b/drivers/dsp/bridge/wmd/tiomap_io.h
new file mode 100644
index 0000000..4d97147
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/tiomap_io.h
@@ -0,0 +1,102 @@
+/*
+ * tiomap_io.h
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Definitions, types and function prototypes for the io (r/w external mem).
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _TIOMAP_IO_
+#define _TIOMAP_IO_
+
+/*
+ * Symbol that defines beginning of shared memory.
+ * For OMAP (Helen) this is the DSP Virtual base address of SDRAM.
+ * This will be used to program DSP MMU to map DSP Virt to GPP phys.
+ * (see dspMmuTlbEntry()).
+ */
+#define SHMBASENAME "SHM_BEG"
+#define EXTBASE     "EXT_BEG"
+#define EXTEND      "_EXT_END"
+#define DYNEXTBASE  "_DYNEXT_BEG"
+#define DYNEXTEND   "_DYNEXT_END"
+#define IVAEXTMEMBASE   "_IVAEXTMEM_BEG"
+#define IVAEXTMEMEND   "_IVAEXTMEM_END"
+
+
+#define DSP_TRACESEC_BEG  "_BRIDGE_TRACE_BEG"
+#define DSP_TRACESEC_END  "_BRIDGE_TRACE_END"
+
+#define SYS_PUTCBEG               "_SYS_PUTCBEG"
+#define SYS_PUTCEND               "_SYS_PUTCEND"
+#define BRIDGE_SYS_PUTC_current   "_BRIDGE_SYS_PUTC_current"
+
+
+#define WORDSWAP_ENABLE 0x3	/* Enable word swap */
+
+/*
+ *  ======== ReadExtDspData ========
+ *  Reads it from DSP External memory. The external memory for the DSP
+ * is configured by the combination of DSP MMU and SHM Memory manager in the CDB
+ */
+extern DSP_STATUS ReadExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
+				OUT u8 *pbHostBuf, u32 dwDSPAddr,
+				u32 ulNumBytes, u32 ulMemType);
+
+/*
+ *  ======== WriteDspData ========
+ */
+extern DSP_STATUS WriteDspData(struct WMD_DEV_CONTEXT *pDevContext,
+			       OUT u8 *pbHostBuf, u32 dwDSPAddr,
+			       u32 ulNumBytes, u32 ulMemType);
+
+/*
+ *  ======== WriteExtDspData ========
+ *  Writes to the DSP External memory for external program.
+ *  The ext mem for progra is configured by the combination of DSP MMU and
+ *  SHM Memory manager in the CDB
+ */
+extern DSP_STATUS WriteExtDspData(struct WMD_DEV_CONTEXT *pDevContext,
+				 IN u8 *pbHostBuf, u32 dwDSPAddr,
+				 u32 ulNumBytes, u32 ulMemType,
+				 bool bDynamicLoad);
+
+/*
+ * ======== WriteExt32BitDspData ========
+ * Writes 32 bit data to the external memory
+ */
+extern inline void WriteExt32BitDspData(IN const
+		struct WMD_DEV_CONTEXT *pDevContext, IN u32 dwDSPAddr,
+		IN u32 val)
+{
+	*(u32 *)dwDSPAddr = ((pDevContext->tcWordSwapOn) ? (((val << 16) &
+			      0xFFFF0000) | ((val >> 16) & 0x0000FFFF)) : val);
+}
+
+/*
+ * ======== ReadExt32BitDspData ========
+ * Reads 32 bit data from the external memory
+ */
+extern inline u32 ReadExt32BitDspData(IN const struct WMD_DEV_CONTEXT
+				       *pDevContext, IN u32 dwDSPAddr)
+{
+	u32 retVal;
+	retVal = *(u32 *)dwDSPAddr;
+
+	retVal = ((pDevContext->tcWordSwapOn) ? (((retVal << 16)
+		 & 0xFFFF0000) | ((retVal >> 16) & 0x0000FFFF)) : retVal);
+	return retVal;
+}
+
+#endif				/* _TIOMAP_IO_ */
+
diff --git a/drivers/dsp/bridge/wmd/tiomap_sm.c b/drivers/dsp/bridge/wmd/tiomap_sm.c
new file mode 100644
index 0000000..ed18fdd
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/tiomap_sm.c
@@ -0,0 +1,184 @@
+/*
+ * tiomap_sm.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+#include <dspbridge/cfg.h>
+#include <dspbridge/drv.h>
+#include <dspbridge/dev.h>
+
+#include "_tiomap.h"
+#include "_tiomap_pwr.h"
+
+#define MAILBOX_FIFOSTATUS(m) (0x80 + 4 * (m))
+
+static inline unsigned int fifo_full(void __iomem *mbox_base, int mbox_id)
+{
+	return __raw_readl(mbox_base + MAILBOX_FIFOSTATUS(mbox_id)) & 0x1;
+}
+
+DSP_STATUS CHNLSM_EnableInterrupt(struct WMD_DEV_CONTEXT *pDevContext)
+{
+	DSP_STATUS status = DSP_SOK;
+	u32 numMbxMsg;
+	u32 mbxValue;
+	struct CFG_HOSTRES resources;
+	u32 devType;
+
+	/* Read the messages in the mailbox until the message queue is empty */
+
+	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			     &resources);
+	DEV_GetDevType(pDevContext->hDevObject, &devType);
+	if (devType == DSP_UNIT) {
+		HW_MBOX_NumMsgGet(resources.dwMboxBase,
+				  MBOX_DSP2ARM, &numMbxMsg);
+		while (numMbxMsg != 0) {
+			HW_MBOX_MsgRead(resources.dwMboxBase,
+					MBOX_DSP2ARM,
+					&mbxValue);
+			numMbxMsg--;
+		}
+		/* clear the DSP mailbox as well...*/
+		HW_MBOX_NumMsgGet(resources.dwMboxBase,
+				  MBOX_ARM2DSP, &numMbxMsg);
+		while (numMbxMsg != 0) {
+			HW_MBOX_MsgRead(resources.dwMboxBase,
+					MBOX_ARM2DSP, &mbxValue);
+			numMbxMsg--;
+			udelay(10);
+
+			HW_MBOX_EventAck(resources.dwMboxBase, MBOX_ARM2DSP,
+					 HW_MBOX_U1_DSP1,
+					 HW_MBOX_INT_NEW_MSG);
+		}
+		/* Enable the new message events on this IRQ line */
+		HW_MBOX_EventEnable(resources.dwMboxBase,
+				    MBOX_DSP2ARM,
+				    MBOX_ARM,
+				    HW_MBOX_INT_NEW_MSG);
+	}
+
+	return status;
+}
+
+DSP_STATUS CHNLSM_DisableInterrupt(struct WMD_DEV_CONTEXT *pDevContext)
+{
+	struct CFG_HOSTRES resources;
+
+	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			     &resources);
+	HW_MBOX_EventDisable(resources.dwMboxBase, MBOX_DSP2ARM,
+			     MBOX_ARM, HW_MBOX_INT_NEW_MSG);
+	return DSP_SOK;
+}
+
+DSP_STATUS CHNLSM_InterruptDSP2(struct WMD_DEV_CONTEXT *pDevContext,
+				u16 wMbVal)
+{
+#ifdef CONFIG_BRIDGE_DVFS
+	struct dspbridge_platform_data *pdata =
+		omap_dspbridge_dev->dev.platform_data;
+	u32 opplevel = 0;
+#endif
+	struct CFG_HOSTRES resources;
+	DSP_STATUS status = DSP_SOK;
+	unsigned long timeout;
+	u32 temp;
+
+	status = CFG_GetHostResources((struct CFG_DEVNODE *)
+			DRV_GetFirstDevExtension(), &resources);
+	if (DSP_FAILED(status))
+		return DSP_EFAIL;
+
+	if (pDevContext->dwBrdState == BRD_DSP_HIBERNATION ||
+	    pDevContext->dwBrdState == BRD_HIBERNATION) {
+#ifdef CONFIG_BRIDGE_DVFS
+		if (pdata->dsp_get_opp)
+			opplevel = (*pdata->dsp_get_opp)();
+		if (opplevel == VDD1_OPP1) {
+			if (pdata->dsp_set_min_opp)
+				(*pdata->dsp_set_min_opp)(VDD1_OPP2);
+		}
+#endif
+		/* Restart the peripheral clocks */
+		DSP_PeripheralClocks_Enable(pDevContext, NULL);
+
+		/*
+		 * 2:0 AUTO_IVA2_DPLL - Enabling IVA2 DPLL auto control
+		 *     in CM_AUTOIDLE_PLL_IVA2 register
+		 */
+		*(REG_UWORD32 *)(resources.dwCmBase + 0x34) = 0x1;
+
+		/*
+		 * 7:4 IVA2_DPLL_FREQSEL - IVA2 internal frq set to
+		 *     0.75 MHz - 1.0 MHz
+		 * 2:0 EN_IVA2_DPLL - Enable IVA2 DPLL in lock mode
+		 */
+		temp = *(REG_UWORD32 *)(resources.dwCmBase + 0x4);
+		temp = (temp & 0xFFFFFF08) | 0x37;
+		*(REG_UWORD32 *)(resources.dwCmBase + 0x4) = temp;
+
+		/* Restore mailbox settings */
+		HW_MBOX_restoreSettings(resources.dwMboxBase);
+
+		/* Access MMU SYS CONFIG register to generate a short wakeup */
+		temp = *(REG_UWORD32 *)(resources.dwDmmuBase + 0x10);
+
+		pDevContext->dwBrdState = BRD_RUNNING;
+	} else if (pDevContext->dwBrdState == BRD_RETENTION) {
+		/* Restart the peripheral clocks */
+		DSP_PeripheralClocks_Enable(pDevContext, NULL);
+	}
+
+	timeout = jiffies + msecs_to_jiffies(1);
+	while (fifo_full((void __iomem *) resources.dwMboxBase, 0)) {
+		if (time_after(jiffies, timeout)) {
+			pr_err("dspbridge: timed out waiting for mailbox\n");
+			return WMD_E_TIMEOUT;
+		}
+	}
+
+	dev_dbg(bridge, "MBX: writing %x to Mailbox\n", wMbVal);
+	HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP, wMbVal);
+	return DSP_SOK;
+}
+
+bool CHNLSM_ISR(struct WMD_DEV_CONTEXT *pDevContext, bool *pfSchedDPC,
+		u16 *pwIntrVal)
+{
+	struct CFG_HOSTRES resources;
+	u32 numMbxMsg;
+	u32 mbxValue;
+
+	CFG_GetHostResources((struct CFG_DEVNODE *)DRV_GetFirstDevExtension(), &resources);
+
+	HW_MBOX_NumMsgGet(resources.dwMboxBase, MBOX_DSP2ARM, &numMbxMsg);
+
+	if (numMbxMsg > 0) {
+		HW_MBOX_MsgRead(resources.dwMboxBase, MBOX_DSP2ARM, &mbxValue);
+
+		HW_MBOX_EventAck(resources.dwMboxBase, MBOX_DSP2ARM,
+				 HW_MBOX_U0_ARM, HW_MBOX_INT_NEW_MSG);
+
+		dev_dbg(bridge, "MBX: Read %x from Mailbox\n", mbxValue);
+		*pwIntrVal = (u16) mbxValue;
+	}
+	/* Set *pfSchedDPC to true; */
+	*pfSchedDPC = true;
+	return true;
+}
diff --git a/drivers/dsp/bridge/wmd/ue_deh.c b/drivers/dsp/bridge/wmd/ue_deh.c
new file mode 100644
index 0000000..5c69f7e
--- /dev/null
+++ b/drivers/dsp/bridge/wmd/ue_deh.c
@@ -0,0 +1,319 @@
+/*
+ * ue_deh.c
+ *
+ * DSP-BIOS Bridge driver support functions for TI OMAP processors.
+ *
+ * Implements upper edge DSP exception handling (DEH) functions.
+ *
+ * Copyright (C) 2005-2006 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+/*  ----------------------------------- Host OS */
+#include <dspbridge/host_os.h>
+
+/*  ----------------------------------- DSP/BIOS Bridge */
+#include <dspbridge/std.h>
+#include <dspbridge/dbdefs.h>
+#include <dspbridge/errbase.h>
+
+/*  ----------------------------------- Trace & Debug */
+#include <dspbridge/dbc.h>
+
+/*  ----------------------------------- OS Adaptation Layer */
+#include <dspbridge/cfg.h>
+#include <dspbridge/mem.h>
+#include <dspbridge/ntfy.h>
+#include <dspbridge/drv.h>
+
+/*  ----------------------------------- Link Driver */
+#include <dspbridge/wmddeh.h>
+
+/*  ----------------------------------- Platform Manager */
+#include <dspbridge/dev.h>
+#include <dspbridge/wcd.h>
+
+/* ------------------------------------ Hardware Abstraction Layer */
+#include <hw_defs.h>
+#include <hw_mmu.h>
+
+/*  ----------------------------------- This */
+#include "mmu_fault.h"
+#include "_tiomap.h"
+#include "_deh.h"
+#include "_tiomap_mmu.h"
+#include "_tiomap_pwr.h"
+#include <dspbridge/io_sm.h>
+
+static struct HW_MMUMapAttrs_t  mapAttrs = { HW_LITTLE_ENDIAN,
+					HW_ELEM_SIZE_16BIT,
+					HW_MMU_CPUES} ;
+#define VirtToPhys(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
+
+static u32 dummyVaAddr;
+/*
+ *  ======== WMD_DEH_Create ========
+ *      Creates DEH manager object.
+ */
+DSP_STATUS WMD_DEH_Create(OUT struct DEH_MGR **phDehMgr,
+			 struct DEV_OBJECT *hDevObject)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEH_MGR *pDehMgr = NULL;
+	struct CFG_HOSTRES cfgHostRes;
+	struct CFG_DEVNODE *hDevNode;
+	struct WMD_DEV_CONTEXT *hWmdContext = NULL;
+
+	 /*  Message manager will be created when a file is loaded, since
+	 *  size of message buffer in shared memory is configurable in
+	 *  the base image.  */
+	/* Get WMD context info. */
+	DEV_GetWMDContext(hDevObject, &hWmdContext);
+	DBC_Assert(hWmdContext);
+	dummyVaAddr = 0;
+	/* Allocate IO manager object: */
+	MEM_AllocObject(pDehMgr, struct DEH_MGR, SIGNATURE);
+	if (pDehMgr == NULL) {
+		status = DSP_EMEMORY;
+	} else {
+		/* Create an NTFY object to manage notifications */
+		status = NTFY_Create(&pDehMgr->hNtfy);
+
+		/* Create a MMUfault DPC */
+		tasklet_init(&pDehMgr->dpc_tasklet, MMU_FaultDpc, (u32)pDehMgr);
+
+		if (DSP_SUCCEEDED(status))
+			status = DEV_GetDevNode(hDevObject, &hDevNode);
+
+		if (DSP_SUCCEEDED(status))
+			status = CFG_GetHostResources(hDevNode, &cfgHostRes);
+
+		if (DSP_SUCCEEDED(status)) {
+			/* Fill in context structure */
+			pDehMgr->hWmdContext = hWmdContext;
+			pDehMgr->errInfo.dwErrMask = 0L;
+			pDehMgr->errInfo.dwVal1 = 0L;
+			pDehMgr->errInfo.dwVal2 = 0L;
+			pDehMgr->errInfo.dwVal3 = 0L;
+			/* Install ISR function for DSP MMU fault */
+			if ((request_irq(INT_DSP_MMU_IRQ, MMU_FaultIsr, 0,
+			   "DspBridge\tiommu fault", (void *)pDehMgr)) == 0)
+				status = DSP_SOK;
+			else
+				status = DSP_EFAIL;
+		}
+	}
+	if (DSP_FAILED(status)) {
+		/* If create failed, cleanup */
+		WMD_DEH_Destroy((struct DEH_MGR *)pDehMgr);
+		*phDehMgr = NULL;
+	} else {
+		*phDehMgr = (struct DEH_MGR *)pDehMgr;
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_DEH_Destroy ========
+ *      Destroys DEH manager object.
+ */
+DSP_STATUS WMD_DEH_Destroy(struct DEH_MGR *hDehMgr)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+
+	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+		/* Release dummy VA buffer */
+		WMD_DEH_ReleaseDummyMem();
+		/* If notification object exists, delete it */
+		if (pDehMgr->hNtfy)
+			(void)NTFY_Delete(pDehMgr->hNtfy);
+		/* Disable DSP MMU fault */
+		free_irq(INT_DSP_MMU_IRQ, pDehMgr);
+
+		/* Free DPC object */
+		tasklet_kill(&pDehMgr->dpc_tasklet);
+
+		/* Deallocate the DEH manager object */
+		MEM_FreeObject(pDehMgr);
+	}
+
+	return status;
+}
+
+/*
+ *  ======== WMD_DEH_RegisterNotify ========
+ *      Registers for DEH notifications.
+ */
+DSP_STATUS WMD_DEH_RegisterNotify(struct DEH_MGR *hDehMgr, u32 uEventMask,
+				 u32 uNotifyType,
+				 struct DSP_NOTIFICATION *hNotification)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+
+	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+		status = NTFY_Register(pDehMgr->hNtfy, hNotification,
+			 uEventMask, uNotifyType);
+	}
+
+	return status;
+}
+
+
+/*
+ *  ======== WMD_DEH_Notify ========
+ *      DEH error notification function. Informs user about the error.
+ */
+void WMD_DEH_Notify(struct DEH_MGR *hDehMgr, u32 ulEventMask,
+			 u32 dwErrInfo)
+{
+	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+	struct WMD_DEV_CONTEXT *pDevContext;
+	DSP_STATUS status = DSP_SOK;
+	u32 memPhysical = 0;
+	u32 HW_MMU_MAX_TLB_COUNT = 31;
+	extern u32 faultAddr;
+	struct CFG_HOSTRES resources;
+	HW_STATUS hwStatus;
+
+	status = CFG_GetHostResources(
+			(struct CFG_DEVNODE *)DRV_GetFirstDevExtension(),
+			&resources);
+
+	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+		printk(KERN_INFO "WMD_DEH_Notify: ********** DEVICE EXCEPTION "
+			"**********\n");
+		pDevContext = (struct WMD_DEV_CONTEXT *)pDehMgr->hWmdContext;
+
+		switch (ulEventMask) {
+		case DSP_SYSERROR:
+			/* reset errInfo structure before use */
+			pDehMgr->errInfo.dwErrMask = DSP_SYSERROR;
+			pDehMgr->errInfo.dwVal1 = 0L;
+			pDehMgr->errInfo.dwVal2 = 0L;
+			pDehMgr->errInfo.dwVal3 = 0L;
+			pDehMgr->errInfo.dwVal1 = dwErrInfo;
+			printk(KERN_ERR "WMD_DEH_Notify: DSP_SYSERROR, errInfo "
+				"= 0x%x\n", dwErrInfo);
+			break;
+		case DSP_MMUFAULT:
+			/* MMU fault routine should have set err info
+			 * structure */
+			pDehMgr->errInfo.dwErrMask = DSP_MMUFAULT;
+			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT,"
+				"errInfo = 0x%x\n", dwErrInfo);
+			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, High "
+				"Address = 0x%x\n",
+				(unsigned int)pDehMgr->errInfo.dwVal1);
+			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, Low "
+				"Address = 0x%x\n",
+				(unsigned int)pDehMgr->errInfo.dwVal2);
+			printk(KERN_INFO "WMD_DEH_Notify: DSP_MMUFAULT, fault "
+				"address = 0x%x\n", (unsigned int)faultAddr);
+			dummyVaAddr = (u32)MEM_Calloc(sizeof(char) * 0x1000,
+					MEM_PAGED);
+			memPhysical  = VirtToPhys(PG_ALIGN_LOW((u32)dummyVaAddr,
+								PG_SIZE_4K));
+			pDevContext = (struct WMD_DEV_CONTEXT *)
+						pDehMgr->hWmdContext;
+			/* Reset the dynamic mmu index to fixed count if it
+			 * exceeds 31. So that the dynmmuindex is always
+			 * between the range of standard/fixed entries
+			 * and 31.  */
+			if (pDevContext->numTLBEntries >
+			   HW_MMU_MAX_TLB_COUNT) {
+				pDevContext->numTLBEntries = pDevContext->
+					fixedTLBEntries;
+			}
+			if (DSP_SUCCEEDED(status)) {
+				hwStatus = HW_MMU_TLBAdd(resources.dwDmmuBase,
+					memPhysical, faultAddr,
+					HW_PAGE_SIZE_4KB, 1, &mapAttrs,
+					HW_SET, HW_SET);
+			}
+			/* send an interrupt to DSP */
+			HW_MBOX_MsgWrite(resources.dwMboxBase, MBOX_ARM2DSP,
+					 MBX_DEH_CLASS | MBX_DEH_EMMU);
+			/* Clear MMU interrupt */
+			HW_MMU_EventAck(resources.dwDmmuBase,
+					 HW_MMU_TRANSLATION_FAULT);
+			break;
+#ifdef CONFIG_BRIDGE_NTFY_PWRERR
+		case DSP_PWRERROR:
+			/* reset errInfo structure before use */
+			pDehMgr->errInfo.dwErrMask = DSP_PWRERROR;
+			pDehMgr->errInfo.dwVal1 = 0L;
+			pDehMgr->errInfo.dwVal2 = 0L;
+			pDehMgr->errInfo.dwVal3 = 0L;
+			pDehMgr->errInfo.dwVal1 = dwErrInfo;
+			printk(KERN_ERR "WMD_DEH_Notify: DSP_PWRERROR, errInfo "
+					"= 0x%x\n", dwErrInfo);
+			break;
+#endif /* CONFIG_BRIDGE_NTFY_PWRERR */
+		default:
+			dev_dbg(bridge, "%s: Unknown Error, errInfo = 0x%x\n",
+							__func__, dwErrInfo);
+			break;
+		}
+
+		/* Filter subsequent notifications when an error occurs */
+		if (pDevContext->dwBrdState != BRD_ERROR)
+			NTFY_Notify(pDehMgr->hNtfy, ulEventMask);
+
+		/* Set the Board state as ERROR */
+		pDevContext->dwBrdState = BRD_ERROR;
+		/* Disable all the clocks that were enabled by DSP */
+		(void)DSP_PeripheralClocks_Disable(pDevContext, NULL);
+		/* Call DSP Trace Buffer */
+		PrintDspTraceBuffer(hDehMgr->hWmdContext);
+
+	}
+}
+
+/*
+ *  ======== WMD_DEH_GetInfo ========
+ *      Retrieves error information.
+ */
+DSP_STATUS WMD_DEH_GetInfo(struct DEH_MGR *hDehMgr,
+			  struct DSP_ERRORINFO *pErrInfo)
+{
+	DSP_STATUS status = DSP_SOK;
+	struct DEH_MGR *pDehMgr = (struct DEH_MGR *)hDehMgr;
+
+	DBC_Require(pDehMgr);
+	DBC_Require(pErrInfo);
+
+	if (MEM_IsValidHandle(pDehMgr, SIGNATURE)) {
+		/* Copy DEH error info structure to PROC error info
+		 * structure. */
+		pErrInfo->dwErrMask = pDehMgr->errInfo.dwErrMask;
+		pErrInfo->dwVal1 = pDehMgr->errInfo.dwVal1;
+		pErrInfo->dwVal2 = pDehMgr->errInfo.dwVal2;
+		pErrInfo->dwVal3 = pDehMgr->errInfo.dwVal3;
+	} else {
+		status = DSP_EHANDLE;
+	}
+
+	return status;
+}
+
+
+/*
+ *  ======== WMD_DEH_ReleaseDummyMem ========
+ *      Releases memory allocated for dummy page
+ */
+void WMD_DEH_ReleaseDummyMem(void)
+{
+	kfree((void *)dummyVaAddr);
+	dummyVaAddr = 0;
+}
+
-- 
1.7.0.4

