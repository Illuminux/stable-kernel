From ca29c458c88604ae6522d3c932078e78d1b30f46 Mon Sep 17 00:00:00 2001
From: Shivananda Hebbar <x0hebbar@ti.com>
Date: Mon, 19 Apr 2010 18:15:45 -0500
Subject: [PATCH 060/135] DSPBRIDGE: replace error code DSP_EMEMORY for -ENOMEM

---
 arch/arm/plat-omap/include/dspbridge/chnl.h     |    2 +-
 arch/arm/plat-omap/include/dspbridge/cmm.h      |    4 +-
 arch/arm/plat-omap/include/dspbridge/dbdcd.h    |    6 ++--
 arch/arm/plat-omap/include/dspbridge/dblldefs.h |    4 +-
 arch/arm/plat-omap/include/dspbridge/dev.h      |    4 +-
 arch/arm/plat-omap/include/dspbridge/disp.h     |    2 +-
 arch/arm/plat-omap/include/dspbridge/drv.h      |    2 +-
 arch/arm/plat-omap/include/dspbridge/io.h       |    2 +-
 arch/arm/plat-omap/include/dspbridge/mgr.h      |    2 +-
 arch/arm/plat-omap/include/dspbridge/nldrdefs.h |    8 +++---
 arch/arm/plat-omap/include/dspbridge/node.h     |   12 ++++----
 arch/arm/plat-omap/include/dspbridge/ntfy.h     |    2 +-
 arch/arm/plat-omap/include/dspbridge/proc.h     |    4 +-
 arch/arm/plat-omap/include/dspbridge/rmm.h      |    4 +-
 arch/arm/plat-omap/include/dspbridge/strm.h     |    6 ++--
 arch/arm/plat-omap/include/dspbridge/wmd.h      |   22 ++++++++--------
 drivers/dsp/bridge/pmgr/cmm.c                   |   14 +++++-----
 drivers/dsp/bridge/pmgr/cod.c                   |    4 +-
 drivers/dsp/bridge/pmgr/dbll.c                  |   12 ++++----
 drivers/dsp/bridge/pmgr/dev.c                   |    2 +-
 drivers/dsp/bridge/pmgr/dmm.c                   |    6 ++--
 drivers/dsp/bridge/pmgr/wcd.c                   |   24 +++++++++---------
 drivers/dsp/bridge/rmgr/dbdcd.c                 |   10 ++++----
 drivers/dsp/bridge/rmgr/disp.c                  |    4 +-
 drivers/dsp/bridge/rmgr/drv.c                   |   10 ++++----
 drivers/dsp/bridge/rmgr/mgr.c                   |    2 +-
 drivers/dsp/bridge/rmgr/nldr.c                  |   26 ++++++++++----------
 drivers/dsp/bridge/rmgr/node.c                  |   30 +++++++++++-----------
 drivers/dsp/bridge/rmgr/proc.c                  |    8 +++---
 drivers/dsp/bridge/rmgr/rmm.c                   |   14 +++++-----
 drivers/dsp/bridge/rmgr/strm.c                  |   10 ++++----
 drivers/dsp/bridge/wmd/chnl_sm.c                |   14 +++++-----
 drivers/dsp/bridge/wmd/io_sm.c                  |   14 +++++-----
 drivers/dsp/bridge/wmd/msg_sm.c                 |   26 ++++++++++----------
 drivers/dsp/bridge/wmd/tiomap3430.c             |   10 ++++----
 drivers/dsp/bridge/wmd/ue_deh.c                 |    4 +-
 36 files changed, 165 insertions(+), 165 deletions(-)

diff --git a/arch/arm/plat-omap/include/dspbridge/chnl.h b/arch/arm/plat-omap/include/dspbridge/chnl.h
index da9115b..7814747 100644
--- a/arch/arm/plat-omap/include/dspbridge/chnl.h
+++ b/arch/arm/plat-omap/include/dspbridge/chnl.h
@@ -62,7 +62,7 @@ extern dsp_status chnl_close(struct chnl_object *chnl_obj);
  *      DSP_SOK:                Success;
  *      DSP_EHANDLE:            hdev_obj is invalid.
  *      DSP_EINVALIDARG:        max_channels is 0.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      -ENOMEM:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
  *      CHNL_E_MAXCHANNELS:     This manager cannot handle this many channels.
  *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
diff --git a/arch/arm/plat-omap/include/dspbridge/cmm.h b/arch/arm/plat-omap/include/dspbridge/cmm.h
index 5d2dfe1..3565729 100644
--- a/arch/arm/plat-omap/include/dspbridge/cmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/cmm.h
@@ -75,7 +75,7 @@ extern void *cmm_calloc_buf(struct cmm_object *hcmm_mgr,
  *      pMgrAttrs:  Comm mem manager attributes.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      -ENOMEM:    Insufficient memory for requested resources.
  *      -EPERM:      Failed to initialize critical sect sync object.
  *
  *  Requires:
@@ -287,7 +287,7 @@ extern void *cmm_xlator_alloc_buf(struct cmm_xlatorobject *xlator,
  *  Returns:
  *     DSP_SOK:            Success.
  *     DSP_EINVALIDARG:    Bad input Attrs.
- *     DSP_EMEMORY:   Insufficient memory(local) for requested resources.
+ *     -ENOMEM:   Insufficient memory(local) for requested resources.
  *  Requires:
  *     phXlator != NULL
  *     hcmm_mgr != NULL
diff --git a/arch/arm/plat-omap/include/dspbridge/dbdcd.h b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
index 3960c69..cc47aab 100644
--- a/arch/arm/plat-omap/include/dspbridge/dbdcd.h
+++ b/arch/arm/plat-omap/include/dspbridge/dbdcd.h
@@ -84,7 +84,7 @@ extern dsp_status dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
  *      phDcdMgr:       A pointer to a DCD manager handle.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Unable to allocate memory for DCD manager handle.
+ *      -ENOMEM:    Unable to allocate memory for DCD manager handle.
  *      -EPERM:      General failure.
  *  Requires:
  *      DCD initialized.
@@ -163,7 +163,7 @@ extern void dcd_exit(void);
  *      phase: phase to obtain correct input library
  *  Returns:
  *      DSP_SOK: Success.
- *      DSP_EMEMORY: Memory allocation failure.
+ *      -ENOMEM: Memory allocation failure.
  *      DSP_EDCDREADSECT: Failure to read section containing library info.
  *      -EPERM: General failure.
  *  Requires:
@@ -193,7 +193,7 @@ extern dsp_status dcd_get_dep_libs(IN struct dcd_manager *hdcd_mgr,
  *      phase:          Phase to obtain correct input library
  *  Returns:
  *      DSP_SOK: Success.
- *      DSP_EMEMORY: Memory allocation failure.
+ *      -ENOMEM: Memory allocation failure.
  *      DSP_EDCDREADSECT: Failure to read section containing library info.
  *      -EPERM: General failure.
  *  Requires:
diff --git a/arch/arm/plat-omap/include/dspbridge/dblldefs.h b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
index ecc5d06..5dd23fb 100644
--- a/arch/arm/plat-omap/include/dspbridge/dblldefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/dblldefs.h
@@ -196,7 +196,7 @@ typedef void (*dbll_close_fxn) (struct dbll_library_obj *library);
  *      pattrs          - Attributes.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
+ *      -ENOMEM:    Memory allocation failed.
  *  Requires:
  *      DBL initialized.
  *      pattrs != NULL.
@@ -384,7 +384,7 @@ typedef dsp_status(*dbll_load_sect_fxn) (struct dbll_library_obj *lib,
  *      pLib            - Location to store library handle on output.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Memory allocation failure.
+ *      -ENOMEM:        Memory allocation failure.
  *      -EBADF:         File open failure.
  *      -EBADF:         File read failure.
  *      DSP_ECORRUPTFILE:   Unable to determine target type.
diff --git a/arch/arm/plat-omap/include/dspbridge/dev.h b/arch/arm/plat-omap/include/dspbridge/dev.h
index 6bf3c48..4d6c7d4 100644
--- a/arch/arm/plat-omap/include/dspbridge/dev.h
+++ b/arch/arm/plat-omap/include/dspbridge/dev.h
@@ -75,7 +75,7 @@ extern u32 dev_brd_write_fxn(void *pArb,
  *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
- *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      -ENOMEM:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
  *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
@@ -120,7 +120,7 @@ extern dsp_status dev_create_device(OUT struct dev_object
  *      dev_node_obj:       Platform (Windows) specific device node.
  *  Returns:
  *      DSP_SOK:            Module is loaded, device object has been created
- *      DSP_EMEMORY:        Insufficient memory to create needed resources.
+ *      -ENOMEM:        Insufficient memory to create needed resources.
  *      DEV_E_NEWWMD:       The WMD was compiled for a newer version of WCD.
  *      DEV_E_NULLWMDINTF:  WMD passed back a NULL fxn Interface Struct Ptr
  *      DEV_E_NOCODMODULE:  No ZL file name was specified in the registry
diff --git a/arch/arm/plat-omap/include/dspbridge/disp.h b/arch/arm/plat-omap/include/dspbridge/disp.h
index 23fcefd..c974f60 100644
--- a/arch/arm/plat-omap/include/dspbridge/disp.h
+++ b/arch/arm/plat-omap/include/dspbridge/disp.h
@@ -37,7 +37,7 @@
  *      pDispAttrs:     Node dispatcher attributes.
  *  Returns:
  *      DSP_SOK:                Success;
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      -ENOMEM:            Insufficient memory for requested resources.
  *      -EPERM:              Unable to create dispatcher.
  *  Requires:
  *      disp_init(void) called.
diff --git a/arch/arm/plat-omap/include/dspbridge/drv.h b/arch/arm/plat-omap/include/dspbridge/drv.h
index 778b57d..80c7e8b 100644
--- a/arch/arm/plat-omap/include/dspbridge/drv.h
+++ b/arch/arm/plat-omap/include/dspbridge/drv.h
@@ -159,7 +159,7 @@ struct process_context {
  *      phDrvObject:    Location to store created DRV Object handle.
  *  Returns:
  *      DSP_SOK:        Sucess
- *      DSP_EMEMORY:    Failed in Memory allocation
+ *      -ENOMEM:    Failed in Memory allocation
  *      -EPERM:      General Failure
  *  Requires:
  *      DRV Initialized (refs > 0 )
diff --git a/arch/arm/plat-omap/include/dspbridge/io.h b/arch/arm/plat-omap/include/dspbridge/io.h
index 6b51274..f41f243 100644
--- a/arch/arm/plat-omap/include/dspbridge/io.h
+++ b/arch/arm/plat-omap/include/dspbridge/io.h
@@ -39,7 +39,7 @@
  *      pMgrAttrs->word_size:   DSP Word size in equivalent PC bytes..
  *  Returns:
  *      DSP_SOK:                Success;
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      -ENOMEM:            Insufficient memory for requested resources.
  *      CHNL_E_ISR:             Unable to plug channel ISR for configured IRQ.
  *      CHNL_E_INVALIDIRQ:      Invalid IRQ number. Must be 0 <= birq <= 15.
  *      CHNL_E_INVALIDWORDSIZE: Invalid DSP word size.  Must be > 0.
diff --git a/arch/arm/plat-omap/include/dspbridge/mgr.h b/arch/arm/plat-omap/include/dspbridge/mgr.h
index 31be765..d141c5b 100644
--- a/arch/arm/plat-omap/include/dspbridge/mgr.h
+++ b/arch/arm/plat-omap/include/dspbridge/mgr.h
@@ -53,7 +53,7 @@ dsp_status mgr_wait_for_bridge_events(struct dsp_notification
  *      dev_node_obj:       Device object as known to Windows system.
  *  Returns:
  *      DSP_SOK:        Success
- *      DSP_EMEMORY:    Failed to Create the Object
+ *      -ENOMEM:    Failed to Create the Object
  *      -EPERM:      General Failure
  *  Requires:
  *      MGR Initialized (refs > 0 )
diff --git a/arch/arm/plat-omap/include/dspbridge/nldrdefs.h b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
index e55634b..ccf9e45 100644
--- a/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
+++ b/arch/arm/plat-omap/include/dspbridge/nldrdefs.h
@@ -117,7 +117,7 @@ enum nldr_phase {
  *      pf_phase_split:   pointer to boolean variable referenced in node.c
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      -ENOMEM:    Insufficient memory on GPP.
  *  Requires:
  *      nldr_init(void) called.
  *      Valid nldr_obj.
@@ -146,7 +146,7 @@ typedef dsp_status(*nldr_allocatefxn) (struct nldr_object *nldr_obj,
  *      pattrs:         Loader attributes.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      -ENOMEM:    Insufficient memory for requested resources.
  *  Requires:
  *      nldr_init(void) called.
  *      phNldr != NULL.
@@ -246,7 +246,7 @@ typedef bool(*nldr_initfxn) (void);
  *      phase:          Type of function to load (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EMEMORY:            Insufficient memory on GPP.
+ *      -ENOMEM:            Insufficient memory on GPP.
  *      DSP_EOVERLAYMEMORY:     Can't overlay phase because overlay memory
  *                              is already in use.
  *      DSP_EDYNLOAD:           Failure in dynamic loader library.
@@ -268,7 +268,7 @@ typedef dsp_status(*nldr_loadfxn) (struct nldr_nodeobject *nldr_node_obj,
  *      phase:          Node function to unload (create, delete, or execute).
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      -ENOMEM:    Insufficient memory on GPP.
  *  Requires:
  *      nldr_init(void) called.
  *      Valid nldr_node_obj.
diff --git a/arch/arm/plat-omap/include/dspbridge/node.h b/arch/arm/plat-omap/include/dspbridge/node.h
index 17c164e..7458a62 100644
--- a/arch/arm/plat-omap/include/dspbridge/node.h
+++ b/arch/arm/plat-omap/include/dspbridge/node.h
@@ -39,7 +39,7 @@
  *      ph_node:             Location to store node handle on output.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory on GPP.
+ *      -ENOMEM:        Insufficient memory on GPP.
  *      -ENOKEY:          Node UUID has not been registered.
  *      DSP_ESYMBOL:        iAlg functions not found for a DAIS node.
  *      -EDOM:         attr_in != NULL and attr_in->prio out of
@@ -77,7 +77,7 @@ extern dsp_status node_allocate(struct proc_object *hprocessor,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid node handle.
- *      DSP_EMEMORY:    Insufficent memory.
+ *      -ENOMEM:    Insufficent memory.
  *      -EPERM:      General Failure.
  *      -EINVAL:      Invalid Size.
  *  Requires:
@@ -166,7 +166,7 @@ extern dsp_status node_close_orphans(struct node_mgr *hnode_mgr,
  *  Returns:
  *      DSP_SOK:                Success.
  *      DSP_EHANDLE:            Invalid hNode1 or hNode2.
- *      DSP_EMEMORY:            Insufficient host memory.
+ *      -ENOMEM:            Insufficient host memory.
  *      -EINVAL:             A stream index parameter is invalid.
  *      DSP_EALREADYCONNECTED:  A connection already exists for one of the
  *                              indices uStream1 or uStream2.
@@ -201,7 +201,7 @@ extern dsp_status node_connect(struct node_object *hNode1,
  *      DSP_EHANDLE:        Invalid hnode.
  *      DSP_ESYMBOL:        Create function not found in the COFF file.
  *      DSP_EWRONGSTATE:    Node is not in the NODE_ALLOCATED state.
- *      DSP_EMEMORY:        Memory allocation failure on the DSP.
+ *      -ENOMEM:        Memory allocation failure on the DSP.
  *      DSP_ETASK:          Unable to create node's task or process on the DSP.
  *      DSP_ESTREAM:        Stream creation failure on the DSP.
  *      -ETIME:       A timeout occurred before the DSP responded.
@@ -226,7 +226,7 @@ extern dsp_status node_create(struct node_object *hnode);
  *      hdev_obj:     Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      -ENOMEM:    Insufficient memory for requested resources.
  *      -EPERM:      General failure.
  *  Requires:
  *      node_init(void) called.
@@ -491,7 +491,7 @@ extern dsp_status node_put_message(struct node_object *hnode,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hnode.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      -ENOMEM:    Insufficient memory on GPP.
  *      -EINVAL:     event_mask is invalid.
  *      -ENOSYS:   Notification type specified by notify_type is not
  *                      supported.
diff --git a/arch/arm/plat-omap/include/dspbridge/ntfy.h b/arch/arm/plat-omap/include/dspbridge/ntfy.h
index dfda615..5af4d17 100644
--- a/arch/arm/plat-omap/include/dspbridge/ntfy.h
+++ b/arch/arm/plat-omap/include/dspbridge/ntfy.h
@@ -170,7 +170,7 @@ static  inline dsp_status ntfy_register(struct ntfy_object *ntfy_obj,
 	}
 	ne = ntfy_event_create(event, type);
 	if (!ne) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	noti->handle = &ne->sync_obj;
diff --git a/arch/arm/plat-omap/include/dspbridge/proc.h b/arch/arm/plat-omap/include/dspbridge/proc.h
index f0b26ec..33ce720 100644
--- a/arch/arm/plat-omap/include/dspbridge/proc.h
+++ b/arch/arm/plat-omap/include/dspbridge/proc.h
@@ -512,7 +512,7 @@ extern dsp_status proc_invalidate_memory(void *hprocessor,
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
  *      -EPERM       :   General failure.
- *      DSP_EMEMORY     :   MPU side memory allocation error.
+ *      -ENOMEM     :   MPU side memory allocation error.
  *      DSP_ENOTFOUND   :   Cannot find a reserved region starting with this
  *		      :   address.
  *  Requires:
@@ -542,7 +542,7 @@ extern dsp_status proc_map(void *hprocessor,
  *      DSP_SOK	 :   Success.
  *      DSP_EHANDLE     :   Invalid processor handle.
  *      -EPERM       :   General failure.
- *      DSP_EMEMORY     :   Cannot reserve chunk of this size.
+ *      -ENOMEM     :   Cannot reserve chunk of this size.
  *  Requires:
  *      pp_rsv_addr is not NULL
  *      PROC Initialized.
diff --git a/arch/arm/plat-omap/include/dspbridge/rmm.h b/arch/arm/plat-omap/include/dspbridge/rmm.h
index b22b5c5..aca319f 100644
--- a/arch/arm/plat-omap/include/dspbridge/rmm.h
+++ b/arch/arm/plat-omap/include/dspbridge/rmm.h
@@ -62,7 +62,7 @@ struct rmm_target_obj;
  *      reserve         - If TRUE, reserve the memory specified by dspAddr.
  *  Returns:
  *      DSP_SOK:                Success.
- *      DSP_EMEMORY:            Memory allocation on GPP failed.
+ *      -ENOMEM:            Memory allocation on GPP failed.
  *      DSP_EOVERLAYMEMORY:     Cannot "allocate" overlay memory because it's
  *                              already in use.
  *  Requires:
@@ -88,7 +88,7 @@ extern dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
  *      num_segs:        - Number of memory segments.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failed.
+ *      -ENOMEM:    Memory allocation failed.
  *  Requires:
  *      RMM initialized.
  *      target_obj != NULL.
diff --git a/arch/arm/plat-omap/include/dspbridge/strm.h b/arch/arm/plat-omap/include/dspbridge/strm.h
index 4305cb8..a18e2f3 100644
--- a/arch/arm/plat-omap/include/dspbridge/strm.h
+++ b/arch/arm/plat-omap/include/dspbridge/strm.h
@@ -36,7 +36,7 @@
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EMEMORY:    Insufficient memory.
+ *      -ENOMEM:    Insufficient memory.
  *      -EPERM:      Failure occurred, unable to allocate buffers.
  *      -EINVAL:      usize must be > 0 bytes.
  *  Requires:
@@ -80,7 +80,7 @@ extern dsp_status strm_close(struct strm_object *hStrm,
  *      dev_obj:           Device for this processor.
  *  Returns:
  *      DSP_SOK:        Success;
- *      DSP_EMEMORY:    Insufficient memory for requested resources.
+ *      -ENOMEM:    Insufficient memory for requested resources.
  *      -EPERM:      General failure.
  *  Requires:
  *      strm_init(void) called.
@@ -338,7 +338,7 @@ extern dsp_status strm_reclaim(struct strm_object *hStrm,
  *  Returns:
  *      DSP_SOK:        Success.
  *      DSP_EHANDLE:    Invalid hStrm.
- *      DSP_EMEMORY:    Insufficient memory on GPP.
+ *      -ENOMEM:    Insufficient memory on GPP.
  *      -EINVAL:     event_mask is invalid.
  *      -ENOSYS:   Notification type specified by notify_type is not
  *                      supported.
diff --git a/arch/arm/plat-omap/include/dspbridge/wmd.h b/arch/arm/plat-omap/include/dspbridge/wmd.h
index 455afa0..e691cbb 100644
--- a/arch/arm/plat-omap/include/dspbridge/wmd.h
+++ b/arch/arm/plat-omap/include/dspbridge/wmd.h
@@ -308,7 +308,7 @@ typedef dsp_status(*fxn_brd_write) (struct wmd_dev_context *hDevContext,
  *      pMgrAttrs->usm_length: Bytes of shared memory block.
  *  Returns:
  *      DSP_SOK:            Success;
- *      DSP_EMEMORY:        Insufficient memory for requested resources.
+ *      -ENOMEM:        Insufficient memory for requested resources.
  *      CHNL_E_ISR:         Unable to plug ISR for given IRQ.
  *      CHNL_E_NOMEMMAP:    Couldn't map physical address to a virtual one.
  *  Requires:
@@ -390,7 +390,7 @@ typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
  *  Returns:
  *      DSP_SOK:                Success.
  *      DSP_EHANDLE:            hchnl_mgr is invalid.
- *      DSP_EMEMORY:            Insufficient memory for requested resources.
+ *      -ENOMEM:            Insufficient memory for requested resources.
  *      DSP_EINVALIDARG:        Invalid number of IOReqs.
  *      CHNL_E_OUTOFSTREAMS:    No free channels available.
  *      CHNL_E_BADCHANID:       Channel ID is out of range.
@@ -630,7 +630,7 @@ typedef dsp_status(*fxn_chnl_idle) (struct chnl_object *chnl_obj,
  *      hnotification:  Handle of a dsp_notification object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory.
+ *      -ENOMEM:    Insufficient memory.
  *      -EINVAL:     event_mask is 0 and hnotification was not
  *                      previously registered.
  *      DSP_EHANDLE:    NULL hnotification, hnotification event name
@@ -659,7 +659,7 @@ typedef dsp_status(*fxn_chnl_registernotify)
  *                      device.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Unable to allocate memory for device context.
+ *      -ENOMEM:        Unable to allocate memory for device context.
  *      WMD_E_BADCONFIG:    One or more of the host or DSP configuration
  *                          parameters did not satisfy hardware assumptions
  *                          made by this WMD.
@@ -672,7 +672,7 @@ typedef dsp_status(*fxn_chnl_registernotify)
  *  Ensures:
  *      DSP_SOK:        All mini-driver specific DSP resource and other
  *                      board context has been allocated.
- *      DSP_EMEMORY:    WMD failed to allocate resources.
+ *      -ENOMEM:    WMD failed to allocate resources.
  *                      Any acquired resources have been freed.  The WCD will
  *                      not call bridge_dev_destroy() if bridge_dev_create()
  *                      fails.
@@ -740,7 +740,7 @@ typedef dsp_status(*fxn_dev_destroy) (struct wmd_dev_context *hDevContext);
  *      hdev_obj:     Handle to DEV object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
+ *      -ENOMEM:    Memory allocation failure.
  *      -EPERM:      Creation failed.
  *  Requires:
  *      hdev_obj != NULL;
@@ -810,7 +810,7 @@ typedef dsp_status(*fxn_deh_getinfo) (struct deh_mgr *phDehMgr,
  *      hmsg_mgr:        Handle to message manager.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
+ *      -ENOMEM:    Memory allocation failure.
  *      -EPERM:      Creation failed.
  *  Requires:
  *      hdev_obj != NULL;
@@ -832,7 +832,7 @@ typedef dsp_status(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
  *      hio_mgr:         IO Manager.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Memory allocation failure.
+ *      -ENOMEM:    Memory allocation failure.
  *      -EPERM:      Creation failed.
  *  Requires:
  *      Valid hio_mgr;
@@ -886,7 +886,7 @@ typedef dsp_status(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
  *      msgCallback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
+ *      -ENOMEM:        Insufficient memory.
  *  Requires:
  *      phMsgMgr != NULL.
  *      msgCallback != NULL.
@@ -911,7 +911,7 @@ typedef dsp_status(*fxn_msg_create)
  *      h:                  Handle passed to hmsg_mgr->msgCallback().
  *  Returns:
  *      DSP_SOK:            Success.
- *      DSP_EMEMORY:        Insufficient memory.
+ *      -ENOMEM:        Insufficient memory.
  *  Requires:
  *      phMsgQueue != NULL.
  *      h != NULL.
@@ -1007,7 +1007,7 @@ typedef dsp_status(*fxn_msg_put) (struct msg_queue *msg_queue_obj,
  *      hnotification:  Handle of notification object.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Insufficient memory.
+ *      -ENOMEM:    Insufficient memory.
  *  Requires:
  *      Valid msg_queue_obj.
  *      hnotification != NULL.
diff --git a/drivers/dsp/bridge/pmgr/cmm.c b/drivers/dsp/bridge/pmgr/cmm.c
index 0ef6024..5fb5a3a 100644
--- a/drivers/dsp/bridge/pmgr/cmm.c
+++ b/drivers/dsp/bridge/pmgr/cmm.c
@@ -290,7 +290,7 @@ dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
 					mem_calloc(sizeof(struct lst_list),
 						   MEM_NONPAGED);
 			if (cmm_obj->node_free_list_head == NULL)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			else
 				INIT_LIST_HEAD(&cmm_obj->
 					       node_free_list_head->head);
@@ -304,7 +304,7 @@ dsp_status cmm_create(OUT struct cmm_object **ph_cmm_mgr,
 			cmm_destroy(cmm_obj, true);
 
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	return status;
 }
@@ -613,7 +613,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 								 lst_list),
 							  MEM_NONPAGED);
 			if (psma->free_list_head == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_end;
 			}
 			INIT_LIST_HEAD(&psma->free_list_head->head);
@@ -624,7 +624,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 								   lst_list),
 							    MEM_NONPAGED);
 			if (psma->in_use_list_head == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_end;
 			}
 			INIT_LIST_HEAD(&psma->in_use_list_head->head);
@@ -638,7 +638,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 				lst_put_tail(psma->free_list_head,
 					     (struct list_head *)new_node);
 			} else {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_end;
 			}
 		}
@@ -647,7 +647,7 @@ dsp_status cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 			un_register_gppsm_seg(psma);
 		}
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	/* make entry */
@@ -989,7 +989,7 @@ dsp_status cmm_xlator_create(OUT struct cmm_xlatorobject **phXlator,
 		/* SM seg_id */
 		xlator_object->ul_seg_id = pXlatorAttrs->ul_seg_id;
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	if (DSP_SUCCEEDED(status))
 		*phXlator = (struct cmm_xlatorobject *)xlator_object;
diff --git a/drivers/dsp/bridge/pmgr/cod.c b/drivers/dsp/bridge/pmgr/cod.c
index 0f2e2a1..468c938 100644
--- a/drivers/dsp/bridge/pmgr/cod.c
+++ b/drivers/dsp/bridge/pmgr/cod.c
@@ -236,7 +236,7 @@ dsp_status cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
 
 	mgr_new = mem_calloc(sizeof(struct cod_manager), MEM_NONPAGED);
 	if (mgr_new == NULL)
-		return DSP_EMEMORY;
+		return -ENOMEM;
 
 	mgr_new->ul_magic = MAGIC;
 
@@ -568,7 +568,7 @@ dsp_status cod_open(struct cod_manager *hmgr, IN char *pszCoffPath,
 
 	lib = mem_calloc(sizeof(struct cod_libraryobj), MEM_NONPAGED);
 	if (lib == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		lib->cod_mgr = hmgr;
diff --git a/drivers/dsp/bridge/pmgr/dbll.c b/drivers/dsp/bridge/pmgr/dbll.c
index 28b71b2..f058195 100644
--- a/drivers/dsp/bridge/pmgr/dbll.c
+++ b/drivers/dsp/bridge/pmgr/dbll.c
@@ -260,7 +260,7 @@ dsp_status dbll_create(struct dbll_tar_obj **target_obj,
 	if (target_obj != NULL) {
 		if (pzl_target == NULL) {
 			*target_obj = NULL;
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			pzl_target->attrs = *pattrs;
 			*target_obj = (struct dbll_tar_obj *)pzl_target;
@@ -489,7 +489,7 @@ dsp_status dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 						    name_hash,
 						    name_match, sym_delete);
 			if (zl_lib->sym_tab == NULL)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 
 		}
 		/*
@@ -623,7 +623,7 @@ dsp_status dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
 		MEM_ALLOC_OBJECT(zl_lib, struct dbll_library_obj,
 				 DBLL_LIBSIGNATURE);
 		if (zl_lib == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			zl_lib->ul_pos = 0;
 			/* Increment ref count to allow close on failure
@@ -634,7 +634,7 @@ dsp_status dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
 			zl_lib->file_name = mem_calloc(strlen(file) + 1,
 						       MEM_PAGED);
 			if (zl_lib->file_name == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			} else {
 				strncpy(zl_lib->file_name, file,
 					strlen(file) + 1);
@@ -685,7 +685,7 @@ dsp_status dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
 	    gh_create(MAXBUCKETS, sizeof(struct dbll_symbol), name_hash,
 		      name_match, sym_delete);
 	if (zl_lib->sym_tab == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	} else {
 		/* Do a fake load to get symbols - set write func to no_op */
 		zl_lib->init.dl_init.writemem = no_op;
@@ -1275,7 +1275,7 @@ static int dbll_rmm_alloc(struct dynamic_loader_allocate *this,
 
 	if (sz_sect_name == NULL || sz_sec_last_token == NULL ||
 	    sz_last_token == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_cont;
 	}
 	strncpy(sz_sect_name, (char *)(info->name), token_len);
diff --git a/drivers/dsp/bridge/pmgr/dev.c b/drivers/dsp/bridge/pmgr/dev.c
index 806ee9c..4284069 100644
--- a/drivers/dsp/bridge/pmgr/dev.c
+++ b/drivers/dsp/bridge/pmgr/dev.c
@@ -187,7 +187,7 @@ dsp_status dev_create_device(OUT struct dev_object **phDevObject,
 			DBC_ASSERT(DSP_FAILED(status)
 				   || (dev_obj->hwmd_context != NULL));
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	}
 	/* Attempt to create the COD manager for this device: */
diff --git a/drivers/dsp/bridge/pmgr/dmm.c b/drivers/dsp/bridge/pmgr/dmm.c
index be84c1e..1e08711 100644
--- a/drivers/dsp/bridge/pmgr/dmm.c
+++ b/drivers/dsp/bridge/pmgr/dmm.c
@@ -104,7 +104,7 @@ dsp_status dmm_create_tables(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 		virtual_mapping_table = (struct map_page *)mem_calloc
 		    (table_size * sizeof(struct map_page), MEM_LARGEVIRTMEM);
 		if (virtual_mapping_table == NULL)
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		else {
 			/* On successful allocation,
 			 * all entries are zero ('free') */
@@ -141,7 +141,7 @@ dsp_status dmm_create(OUT struct dmm_object **phDmmMgr,
 		spin_lock_init(&dmm_obj->dmm_lock);
 		*phDmmMgr = dmm_obj;
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 
 	return status;
@@ -318,7 +318,7 @@ dsp_status dmm_reserve_memory(struct dmm_object *dmm_mgr, u32 size,
 		*prsv_addr = rsv_addr;
 	} else
 		/*dSP chunk of given size is not available */
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	spin_unlock(&dmm_obj->dmm_lock);
 
diff --git a/drivers/dsp/bridge/pmgr/wcd.c b/drivers/dsp/bridge/pmgr/wcd.c
index 06c4c7f..97a55a7 100644
--- a/drivers/dsp/bridge/pmgr/wcd.c
+++ b/drivers/dsp/bridge/pmgr/wcd.c
@@ -422,7 +422,7 @@ u32 mgrwrap_enum_node_info(union Trapped_Args *args, void *pr_ctxt)
 
 	pndb_props = mem_alloc(size, MEM_NONPAGED);
 	if (pndb_props == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		status =
@@ -454,7 +454,7 @@ u32 mgrwrap_enum_proc_info(union Trapped_Args *args, void *pr_ctxt)
 
 	processor_info = mem_alloc(size, MEM_NONPAGED);
 	if (processor_info == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		status =
@@ -622,7 +622,7 @@ u32 procwrap_ctrl(union Trapped_Args *args, void *pr_ctxt)
 		cb_data_size += sizeof(u32);
 		pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
 		if (pargs == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			goto func_end;
 		}
 
@@ -773,7 +773,7 @@ u32 procwrap_get_trace(union Trapped_Args *args, void *pr_ctxt)
 					pbuf,
 					args->args_proc_gettrace.max_size);
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	CP_TO_USR(args->args_proc_gettrace.pbuf, pbuf, status,
 		  args->args_proc_gettrace.max_size);
@@ -800,7 +800,7 @@ u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 
 	argv = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 	if (!argv) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_cont;
 	}
 
@@ -827,7 +827,7 @@ u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 					goto func_cont;
 				}
 			} else {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_cont;
 			}
 		}
@@ -842,7 +842,7 @@ u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 		} while (temp);
 		envp = mem_alloc(count * sizeof(u8 *), MEM_NONPAGED);
 		if (!envp) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			goto func_cont;
 		}
 
@@ -867,7 +867,7 @@ u32 procwrap_load(union Trapped_Args *args, void *pr_ctxt)
 					goto func_cont;
 				}
 			} else {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_cont;
 			}
 		}
@@ -1042,7 +1042,7 @@ u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 		if (DSP_SUCCEEDED(status)) {
 			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
 			if (pargs == NULL)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 
 		}
 		CP_FM_USR(pargs, args->args_node_allocate.pargs, status,
@@ -1058,7 +1058,7 @@ u32 nodewrap_allocate(union Trapped_Args *args, void *pr_ctxt)
 		if (DSP_SUCCEEDED(status))
 			attr_in = &proc_attr_in;
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -1143,7 +1143,7 @@ u32 nodewrap_connect(union Trapped_Args *args, void *pr_ctxt)
 		if (DSP_SUCCEEDED(status)) {
 			pargs = mem_alloc(cb_data_size, MEM_NONPAGED);
 			if (pargs == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				goto func_cont;
 			}
 
@@ -1359,7 +1359,7 @@ u32 nodewrap_get_uuid_props(union Trapped_Args *args, void *pr_ctxt)
 		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
 			  status, 1);
 	} else
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 func_cont:
 	kfree(pnode_props);
 	return status;
diff --git a/drivers/dsp/bridge/rmgr/dbdcd.c b/drivers/dsp/bridge/rmgr/dbdcd.c
index 012e5ea..ea7cbe1 100644
--- a/drivers/dsp/bridge/rmgr/dbdcd.c
+++ b/drivers/dsp/bridge/rmgr/dbdcd.c
@@ -153,7 +153,7 @@ dsp_status dcd_create_manager(IN char *pszZlDllName,
 		/* Return handle to this DCD interface. */
 		*phDcdMgr = dcd_mgr_obj;
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 		/*
 		 * If allocation of DcdManager object failed, delete the
@@ -164,7 +164,7 @@ dsp_status dcd_create_manager(IN char *pszZlDllName,
 
 	DBC_ENSURE((DSP_SUCCEEDED(status)) || ((cod_mgr == NULL) &&
 					       (status == -EPERM))
-		   || ((dcd_mgr_obj == NULL) && (status == DSP_EMEMORY)));
+		   || ((dcd_mgr_obj == NULL) && (status == -ENOMEM)));
 
 func_end:
 	return status;
@@ -389,7 +389,7 @@ dsp_status dcd_get_object_def(IN struct dcd_manager *hdcd_mgr,
 
 	sz_uuid = (char *)mem_calloc(MAXUUIDLEN, MEM_PAGED);
 	if (!sz_uuid) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 
@@ -1322,7 +1322,7 @@ static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
 	/* Allocate a buffer for file name */
 	psz_file_name = mem_calloc(dw_data_size, MEM_PAGED);
 	if (psz_file_name == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	} else {
 		/* Get the name of the library */
 		status = dcd_get_library_name(hdcd_mgr, uuid_obj, psz_file_name,
@@ -1351,7 +1351,7 @@ static dsp_status get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
 	/* Allocate zeroed buffer. */
 	psz_coff_buf = mem_calloc(ul_len + 4, MEM_PAGED);
 	if (psz_coff_buf == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	/* Read section contents. */
 	status = cod_read_section(lib, DEPLIBSECT, psz_coff_buf, ul_len);
diff --git a/drivers/dsp/bridge/rmgr/disp.c b/drivers/dsp/bridge/rmgr/disp.c
index 7f5c610..48598dd 100644
--- a/drivers/dsp/bridge/rmgr/disp.c
+++ b/drivers/dsp/bridge/rmgr/disp.c
@@ -112,7 +112,7 @@ dsp_status disp_create(OUT struct disp_object **phDispObject,
 	/* Allocate Node Dispatcher object */
 	MEM_ALLOC_OBJECT(disp_obj, struct disp_object, DISP_SIGNATURE);
 	if (disp_obj == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	else
 		disp_obj->hdev_obj = hdev_obj;
 
@@ -166,7 +166,7 @@ dsp_status disp_create(OUT struct disp_object **phDispObject,
 		disp_obj->ul_bufsize_rms = RMS_COMMANDBUFSIZE;
 		disp_obj->pbuf = mem_calloc(disp_obj->ul_bufsize, MEM_PAGED);
 		if (disp_obj->pbuf == NULL)
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status))
diff --git a/drivers/dsp/bridge/rmgr/drv.c b/drivers/dsp/bridge/rmgr/drv.c
index 4b0687b..c556954 100644
--- a/drivers/dsp/bridge/rmgr/drv.c
+++ b/drivers/dsp/bridge/rmgr/drv.c
@@ -454,10 +454,10 @@ dsp_status drv_create(OUT struct drv_object **phDRVObject)
 				INIT_LIST_HEAD(&pdrv_object->dev_list->head);
 			}
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	/* Store the DRV Object in the Registry */
 	if (DSP_SUCCEEDED(status))
@@ -766,7 +766,7 @@ dsp_status drv_request_resources(u32 dw_context, u32 *pDevNodeString)
 			lst_put_tail(pdrv_object->dev_node_string,
 				     (struct list_head *)pszdev_node);
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			*pDevNodeString = 0;
 		}
 	} else {
@@ -933,7 +933,7 @@ static dsp_status request_bridge_resources(u32 dw_context, s32 bRequest)
 			/*  Set all the other entries to NULL */
 			kfree(host_res);
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 		return status;
 	}
@@ -1059,7 +1059,7 @@ static dsp_status request_bridge_resources_dsp(u32 dw_context, s32 bRequest)
 			    (u32) mem_alloc_phys_mem(shm_size, 0x100000,
 						     &dma_addr);
 			if (host_res->dw_mem_base[1] == 0) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				pr_err("shm reservation Failed\n");
 			} else {
 				host_res->dw_mem_length[1] = shm_size;
diff --git a/drivers/dsp/bridge/rmgr/mgr.c b/drivers/dsp/bridge/rmgr/mgr.c
index 5fb177f..dd03d3e 100644
--- a/drivers/dsp/bridge/rmgr/mgr.c
+++ b/drivers/dsp/bridge/rmgr/mgr.c
@@ -82,7 +82,7 @@ dsp_status mgr_create(OUT struct mgr_object **phMgrObject,
 			MEM_FREE_OBJECT(pmgr_obj);
 		}
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 
 	DBC_ENSURE(DSP_FAILED(status) ||
diff --git a/drivers/dsp/bridge/rmgr/nldr.c b/drivers/dsp/bridge/rmgr/nldr.c
index dc0006b..4ff4cdc 100644
--- a/drivers/dsp/bridge/rmgr/nldr.c
+++ b/drivers/dsp/bridge/rmgr/nldr.c
@@ -351,7 +351,7 @@ dsp_status nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 			 NLDR_NODESIGNATURE);
 
 	if (nldr_node_obj == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	} else {
 		nldr_node_obj->pf_phase_split = pf_phase_split;
 		nldr_node_obj->pers_libs = 0;
@@ -481,10 +481,10 @@ dsp_status nldr_create(OUT struct nldr_object **phNldr,
 		nldr_obj->us_dsp_word_size = pattrs->us_dsp_word_size;
 		nldr_obj->ldr_fxns = ldr_fxns;
 		if (!(nldr_obj->ldr_fxns.init_fxn()))
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	/* Create the DCD Manager */
 	if (DSP_SUCCEEDED(status))
@@ -501,7 +501,7 @@ dsp_status nldr_create(OUT struct nldr_object **phNldr,
 			    mem_calloc(ul_len * nldr_obj->us_dsp_mau_size,
 				       MEM_PAGED);
 			if (!psz_coff_buf)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 		} else {
 			/* Ok to not have dynamic loading memory */
 			status = DSP_SOK;
@@ -530,7 +530,7 @@ dsp_status nldr_create(OUT struct nldr_object **phNldr,
 		nldr_obj->seg_table =
 		    mem_calloc(sizeof(u32) * dload_segs, MEM_PAGED);
 		if (rmm_segs == NULL || nldr_obj->seg_table == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			nldr_obj->dload_segs = dload_segs;
 			mem_info_obj = (struct mem_seg_info *)(psz_coff_buf +
@@ -1057,7 +1057,7 @@ static dsp_status add_ovly_node(struct dsp_uuid *uuid_obj,
 			node_name = obj_def.obj_data.node_obj.ndb_props.ac_name;
 			pbuf = mem_calloc(len + 1, MEM_PAGED);
 			if (pbuf == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			} else {
 				strncpy(pbuf, node_name, len);
 				nldr_obj->ovly_table[nldr_obj->ovly_nid].
@@ -1112,7 +1112,7 @@ static dsp_status add_ovly_sect(struct nldr_object *nldr_obj,
 		/* New section */
 		new_sect = mem_calloc(sizeof(struct ovly_sect), MEM_PAGED);
 		if (new_sect == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			new_sect->sect_load_addr = addr;
 			new_sect->sect_run_addr = pSectInfo->sect_run_addr +
@@ -1283,7 +1283,7 @@ static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
 	/* Allocate a buffer for library file name of size DBL_MAXPATHLENGTH */
 	psz_file_name = mem_calloc(DBLL_MAXPATHLENGTH, MEM_PAGED);
 	if (psz_file_name == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Get the name of the library */
@@ -1353,7 +1353,7 @@ static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
 			persistent_dep_libs =
 			    mem_calloc(sizeof(bool) * nd_libs, MEM_PAGED);
 			if (!dep_lib_uui_ds || !persistent_dep_libs)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 
 			if (root->dep_libs > 0) {
 				/* Allocate arrays for dependent lib UUIDs,
@@ -1362,7 +1362,7 @@ static dsp_status load_lib(struct nldr_nodeobject *nldr_node_obj,
 				    (sizeof(struct lib_node) *
 				     (root->dep_libs), MEM_PAGED);
 				if (!(root->dep_libs_tree))
-					status = DSP_EMEMORY;
+					status = -ENOMEM;
 
 			}
 
@@ -1650,7 +1650,7 @@ static dsp_status remote_alloc(void **pRef, u16 space, u32 size,
 	u32 word_size;
 	struct rmm_addr *rmm_addr_obj = (struct rmm_addr *)dspAddr;
 	bool mem_load_req = false;
-	dsp_status status = DSP_EMEMORY;	/* Set to fail */
+	dsp_status status = -ENOMEM;	/* Set to fail */
 	DBC_REQUIRE(MEM_IS_VALID_HANDLE(hnode, NLDR_NODESIGNATURE));
 	DBC_REQUIRE(space == DBLL_CODE || space == DBLL_DATA ||
 		    space == DBLL_BSS);
@@ -1734,7 +1734,7 @@ static dsp_status remote_alloc(void **pRef, u16 space, u32 size,
 	}
 func_cont:
 	/* Haven't found memory yet, attempt to find any segment that works */
-	if (status == DSP_EMEMORY && !mem_load_req) {
+	if (status == -ENOMEM && !mem_load_req) {
 		dev_dbg(bridge, "%s: Preferred segment unavailable, trying "
 			"another\n", __func__);
 		for (i = 0; i < nldr_obj->dload_segs; i++) {
@@ -1762,7 +1762,7 @@ static dsp_status remote_free(void **pRef, u16 space, u32 dspAddr,
 	struct nldr_object *nldr_obj = (struct nldr_object *)pRef;
 	struct rmm_target_obj *rmm;
 	u32 word_size;
-	dsp_status status = DSP_EMEMORY;	/* Set to fail */
+	dsp_status status = -ENOMEM;	/* Set to fail */
 
 	DBC_REQUIRE(MEM_IS_VALID_HANDLE(nldr_obj, NLDR_SIGNATURE));
 
diff --git a/drivers/dsp/bridge/rmgr/node.c b/drivers/dsp/bridge/rmgr/node.c
index e39c555..be46a75 100644
--- a/drivers/dsp/bridge/rmgr/node.c
+++ b/drivers/dsp/bridge/rmgr/node.c
@@ -383,7 +383,7 @@ dsp_status node_allocate(struct proc_object *hprocessor,
 
 	MEM_ALLOC_OBJECT(pnode, struct node_object, NODE_SIGNATURE);
 	if (pnode == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	pnode->hnode_mgr = hnode_mgr;
@@ -477,7 +477,7 @@ func_cont:
 		if (pnode->ntfy_obj)
 			ntfy_init(pnode->ntfy_obj);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -490,7 +490,7 @@ func_cont:
 					sizeof(struct dsp_streamconnect),
 					MEM_PAGED);
 			if (num_streams > 0 && pnode->stream_connect == NULL)
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 
 		}
 		if (DSP_SUCCEEDED(status) && (node_type == NODE_TASK ||
@@ -515,7 +515,7 @@ func_cont:
 			    || (MAX_OUTPUTS(pnode) > 0
 				&& (pnode->outputs == NULL
 				    || ptask_args->strm_out_def == NULL)))
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 		}
 	}
 	if (DSP_SUCCEEDED(status) && (node_type != NODE_DEVICE)) {
@@ -526,7 +526,7 @@ func_cont:
 		if (pnode->sync_done)
 			sync_init_event(pnode->sync_done);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 
 		if (DSP_SUCCEEDED(status)) {
 			/*Get the shared mem mgr for this nodes dev object */
@@ -546,7 +546,7 @@ func_cont:
 				pmsg_args->pdata =
 				    mem_calloc(pargs->cb_data, MEM_PAGED);
 				if (pmsg_args->pdata == NULL) {
-					status = DSP_EMEMORY;
+					status = -ENOMEM;
 				} else {
 					pmsg_args->arg_length = pargs->cb_data;
 					memcpy(pmsg_args->pdata,
@@ -758,7 +758,7 @@ DBAPI node_alloc_msg_buf(struct node_object *hnode, u32 usize,
 			if (*pbuffer == NULL) {
 				pr_err("%s: error - Out of shared memory\n",
 				       __func__);
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			}
 		}
 	}
@@ -975,7 +975,7 @@ dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
 				output->sz_device = NULL;
 				input->sz_device = NULL;
 				gb_clear(hnode_mgr->pipe_map, pipe_id);
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			} else {
 				/* Copy "/dbpipe<pipId>" name to device names */
 				sprintf(output->sz_device, "%s%d",
@@ -1049,7 +1049,7 @@ dsp_status node_connect(struct node_object *hNode1, u32 uStream1,
 		} else {
 			gb_clear(hnode_mgr->chnl_map, chnl_id);
 		}
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 func_cont2:
 		if (DSP_SUCCEEDED(status)) {
 			if (hNode1 == (struct node_object *)DSP_HGPPNODE) {
@@ -1092,7 +1092,7 @@ func_cont2:
 							  MEM_PAGED);
 		}
 		if (pstrm_def->sz_device == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			/* Copy device name */
 			strncpy(pstrm_def->sz_device,
@@ -1330,7 +1330,7 @@ dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
 		if (node_mgr_obj->node_list == NULL
 		    || node_mgr_obj->pipe_map == NULL
 		    || node_mgr_obj->pipe_done_map == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			INIT_LIST_HEAD(&node_mgr_obj->node_list->head);
 			node_mgr_obj->ntfy_obj = kmalloc(
@@ -1338,11 +1338,11 @@ dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
 			if (node_mgr_obj->ntfy_obj)
 				ntfy_init(node_mgr_obj->ntfy_obj);
 			else
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 		}
 		node_mgr_obj->num_created = 0;
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	/* get devNodeType */
 	if (DSP_SUCCEEDED(status))
@@ -1384,7 +1384,7 @@ dsp_status node_create_mgr(OUT struct node_mgr **phNodeMgr,
 		if ((node_mgr_obj->chnl_map == NULL)
 		    || (node_mgr_obj->dma_chnl_map == NULL)
 		    || (node_mgr_obj->zc_chnl_map == NULL)) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			/* Block out reserved channels */
 			for (i = 0; i < node_mgr_obj->ul_chnl_offset; i++)
@@ -2942,7 +2942,7 @@ static dsp_status get_node_props(struct dcd_manager *hdcd_mgr,
 			DBC_ASSERT(len < MAXDEVNAMELEN);
 			hnode->pstr_dev_name = mem_calloc(len + 1, MEM_PAGED);
 			if (hnode->pstr_dev_name == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			} else {
 				strncpy(hnode->pstr_dev_name,
 					pndb_props->ac_name, len);
diff --git a/drivers/dsp/bridge/rmgr/proc.c b/drivers/dsp/bridge/rmgr/proc.c
index eb57b4d..3834eb5 100644
--- a/drivers/dsp/bridge/rmgr/proc.c
+++ b/drivers/dsp/bridge/rmgr/proc.c
@@ -159,7 +159,7 @@ proc_attach(u32 processor_id,
 	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
 	/* Fill out the Processor Object: */
 	if (p_proc_object == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	p_proc_object->hdev_obj = hdev_obj;
@@ -196,7 +196,7 @@ proc_attach(u32 processor_id,
 	if (p_proc_object->ntfy_obj)
 		ntfy_init(p_proc_object->ntfy_obj);
 	else
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* Insert the Processor Object into the DEV List.
@@ -294,7 +294,7 @@ dsp_status proc_auto_start(struct cfg_devnode *dev_node_obj,
 
 	MEM_ALLOC_OBJECT(p_proc_object, struct proc_object, PROC_SIGNATURE);
 	if (p_proc_object == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	p_proc_object->hdev_obj = hdev_obj;
@@ -904,7 +904,7 @@ dsp_status proc_load(void *hprocessor, IN CONST s32 argc_index,
 					       COD_SYMB);
 		}
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* Auto-register data base */
diff --git a/drivers/dsp/bridge/rmgr/rmm.c b/drivers/dsp/bridge/rmgr/rmm.c
index d5a8bfb..3147524 100644
--- a/drivers/dsp/bridge/rmgr/rmm.c
+++ b/drivers/dsp/bridge/rmgr/rmm.c
@@ -113,7 +113,7 @@ dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
 
 	if (!reserve) {
 		if (!alloc_block(target, segid, size, align, dspAddr)) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			/* Increment the number of allocated blocks in this
 			 * segment */
@@ -147,7 +147,7 @@ dsp_status rmm_alloc(struct rmm_target_obj *target, u32 segid, u32 size,
 		/* No overlap - allocate list element for new section. */
 		new_sect = mem_calloc(sizeof(struct rmm_ovly_sect), MEM_PAGED);
 		if (new_sect == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			lst_init_elem((struct list_head *)new_sect);
 			new_sect->addr = addr;
@@ -188,7 +188,7 @@ dsp_status rmm_create(struct rmm_target_obj **target_obj,
 	MEM_ALLOC_OBJECT(target, struct rmm_target_obj, RMM_TARGSIGNATURE);
 
 	if (target == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_FAILED(status))
 		goto func_cont;
@@ -201,14 +201,14 @@ dsp_status rmm_create(struct rmm_target_obj **target_obj,
 	target->free_list = mem_calloc(num_segs * sizeof(struct rmm_header *),
 				       MEM_PAGED);
 	if (target->free_list == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	} else {
 		/* Allocate headers for each element on the free list */
 		for (i = 0; i < (s32) num_segs; i++) {
 			target->free_list[i] =
 			    mem_calloc(sizeof(struct rmm_header), MEM_PAGED);
 			if (target->free_list[i] == NULL) {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 				break;
 			}
 		}
@@ -217,7 +217,7 @@ dsp_status rmm_create(struct rmm_target_obj **target_obj,
 					     sizeof(struct rmm_segment),
 					     MEM_PAGED);
 		if (target->seg_tab == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			/* Initialize segment table and free list */
 			sptr = target->seg_tab;
@@ -239,7 +239,7 @@ func_cont:
 		target->ovly_list = mem_calloc(sizeof(struct lst_list),
 					       MEM_NONPAGED);
 		if (target->ovly_list == NULL)
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		else
 			INIT_LIST_HEAD(&target->ovly_list->head);
 	}
diff --git a/drivers/dsp/bridge/rmgr/strm.c b/drivers/dsp/bridge/rmgr/strm.c
index 61ed363..7b40566 100644
--- a/drivers/dsp/bridge/rmgr/strm.c
+++ b/drivers/dsp/bridge/rmgr/strm.c
@@ -133,7 +133,7 @@ dsp_status strm_allocate_buffer(struct strm_object *hStrm, u32 usize,
 		DBC_ASSERT(hStrm->xlator != NULL);
 		(void)cmm_xlator_alloc_buf(hStrm->xlator, &ap_buffer[i], usize);
 		if (ap_buffer[i] == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			alloc_cnt = i;
 			break;
 		}
@@ -219,7 +219,7 @@ dsp_status strm_create(OUT struct strm_mgr **phStrmMgr,
 	/* Allocate STRM manager object */
 	MEM_ALLOC_OBJECT(strm_mgr_obj, struct strm_mgr, STRMMGR_SIGNATURE);
 	if (strm_mgr_obj == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	else
 		strm_mgr_obj->dev_obj = dev_obj;
 
@@ -503,7 +503,7 @@ dsp_status strm_open(struct node_object *hnode, u32 dir, u32 index,
 	if (DSP_SUCCEEDED(status)) {
 		MEM_ALLOC_OBJECT(strm_obj, struct strm_object, STRM_SIGNATURE);
 		if (strm_obj == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			strm_obj->strm_mgr_obj = strm_mgr_obj;
 			strm_obj->dir = dir;
@@ -582,7 +582,7 @@ func_cont:
 			 * over-ride non-returnable status codes so we return
 			 * something documented
 			 */
-			if (status != DSP_EMEMORY && status !=
+			if (status != -ENOMEM && status !=
 			    DSP_EINVALIDARG && status != -EPERM) {
 				/*
 				 * We got a status that's not return-able.
@@ -792,7 +792,7 @@ dsp_status strm_select(IN struct strm_object **strm_tab, u32 nStrms,
 			      sizeof(struct sync_object *), MEM_PAGED);
 
 		if (sync_events == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			for (i = 0; i < nStrms; i++) {
 				intf_fxns =
diff --git a/drivers/dsp/bridge/wmd/chnl_sm.c b/drivers/dsp/bridge/wmd/chnl_sm.c
index bb6b02a..3d020c4 100644
--- a/drivers/dsp/bridge/wmd/chnl_sm.c
+++ b/drivers/dsp/bridge/wmd/chnl_sm.c
@@ -149,7 +149,7 @@ dsp_status bridge_chnl_add_io_req(struct chnl_object *chnl_obj, void *pHostBuf,
 		/* if addr in user mode, then copy to kernel space */
 		host_sys_buf = mem_alloc(buf_size, MEM_NONPAGED);
 		if (host_sys_buf == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			goto func_end;
 		}
 		if (CHNL_IS_OUTPUT(pchnl->chnl_mode)) {
@@ -429,10 +429,10 @@ dsp_status bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
 			if (DSP_SUCCEEDED(status))
 				spin_lock_init(&chnl_mgr_obj->chnl_mgr_lock);
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 
 	if (DSP_FAILED(status)) {
@@ -823,7 +823,7 @@ dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
 	/* Create channel object: */
 	MEM_ALLOC_OBJECT(pchnl, struct chnl_object, 0x0000);
 	if (!pchnl) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	/* Protect queues from io_dpc: */
@@ -839,7 +839,7 @@ dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
 	if (sync_event)
 		sync_init_event(sync_event);
 	else
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		pchnl->ntfy_obj = kmalloc(sizeof(struct ntfy_object),
@@ -847,7 +847,7 @@ dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
 		if (pchnl->ntfy_obj)
 			ntfy_init(pchnl->ntfy_obj);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -866,7 +866,7 @@ dsp_status bridge_chnl_open(OUT struct chnl_object **phChnl,
 			/* Default to proc-copy */
 			pchnl->chnl_type = CHNL_PCPY;
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	}
 
diff --git a/drivers/dsp/bridge/wmd/io_sm.c b/drivers/dsp/bridge/wmd/io_sm.c
index c634f7c..bdc8a1b 100644
--- a/drivers/dsp/bridge/wmd/io_sm.c
+++ b/drivers/dsp/bridge/wmd/io_sm.c
@@ -211,7 +211,7 @@ dsp_status bridge_io_create(OUT struct io_mgr **phIOMgr,
 	/* Allocate IO manager object */
 	MEM_ALLOC_OBJECT(pio_mgr, struct io_mgr, IO_MGRSIGNATURE);
 	if (pio_mgr == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 
@@ -465,7 +465,7 @@ dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 			pr_err("%s: shm Error, reserved 0x%x required 0x%x\n",
 			       __func__, host_res.dw_mem_length[1],
 			       ul_seg_size + ul_seg1_size + ul_pad_size);
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	}
 	if (DSP_FAILED(status))
@@ -787,7 +787,7 @@ dsp_status bridge_io_on_loaded(struct io_mgr *hio_mgr)
 				    hio_mgr->ul_trace_buffer_begin) *
 				   hio_mgr->word_size) + 2, MEM_NONPAGED);
 	if (!hio_mgr->pmsg)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	hio_mgr->ul_dsp_va = ul_dsp_va;
 	hio_mgr->ul_gpp_va = (ul_gpp_va + ul_seg1_size + ul_pad_size);
@@ -1874,7 +1874,7 @@ void print_dsp_debug_trace(struct io_mgr *hio_mgr)
  *                      number of extra carriage returns to generate.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Unable to allocate memory.
+ *      -ENOMEM:    Unable to allocate memory.
  *  Requires:
  *      lpBuf must be a fully allocated writable block of at least bytes.
  *      There are no more than ul_num_words extra characters needed (the number
@@ -1892,7 +1892,7 @@ static dsp_status pack_trace_buffer(char *lpBuf, u32 bytes, u32 ul_num_words)
 	/* Tmp workspace, 1 KB longer than input buf */
 	lp_tmp_buf = mem_calloc((bytes + ul_num_words), MEM_PAGED);
 	if (lp_tmp_buf == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		lp_buf_start = lpBuf;
@@ -1934,7 +1934,7 @@ static dsp_status pack_trace_buffer(char *lpBuf, u32 bytes, u32 ul_num_words)
  *                      number of extra carriage returns to generate.
  *  Returns:
  *      DSP_SOK:        Success.
- *      DSP_EMEMORY:    Unable to allocate memory.
+ *      -ENOMEM:    Unable to allocate memory.
  *  Requires:
  *      hdeh_mgr muse be valid. Checked in bridge_deh_notify.
  */
@@ -2003,7 +2003,7 @@ dsp_status print_dsp_trace_buffer(struct wmd_dev_context *hwmd_context)
 			kfree(psz_buf);
 			kfree(lpsz_buf);
 		} else {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		}
 	}
 	return status;
diff --git a/drivers/dsp/bridge/wmd/msg_sm.c b/drivers/dsp/bridge/wmd/msg_sm.c
index 6edd3b8..55b656c 100644
--- a/drivers/dsp/bridge/wmd/msg_sm.c
+++ b/drivers/dsp/bridge/wmd/msg_sm.c
@@ -90,7 +90,7 @@ dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 		if (msg_mgr_obj->queue_list == NULL ||
 		    msg_mgr_obj->msg_free_list == NULL ||
 		    msg_mgr_obj->msg_used_list == NULL) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		} else {
 			INIT_LIST_HEAD(&msg_mgr_obj->queue_list->head);
 			INIT_LIST_HEAD(&msg_mgr_obj->msg_free_list->head);
@@ -103,7 +103,7 @@ dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 		msg_mgr_obj->sync_event =
 				kzalloc(sizeof(struct sync_object), GFP_KERNEL);
 		if (!msg_mgr_obj->sync_event)
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 		else
 			sync_init_event(msg_mgr_obj->sync_event);
 
@@ -113,7 +113,7 @@ dsp_status bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 			delete_msg_mgr(msg_mgr_obj);
 
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 func_end:
 	return status;
@@ -143,7 +143,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 	/* Allocate msg_queue object */
 	MEM_ALLOC_OBJECT(msg_q, struct msg_queue, MSGQ_SIGNATURE);
 	if (!msg_q) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	lst_init_elem((struct list_head *)msg_q);
@@ -157,7 +157,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 	msg_q->msg_used_list =
 	    mem_calloc(sizeof(struct lst_list), MEM_NONPAGED);
 	if (msg_q->msg_free_list == NULL || msg_q->msg_used_list == NULL)
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	else {
 		INIT_LIST_HEAD(&msg_q->msg_free_list->head);
 		INIT_LIST_HEAD(&msg_q->msg_used_list->head);
@@ -171,7 +171,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 		if (msg_q->sync_event)
 			sync_init_event(msg_q->sync_event);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	/* Create a notification list for message ready notification. */
@@ -181,7 +181,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 		if (msg_q->ntfy_obj)
 			ntfy_init(msg_q->ntfy_obj);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	/*  Create events that will be used to synchronize cleanup
@@ -195,7 +195,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 		if (msg_q->sync_done)
 			sync_init_event(msg_q->sync_done);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -204,7 +204,7 @@ dsp_status bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 		if (msg_q->sync_done_ack)
 			sync_init_event(msg_q->sync_done_ack);
 		else
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 	}
 
 	if (DSP_SUCCEEDED(status)) {
@@ -306,7 +306,7 @@ dsp_status bridge_msg_get(struct msg_queue *msg_queue_obj,
 
 	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) ||
 	    pmsg == NULL) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 
@@ -404,7 +404,7 @@ dsp_status bridge_msg_put(struct msg_queue *msg_queue_obj,
 
 	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE) || !pmsg ||
 	    !msg_queue_obj->hmsg_mgr) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	hmsg_mgr = msg_queue_obj->hmsg_mgr;
@@ -512,7 +512,7 @@ dsp_status bridge_msg_register_notify(struct msg_queue *msg_queue_obj,
 
 	if (!MEM_IS_VALID_HANDLE(msg_queue_obj, MSGQ_SIGNATURE)
 	    || !hnotification) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 
@@ -574,7 +574,7 @@ static dsp_status add_new_msg(struct lst_list *msgList)
 		lst_init_elem((struct list_head *)pmsg);
 		lst_put_tail(msgList, (struct list_head *)pmsg);
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 	}
 
 	return status;
diff --git a/drivers/dsp/bridge/wmd/tiomap3430.c b/drivers/dsp/bridge/wmd/tiomap3430.c
index 439cae1..c77252a 100644
--- a/drivers/dsp/bridge/wmd/tiomap3430.c
+++ b/drivers/dsp/bridge/wmd/tiomap3430.c
@@ -945,14 +945,14 @@ static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
 	 *  state, which becomes the context for later calls into this WMD. */
 	dev_context = mem_calloc(sizeof(struct wmd_dev_context), MEM_NONPAGED);
 	if (!dev_context) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 	status = cfg_get_host_resources((struct cfg_devnode *)
 					drv_get_first_dev_extension(),
 					&resources);
 	if (DSP_FAILED(status)) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto func_end;
 	}
 
@@ -1056,7 +1056,7 @@ static dsp_status bridge_dev_create(OUT struct wmd_dev_context **ppDevContext,
 	    (pt_attrs->l2_base_va != 0) && (pt_attrs->pg_info != NULL))
 		dev_context->pt_attrs = pt_attrs;
 	else
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 
 	if (DSP_SUCCEEDED(status)) {
 		spin_lock_init(&pt_attrs->pg_lock);
@@ -1824,7 +1824,7 @@ static dsp_status pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
 						   HW_MMU_COARSE_PAGE_SIZE,
 						   attrs);
 			} else {
-				status = DSP_EMEMORY;
+				status = -ENOMEM;
 			}
 		} else {
 			/* Found valid L1 PTE of another size.
@@ -1908,7 +1908,7 @@ static dsp_status mem_map_vmalloc(struct wmd_dev_context *dev_context,
 
 		}
 		if (pa_next == 0) {
-			status = DSP_EMEMORY;
+			status = -ENOMEM;
 			break;
 		}
 		pa = pa_curr;
diff --git a/drivers/dsp/bridge/wmd/ue_deh.c b/drivers/dsp/bridge/wmd/ue_deh.c
index 5ddf5d9..78ae73c 100644
--- a/drivers/dsp/bridge/wmd/ue_deh.c
+++ b/drivers/dsp/bridge/wmd/ue_deh.c
@@ -80,7 +80,7 @@ dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
 	/* Allocate IO manager object: */
 	MEM_ALLOC_OBJECT(deh_mgr, struct deh_mgr, SIGNATURE);
 	if (!deh_mgr) {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto leave;
 	}
 
@@ -89,7 +89,7 @@ dsp_status bridge_deh_create(struct deh_mgr **ret_deh_mgr,
 	if (deh_mgr->ntfy_obj) {
 		ntfy_init(deh_mgr->ntfy_obj);
 	} else {
-		status = DSP_EMEMORY;
+		status = -ENOMEM;
 		goto err;
 	}
 
-- 
1.7.0.4

