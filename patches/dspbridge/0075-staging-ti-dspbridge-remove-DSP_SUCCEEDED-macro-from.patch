From 157990f0d7f70aaa2b0158f959994eb0f65c05c0 Mon Sep 17 00:00:00 2001
From: Ernesto Ramos <ernesto@ti.com>
Date: Wed, 28 Jul 2010 09:45:25 -0500
Subject: [PATCH 075/116] staging:ti dspbridge: remove DSP_SUCCEEDED macro from pmgr

Since status succeeded is now 0 macro DSP_SUCCEEDED
is not necessary anymore.

Signed-off-by: Ernesto Ramos <ernesto@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/pmgr/chnl.c   |    8 +-
 drivers/staging/tidspbridge/pmgr/cmm.c    |  135 +++++++++++++----------------
 drivers/staging/tidspbridge/pmgr/cod.c    |   10 +-
 drivers/staging/tidspbridge/pmgr/dbll.c   |   20 ++--
 drivers/staging/tidspbridge/pmgr/dev.c    |   59 ++++++-------
 drivers/staging/tidspbridge/pmgr/dmm.c    |   10 +-
 drivers/staging/tidspbridge/pmgr/dspapi.c |   52 ++++++------
 drivers/staging/tidspbridge/pmgr/io.c     |    4 +-
 drivers/staging/tidspbridge/pmgr/msg.c    |    2 +-
 9 files changed, 139 insertions(+), 161 deletions(-)

diff --git a/drivers/staging/tidspbridge/pmgr/chnl.c b/drivers/staging/tidspbridge/pmgr/chnl.c
index d73c89c..626a993 100644
--- a/drivers/staging/tidspbridge/pmgr/chnl.c
+++ b/drivers/staging/tidspbridge/pmgr/chnl.c
@@ -77,20 +77,20 @@ int chnl_create(struct chnl_mgr **channel_mgr,
 	if (mgr_attrts->word_size == 0)
 		status = -EINVAL;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = dev_get_chnl_mgr(hdev_obj, &hchnl_mgr);
-		if (DSP_SUCCEEDED(status) && hchnl_mgr != NULL)
+		if (!status && hchnl_mgr != NULL)
 			status = -EEXIST;
 
 	}
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		struct bridge_drv_interface *intf_fxns;
 		dev_get_intf_fxns(hdev_obj, &intf_fxns);
 		/* Let Bridge channel module finish the create: */
 		status = (*intf_fxns->pfn_chnl_create) (&hchnl_mgr, hdev_obj,
 							mgr_attrts);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			/* Fill in DSP API channel module's fields of the
 			 * chnl_mgr structure */
 			chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
diff --git a/drivers/staging/tidspbridge/pmgr/cmm.c b/drivers/staging/tidspbridge/pmgr/cmm.c
index b7cba1b..2f974c5 100644
--- a/drivers/staging/tidspbridge/pmgr/cmm.c
+++ b/drivers/staging/tidspbridge/pmgr/cmm.c
@@ -266,33 +266,25 @@ int cmm_create(struct cmm_object **ph_cmm_mgr,
 		sys_info.dw_page_size = PAGE_SIZE;
 		sys_info.dw_allocation_granularity = PAGE_SIZE;
 		sys_info.dw_number_of_processors = 1;
-		if (DSP_SUCCEEDED(status)) {
-			cmm_obj->dw_page_size = sys_info.dw_page_size;
-		} else {
-			cmm_obj->dw_page_size = 0;
-			status = -EPERM;
-		}
+
+		cmm_obj->dw_page_size = sys_info.dw_page_size;
+
 		/* Note: DSP SM seg table(aDSPSMSegTab[]) zero'd by
 		 * MEM_ALLOC_OBJECT */
-		if (DSP_SUCCEEDED(status)) {
-			/* create node free list */
-			cmm_obj->node_free_list_head =
-					kzalloc(sizeof(struct lst_list),
-							GFP_KERNEL);
-			if (cmm_obj->node_free_list_head == NULL)
-				status = -ENOMEM;
-			else
-				INIT_LIST_HEAD(&cmm_obj->
-					       node_free_list_head->head);
-		}
-		if (DSP_SUCCEEDED(status))
-			mutex_init(&cmm_obj->cmm_lock);
 
-		if (DSP_SUCCEEDED(status))
-			*ph_cmm_mgr = cmm_obj;
-		else
+		/* create node free list */
+		cmm_obj->node_free_list_head =
+				kzalloc(sizeof(struct lst_list),
+						GFP_KERNEL);
+		if (cmm_obj->node_free_list_head == NULL) {
+			status = -ENOMEM;
 			cmm_destroy(cmm_obj, true);
-
+		} else {
+			INIT_LIST_HEAD(&cmm_obj->
+				       node_free_list_head->head);
+			mutex_init(&cmm_obj->cmm_lock);
+			*ph_cmm_mgr = cmm_obj;
+		}
 	} else {
 		status = -ENOMEM;
 	}
@@ -322,14 +314,14 @@ int cmm_destroy(struct cmm_object *hcmm_mgr, bool force)
 	if (!force) {
 		/* Check for outstanding memory allocations */
 		status = cmm_get_info(hcmm_mgr, &temp_info);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			if (temp_info.ul_total_in_use_cnt > 0) {
 				/* outstanding allocations */
 				status = -EPERM;
 			}
 		}
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* UnRegister SM allocator */
 		for (slot_seg = 0; slot_seg < CMM_MAXGPPSEGS; slot_seg++) {
 			if (cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] != NULL) {
@@ -351,7 +343,7 @@ int cmm_destroy(struct cmm_object *hcmm_mgr, bool force)
 		kfree(cmm_mgr_obj->node_free_list_head);
 	}
 	mutex_unlock(&cmm_mgr_obj->cmm_lock);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* delete CS & cmm mgr object */
 		mutex_destroy(&cmm_mgr_obj->cmm_lock);
 		kfree(cmm_mgr_obj);
@@ -441,7 +433,7 @@ int cmm_get_handle(void *hprocessor, struct cmm_object ** ph_cmm_mgr)
 	else
 		hdev_obj = dev_get_first();	/* default */
 
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		status = dev_get_cmm_mgr(hdev_obj, ph_cmm_mgr);
 
 	return status;
@@ -571,16 +563,13 @@ int cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 		goto func_end;
 	}
 	/* Check if input ul_size is big enough to alloc at least one block */
-	if (DSP_SUCCEEDED(status)) {
-		if (ul_size < cmm_mgr_obj->ul_min_block_size) {
-			status = -EINVAL;
-			goto func_end;
-		}
-	}
-	if (DSP_SUCCEEDED(status)) {
-		/* create, zero, and tag an SM allocator object */
-		psma = kzalloc(sizeof(struct cmm_allocator), GFP_KERNEL);
+	if (ul_size < cmm_mgr_obj->ul_min_block_size) {
+		status = -EINVAL;
+		goto func_end;
 	}
+
+	/* create, zero, and tag an SM allocator object */
+	psma = kzalloc(sizeof(struct cmm_allocator), GFP_KERNEL);
 	if (psma != NULL) {
 		psma->hcmm_mgr = hcmm_mgr;	/* ref to parent */
 		psma->shm_base = dw_gpp_base_pa;	/* SM Base phys */
@@ -594,54 +583,50 @@ int cmm_register_gppsm_seg(struct cmm_object *hcmm_mgr,
 			status = -EPERM;
 			goto func_end;
 		}
-		if (DSP_SUCCEEDED(status)) {
-			/* return the actual segment identifier */
-			*sgmt_id = (u32) slot_seg + 1;
-			/* create memory free list */
-			psma->free_list_head = kzalloc(sizeof(struct lst_list),
-								GFP_KERNEL);
-			if (psma->free_list_head == NULL) {
-				status = -ENOMEM;
-				goto func_end;
-			}
-			INIT_LIST_HEAD(&psma->free_list_head->head);
-		}
-		if (DSP_SUCCEEDED(status)) {
-			/* create memory in-use list */
-			psma->in_use_list_head = kzalloc(sizeof(struct
-							lst_list), GFP_KERNEL);
-			if (psma->in_use_list_head == NULL) {
-				status = -ENOMEM;
-				goto func_end;
-			}
-			INIT_LIST_HEAD(&psma->in_use_list_head->head);
+		/* return the actual segment identifier */
+		*sgmt_id = (u32) slot_seg + 1;
+		/* create memory free list */
+		psma->free_list_head = kzalloc(sizeof(struct lst_list),
+							GFP_KERNEL);
+		if (psma->free_list_head == NULL) {
+			status = -ENOMEM;
+			goto func_end;
 		}
-		if (DSP_SUCCEEDED(status)) {
-			/* Get a mem node for this hunk-o-memory */
-			new_node = get_node(cmm_mgr_obj, dw_gpp_base_pa,
-					    psma->dw_vm_base, ul_size);
-			/* Place node on the SM allocator's free list */
-			if (new_node) {
-				lst_put_tail(psma->free_list_head,
-					     (struct list_head *)new_node);
-			} else {
-				status = -ENOMEM;
-				goto func_end;
-			}
+		INIT_LIST_HEAD(&psma->free_list_head->head);
+
+		/* create memory in-use list */
+		psma->in_use_list_head = kzalloc(sizeof(struct
+						lst_list), GFP_KERNEL);
+		if (psma->in_use_list_head == NULL) {
+			status = -ENOMEM;
+			goto func_end;
 		}
-		if (DSP_FAILED(status)) {
-			/* Cleanup allocator */
-			un_register_gppsm_seg(psma);
+		INIT_LIST_HEAD(&psma->in_use_list_head->head);
+
+		/* Get a mem node for this hunk-o-memory */
+		new_node = get_node(cmm_mgr_obj, dw_gpp_base_pa,
+				    psma->dw_vm_base, ul_size);
+		/* Place node on the SM allocator's free list */
+		if (new_node) {
+			lst_put_tail(psma->free_list_head,
+				     (struct list_head *)new_node);
+		} else {
+			status = -ENOMEM;
+			goto func_end;
 		}
 	} else {
 		status = -ENOMEM;
 		goto func_end;
 	}
 	/* make entry */
-	if (DSP_SUCCEEDED(status))
-		cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = psma;
+	cmm_mgr_obj->pa_gppsm_seg_tab[slot_seg] = psma;
 
 func_end:
+	if (status && psma) {
+		/* Cleanup allocator */
+		un_register_gppsm_seg(psma);
+	}
+
 	mutex_unlock(&cmm_mgr_obj->cmm_lock);
 	return status;
 }
@@ -977,7 +962,7 @@ int cmm_xlator_create(struct cmm_xlatorobject **xlator,
 	} else {
 		status = -ENOMEM;
 	}
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		*xlator = (struct cmm_xlatorobject *)xlator_object;
 
 	return status;
diff --git a/drivers/staging/tidspbridge/pmgr/cod.c b/drivers/staging/tidspbridge/pmgr/cod.c
index 81102d2..9f902de 100644
--- a/drivers/staging/tidspbridge/pmgr/cod.c
+++ b/drivers/staging/tidspbridge/pmgr/cod.c
@@ -411,7 +411,7 @@ int cod_get_section(struct cod_libraryobj *lib, char *str_sect,
 		status = -ESPIPE;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((*addr == 0) && (*len == 0)));
+	DBC_ENSURE(!status || ((*addr == 0) && (*len == 0)));
 
 	return status;
 }
@@ -532,7 +532,7 @@ int cod_load_base(struct cod_manager *cod_mgr_obj, u32 num_argc, char *args[],
 	if (DSP_FAILED(status))
 		cod_mgr_obj->fxns.close_fxn(cod_mgr_obj->base_lib);
 
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		cod_mgr_obj->loaded = true;
 	else
 		cod_mgr_obj->base_lib = NULL;
@@ -562,11 +562,11 @@ int cod_open(struct cod_manager *hmgr, char *sz_coff_path,
 	if (lib == NULL)
 		status = -ENOMEM;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		lib->cod_mgr = hmgr;
 		status = hmgr->fxns.open_fxn(hmgr->target, sz_coff_path, flags,
 					     &lib->dbll_lib);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			*lib_obj = lib;
 	}
 
@@ -601,7 +601,7 @@ int cod_open_base(struct cod_manager *hmgr, char *sz_coff_path,
 		hmgr->base_lib = NULL;
 	}
 	status = hmgr->fxns.open_fxn(hmgr->target, sz_coff_path, flags, &lib);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* hang onto the library for subsequent sym table usage */
 		hmgr->base_lib = lib;
 		strncpy(hmgr->sz_zl_file, sz_coff_path, COD_MAXPATHLENGTH - 1);
diff --git a/drivers/staging/tidspbridge/pmgr/dbll.c b/drivers/staging/tidspbridge/pmgr/dbll.c
index d1806aa..ea27824 100644
--- a/drivers/staging/tidspbridge/pmgr/dbll.c
+++ b/drivers/staging/tidspbridge/pmgr/dbll.c
@@ -255,7 +255,7 @@ int dbll_create(struct dbll_tar_obj **target_obj,
 			pzl_target->attrs = *pattrs;
 			*target_obj = (struct dbll_tar_obj *)pzl_target;
 		}
-		DBC_ENSURE((DSP_SUCCEEDED(status) && *target_obj) ||
+		DBC_ENSURE((!status && *target_obj) ||
 				(DSP_FAILED(status) && *target_obj == NULL));
 	}
 
@@ -393,7 +393,7 @@ int dbll_get_sect(struct dbll_library_obj *lib, char *name, u32 *paddr,
 	if (zl_lib != NULL) {
 		if (zl_lib->fp == NULL) {
 			status = dof_open(zl_lib);
-			if (DSP_SUCCEEDED(status))
+			if (!status)
 				opened_doff = true;
 
 		} else {
@@ -404,7 +404,7 @@ int dbll_get_sect(struct dbll_library_obj *lib, char *name, u32 *paddr,
 	} else {
 		status = -EFAULT;
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		byte_size = 1;
 		if (dload_get_section_info(zl_lib->desc, name, &sect)) {
 			*paddr = sect->load_addr;
@@ -517,11 +517,11 @@ int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 		/* If COFF file is not open, we open it. */
 		if (zl_lib->fp == NULL) {
 			status = dof_open(zl_lib);
-			if (DSP_SUCCEEDED(status))
+			if (!status)
 				opened_doff = true;
 
 		}
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell))
 			    (zl_lib->fp);
 			/* Reset file cursor */
@@ -552,7 +552,7 @@ int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 			}
 		}
 	}
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		zl_lib->load_ref++;
 
 	/* Clean up DOFF resources */
@@ -658,7 +658,7 @@ int dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
 	zl_lib->init.dl_init.execute = execute;
 	zl_lib->init.dl_init.release = release;
 	zl_lib->init.lib = zl_lib;
-	if (DSP_SUCCEEDED(status) && zl_lib->fp == NULL)
+	if (!status && zl_lib->fp == NULL)
 		status = dof_open(zl_lib);
 
 	zl_lib->ul_pos = (*(zl_lib->target_obj->attrs.ftell)) (zl_lib->fp);
@@ -695,7 +695,7 @@ int dbll_open(struct dbll_tar_obj *target, char *file, dbll_flags flags,
 		}
 	}
 func_cont:
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		if (zl_lib->open_ref == 1) {
 			/* First time opened - insert in list */
 			if (zl_target->head)
@@ -712,7 +712,7 @@ func_cont:
 			dbll_close((struct dbll_library_obj *)zl_lib);
 
 	}
-	DBC_ENSURE((DSP_SUCCEEDED(status) && (zl_lib->open_ref > 0) && *lib_obj)
+	DBC_ENSURE((!status && (zl_lib->open_ref > 0) && *lib_obj)
 				|| (DSP_FAILED(status) && *lib_obj == NULL));
 
 	dev_dbg(bridge, "%s: target: %p file: %s lib_obj: %p, status 0x%x\n",
@@ -745,7 +745,7 @@ int dbll_read_sect(struct dbll_library_obj *lib, char *name,
 	if (zl_lib != NULL) {
 		if (zl_lib->fp == NULL) {
 			status = dof_open(zl_lib);
-			if (DSP_SUCCEEDED(status))
+			if (!status)
 				opened_doff = true;
 
 		} else {
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index 2039e6f..8f1e56a 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -118,7 +118,7 @@ u32 dev_brd_write_fxn(void *arb, u32 dsp_add, void *host_buf,
 		/* Special case of getting the address only */
 		if (ul_num_bytes == 0)
 			ul_num_bytes = 1;
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			ul_written = ul_num_bytes;
 
 	}
@@ -164,7 +164,7 @@ int dev_create_device(struct dev_object **device_obj,
 	}
 	/* Create the device object, and pass a handle to the Bridge driver for
 	 * storage. */
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		DBC_ASSERT(drv_fxns);
 		dev_obj = kzalloc(sizeof(struct dev_object), GFP_KERNEL);
 		if (dev_obj) {
@@ -196,11 +196,11 @@ int dev_create_device(struct dev_object **device_obj,
 		}
 	}
 	/* Attempt to create the COD manager for this device: */
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		status = init_cod_mgr(dev_obj);
 
 	/* Attempt to create the channel manager for this device: */
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		mgr_attrs.max_channels = CHNL_MAXCHANNELS;
 		io_mgr_attrs.birq = host_res->birq_registers;
 		io_mgr_attrs.irq_shared =
@@ -231,12 +231,12 @@ int dev_create_device(struct dev_object **device_obj,
 		status = cmm_create(&dev_obj->hcmm_mgr,
 				    (struct dev_object *)dev_obj, NULL);
 		/* Only create IO manager if we have a channel manager */
-		if (DSP_SUCCEEDED(status) && dev_obj->hchnl_mgr) {
+		if (!status && dev_obj->hchnl_mgr) {
 			status = io_create(&dev_obj->hio_mgr, dev_obj,
 					   &io_mgr_attrs);
 		}
 		/* Only create DEH manager if we have an IO manager */
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			/* Instantiate the DEH module */
 			status = bridge_deh_create(&dev_obj->hdeh_mgr, dev_obj);
 		}
@@ -245,12 +245,12 @@ int dev_create_device(struct dev_object **device_obj,
 				    (struct dev_object *)dev_obj, NULL);
 	}
 	/* Add the new DEV_Object to the global list: */
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		lst_init_elem(&dev_obj->link);
 		status = drv_insert_dev_object(hdrv_obj, dev_obj);
 	}
 	/* Create the Processor List */
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		dev_obj->proc_list = kzalloc(sizeof(struct lst_list),
 							GFP_KERNEL);
 		if (!(dev_obj->proc_list))
@@ -260,8 +260,8 @@ int dev_create_device(struct dev_object **device_obj,
 	}
 leave:
 	/*  If all went well, return a handle to the dev object;
-	 *  else, cleanup and return NULL in the parameter. */
-	if (DSP_SUCCEEDED(status)) {
+	 *  else, cleanup and return NULL in the OUT parameter. */
+	if (!status) {
 		*device_obj = dev_obj;
 	} else {
 		if (dev_obj) {
@@ -276,7 +276,7 @@ leave:
 		*device_obj = NULL;
 	}
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *device_obj) ||
+	DBC_ENSURE((!status && *device_obj) ||
 		   (DSP_FAILED(status) && !*device_obj));
 	return status;
 }
@@ -302,7 +302,7 @@ int dev_create2(struct dev_object *hdev_obj)
 	if (DSP_FAILED(status))
 		dev_obj->hnode_mgr = NULL;
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr != NULL)
+	DBC_ENSURE((!status && dev_obj->hnode_mgr != NULL)
 		   || (DSP_FAILED(status) && dev_obj->hnode_mgr == NULL));
 	return status;
 }
@@ -328,7 +328,7 @@ int dev_destroy2(struct dev_object *hdev_obj)
 
 	}
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && dev_obj->hnode_mgr == NULL) ||
+	DBC_ENSURE((!status && dev_obj->hnode_mgr == NULL) ||
 		   DSP_FAILED(status));
 	return status;
 }
@@ -394,7 +394,7 @@ int dev_destroy_device(struct dev_object *hdev_obj)
 			dev_obj->hbridge_context = NULL;
 		} else
 			status = -EPERM;
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			kfree(dev_obj->proc_list);
 			dev_obj->proc_list = NULL;
 
@@ -435,8 +435,7 @@ int dev_get_chnl_mgr(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
-					     (*mgr == NULL)));
+	DBC_ENSURE(!status || (mgr != NULL && *mgr == NULL));
 	return status;
 }
 
@@ -462,8 +461,7 @@ int dev_get_cmm_mgr(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
-					     (*mgr == NULL)));
+	DBC_ENSURE(!status || (mgr != NULL && *mgr == NULL));
 	return status;
 }
 
@@ -489,8 +487,7 @@ int dev_get_dmm_mgr(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
-					     (*mgr == NULL)));
+	DBC_ENSURE(!status || (mgr != NULL && *mgr == NULL));
 	return status;
 }
 
@@ -515,8 +512,7 @@ int dev_get_cod_mgr(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((cod_mgr != NULL) &&
-					     (*cod_mgr == NULL)));
+	DBC_ENSURE(!status || (cod_mgr != NULL && *cod_mgr == NULL));
 	return status;
 }
 
@@ -561,8 +557,7 @@ int dev_get_dev_node(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((dev_nde != NULL) &&
-					     (*dev_nde == NULL)));
+	DBC_ENSURE(!status || (dev_nde != NULL && *dev_nde == NULL));
 	return status;
 }
 
@@ -603,8 +598,7 @@ int dev_get_intf_fxns(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((if_fxns != NULL) &&
-					     (*if_fxns == NULL)));
+	DBC_ENSURE(!status || ((if_fxns != NULL) && (*if_fxns == NULL)));
 	return status;
 }
 
@@ -682,8 +676,7 @@ int dev_get_node_manager(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((node_man != NULL) &&
-					     (*node_man == NULL)));
+	DBC_ENSURE(!status || (node_man != NULL && *node_man == NULL));
 	return status;
 }
 
@@ -733,7 +726,7 @@ int dev_get_bridge_context(struct dev_object *hdev_obj,
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phbridge_context != NULL) &&
+	DBC_ENSURE(!status || ((phbridge_context != NULL) &&
 					     (*phbridge_context == NULL)));
 	return status;
 }
@@ -826,7 +819,7 @@ int dev_remove_device(struct cfg_devnode *dev_node_obj)
 	/* Retrieve the device object handle originaly stored with
 	 * the dev_node: */
 	status = cfg_get_dev_object(dev_node_obj, (u32 *) &hdev_obj);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Remove the Processor List */
 		dev_obj = (struct dev_object *)hdev_obj;
 		/* Destroy the device object. */
@@ -889,7 +882,7 @@ int dev_start_device(struct cfg_devnode *dev_node_obj)
 	/* Given all resources, create a device object. */
 	status = dev_create_device(&hdev_obj, bridge_file_name,
 				   dev_node_obj);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Store away the hdev_obj with the DEVNODE */
 		status = cfg_set_dev_object(dev_node_obj, (u32) hdev_obj);
 		if (DSP_FAILED(status)) {
@@ -898,7 +891,7 @@ int dev_start_device(struct cfg_devnode *dev_node_obj)
 			hdev_obj = NULL;
 		}
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Create the Manager Object */
 		status = mgr_create(&hmgr_obj, dev_node_obj);
 	}
@@ -990,7 +983,7 @@ int dev_insert_proc_object(struct dev_object *hdev_obj,
 	/* Add DevObject to tail. */
 	lst_put_tail(dev_obj->proc_list, (struct list_head *)proc_obj);
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) && !LST_IS_EMPTY(dev_obj->proc_list));
+	DBC_ENSURE(!status && !LST_IS_EMPTY(dev_obj->proc_list));
 
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/pmgr/dmm.c b/drivers/staging/tidspbridge/pmgr/dmm.c
index e53700f..ef28748 100644
--- a/drivers/staging/tidspbridge/pmgr/dmm.c
+++ b/drivers/staging/tidspbridge/pmgr/dmm.c
@@ -88,7 +88,7 @@ int dmm_create_tables(struct dmm_object *dmm_mgr, u32 addr, u32 size)
 	int status = 0;
 
 	status = dmm_delete_tables(dmm_obj);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		dyn_mem_map_beg = addr;
 		table_size = PG_ALIGN_HIGH(size, PG_SIZE4K) / PG_SIZE4K;
 		/*  Create the free list */
@@ -152,7 +152,7 @@ int dmm_destroy(struct dmm_object *dmm_mgr)
 	DBC_REQUIRE(refs > 0);
 	if (dmm_mgr) {
 		status = dmm_delete_tables(dmm_obj);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			kfree(dmm_obj);
 	} else
 		status = -EFAULT;
@@ -209,7 +209,7 @@ int dmm_get_handle(void *hprocessor, struct dmm_object **dmm_manager)
 	else
 		hdev_obj = dev_get_first();	/* default */
 
-	if (DSP_SUCCEEDED(status))
+	if (!status)
 		status = dev_get_dmm_mgr(hdev_obj, dmm_manager);
 
 	return status;
@@ -337,7 +337,7 @@ int dmm_un_map_memory(struct dmm_object *dmm_mgr, u32 addr, u32 *psize)
 	if (chunk == NULL)
 		status = -ENOENT;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Unmap the region */
 		*psize = chunk->mapped_size * PG_SIZE4K;
 		chunk->mapped = false;
@@ -371,7 +371,7 @@ int dmm_un_reserve_memory(struct dmm_object *dmm_mgr, u32 rsv_addr)
 	if (chunk == NULL)
 		status = -ENOENT;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Free all the mapped pages for this reserved region */
 		i = 0;
 		while (i < chunk->region_size) {
diff --git a/drivers/staging/tidspbridge/pmgr/dspapi.c b/drivers/staging/tidspbridge/pmgr/dspapi.c
index 78192a3..60d7410 100644
--- a/drivers/staging/tidspbridge/pmgr/dspapi.c
+++ b/drivers/staging/tidspbridge/pmgr/dspapi.c
@@ -425,7 +425,7 @@ u32 mgrwrap_enum_node_info(union trapped_args *args, void *pr_ctxt)
 	if (pndb_props == NULL)
 		status = -ENOMEM;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status =
 		    mgr_enum_node_info(args->args_mgr_enumnode_info.node_id,
 				       (struct dsp_ndbprops *)pndb_props, size,
@@ -457,7 +457,7 @@ u32 mgrwrap_enum_proc_info(union trapped_args *args, void *pr_ctxt)
 	if (processor_info == NULL)
 		status = -ENOMEM;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status =
 		    mgr_enum_processor_info(args->args_mgr_enumproc_info.
 					    processor_id,
@@ -554,12 +554,12 @@ u32 mgrwrap_wait_for_bridge_events(union trapped_args *args, void *pr_ctxt)
 	/* get the events */
 	for (i = 0; i < count; i++) {
 		CP_FM_USR(&notifications[i], anotifications[i], status, 1);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			/* set the array of pointers to kernel structures */
 			anotifications[i] = &notifications[i];
 		}
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		real_status = mgr_wait_for_bridge_events(anotifications, count,
 							 &index,
 							 args->args_mgr_wait.
@@ -592,7 +592,7 @@ u32 procwrap_attach(union trapped_args *args, void *pr_ctxt)
 	if (args->args_proc_attach.attr_in) {
 		CP_FM_USR(&proc_attr_in, args->args_proc_attach.attr_in, status,
 			  1);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			attr_in = &proc_attr_in;
 		else
 			goto func_end;
@@ -630,7 +630,7 @@ u32 procwrap_ctrl(union trapped_args *args, void *pr_ctxt)
 		CP_FM_USR(pargs, args->args_proc_ctrl.pargs, status,
 			  cb_data_size);
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
 				   args->args_proc_ctrl.dw_cmd,
 				   (struct dsp_cbdata *)pargs);
@@ -902,7 +902,7 @@ u32 procwrap_load(union trapped_args *args, void *pr_ctxt)
 		}
 	}
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = proc_load(args->args_proc_load.hprocessor,
 				   args->args_proc_load.argc_index,
 				   (const char **)argv, (const char **)envp);
@@ -943,7 +943,7 @@ u32 procwrap_map(union trapped_args *args, void *pr_ctxt)
 			  args->args_proc_mapmem.ul_size,
 			  args->args_proc_mapmem.req_addr, &map_addr,
 			  args->args_proc_mapmem.ul_map_attr, pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
 			status = -EINVAL;
 			proc_un_map(args->args_proc_mapmem.hprocessor,
@@ -991,7 +991,7 @@ u32 procwrap_reserve_memory(union trapped_args *args, void *pr_ctxt)
 	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
 				     args->args_proc_rsvmem.ul_size, &prsv_addr,
 				     pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
 			status = -EINVAL;
 			proc_un_reserve_memory(args->args_proc_rsvmem.
@@ -1068,7 +1068,7 @@ u32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)
 			status = -EPERM;
 
 		cb_data_size += sizeof(u32);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			pargs = kmalloc(cb_data_size, GFP_KERNEL);
 			if (pargs == NULL)
 				status = -ENOMEM;
@@ -1084,18 +1084,18 @@ u32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)
 	if (args->args_node_allocate.attr_in) {
 		CP_FM_USR(&proc_attr_in, args->args_node_allocate.attr_in,
 			  status, 1);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			attr_in = &proc_attr_in;
 		else
 			status = -ENOMEM;
 
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = node_allocate(args->args_node_allocate.hprocessor,
 				       &node_uuid, (struct dsp_cbdata *)pargs,
 				       attr_in, &hnode, pr_ctxt);
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		CP_TO_USR(args->args_node_allocate.ph_node, &hnode, status, 1);
 		if (DSP_FAILED(status)) {
 			status = -EFAULT;
@@ -1123,13 +1123,13 @@ u32 nodewrap_alloc_msg_buf(union trapped_args *args, void *pr_ctxt)
 
 	if (args->args_node_allocmsgbuf.pattr) {	/* Optional argument */
 		CP_FM_USR(&attr, args->args_node_allocmsgbuf.pattr, status, 1);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			pattr = &attr;
 
 	}
 	/* argument */
 	CP_FM_USR(&pbuffer, args->args_node_allocmsgbuf.pbuffer, status, 1);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = node_alloc_msg_buf(args->args_node_allocmsgbuf.hnode,
 					    args->args_node_allocmsgbuf.usize,
 					    pattr, &pbuffer);
@@ -1169,7 +1169,7 @@ u32 nodewrap_connect(union trapped_args *args, void *pr_ctxt)
 			status = -EPERM;
 
 		cb_data_size += sizeof(u32);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			pargs = kmalloc(cb_data_size, GFP_KERNEL);
 			if (pargs == NULL) {
 				status = -ENOMEM;
@@ -1184,11 +1184,11 @@ u32 nodewrap_connect(union trapped_args *args, void *pr_ctxt)
 	}
 	if (args->args_node_connect.pattrs) {	/* Optional argument */
 		CP_FM_USR(&attrs, args->args_node_connect.pattrs, status, 1);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			pattrs = &attrs;
 
 	}
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = node_connect(args->args_node_connect.hnode,
 				      args->args_node_connect.stream_id,
 				      args->args_node_connect.other_node,
@@ -1235,7 +1235,7 @@ u32 nodewrap_free_msg_buf(union trapped_args *args, void *pr_ctxt)
 	struct dsp_bufferattr attr;
 	if (args->args_node_freemsgbuf.pattr) {	/* Optional argument */
 		CP_FM_USR(&attr, args->args_node_freemsgbuf.pattr, status, 1);
-		if (DSP_SUCCEEDED(status))
+		if (!status)
 			pattr = &attr;
 
 	}
@@ -1243,7 +1243,7 @@ u32 nodewrap_free_msg_buf(union trapped_args *args, void *pr_ctxt)
 	if (!args->args_node_freemsgbuf.pbuffer)
 		return -EFAULT;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = node_free_msg_buf(args->args_node_freemsgbuf.hnode,
 					   args->args_node_freemsgbuf.pbuffer,
 					   pattr);
@@ -1305,7 +1305,7 @@ u32 nodewrap_put_message(union trapped_args *args, void *pr_ctxt)
 
 	CP_FM_USR(&msg, args->args_node_putmessage.message, status, 1);
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status =
 		    node_put_message(args->args_node_putmessage.hnode, &msg,
 				     args->args_node_putmessage.utimeout);
@@ -1413,7 +1413,7 @@ u32 strmwrap_allocate_buffer(union trapped_args *args, void *pr_ctxt)
 	status = strm_allocate_buffer(args->args_strm_allocatebuffer.hstream,
 				      args->args_strm_allocatebuffer.usize,
 				      ap_buffer, num_bufs, pr_ctxt);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		CP_TO_USR(args->args_strm_allocatebuffer.ap_buffer, ap_buffer,
 			  status, num_bufs);
 		if (DSP_FAILED(status)) {
@@ -1454,7 +1454,7 @@ u32 strmwrap_free_buffer(union trapped_args *args, void *pr_ctxt)
 	CP_FM_USR(ap_buffer, args->args_strm_freebuffer.ap_buffer, status,
 		  num_bufs);
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = strm_free_buffer(args->args_strm_freebuffer.hstream,
 					  ap_buffer, num_bufs, pr_ctxt);
 	}
@@ -1490,7 +1490,7 @@ u32 strmwrap_get_info(union trapped_args *args, void *pr_ctxt)
 
 	strm_info.user_strm = &user;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = strm_get_info(args->args_strm_getinfo.hstream,
 				       &strm_info,
 				       args->args_strm_getinfo.
@@ -1551,7 +1551,7 @@ u32 strmwrap_open(union trapped_args *args, void *pr_ctxt)
 
 	if (attr.stream_attr_in != NULL) {	/* Optional argument */
 		CP_FM_USR(&strm_attr_in, attr.stream_attr_in, status, 1);
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			attr.stream_attr_in = &strm_attr_in;
 			if (attr.stream_attr_in->strm_mode == STRMMODE_LDMA)
 				return -ENOSYS;
@@ -1627,7 +1627,7 @@ u32 strmwrap_select(union trapped_args *args, void *pr_ctxt)
 
 	CP_FM_USR(strm_tab, args->args_strm_select.stream_tab, status,
 		  args->args_strm_select.strm_num);
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		status = strm_select(strm_tab, args->args_strm_select.strm_num,
 				     &mask, args->args_strm_select.utimeout);
 	}
diff --git a/drivers/staging/tidspbridge/pmgr/io.c b/drivers/staging/tidspbridge/pmgr/io.c
index 2c26f06..7970fe5 100644
--- a/drivers/staging/tidspbridge/pmgr/io.c
+++ b/drivers/staging/tidspbridge/pmgr/io.c
@@ -67,14 +67,14 @@ int io_create(struct io_mgr **io_man, struct dev_object *hdev_obj,
 	if (mgr_attrts->word_size == 0)
 		status = -EINVAL;
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		dev_get_intf_fxns(hdev_obj, &intf_fxns);
 
 		/* Let Bridge channel module finish the create: */
 		status = (*intf_fxns->pfn_io_create) (&hio_mgr, hdev_obj,
 						      mgr_attrts);
 
-		if (DSP_SUCCEEDED(status)) {
+		if (!status) {
 			pio_mgr = (struct io_mgr_ *)hio_mgr;
 			pio_mgr->intf_fxns = intf_fxns;
 			pio_mgr->hdev_obj = hdev_obj;
diff --git a/drivers/staging/tidspbridge/pmgr/msg.c b/drivers/staging/tidspbridge/pmgr/msg.c
index 884f8b5..abd4365 100644
--- a/drivers/staging/tidspbridge/pmgr/msg.c
+++ b/drivers/staging/tidspbridge/pmgr/msg.c
@@ -66,7 +66,7 @@ int msg_create(struct msg_mgr **msg_man,
 	status =
 	    (*intf_fxns->pfn_msg_create) (&hmsg_mgr, hdev_obj, msg_callback);
 
-	if (DSP_SUCCEEDED(status)) {
+	if (!status) {
 		/* Fill in DSP API message module's fields of the msg_mgr
 		 * structure */
 		msg_mgr_obj = (struct msg_mgr_ *)hmsg_mgr;
-- 
1.7.1

