From 803cd75eff2d560d622da69569f0bf66a3ea4ed1 Mon Sep 17 00:00:00 2001
From: Armando Uribe <x0095078@ti.com>
Date: Thu, 22 Jul 2010 20:25:32 -0500
Subject: [PATCH 66/94] staging: tidspbridge: Remove macros used as cast

This patch removes those macros that are used to
perform casts

Signed-off-by: Armando Uribe <x0095078@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/dynload/cload.c        |   19 ++++++-------------
 drivers/staging/tidspbridge/dynload/doff.h         |    7 ++-----
 drivers/staging/tidspbridge/dynload/getsection.c   |   16 ++++------------
 drivers/staging/tidspbridge/dynload/reloc.c        |    2 +-
 .../tidspbridge/dynload/reloc_table_c6000.c        |    2 +-
 .../tidspbridge/dynload/tramp_table_c6000.c        |    2 +-
 drivers/staging/tidspbridge/pmgr/dbll.c            |    5 +----
 7 files changed, 16 insertions(+), 37 deletions(-)

diff --git a/drivers/staging/tidspbridge/dynload/cload.c b/drivers/staging/tidspbridge/dynload/cload.c
index 32150f0..c85a5e8 100644
--- a/drivers/staging/tidspbridge/dynload/cload.c
+++ b/drivers/staging/tidspbridge/dynload/cload.c
@@ -20,13 +20,6 @@
 #define LINKER_MODULES_HEADER ("_" MODULES_HEADER)
 
 /*
- * we use the fact that DOFF section records are shaped just like
- * ldr_section_info to reduce our section storage usage.  This macro marks
- * the places where that assumption is made
- */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
-
-/*
  * forward references
  */
 static void dload_symbols(struct dload_state *dlthis);
@@ -519,17 +512,17 @@ static void allocate_sections(struct dload_state *dlthis)
 #if BITS_PER_AU <= BITS_PER_BYTE
 		/* attempt to insert the name of this section */
 		if (soffset < dlthis->dfile_hdr.df_strtab_size)
-			DOFFSEC_IS_LDRSEC(shp)->name = dlthis->str_head +
-			    soffset;
+			((struct ldr_section_info *)shp)->name =
+				dlthis->str_head + soffset;
 		else {
 			dload_error(dlthis, "Bad name offset in section %d",
 				    curr_sect);
-			DOFFSEC_IS_LDRSEC(shp)->name = NULL;
+			((struct ldr_section_info *)shp)->name = NULL;
 		}
 #endif
 		/* allocate target storage for sections that require it */
 		if (ds_needs_allocation(shp)) {
-			*asecs = *DOFFSEC_IS_LDRSEC(shp);
+			*asecs = *(struct ldr_section_info *)shp;
 			asecs->context = 0;	/* zero the context field */
 #if BITS_PER_AU > BITS_PER_BYTE
 			asecs->name = unpack_name(dlthis, soffset);
@@ -1162,7 +1155,7 @@ static void dload_data(struct dload_state *dlthis)
 			if (curr_sect < dlthis->allocated_secn_count)
 				dlthis->delta_runaddr = sptr->ds_paddr;
 			else {
-				lptr = DOFFSEC_IS_LDRSEC(sptr);
+				lptr = (struct ldr_section_info *)sptr;
 				dlthis->delta_runaddr = 0;
 			}
 			dlthis->image_secn = lptr;
@@ -1337,7 +1330,7 @@ static void dload_data(struct dload_state *dlthis)
 			goto loop_cont;
 
 		if (curr_sect >= dlthis->allocated_secn_count)
-			lptr = DOFFSEC_IS_LDRSEC(sptr);
+			lptr = (struct ldr_section_info *)sptr;
 
 		if (cinit_processed) {
 			/*Don't clear BSS after load-time initialization */
diff --git a/drivers/staging/tidspbridge/dynload/doff.h b/drivers/staging/tidspbridge/dynload/doff.h
index c00d189..a7c3145 100644
--- a/drivers/staging/tidspbridge/dynload/doff.h
+++ b/drivers/staging/tidspbridge/dynload/doff.h
@@ -24,11 +24,8 @@
 #ifndef _DOFF_H
 #define _DOFF_H
 
-#ifndef UINT32_C
-#define UINT32_C(zzz) ((u32)zzz)
-#endif
 
-#define BYTE_RESHUFFLE_VALUE UINT32_C(0x00010203)
+#define BYTE_RESHUFFLE_VALUE 0x00010203
 
 /* DOFF file header containing fields categorizing the remainder of the file */
 struct doff_filehdr_t {
@@ -312,7 +309,7 @@ struct reloc_record_t {
 
 /* Return the address/size >= to addr that is at a 32-bit boundary */
 /* This assumes that a byte is 8 bits */
-#define         DOFF_ALIGN(addr)            (((addr) + 3) & ~UINT32_C(3))
+#define         DOFF_ALIGN(addr)            (((addr) + 3) & ~3UL)
 
 /**************************************************************************** */
 /* */
diff --git a/drivers/staging/tidspbridge/dynload/getsection.c b/drivers/staging/tidspbridge/dynload/getsection.c
index 3086118..51a7167 100644
--- a/drivers/staging/tidspbridge/dynload/getsection.c
+++ b/drivers/staging/tidspbridge/dynload/getsection.c
@@ -34,14 +34,6 @@ static const char err_alloc[] = { "Syms->dload_allocate( %d ) failed" };
 static const char stbl[] = { "Bad string table offset " FMT_UI32 };
 #endif
 
-/*
- * we use the fact that DOFF section records are shaped just like
- * ldr_section_info to reduce our section storage usage.  These macros
- * marks the places where that assumption is made
- */
-#define DOFFSEC_IS_LDRSEC(pdoffsec) ((struct ldr_section_info *)(pdoffsec))
-#define LDRSEC_IS_DOFFSEC(ldrsec) ((struct doff_scnhdr_t *)(ldrsec))
-
 /************************************************************** */
 /********************* SUPPORT FUNCTIONS ********************** */
 /************************************************************** */
@@ -110,7 +102,7 @@ static void expand_sec_names(struct dload_state *dlthis)
 	/* For each sec, copy and expand its name */
 	curr = xstrings;
 	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
-		shp = DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		shp = (struct ldr_section_info *)&dlthis->sect_hdrs[sec];
 		next = unpack_sec_name(dlthis, *(u32 *) &shp->name, curr);
 		if (next == NULL)
 			break;	/* error */
@@ -213,7 +205,7 @@ void *dload_module_open(struct dynamic_loader_stream *module,
 	/* to a pointer into the string table. */
 	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
 		struct ldr_section_info *shp =
-		    DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		    (struct ldr_section_info *)&dlthis->sect_hdrs[sec];
 		shp->name = dlthis->str_head + *(u32 *) &shp->name;
 	}
 #endif
@@ -249,7 +241,7 @@ int dload_get_section_info(void *minfo, const char *section_name,
 		return false;
 
 	for (sec = 0; sec < dlthis->dfile_hdr.df_no_scns; sec++) {
-		shp = DOFFSEC_IS_LDRSEC(&dlthis->sect_hdrs[sec]);
+		shp = (struct ldr_section_info *)&dlthis->sect_hdrs[sec];
 		if (strcmp(section_name, shp->name) == 0) {
 			*section_info = shp;
 			return true;
@@ -294,7 +286,7 @@ int dload_get_section(void *minfo,
 	dlthis = (struct dload_state *)minfo;
 	if (!dlthis)
 		return false;
-	sptr = LDRSEC_IS_DOFFSEC(section_info);
+	sptr = (struct doff_scnhdr_t *)section_info;
 	if (sptr == NULL)
 		return false;
 
diff --git a/drivers/staging/tidspbridge/dynload/reloc.c b/drivers/staging/tidspbridge/dynload/reloc.c
index ec59777..7b28c07 100644
--- a/drivers/staging/tidspbridge/dynload/reloc.c
+++ b/drivers/staging/tidspbridge/dynload/reloc.c
@@ -107,7 +107,7 @@ int dload_repack(struct dload_state *dlthis, rvalue val, tgt_au_t * data,
 
 	fieldsz -= 1;	/* avoid nastiness with 32-bit shift of 32-bit value */
 	/* clip the bits */
-	mask = ((UINT32_C(2) << fieldsz) - 1);
+	mask = (2UL << fieldsz) - 1;
 	objval = (val & mask);
 	/* * store the bits through the specified mask */
 	if (TARGET_BIG_ENDIAN) {
diff --git a/drivers/staging/tidspbridge/dynload/reloc_table_c6000.c b/drivers/staging/tidspbridge/dynload/reloc_table_c6000.c
index 8ae3b38..a28bc04 100644
--- a/drivers/staging/tidspbridge/dynload/reloc_table_c6000.c
+++ b/drivers/staging/tidspbridge/dynload/reloc_table_c6000.c
@@ -16,7 +16,7 @@
 
 /* Tables generated for c6000 */
 
-#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+#define HASH_FUNC(zz) (((((zz) + 1) * 1845UL) >> 11) & 63)
 #define HASH_L(zz) ((zz) >> 8)
 #define HASH_I(zz) ((zz) & 0xFF)
 
diff --git a/drivers/staging/tidspbridge/dynload/tramp_table_c6000.c b/drivers/staging/tidspbridge/dynload/tramp_table_c6000.c
index 47b7492..09cc64f 100644
--- a/drivers/staging/tidspbridge/dynload/tramp_table_c6000.c
+++ b/drivers/staging/tidspbridge/dynload/tramp_table_c6000.c
@@ -27,7 +27,7 @@
 #define C6X_TRAMP_MAX_RELOS			 8
 
 /*  THIS HASH FUNCTION MUST MATCH THE ONE reloc_table_c6000.c */
-#define HASH_FUNC(zz) (((((zz) + 1) * UINT32_C(1845)) >> 11) & 63)
+#define HASH_FUNC(zz) (((((zz) + 1) * 1845UL) >> 11) & 63)
 
 /*  THIS MUST MATCH reloc_record_t FOR A SYMBOL BASED RELO */
 struct c6000_relo_record {
diff --git a/drivers/staging/tidspbridge/pmgr/dbll.c b/drivers/staging/tidspbridge/pmgr/dbll.c
index e8da030..d1806aa 100644
--- a/drivers/staging/tidspbridge/pmgr/dbll.c
+++ b/drivers/staging/tidspbridge/pmgr/dbll.c
@@ -41,10 +41,7 @@
 /* Max buffer length */
 #define MAXEXPR 128
 
-#ifndef UINT32_C
-#define UINT32_C(zzz) ((uint32_t)zzz)
-#endif
-#define DOFF_ALIGN(x) (((x) + 3) & ~UINT32_C(3))
+#define DOFF_ALIGN(x) (((x) + 3) & ~3UL)
 
 /*
  *  ======== struct dbll_tar_obj* ========
-- 
1.7.0.4

