From a5120278008a5f48634085c23a70f1153065765d Mon Sep 17 00:00:00 2001
From: Rene Sapiens <rene.sapiens@ti.com>
Date: Fri, 9 Jul 2010 21:23:59 -0500
Subject: [PATCH 37/94] staging: ti dspbridge: Rename words with camel case.

The intention of this patch is to rename the remaining variables with camel
case. Variables will be renamed avoiding camel case and Hungarian notation.
The words to be renamed in this patch are:
========================================
pdwSize to buff_size
pdwState to board_state
pdwValue to value
pdwVersion to version
pElemExisting to elem_existing
pEntry to entry
pExists to exists
pfEnablePerf to enable_perf
pGenObj to gen_obj
phChnlMgr to channel_mgr
phChnl to chnl
phCodMgr to cod_mgr
phDCDHandle to dcd_handle
phDcdMgr to dcd_mgr
phDehMgr to deh_manager
========================================

Signed-off-by: Rene Sapiens <rene.sapiens@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/core/chnl_sm.c         |   18 ++--
 drivers/staging/tidspbridge/core/tiomap3430.c      |    6 +-
 .../staging/tidspbridge/include/dspbridge/cfg.h    |   30 +++---
 .../staging/tidspbridge/include/dspbridge/chnl.h   |    6 +-
 .../staging/tidspbridge/include/dspbridge/dbdcd.h  |   12 +-
 .../staging/tidspbridge/include/dspbridge/dbll.h   |    2 +-
 .../tidspbridge/include/dspbridge/dblldefs.h       |    2 +-
 .../staging/tidspbridge/include/dspbridge/dev.h    |   20 ++--
 .../tidspbridge/include/dspbridge/dspchnl.h        |    4 +-
 .../tidspbridge/include/dspbridge/dspdefs.h        |   25 ++--
 drivers/staging/tidspbridge/include/dspbridge/io.h |    2 +-
 .../staging/tidspbridge/include/dspbridge/list.h   |   10 +-
 .../staging/tidspbridge/include/dspbridge/mgr.h    |   10 +-
 drivers/staging/tidspbridge/pmgr/chnl.c            |    8 +-
 drivers/staging/tidspbridge/pmgr/dbll.c            |   10 +-
 drivers/staging/tidspbridge/pmgr/dev.c             |   20 ++--
 drivers/staging/tidspbridge/rmgr/dbdcd.c           |  134 ++++++++++----------
 drivers/staging/tidspbridge/rmgr/mgr.c             |   12 +-
 drivers/staging/tidspbridge/rmgr/nldr.c            |    8 +-
 drivers/staging/tidspbridge/services/cfg.c         |   22 ++--
 20 files changed, 182 insertions(+), 179 deletions(-)

diff --git a/drivers/staging/tidspbridge/core/chnl_sm.c b/drivers/staging/tidspbridge/core/chnl_sm.c
index 834172d..cec3bb5 100644
--- a/drivers/staging/tidspbridge/core/chnl_sm.c
+++ b/drivers/staging/tidspbridge/core/chnl_sm.c
@@ -380,7 +380,7 @@ func_cont:
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  */
-int bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+int bridge_chnl_create(OUT struct chnl_mgr **channel_mgr,
 			      struct dev_object *hdev_obj,
 			      IN CONST struct chnl_mgrattrs *pMgrAttrs)
 {
@@ -389,7 +389,7 @@ int bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
 	u8 max_channels;
 
 	/* Check DBC requirements: */
-	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(channel_mgr != NULL);
 	DBC_REQUIRE(pMgrAttrs != NULL);
 	DBC_REQUIRE(pMgrAttrs->max_channels > 0);
 	DBC_REQUIRE(pMgrAttrs->max_channels <= CHNL_MAXCHANNELS);
@@ -430,10 +430,10 @@ int bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
 
 	if (DSP_FAILED(status)) {
 		bridge_chnl_destroy(chnl_mgr_obj);
-		*phChnlMgr = NULL;
+		*channel_mgr = NULL;
 	} else {
 		/* Return channel manager object to caller... */
-		*phChnlMgr = chnl_mgr_obj;
+		*channel_mgr = chnl_mgr_obj;
 	}
 	return status;
 }
@@ -774,7 +774,7 @@ int bridge_chnl_idle(struct chnl_object *chnl_obj, u32 timeout,
  *  ======== bridge_chnl_open ========
  *      Open a new half-duplex channel to the DSP board.
  */
-int bridge_chnl_open(OUT struct chnl_object **phChnl,
+int bridge_chnl_open(OUT struct chnl_object **chnl,
 			    struct chnl_mgr *hchnl_mgr, s8 chnl_mode,
 			    u32 uChnlId, CONST IN struct chnl_attr *pattrs)
 {
@@ -783,10 +783,10 @@ int bridge_chnl_open(OUT struct chnl_object **phChnl,
 	struct chnl_object *pchnl = NULL;
 	struct sync_object *sync_event = NULL;
 	/* Ensure DBC requirements: */
-	DBC_REQUIRE(phChnl != NULL);
+	DBC_REQUIRE(chnl != NULL);
 	DBC_REQUIRE(pattrs != NULL);
 	DBC_REQUIRE(hchnl_mgr != NULL);
-	*phChnl = NULL;
+	*chnl = NULL;
 	/* Validate Args: */
 	if (pattrs->uio_reqs == 0) {
 		status = -EINVAL;
@@ -893,10 +893,10 @@ int bridge_chnl_open(OUT struct chnl_object **phChnl,
 		spin_unlock_bh(&chnl_mgr_obj->chnl_mgr_lock);
 		/* Return result... */
 		pchnl->dw_state = CHNL_STATEREADY;
-		*phChnl = pchnl;
+		*chnl = pchnl;
 	}
 func_end:
-	DBC_ENSURE((DSP_SUCCEEDED(status) && pchnl) || (*phChnl == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && pchnl) || (*chnl == NULL));
 	return status;
 }
 
diff --git a/drivers/staging/tidspbridge/core/tiomap3430.c b/drivers/staging/tidspbridge/core/tiomap3430.c
index dd7436d..dc20cad 100644
--- a/drivers/staging/tidspbridge/core/tiomap3430.c
+++ b/drivers/staging/tidspbridge/core/tiomap3430.c
@@ -82,7 +82,7 @@ static int bridge_brd_read(struct bridge_dev_context *dev_context,
 static int bridge_brd_start(struct bridge_dev_context *dev_context,
 				   u32 dsp_addr);
 static int bridge_brd_status(struct bridge_dev_context *dev_context,
-				    int *pdwState);
+				    int *board_state);
 static int bridge_brd_stop(struct bridge_dev_context *dev_context);
 static int bridge_brd_write(struct bridge_dev_context *dev_context,
 				   IN u8 *host_buff,
@@ -753,10 +753,10 @@ static int bridge_brd_delete(struct bridge_dev_context *dev_ctxt)
  *      Returns the board status.
  */
 static int bridge_brd_status(struct bridge_dev_context *dev_ctxt,
-				    int *pdwState)
+				    int *board_state)
 {
 	struct bridge_dev_context *dev_context = dev_ctxt;
-	*pdwState = dev_context->dw_brd_state;
+	*board_state = dev_context->dw_brd_state;
 	return 0;
 }
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/cfg.h b/drivers/staging/tidspbridge/include/dspbridge/cfg.h
index 0eadd71..29f9024 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/cfg.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/cfg.h
@@ -58,9 +58,9 @@ extern int cfg_get_auto_start(IN struct cfg_devnode *dev_node_obj,
  *  Purpose:
  *      Retrieves the version of the PM Class Driver.
  *  Parameters:
- *      pdwVersion: Ptr to u32 to contain version number upon return.
+ *      version:    Ptr to u32 to contain version number upon return.
  *  Returns:
- *      0:    Success.  pdwVersion contains Class Driver version in
+ *      0:    Success.  version contains Class Driver version in
  *                  the form: 0xAABBCCDD where AABB is Major version and
  *                  CCDD is Minor.
  *      -EPERM:  Failure.
@@ -68,9 +68,9 @@ extern int cfg_get_auto_start(IN struct cfg_devnode *dev_node_obj,
  *      CFG initialized.
  *  Ensures:
  *      0:    Success.
- *      else:       *pdwVersion is NULL.
+ *      else:       *version is NULL.
  */
-extern int cfg_get_cd_version(OUT u32 *pdwVersion);
+extern int cfg_get_cd_version(OUT u32 *version);
 
 /*
  *  ======== cfg_get_dev_object ========
@@ -79,7 +79,7 @@ extern int cfg_get_cd_version(OUT u32 *pdwVersion);
  *  Parameters:
  *      dev_node_obj:	Platform's dev_node handle from which to retrieve
  *      		value.
- *      pdwValue:       Ptr to location to store the value.
+ *      value:          Ptr to location to store the value.
  *  Returns:
  *      0:                Success.
  *      -EFAULT: dev_node_obj is invalid or phDevObject is invalid.
@@ -87,11 +87,11 @@ extern int cfg_get_cd_version(OUT u32 *pdwVersion);
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      0:    *pdwValue is set to the retrieved u32.
- *      else:       *pdwValue is set to 0L.
+ *      0:    *value is set to the retrieved u32.
+ *      else:       *value is set to 0L.
  */
 extern int cfg_get_dev_object(IN struct cfg_devnode *dev_node_obj,
-				     OUT u32 *pdwValue);
+				     OUT u32 *value);
 
 /*
  *  ======== cfg_get_exec_file ========
@@ -120,17 +120,17 @@ extern int cfg_get_exec_file(IN struct cfg_devnode *dev_node_obj,
  *  Purpose:
  *      Retrieve the Driver Object handle From the Registry
  *  Parameters:
- *      pdwValue:   Ptr to location to store the value.
+ *      value:      Ptr to location to store the value.
  *      dw_type      Type of Object to Get
  *  Returns:
  *      0:    Success.
  *  Requires:
  *      CFG initialized.
  *  Ensures:
- *      0:    *pdwValue is set to the retrieved u32(non-Zero).
- *      else:       *pdwValue is set to 0L.
+ *      0:    *value is set to the retrieved u32(non-Zero).
+ *      else:       *value is set to 0L.
  */
-extern int cfg_get_object(OUT u32 *pdwValue, u8 dw_type);
+extern int cfg_get_object(OUT u32 *value, u8 dw_type);
 
 /*
  *  ======== cfg_get_perf_value ========
@@ -138,15 +138,15 @@ extern int cfg_get_object(OUT u32 *pdwValue, u8 dw_type);
  *      Retrieve a flag indicating whether PERF should log statistics for the
  *      PM class driver.
  *  Parameters:
- *      pfEnablePerf:   Location to store flag.  0 indicates the key was
+ *      enable_perf:    Location to store flag.  0 indicates the key was
  *                      not found, or had a zero value.  A nonzero value
  *                      means the key was found and had a nonzero value.
  *  Returns:
  *  Requires:
- *      pfEnablePerf != NULL;
+ *      enable_perf != NULL;
  *  Ensures:
  */
-extern void cfg_get_perf_value(OUT bool *pfEnablePerf);
+extern void cfg_get_perf_value(OUT bool *enable_perf);
 
 /*
  *  ======== cfg_get_zl_file ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/chnl.h b/drivers/staging/tidspbridge/include/dspbridge/chnl.h
index 89315dc..7b0352e 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/chnl.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/chnl.h
@@ -51,7 +51,7 @@ extern int chnl_close(struct chnl_object *chnl_obj);
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given board.
  *  Parameters:
- *      phChnlMgr:      Location to store a channel manager object on output.
+ *      channel_mgr:    Location to store a channel manager object on output.
  *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
  *      pMgrAttrs->max_channels:   Max channels
@@ -70,14 +70,14 @@ extern int chnl_close(struct chnl_object *chnl_obj);
  *      -EEXIST:       Channel manager already exists for this device.
  *  Requires:
  *      chnl_init(void) called.
- *      phChnlMgr != NULL.
+ *      channel_mgr != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
  *      0:                Subsequent calls to chnl_create() for the same
  *                              board without an intervening call to
  *                              chnl_destroy() will fail.
  */
-extern int chnl_create(OUT struct chnl_mgr **phChnlMgr,
+extern int chnl_create(OUT struct chnl_mgr **channel_mgr,
 			      struct dev_object *hdev_obj,
 			      IN CONST struct chnl_mgrattrs *pMgrAttrs);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dbdcd.h b/drivers/staging/tidspbridge/include/dspbridge/dbdcd.h
index 2a2b655..8c06272 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dbdcd.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dbdcd.h
@@ -77,7 +77,7 @@ extern int dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
  *      This function creates a DCD module manager.
  *  Parameters:
  *      pszZlDllName:   Pointer to a DLL name string.
- *      phDcdMgr:       A pointer to a DCD manager handle.
+ *      dcd_mgr:        A pointer to a DCD manager handle.
  *  Returns:
  *      0:        Success.
  *      -ENOMEM:    Unable to allocate memory for DCD manager handle.
@@ -85,12 +85,12 @@ extern int dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
  *  Requires:
  *      DCD initialized.
  *      pszZlDllName is non-NULL.
- *      phDcdMgr is non-NULL.
+ *      dcd_mgr is non-NULL.
  *  Ensures:
  *      A DCD manager handle is created.
  */
 extern int dcd_create_manager(IN char *pszZlDllName,
-				     OUT struct dcd_manager **phDcdMgr);
+				     OUT struct dcd_manager **dcd_mgr);
 
 /*
  *  ======== dcd_destroy_manager ========
@@ -215,7 +215,7 @@ extern int dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
  *      uuid_obj:	Pointer to a dsp_uuid that represents a unique DSP/BIOS
  *                      Bridge object.
  *      pstrLibName: Buffer to hold library name.
- *      pdwSize: Contains buffer size. Set to string size on output.
+ *      buff_size: Contains buffer size. Set to string size on output.
  *      phase:          Which phase to load
  *      phase_split:    Are phases in multiple libraries
  *  Returns:
@@ -226,13 +226,13 @@ extern int dcd_get_num_dep_libs(IN struct dcd_manager *hdcd_mgr,
  *      Valid hdcd_mgr.
  *      pstrLibName != NULL.
  *      uuid_obj != NULL
- *      pdwSize != NULL.
+ *      buff_size != NULL.
  *  Ensures:
  */
 extern int dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 				       IN struct dsp_uuid *uuid_obj,
 				       IN OUT char *pstrLibName,
-				       IN OUT u32 *pdwSize,
+				       IN OUT u32 *buff_size,
 				       IN enum nldr_phase phase,
 				       OUT bool *phase_split);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dbll.h b/drivers/staging/tidspbridge/include/dspbridge/dbll.h
index 0d03714..daf8105 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dbll.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dbll.h
@@ -41,7 +41,7 @@ extern int dbll_get_sect(struct dbll_library_obj *lib, char *name,
 extern bool dbll_init(void);
 extern int dbll_load(struct dbll_library_obj *lib,
 			    dbll_flags flags,
-			    struct dbll_attrs *attrs, u32 * pEntry);
+			    struct dbll_attrs *attrs, u32 * entry);
 extern int dbll_load_sect(struct dbll_library_obj *lib,
 				 char *sectName, struct dbll_attrs *attrs);
 extern int dbll_open(struct dbll_tar_obj *target, char *file,
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dblldefs.h b/drivers/staging/tidspbridge/include/dspbridge/dblldefs.h
index d780ee8..da8abf4 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dblldefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dblldefs.h
@@ -342,7 +342,7 @@ typedef bool(*dbll_init_fxn) (void);
  *  Requires:
  *      DBL initialized.
  *      Valid lib.
- *      pEntry != NULL.
+ *      entry != NULL.
  *  Ensures:
  */
 typedef int(*dbll_load_fxn) (struct dbll_library_obj *lib,
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dev.h b/drivers/staging/tidspbridge/include/dspbridge/dev.h
index 2e18edf..3d7a08a 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dev.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dev.h
@@ -263,19 +263,19 @@ extern int dev_get_dmm_mgr(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      *phCodMgr:      Ptr to location to store handle.
+ *      *cod_mgr:       Ptr to location to store handle.
  *  Returns:
  *      0:        Success.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phCodMgr != NULL.
+ *      cod_mgr != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phCodMgr contains a handle to a COD manager object.
- *      else:           *phCodMgr is NULL.
+ *      0:        *cod_mgr contains a handle to a COD manager object.
+ *      else:           *cod_mgr is NULL.
  */
 extern int dev_get_cod_mgr(struct dev_object *hdev_obj,
-				  OUT struct cod_manager **phCodMgr);
+				  OUT struct cod_manager **cod_mgr);
 
 /*
  *  ======== dev_get_deh_mgr ========
@@ -283,19 +283,19 @@ extern int dev_get_cod_mgr(struct dev_object *hdev_obj,
  *      Retrieve the DEH manager created for this device.
  *  Parameters:
  *      hdev_obj: Handle to device object created with dev_create_device().
- *      *phDehMgr:  Ptr to location to store handle.
+ *      *deh_manager:  Ptr to location to store handle.
  *  Returns:
  *      0:    Success.
  *      -EFAULT:   Invalid hdev_obj.
  *  Requires:
- *      phDehMgr != NULL.
+ *      deh_manager != NULL.
  *      DEH Initialized.
  *  Ensures:
- *      0:    *phDehMgr contains a handle to a DEH manager object.
- *      else:       *phDehMgr is NULL.
+ *      0:    *deh_manager contains a handle to a DEH manager object.
+ *      else:       *deh_manager is NULL.
  */
 extern int dev_get_deh_mgr(struct dev_object *hdev_obj,
-				  OUT struct deh_mgr **phDehMgr);
+				  OUT struct deh_mgr **deh_manager);
 
 /*
  *  ======== dev_get_dev_node ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspchnl.h b/drivers/staging/tidspbridge/include/dspbridge/dspchnl.h
index 34ce4e8..c009204 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspchnl.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspchnl.h
@@ -24,14 +24,14 @@
 #ifndef DSPCHNL_
 #define DSPCHNL_
 
-extern int bridge_chnl_create(OUT struct chnl_mgr **phChnlMgr,
+extern int bridge_chnl_create(OUT struct chnl_mgr **channel_mgr,
 				     struct dev_object *hdev_obj,
 				     IN CONST struct chnl_mgrattrs
 				     *pMgrAttrs);
 
 extern int bridge_chnl_destroy(struct chnl_mgr *hchnl_mgr);
 
-extern int bridge_chnl_open(OUT struct chnl_object **phChnl,
+extern int bridge_chnl_open(OUT struct chnl_object **chnl,
 				   struct chnl_mgr *hchnl_mgr,
 				   s8 chnl_mode,
 				   u32 uChnlId,
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
index 19301b2..f8146cc 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
@@ -228,17 +228,18 @@ typedef int(*fxn_brd_stop) (struct bridge_dev_context *dev_ctxt);
  *      Report the current state of the board.
  *  Parameters:
  *      dev_ctxt:    Handle to Bridge driver defined device context.
- *      pdwState:       Ptr to BRD status variable.
+ *      board_state:    Ptr to BRD status variable.
  *  Returns:
  *      0:
  *  Requires:
- *      pdwState != NULL;
+ *      board_state != NULL;
  *      dev_ctxt != NULL
  *  Ensures:
- *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
+ *      *board_state is one of
+ *       {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
  */
 typedef int(*fxn_brd_status) (struct bridge_dev_context *dev_ctxt,
-				     int *pdwState);
+				     int *board_state);
 
 /*
  *  ======== bridge_brd_read ========
@@ -297,7 +298,7 @@ typedef int(*fxn_brd_write) (struct bridge_dev_context *dev_ctxt,
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  *  Parameters:
- *      phChnlMgr:      Location to store a channel manager object on output.
+ *      channel_mgr:    Location to store a channel manager object on output.
  *      hdev_obj:     Handle to a device object.
  *      pMgrAttrs:      Channel manager attributes.
  *      pMgrAttrs->max_channels: Max channels
@@ -312,7 +313,7 @@ typedef int(*fxn_brd_write) (struct bridge_dev_context *dev_ctxt,
  *      -EIO:         Unable to plug ISR for given IRQ.
  *      -EFAULT:    Couldn't map physical address to a virtual one.
  *  Requires:
- *      phChnlMgr != NULL.
+ *      channel_mgr != NULL.
  *      pMgrAttrs != NULL
  *      pMgrAttrs field are all valid:
  *          0 < max_channels <= CHNL_MAXCHANNELS.
@@ -323,7 +324,7 @@ typedef int(*fxn_brd_write) (struct bridge_dev_context *dev_ctxt,
  *  Ensures:
  */
 typedef int(*fxn_chnl_create) (OUT struct chnl_mgr
-				      **phChnlMgr,
+				      **channel_mgr,
 				      struct dev_object
 				      * hdev_obj,
 				      IN CONST struct
@@ -367,7 +368,7 @@ typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
  *  Purpose:
  *      Open a new half-duplex channel to the DSP board.
  *  Parameters:
- *      phChnl:         Location to store a channel object handle.
+ *      chnl:           Location to store a channel object handle.
  *      hchnl_mgr:	Handle to channel manager, as returned by
  *      		CHNL_GetMgr().
  *      chnl_mode:          One of {CHNL_MODETODSP, CHNL_MODEFROMDSP} specifies
@@ -398,16 +399,16 @@ typedef void (*fxn_deh_notify) (struct deh_mgr *hdeh_mgr,
  *      -EIO:         No free IO request packets available for
  *                              queuing.
  *  Requires:
- *      phChnl != NULL.
+ *      chnl != NULL.
  *      pattrs != NULL.
  *      pattrs->event_obj is a valid event handle.
  *      pattrs->hReserved is the kernel mode handle for pattrs->event_obj.
  *  Ensures:
- *      0:                *phChnl is a valid channel.
- *      else:                   *phChnl is set to NULL if (phChnl != NULL);
+ *      0:                *chnl is a valid channel.
+ *      else:                   *chnl is set to NULL if (chnl != NULL);
  */
 typedef int(*fxn_chnl_open) (OUT struct chnl_object
-				    **phChnl,
+				    **chnl,
 				    struct chnl_mgr *hchnl_mgr,
 				    s8 chnl_mode,
 				    u32 uChnlId,
diff --git a/drivers/staging/tidspbridge/include/dspbridge/io.h b/drivers/staging/tidspbridge/include/dspbridge/io.h
index e1610f1..123cf03 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/io.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/io.h
@@ -30,7 +30,7 @@
  *      Create an IO manager object, responsible for managing IO between
  *      CHNL and msg_ctrl.
  *  Parameters:
- *      phChnlMgr:              Location to store a channel manager object on
+ *      channel_mgr:            Location to store a channel manager object on
  *                              output.
  *      hdev_obj:             Handle to a device object.
  *      pMgrAttrs:              IO manager attributes.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/list.h b/drivers/staging/tidspbridge/include/dspbridge/list.h
index dc8ae09..2cf885d 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/list.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/list.h
@@ -123,21 +123,21 @@ static inline void lst_init_elem(struct list_head *elem_list)
  *  Parameters:
  *      pList:          Pointer to list control structure.
  *      elem_list:          Pointer to element in list to insert.
- *      pElemExisting:  Pointer to existing list element.
+ *      elem_existing:  Pointer to existing list element.
  *  Returns:
  *  Requires:
  *      - LST initialized.
  *      - pList != NULL.
  *      - elem_list != NULL.
- *      - pElemExisting != NULL.
+ *      - elem_existing != NULL.
  *  Ensures:
  */
 static inline void lst_insert_before(struct lst_list *pList,
 				     struct list_head *elem_list,
-				     struct list_head *pElemExisting)
+				     struct list_head *elem_existing)
 {
-	if (pList && elem_list && pElemExisting)
-		list_add_tail(elem_list, pElemExisting);
+	if (pList && elem_list && elem_existing)
+		list_add_tail(elem_list, elem_existing);
 }
 
 /*
diff --git a/drivers/staging/tidspbridge/include/dspbridge/mgr.h b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
index e225845..90e174c 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/mgr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
@@ -174,19 +174,19 @@ extern void mgr_exit(void);
  *      Retrieves the MGR handle. Accessor Function
  *  Parameters:
  *      mgr_handle:     Handle to the Manager Object
- *      phDCDHandle:    Ptr to receive the DCD Handle.
+ *      dcd_handle:     Ptr to receive the DCD Handle.
  *  Returns:
  *      0:        Sucess
  *      -EPERM:      Failure to get the Handle
  *  Requires:
  *      MGR is initialized.
- *      phDCDHandle != NULL
+ *      dcd_handle != NULL
  *  Ensures:
- *      0 and *phDCDHandle != NULL ||
- *      -EPERM and *phDCDHandle == NULL
+ *      0 and *dcd_handle != NULL ||
+ *      -EPERM and *dcd_handle == NULL
  */
 extern int mgr_get_dcd_handle(IN struct mgr_object
-				     *mgr_handle, OUT u32 *phDCDHandle);
+				     *mgr_handle, OUT u32 *dcd_handle);
 
 /*
  *  ======== mgr_init ========
diff --git a/drivers/staging/tidspbridge/pmgr/chnl.c b/drivers/staging/tidspbridge/pmgr/chnl.c
index bc969d8..0ba5039 100644
--- a/drivers/staging/tidspbridge/pmgr/chnl.c
+++ b/drivers/staging/tidspbridge/pmgr/chnl.c
@@ -51,7 +51,7 @@ static u32 refs;
  *      Create a channel manager object, responsible for opening new channels
  *      and closing old ones for a given 'Bridge board.
  */
-int chnl_create(OUT struct chnl_mgr **phChnlMgr,
+int chnl_create(OUT struct chnl_mgr **channel_mgr,
 		       struct dev_object *hdev_obj,
 		       IN CONST struct chnl_mgrattrs *pMgrAttrs)
 {
@@ -60,10 +60,10 @@ int chnl_create(OUT struct chnl_mgr **phChnlMgr,
 	struct chnl_mgr_ *chnl_mgr_obj = NULL;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phChnlMgr != NULL);
+	DBC_REQUIRE(channel_mgr != NULL);
 	DBC_REQUIRE(pMgrAttrs != NULL);
 
-	*phChnlMgr = NULL;
+	*channel_mgr = NULL;
 
 	/* Validate args: */
 	if ((0 < pMgrAttrs->max_channels) &&
@@ -96,7 +96,7 @@ int chnl_create(OUT struct chnl_mgr **phChnlMgr,
 			chnl_mgr_obj = (struct chnl_mgr_ *)hchnl_mgr;
 			chnl_mgr_obj->intf_fxns = intf_fxns;
 			/* Finally, return the new channel manager handle: */
-			*phChnlMgr = hchnl_mgr;
+			*channel_mgr = hchnl_mgr;
 		}
 	}
 
diff --git a/drivers/staging/tidspbridge/pmgr/dbll.c b/drivers/staging/tidspbridge/pmgr/dbll.c
index 29918cc..530191a 100644
--- a/drivers/staging/tidspbridge/pmgr/dbll.c
+++ b/drivers/staging/tidspbridge/pmgr/dbll.c
@@ -451,7 +451,7 @@ bool dbll_init(void)
  *  ======== dbll_load ========
  */
 int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
-		     struct dbll_attrs *attrs, u32 *pEntry)
+		     struct dbll_attrs *attrs, u32 *entry)
 {
 	struct dbll_library_obj *zl_lib = (struct dbll_library_obj *)lib;
 	struct dbll_tar_obj *dbzl;
@@ -461,7 +461,7 @@ int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 	bool opened_doff = false;
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(zl_lib);
-	DBC_REQUIRE(pEntry != NULL);
+	DBC_REQUIRE(entry != NULL);
 	DBC_REQUIRE(attrs != NULL);
 
 	/*
@@ -550,7 +550,7 @@ int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 				redefined_symbol = false;
 				status = -EILSEQ;
 			} else {
-				*pEntry = zl_lib->entry;
+				*entry = zl_lib->entry;
 			}
 		}
 	}
@@ -563,8 +563,8 @@ int dbll_load(struct dbll_library_obj *lib, dbll_flags flags,
 
 	DBC_ENSURE(DSP_FAILED(status) || zl_lib->load_ref > 0);
 
-	dev_dbg(bridge, "%s: lib: %p flags: 0x%x pEntry: %p, status 0x%x\n",
-		__func__, lib, flags, pEntry, status);
+	dev_dbg(bridge, "%s: lib: %p flags: 0x%x entry: %p, status 0x%x\n",
+		__func__, lib, flags, entry, status);
 
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index 2e4726e..1cb891f 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -500,23 +500,23 @@ int dev_get_dmm_mgr(struct dev_object *hdev_obj,
  *      Retrieve the COD manager create for this device.
  */
 int dev_get_cod_mgr(struct dev_object *hdev_obj,
-			   OUT struct cod_manager **phCodMgr)
+			   OUT struct cod_manager **cod_mgr)
 {
 	int status = 0;
 	struct dev_object *dev_obj = hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phCodMgr != NULL);
+	DBC_REQUIRE(cod_mgr != NULL);
 
 	if (hdev_obj) {
-		*phCodMgr = dev_obj->cod_mgr;
+		*cod_mgr = dev_obj->cod_mgr;
 	} else {
-		*phCodMgr = NULL;
+		*cod_mgr = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phCodMgr != NULL) &&
-					     (*phCodMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((cod_mgr != NULL) &&
+					     (*cod_mgr == NULL)));
 	return status;
 }
 
@@ -524,17 +524,17 @@ int dev_get_cod_mgr(struct dev_object *hdev_obj,
  *  ========= dev_get_deh_mgr ========
  */
 int dev_get_deh_mgr(struct dev_object *hdev_obj,
-			   OUT struct deh_mgr **phDehMgr)
+			   OUT struct deh_mgr **deh_manager)
 {
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDehMgr != NULL);
+	DBC_REQUIRE(deh_manager != NULL);
 	DBC_REQUIRE(hdev_obj);
 	if (hdev_obj) {
-		*phDehMgr = hdev_obj->hdeh_mgr;
+		*deh_manager = hdev_obj->hdeh_mgr;
 	} else {
-		*phDehMgr = NULL;
+		*deh_manager = NULL;
 		status = -EFAULT;
 	}
 	return status;
diff --git a/drivers/staging/tidspbridge/rmgr/dbdcd.c b/drivers/staging/tidspbridge/rmgr/dbdcd.c
index be98c4c..595f9ec 100644
--- a/drivers/staging/tidspbridge/rmgr/dbdcd.c
+++ b/drivers/staging/tidspbridge/rmgr/dbdcd.c
@@ -64,7 +64,7 @@ static u32 enum_refs;
 static s32 atoi(char *psz_buf);
 static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 				     enum dsp_dcdobjtype obj_type,
-				     struct dcd_genericobj *pGenObj);
+				     struct dcd_genericobj *gen_obj);
 static void compress_buf(char *psz_buf, u32 ul_buf_size, s32 char_size);
 static char dsp_char2_gpp_char(char *pWord, s32 dsp_char_size);
 static int get_dep_lib_info(IN struct dcd_manager *hdcd_mgr,
@@ -125,14 +125,14 @@ int dcd_auto_unregister(IN struct dcd_manager *hdcd_mgr,
  *      Creates DCD manager.
  */
 int dcd_create_manager(IN char *pszZlDllName,
-			      OUT struct dcd_manager **phDcdMgr)
+			      OUT struct dcd_manager **dcd_mgr)
 {
 	struct cod_manager *cod_mgr;	/* COD manager handle */
 	struct dcd_manager *dcd_mgr_obj = NULL;	/* DCD Manager pointer */
 	int status = 0;
 
 	DBC_REQUIRE(refs >= 0);
-	DBC_REQUIRE(phDcdMgr);
+	DBC_REQUIRE(dcd_mgr);
 
 	status = cod_create(&cod_mgr, pszZlDllName, NULL);
 	if (DSP_FAILED(status))
@@ -145,7 +145,7 @@ int dcd_create_manager(IN char *pszZlDllName,
 		dcd_mgr_obj->cod_mgr = cod_mgr;
 
 		/* Return handle to this DCD interface. */
-		*phDcdMgr = dcd_mgr_obj;
+		*dcd_mgr = dcd_mgr_obj;
 	} else {
 		status = -ENOMEM;
 
@@ -644,7 +644,8 @@ func_end:
  */
 int dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 				IN struct dsp_uuid *uuid_obj,
-				IN OUT char *pstrLibName, IN OUT u32 * pdwSize,
+				IN OUT char *pstrLibName,
+				IN OUT u32 *buff_size,
 				enum nldr_phase phase, OUT bool *phase_split)
 {
 	char sz_reg_key[DCD_MAXPATHLENGTH];
@@ -656,11 +657,12 @@ int dcd_get_library_name(IN struct dcd_manager *hdcd_mgr,
 
 	DBC_REQUIRE(uuid_obj != NULL);
 	DBC_REQUIRE(pstrLibName != NULL);
-	DBC_REQUIRE(pdwSize != NULL);
+	DBC_REQUIRE(buff_size != NULL);
 	DBC_REQUIRE(hdcd_mgr);
 
-	dev_dbg(bridge, "%s: hdcd_mgr %p, uuid_obj %p, pstrLibName %p, pdwSize "
-		"%p\n", __func__, hdcd_mgr, uuid_obj, pstrLibName, pdwSize);
+	dev_dbg(bridge, "%s: hdcd_mgr %p, uuid_obj %p, pstrLibName %p,"
+		" buff_size %p\n", __func__, hdcd_mgr, uuid_obj, pstrLibName,
+		buff_size);
 
 	/*
 	 *  Pre-determine final key length. It's length of DCD_REGKEY +
@@ -1033,7 +1035,7 @@ static s32 atoi(char *psz_buf)
  */
 static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 				     enum dsp_dcdobjtype obj_type,
-				     struct dcd_genericobj *pGenObj)
+				     struct dcd_genericobj *gen_obj)
 {
 	int status = 0;
 	char seps[] = ", ";
@@ -1049,7 +1051,7 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 	DBC_REQUIRE(ul_buf_size != 0);
 	DBC_REQUIRE((obj_type == DSP_DCDNODETYPE)
 		    || (obj_type == DSP_DCDPROCESSORTYPE));
-	DBC_REQUIRE(pGenObj != NULL);
+	DBC_REQUIRE(gen_obj != NULL);
 
 	switch (obj_type) {
 	case DSP_DCDNODETYPE:
@@ -1061,13 +1063,13 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		token = strsep(&psz_cur, seps);
 
 		/* u32 cb_struct */
-		pGenObj->obj_data.node_obj.ndb_props.cb_struct =
+		gen_obj->obj_data.node_obj.ndb_props.cb_struct =
 		    (u32) atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* dsp_uuid ui_node_id */
 		uuid_uuid_from_string(token,
-				      &pGenObj->obj_data.node_obj.ndb_props.
+				      &gen_obj->obj_data.node_obj.ndb_props.
 				      ui_node_id);
 		token = strsep(&psz_cur, seps);
 
@@ -1077,154 +1079,154 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		if (token_len > DSP_MAXNAMELEN - 1)
 			token_len = DSP_MAXNAMELEN - 1;
 
-		strncpy(pGenObj->obj_data.node_obj.ndb_props.ac_name,
+		strncpy(gen_obj->obj_data.node_obj.ndb_props.ac_name,
 			token, token_len);
-		pGenObj->obj_data.node_obj.ndb_props.ac_name[token_len] = '\0';
+		gen_obj->obj_data.node_obj.ndb_props.ac_name[token_len] = '\0';
 		token = strsep(&psz_cur, seps);
 		/* u32 ntype */
-		pGenObj->obj_data.node_obj.ndb_props.ntype = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.ntype = atoi(token);
 		token = strsep(&psz_cur, seps);
 		/* u32 cache_on_gpp */
-		pGenObj->obj_data.node_obj.ndb_props.cache_on_gpp = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.cache_on_gpp = atoi(token);
 		token = strsep(&psz_cur, seps);
 		/* dsp_resourcereqmts dsp_resource_reqmts */
-		pGenObj->obj_data.node_obj.ndb_props.dsp_resource_reqmts.
+		gen_obj->obj_data.node_obj.ndb_props.dsp_resource_reqmts.
 		    cb_struct = (u32) atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.static_data_size = atoi(token);
 		token = strsep(&psz_cur, seps);
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.global_data_size = atoi(token);
 		token = strsep(&psz_cur, seps);
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.program_mem_size = atoi(token);
 		token = strsep(&psz_cur, seps);
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.uwc_execution_time = atoi(token);
 		token = strsep(&psz_cur, seps);
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.uwc_period = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.uwc_deadline = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.avg_exection_time = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.node_obj.ndb_props.
+		gen_obj->obj_data.node_obj.ndb_props.
 		    dsp_resource_reqmts.minimum_period = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* s32 prio */
-		pGenObj->obj_data.node_obj.ndb_props.prio = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.prio = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 stack_size */
-		pGenObj->obj_data.node_obj.ndb_props.stack_size = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.stack_size = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 sys_stack_size */
-		pGenObj->obj_data.node_obj.ndb_props.sys_stack_size =
+		gen_obj->obj_data.node_obj.ndb_props.sys_stack_size =
 		    atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 stack_seg */
-		pGenObj->obj_data.node_obj.ndb_props.stack_seg = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.stack_seg = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 message_depth */
-		pGenObj->obj_data.node_obj.ndb_props.message_depth =
+		gen_obj->obj_data.node_obj.ndb_props.message_depth =
 		    atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 num_input_streams */
-		pGenObj->obj_data.node_obj.ndb_props.num_input_streams =
+		gen_obj->obj_data.node_obj.ndb_props.num_input_streams =
 		    atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 num_output_streams */
-		pGenObj->obj_data.node_obj.ndb_props.num_output_streams =
+		gen_obj->obj_data.node_obj.ndb_props.num_output_streams =
 		    atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* u32 utimeout */
-		pGenObj->obj_data.node_obj.ndb_props.utimeout = atoi(token);
+		gen_obj->obj_data.node_obj.ndb_props.utimeout = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* char *pstr_create_phase_fxn */
 		DBC_REQUIRE(token);
 		token_len = strlen(token);
-		pGenObj->obj_data.node_obj.pstr_create_phase_fxn =
+		gen_obj->obj_data.node_obj.pstr_create_phase_fxn =
 					kzalloc(token_len + 1, GFP_KERNEL);
-		strncpy(pGenObj->obj_data.node_obj.pstr_create_phase_fxn,
+		strncpy(gen_obj->obj_data.node_obj.pstr_create_phase_fxn,
 			token, token_len);
-		pGenObj->obj_data.node_obj.pstr_create_phase_fxn[token_len] =
+		gen_obj->obj_data.node_obj.pstr_create_phase_fxn[token_len] =
 		    '\0';
 		token = strsep(&psz_cur, seps);
 
 		/* char *pstr_execute_phase_fxn */
 		DBC_REQUIRE(token);
 		token_len = strlen(token);
-		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn =
+		gen_obj->obj_data.node_obj.pstr_execute_phase_fxn =
 					kzalloc(token_len + 1, GFP_KERNEL);
-		strncpy(pGenObj->obj_data.node_obj.pstr_execute_phase_fxn,
+		strncpy(gen_obj->obj_data.node_obj.pstr_execute_phase_fxn,
 			token, token_len);
-		pGenObj->obj_data.node_obj.pstr_execute_phase_fxn[token_len] =
+		gen_obj->obj_data.node_obj.pstr_execute_phase_fxn[token_len] =
 		    '\0';
 		token = strsep(&psz_cur, seps);
 
 		/* char *pstr_delete_phase_fxn */
 		DBC_REQUIRE(token);
 		token_len = strlen(token);
-		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn =
+		gen_obj->obj_data.node_obj.pstr_delete_phase_fxn =
 					kzalloc(token_len + 1, GFP_KERNEL);
-		strncpy(pGenObj->obj_data.node_obj.pstr_delete_phase_fxn,
+		strncpy(gen_obj->obj_data.node_obj.pstr_delete_phase_fxn,
 			token, token_len);
-		pGenObj->obj_data.node_obj.pstr_delete_phase_fxn[token_len] =
+		gen_obj->obj_data.node_obj.pstr_delete_phase_fxn[token_len] =
 		    '\0';
 		token = strsep(&psz_cur, seps);
 
 		/* Segment id for message buffers */
-		pGenObj->obj_data.node_obj.msg_segid = atoi(token);
+		gen_obj->obj_data.node_obj.msg_segid = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* Message notification type */
-		pGenObj->obj_data.node_obj.msg_notify_type = atoi(token);
+		gen_obj->obj_data.node_obj.msg_notify_type = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* char *pstr_i_alg_name */
 		if (token) {
 			token_len = strlen(token);
-			pGenObj->obj_data.node_obj.pstr_i_alg_name =
+			gen_obj->obj_data.node_obj.pstr_i_alg_name =
 					kzalloc(token_len + 1, GFP_KERNEL);
-			strncpy(pGenObj->obj_data.node_obj.pstr_i_alg_name,
+			strncpy(gen_obj->obj_data.node_obj.pstr_i_alg_name,
 				token, token_len);
-			pGenObj->obj_data.node_obj.pstr_i_alg_name[token_len] =
+			gen_obj->obj_data.node_obj.pstr_i_alg_name[token_len] =
 			    '\0';
 			token = strsep(&psz_cur, seps);
 		}
 
 		/* Load type (static, dynamic, or overlay) */
 		if (token) {
-			pGenObj->obj_data.node_obj.us_load_type = atoi(token);
+			gen_obj->obj_data.node_obj.us_load_type = atoi(token);
 			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load data requirements */
 		if (token) {
-			pGenObj->obj_data.node_obj.ul_data_mem_seg_mask =
+			gen_obj->obj_data.node_obj.ul_data_mem_seg_mask =
 			    atoi(token);
 			token = strsep(&psz_cur, seps);
 		}
 
 		/* Dynamic load code requirements */
 		if (token) {
-			pGenObj->obj_data.node_obj.ul_code_mem_seg_mask =
+			gen_obj->obj_data.node_obj.ul_code_mem_seg_mask =
 			    atoi(token);
 			token = strsep(&psz_cur, seps);
 		}
@@ -1232,16 +1234,16 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		/* Extract node profiles into node properties */
 		if (token) {
 
-			pGenObj->obj_data.node_obj.ndb_props.count_profiles =
+			gen_obj->obj_data.node_obj.ndb_props.count_profiles =
 			    atoi(token);
 			for (i = 0;
 			     i <
-			     pGenObj->obj_data.node_obj.
+			     gen_obj->obj_data.node_obj.
 			     ndb_props.count_profiles; i++) {
 				token = strsep(&psz_cur, seps);
 				if (token) {
 					/* Heap Size for the node */
-					pGenObj->obj_data.node_obj.
+					gen_obj->obj_data.node_obj.
 					    ndb_props.node_profiles[i].
 					    ul_heap_size = atoi(token);
 				}
@@ -1249,7 +1251,7 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		}
 		token = strsep(&psz_cur, seps);
 		if (token) {
-			pGenObj->obj_data.node_obj.ndb_props.stack_seg_name =
+			gen_obj->obj_data.node_obj.ndb_props.stack_seg_name =
 			    (u32) (token);
 		}
 
@@ -1263,45 +1265,45 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		psz_cur = psz_buf;
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.cb_struct = atoi(token);
+		gen_obj->obj_data.proc_info.cb_struct = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.processor_family = atoi(token);
+		gen_obj->obj_data.proc_info.processor_family = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.processor_type = atoi(token);
+		gen_obj->obj_data.proc_info.processor_type = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.clock_rate = atoi(token);
+		gen_obj->obj_data.proc_info.clock_rate = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.ul_internal_mem_size = atoi(token);
+		gen_obj->obj_data.proc_info.ul_internal_mem_size = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.ul_external_mem_size = atoi(token);
+		gen_obj->obj_data.proc_info.ul_external_mem_size = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.processor_id = atoi(token);
+		gen_obj->obj_data.proc_info.processor_id = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.ty_running_rtos = atoi(token);
+		gen_obj->obj_data.proc_info.ty_running_rtos = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.node_min_priority = atoi(token);
+		gen_obj->obj_data.proc_info.node_min_priority = atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		pGenObj->obj_data.proc_info.node_max_priority = atoi(token);
+		gen_obj->obj_data.proc_info.node_max_priority = atoi(token);
 
 #ifdef _DB_TIOMAP
 		/* Proc object may contain additional(extended) attributes. */
 		/* attr must match proc.hxx */
 		for (entry_id = 0; entry_id < 7; entry_id++) {
 			token = strsep(&psz_cur, seps);
-			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			gen_obj->obj_data.ext_proc_obj.ty_tlb[entry_id].
 			    ul_gpp_phys = atoi(token);
 
 			token = strsep(&psz_cur, seps);
-			pGenObj->obj_data.ext_proc_obj.ty_tlb[entry_id].
+			gen_obj->obj_data.ext_proc_obj.ty_tlb[entry_id].
 			    ul_dsp_virt = atoi(token);
 		}
 #endif
diff --git a/drivers/staging/tidspbridge/rmgr/mgr.c b/drivers/staging/tidspbridge/rmgr/mgr.c
index 52d7865..43be669 100644
--- a/drivers/staging/tidspbridge/rmgr/mgr.c
+++ b/drivers/staging/tidspbridge/rmgr/mgr.c
@@ -304,21 +304,21 @@ void mgr_exit(void)
  *      Retrieves the MGR handle. Accessor Function.
  */
 int mgr_get_dcd_handle(struct mgr_object *mgr_handle,
-			      OUT u32 *phDCDHandle)
+			      OUT u32 *dcd_handle)
 {
 	int status = -EPERM;
 	struct mgr_object *pmgr_obj = (struct mgr_object *)mgr_handle;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDCDHandle != NULL);
+	DBC_REQUIRE(dcd_handle != NULL);
 
-	*phDCDHandle = (u32) NULL;
+	*dcd_handle = (u32) NULL;
 	if (pmgr_obj) {
-		*phDCDHandle = (u32) pmgr_obj->hdcd_mgr;
+		*dcd_handle = (u32) pmgr_obj->hdcd_mgr;
 		status = 0;
 	}
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDCDHandle != (u32) NULL) ||
-		   (DSP_FAILED(status) && *phDCDHandle == (u32) NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *dcd_handle != (u32) NULL) ||
+		   (DSP_FAILED(status) && *dcd_handle == (u32) NULL));
 
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/rmgr/nldr.c b/drivers/staging/tidspbridge/rmgr/nldr.c
index 91b32cb..51b9d03 100644
--- a/drivers/staging/tidspbridge/rmgr/nldr.c
+++ b/drivers/staging/tidspbridge/rmgr/nldr.c
@@ -290,7 +290,7 @@ static int add_ovly_node(struct dsp_uuid *uuid_obj,
 static int add_ovly_sect(struct nldr_object *nldr_obj,
 				struct ovly_sect **pList,
 				struct dbll_sect_info *pSectInfo,
-				bool *pExists, u32 addr, u32 bytes);
+				bool *exists, u32 addr, u32 bytes);
 static s32 fake_ovly_write(void *handle, u32 dsp_address, void *buf, u32 bytes,
 			   s32 mtype);
 static void free_sects(struct nldr_object *nldr_obj,
@@ -1073,7 +1073,7 @@ func_end:
 static int add_ovly_sect(struct nldr_object *nldr_obj,
 				struct ovly_sect **pList,
 				struct dbll_sect_info *pSectInfo,
-				bool *pExists, u32 addr, u32 bytes)
+				bool *exists, u32 addr, u32 bytes)
 {
 	struct ovly_sect *new_sect = NULL;
 	struct ovly_sect *last_sect;
@@ -1081,7 +1081,7 @@ static int add_ovly_sect(struct nldr_object *nldr_obj,
 	int status = 0;
 
 	ovly_section = last_sect = *pList;
-	*pExists = false;
+	*exists = false;
 	while (ovly_section) {
 		/*
 		 *  Make sure section has not already been added. Multiple
@@ -1089,7 +1089,7 @@ static int add_ovly_sect(struct nldr_object *nldr_obj,
 		 */
 		if (ovly_section->sect_load_addr == addr) {
 			/* Already added */
-			*pExists = true;
+			*exists = true;
 			break;
 		}
 		last_sect = ovly_section;
diff --git a/drivers/staging/tidspbridge/services/cfg.c b/drivers/staging/tidspbridge/services/cfg.c
index cc138f7..53ede23 100644
--- a/drivers/staging/tidspbridge/services/cfg.c
+++ b/drivers/staging/tidspbridge/services/cfg.c
@@ -76,7 +76,7 @@ int cfg_get_auto_start(struct cfg_devnode *dev_node_obj,
  *      Retrieve the Device Object handle for a given devnode.
  */
 int cfg_get_dev_object(struct cfg_devnode *dev_node_obj,
-			      OUT u32 *pdwValue)
+			      OUT u32 *value)
 {
 	int status = 0;
 	u32 dw_buf_size;
@@ -88,10 +88,10 @@ int cfg_get_dev_object(struct cfg_devnode *dev_node_obj,
 	if (!dev_node_obj)
 		status = -EFAULT;
 
-	if (!pdwValue)
+	if (!value)
 		status = -EFAULT;
 
-	dw_buf_size = sizeof(pdwValue);
+	dw_buf_size = sizeof(value);
 	if (DSP_SUCCEEDED(status)) {
 
 		/* check the device string and then store dev object */
@@ -99,7 +99,7 @@ int cfg_get_dev_object(struct cfg_devnode *dev_node_obj,
 		    (strcmp
 		     ((char *)((struct drv_ext *)dev_node_obj)->sz_string,
 		      "TIOMAP1510")))
-			*pdwValue = (u32)drv_datap->dev_object;
+			*value = (u32)drv_datap->dev_object;
 	}
 	if (DSP_FAILED(status))
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
@@ -142,12 +142,12 @@ int cfg_get_exec_file(struct cfg_devnode *dev_node_obj, u32 ul_buf_size,
  *  Purpose:
  *      Retrieve the Object handle from the Registry
  */
-int cfg_get_object(OUT u32 *pdwValue, u8 dw_type)
+int cfg_get_object(OUT u32 *value, u8 dw_type)
 {
 	int status = -EINVAL;
 	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
-	DBC_REQUIRE(pdwValue != NULL);
+	DBC_REQUIRE(value != NULL);
 
 	if (!drv_datap)
 		return -EPERM;
@@ -155,7 +155,7 @@ int cfg_get_object(OUT u32 *pdwValue, u8 dw_type)
 	switch (dw_type) {
 	case (REG_DRV_OBJECT):
 		if (drv_datap->drv_object) {
-			*pdwValue = (u32)drv_datap->drv_object;
+			*value = (u32)drv_datap->drv_object;
 			status = 0;
 		} else {
 			status = -ENODATA;
@@ -163,7 +163,7 @@ int cfg_get_object(OUT u32 *pdwValue, u8 dw_type)
 		break;
 	case (REG_MGR_OBJECT):
 		if (drv_datap->mgr_object) {
-			*pdwValue = (u32)drv_datap->mgr_object;
+			*value = (u32)drv_datap->mgr_object;
 			status = 0;
 		} else {
 			status = -ENODATA;
@@ -174,11 +174,11 @@ int cfg_get_object(OUT u32 *pdwValue, u8 dw_type)
 		break;
 	}
 	if (DSP_FAILED(status)) {
-		*pdwValue = 0;
+		*value = 0;
 		pr_err("%s: Failed, status 0x%x\n", __func__, status);
 	}
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *pdwValue != 0) ||
-		   (DSP_FAILED(status) && *pdwValue == 0));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *value != 0) ||
+		   (DSP_FAILED(status) && *value == 0));
 	return status;
 }
 
-- 
1.7.0.4

