From 647833268eed70218c0e56e1464611b19625be58 Mon Sep 17 00:00:00 2001
From: Rene Sapiens <rene.sapiens@ti.com>
Date: Tue, 18 Jan 2011 03:19:11 +0000
Subject: [PATCH 34/37] staging: tidspbridge: set9 remove hungarian from structs

hungarian notation will be removed from the elements inside
structures, the next varibles will be renamed:

Original:               Replacement:
hprocessor              processor
udma_priority           dma_priority
udsp_data_mau_size      dsp_data_mau_size
udsp_heap_addr          dsp_heap_addr
udsp_heap_res_addr      dsp_heap_res_addr
udsp_heap_virt_addr     dsp_heap_virt_addr
udsp_mau_size           dsp_mau_size
udsp_word_size          dsp_word_size
ugpp_heap_addr          gpp_heap_addr
ugpp_heap_virt_addr     gpp_heap_virt_addr
us_data2                data2
us_data3                data3
uc_data4                data4
uc_data5                data5
uc_data6                data6
us_load_type            load_type
usm_length              sm_length
utimeout                timeout
uwc_deadline            wc_deadline
uwc_execution_time      wc_execution_time
uwc_period              wc_period

Signed-off-by: Rene Sapiens <rene.sapiens@ti.com>
Signed-off-by: Armando Uribe <x0095078@ti.com>
Signed-off-by: Omar Ramirez Luna <omar.ramirez@ti.com>
---
 drivers/staging/tidspbridge/gen/uuidutil.c         |   20 ++--
 .../tidspbridge/include/dspbridge/dbdcddef.h       |    2 +-
 .../staging/tidspbridge/include/dspbridge/dbdefs.h |   30 ++--
 .../staging/tidspbridge/include/dspbridge/drv.h    |    2 +-
 .../tidspbridge/include/dspbridge/dspapi-ioctl.h   |   44 +++---
 .../tidspbridge/include/dspbridge/dspdefs.h        |    2 +-
 drivers/staging/tidspbridge/include/dspbridge/io.h |    2 +-
 .../tidspbridge/include/dspbridge/nodepriv.h       |    8 +-
 drivers/staging/tidspbridge/pmgr/dev.c             |    4 +-
 drivers/staging/tidspbridge/pmgr/dspapi.c          |   44 +++---
 drivers/staging/tidspbridge/pmgr/io.c              |    2 +-
 drivers/staging/tidspbridge/rmgr/dbdcd.c           |   12 +-
 drivers/staging/tidspbridge/rmgr/disp.c            |    8 +-
 drivers/staging/tidspbridge/rmgr/drv.c             |    4 +-
 drivers/staging/tidspbridge/rmgr/nldr.c            |    6 +-
 drivers/staging/tidspbridge/rmgr/node.c            |  138 ++++++++++----------
 drivers/staging/tidspbridge/rmgr/proc.c            |   16 +-
 drivers/staging/tidspbridge/rmgr/strm.c            |   22 ++--
 18 files changed, 183 insertions(+), 183 deletions(-)

diff --git a/drivers/staging/tidspbridge/gen/uuidutil.c b/drivers/staging/tidspbridge/gen/uuidutil.c
index 2aa9b64..ff6ebad 100644
--- a/drivers/staging/tidspbridge/gen/uuidutil.c
+++ b/drivers/staging/tidspbridge/gen/uuidutil.c
@@ -45,11 +45,11 @@ void uuid_uuid_to_string(struct dsp_uuid *uuid_obj, char *sz_uuid,
 
 	i = snprintf(sz_uuid, size,
 		     "%.8X_%.4X_%.4X_%.2X%.2X_%.2X%.2X%.2X%.2X%.2X%.2X",
-		     uuid_obj->data1, uuid_obj->us_data2, uuid_obj->us_data3,
-		     uuid_obj->uc_data4, uuid_obj->uc_data5,
-		     uuid_obj->uc_data6[0], uuid_obj->uc_data6[1],
-		     uuid_obj->uc_data6[2], uuid_obj->uc_data6[3],
-		     uuid_obj->uc_data6[4], uuid_obj->uc_data6[5]);
+		     uuid_obj->data1, uuid_obj->data2, uuid_obj->data3,
+		     uuid_obj->data4, uuid_obj->data5,
+		     uuid_obj->data6[0], uuid_obj->data6[1],
+		     uuid_obj->data6[2], uuid_obj->data6[3],
+		     uuid_obj->data6[4], uuid_obj->data6[5]);
 
 	DBC_ENSURE(i != -1);
 }
@@ -85,29 +85,29 @@ void uuid_uuid_from_string(char *sz_uuid, struct dsp_uuid *uuid_obj)
 	/* Step over underscore */
 	sz_uuid++;
 
-	uuid_obj->us_data2 = (u16) uuid_hex_to_bin(sz_uuid, 4);
+	uuid_obj->data2 = (u16) uuid_hex_to_bin(sz_uuid, 4);
 	sz_uuid += 4;
 
 	/* Step over underscore */
 	sz_uuid++;
 
-	uuid_obj->us_data3 = (u16) uuid_hex_to_bin(sz_uuid, 4);
+	uuid_obj->data3 = (u16) uuid_hex_to_bin(sz_uuid, 4);
 	sz_uuid += 4;
 
 	/* Step over underscore */
 	sz_uuid++;
 
-	uuid_obj->uc_data4 = (u8) uuid_hex_to_bin(sz_uuid, 2);
+	uuid_obj->data4 = (u8) uuid_hex_to_bin(sz_uuid, 2);
 	sz_uuid += 2;
 
-	uuid_obj->uc_data5 = (u8) uuid_hex_to_bin(sz_uuid, 2);
+	uuid_obj->data5 = (u8) uuid_hex_to_bin(sz_uuid, 2);
 	sz_uuid += 2;
 
 	/* Step over underscore */
 	sz_uuid++;
 
 	for (j = 0; j < 6; j++) {
-		uuid_obj->uc_data6[j] = (u8) uuid_hex_to_bin(sz_uuid, 2);
+		uuid_obj->data6[j] = (u8) uuid_hex_to_bin(sz_uuid, 2);
 		sz_uuid += 2;
 	}
 }
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dbdcddef.h b/drivers/staging/tidspbridge/include/dspbridge/dbdcddef.h
index fc2a736..f97266c 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dbdcddef.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dbdcddef.h
@@ -54,7 +54,7 @@ struct dcd_nodeprops {
 	char *pstr_i_alg_name;
 
 	/* Dynamic load properties */
-	u16 us_load_type;	/* Static, dynamic, overlay */
+	u16 load_type;	/* Static, dynamic, overlay */
 	u32 data_mem_seg_mask;		/* Data memory requirements */
 	u32 code_mem_seg_mask;		/* Code memory requirements */
 };
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dbdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dbdefs.h
index 82e2439..592c16d 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dbdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dbdefs.h
@@ -100,11 +100,11 @@ static inline bool is_valid_proc_event(u32 x)
 /* The Node UUID structure */
 struct dsp_uuid {
 	u32 data1;
-	u16 us_data2;
-	u16 us_data3;
-	u8 uc_data4;
-	u8 uc_data5;
-	u8 uc_data6[6];
+	u16 data2;
+	u16 data3;
+	u8 data4;
+	u8 data5;
+	u8 data6[6];
 };
 
 /* DCD types */
@@ -229,11 +229,11 @@ struct dsp_strmattr {
 	u32 buf_size;		/* Buffer size (DSP words) */
 	u32 num_bufs;		/* Number of buffers */
 	u32 buf_alignment;	/* Buffer alignment */
-	u32 utimeout;		/* Timeout for blocking STRM calls */
+	u32 timeout;		/* Timeout for blocking STRM calls */
 	enum dsp_strmmode strm_mode;	/* mode of stream when opened */
 	/* DMA chnl id if dsp_strmmode is LDMA or RDMA */
 	u32 udma_chnl_id;
-	u32 udma_priority;	/* DMA channel priority 0=lowest, >0=high */
+	u32 dma_priority;	/* DMA channel priority 0=lowest, >0=high */
 };
 
 /* The dsp_cbdata structure */
@@ -255,9 +255,9 @@ struct dsp_resourcereqmts {
 	u32 static_data_size;
 	u32 global_data_size;
 	u32 program_mem_size;
-	u32 uwc_execution_time;
-	u32 uwc_period;
-	u32 uwc_deadline;
+	u32 wc_execution_time;
+	u32 wc_period;
+	u32 wc_deadline;
 	u32 avg_exection_time;
 	u32 minimum_period;
 };
@@ -294,7 +294,7 @@ struct dsp_ndbprops {
 	u32 message_depth;
 	u32 num_input_streams;
 	u32 num_output_streams;
-	u32 utimeout;
+	u32 timeout;
 	u32 count_profiles;	/* Number of supported profiles */
 	/* Array of profiles */
 	struct dsp_nodeprofs node_profiles[MAX_PROFILES];
@@ -306,7 +306,7 @@ struct dsp_ndbprops {
 struct dsp_nodeattrin {
 	u32 cb_struct;
 	s32 prio;
-	u32 utimeout;
+	u32 timeout;
 	u32 profile_id;
 	/* Reserved, for Bridge Internal use only */
 	u32 heap_size;
@@ -347,7 +347,7 @@ struct dsp_notification {
 /* The dsp_processorattrin structure describes the attributes of a processor */
 struct dsp_processorattrin {
 	u32 cb_struct;
-	u32 utimeout;
+	u32 timeout;
 };
 /*
  * The dsp_processorinfo structure describes basic capabilities of a
@@ -401,13 +401,13 @@ struct dsp_resourceinfo {
  */
 struct dsp_streamattrin {
 	u32 cb_struct;
-	u32 utimeout;
+	u32 timeout;
 	u32 segment_id;
 	u32 buf_alignment;
 	u32 num_bufs;
 	enum dsp_strmmode strm_mode;
 	u32 udma_chnl_id;
-	u32 udma_priority;
+	u32 dma_priority;
 };
 
 /* The dsp_bufferattr structure describes the attributes of a data buffer */
diff --git a/drivers/staging/tidspbridge/include/dspbridge/drv.h b/drivers/staging/tidspbridge/include/dspbridge/drv.h
index bcb2817..3b98c1a 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/drv.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/drv.h
@@ -129,7 +129,7 @@ struct process_context {
 	enum gpp_proc_res_state res_state;
 
 	/* Handle to Processor */
-	void *hprocessor;
+	void *processor;
 
 	/* DSP Node resources */
 	struct idr *node_id;
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspapi-ioctl.h b/drivers/staging/tidspbridge/include/dspbridge/dspapi-ioctl.h
index ab20062..1511922 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspapi-ioctl.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspapi-ioctl.h
@@ -56,7 +56,7 @@ union trapped_args {
 		struct dsp_notification __user *__user *anotifications;
 		u32 count;
 		u32 __user *pu_index;
-		u32 utimeout;
+		u32 timeout;
 	} args_mgr_wait;
 
 	/* PROC Module */
@@ -67,17 +67,17 @@ union trapped_args {
 	} args_proc_attach;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 cmd;
 		struct dsp_cbdata __user *pargs;
 	} args_proc_ctrl;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 	} args_proc_detach;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		void *__user *node_tab;
 		u32 node_tab_size;
 		u32 __user *pu_num_nodes;
@@ -85,53 +85,53 @@ union trapped_args {
 	} args_proc_enumnode_info;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 resource_type;
 		struct dsp_resourceinfo *resource_info;
 		u32 resource_info_size;
 	} args_proc_enumresources;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		struct dsp_processorstate __user *proc_state_obj;
 		u32 state_info_size;
 	} args_proc_getstate;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u8 __user *pbuf;
 		u8 __user *psize;
 		u32 max_size;
 	} args_proc_gettrace;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		s32 argc_index;
 		char __user *__user *user_args;
 		char *__user *user_envp;
 	} args_proc_load;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 event_mask;
 		u32 notify_type;
 		struct dsp_notification __user *hnotification;
 	} args_proc_register_notify;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 size;
 		void *__user *pp_rsv_addr;
 	} args_proc_rsvmem;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 size;
 		void *prsv_addr;
 	} args_proc_unrsvmem;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		void *pmpu_addr;
 		u32 size;
 		void *req_addr;
@@ -140,34 +140,34 @@ union trapped_args {
 	} args_proc_mapmem;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		u32 size;
 		void *map_addr;
 	} args_proc_unmapmem;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		void *pmpu_addr;
 		u32 size;
 		u32 dir;
 	} args_proc_dma;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		void *pmpu_addr;
 		u32 size;
 		u32 ul_flags;
 	} args_proc_flushmemory;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		void *pmpu_addr;
 		u32 size;
 	} args_proc_invalidatememory;
 
 	/* NODE Module */
 	struct {
-		void *hprocessor;
+		void *processor;
 		struct dsp_uuid __user *node_id_ptr;
 		struct dsp_cbdata __user *pargs;
 		struct dsp_nodeattrin __user *attr_in;
@@ -218,7 +218,7 @@ union trapped_args {
 	struct {
 		void *hnode;
 		struct dsp_msg __user *message;
-		u32 utimeout;
+		u32 timeout;
 	} args_node_getmessage;
 
 	struct {
@@ -228,7 +228,7 @@ union trapped_args {
 	struct {
 		void *hnode;
 		struct dsp_msg __user *message;
-		u32 utimeout;
+		u32 timeout;
 	} args_node_putmessage;
 
 	struct {
@@ -248,7 +248,7 @@ union trapped_args {
 	} args_node_terminate;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		struct dsp_uuid __user *node_id_ptr;
 		struct dsp_ndbprops __user *node_props;
 	} args_node_getuuidprops;
@@ -323,7 +323,7 @@ union trapped_args {
 		void *__user *stream_tab;
 		u32 strm_num;
 		u32 __user *pmask;
-		u32 utimeout;
+		u32 timeout;
 	} args_strm_select;
 
 	/* CMM Module */
@@ -341,7 +341,7 @@ union trapped_args {
 	} args_cmm_freebuf;
 
 	struct {
-		void *hprocessor;
+		void *processor;
 		struct cmm_object *__user *ph_cmm_mgr;
 	} args_cmm_gethandle;
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
index 7ba08ca..c2ba26c 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
@@ -300,7 +300,7 @@ typedef int(*fxn_brd_write) (struct bridge_dev_context *dev_ctxt,
  *      mgr_attrts->irq_shared:   TRUE if the IRQ is shareable.
  *      mgr_attrts->word_size: DSP Word size in equivalent PC bytes..
  *      mgr_attrts->shm_base:  Base physical address of shared memory, if any.
- *      mgr_attrts->usm_length: Bytes of shared memory block.
+ *      mgr_attrts->sm_length: Bytes of shared memory block.
  *  Returns:
  *      0:            Success;
  *      -ENOMEM:        Insufficient memory for requested resources.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/io.h b/drivers/staging/tidspbridge/include/dspbridge/io.h
index 9615980..500bbd7 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/io.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/io.h
@@ -31,7 +31,7 @@ struct io_attrs {
 	bool irq_shared;	/* TRUE if the IRQ is shareable. */
 	u32 word_size;		/* DSP Word size. */
 	u32 shm_base;		/* Physical base address of shared memory. */
-	u32 usm_length;		/* Size (in bytes) of shared memory. */
+	u32 sm_length;		/* Size (in bytes) of shared memory. */
 };
 
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/nodepriv.h b/drivers/staging/tidspbridge/include/dspbridge/nodepriv.h
index b14f79a..9c1e067 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/nodepriv.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/nodepriv.h
@@ -43,7 +43,7 @@ struct node_strmdef {
 	u32 buf_size;		/* Size of buffers for SIO stream */
 	u32 num_bufs;		/* max # of buffers in SIO stream at once */
 	u32 seg_id;		/* Memory segment id to allocate buffers */
-	u32 utimeout;		/* Timeout for blocking SIO calls */
+	u32 timeout;		/* Timeout for blocking SIO calls */
 	u32 buf_alignment;	/* Buffer alignment */
 	char *sz_device;	/* Device name for stream */
 };
@@ -55,10 +55,10 @@ struct node_taskargs {
 	u32 stack_size;
 	u32 sys_stack_size;
 	u32 stack_seg;
-	u32 udsp_heap_res_addr;	/* DSP virtual heap address */
-	u32 udsp_heap_addr;	/* DSP virtual heap address */
+	u32 dsp_heap_res_addr;	/* DSP virtual heap address */
+	u32 dsp_heap_addr;	/* DSP virtual heap address */
 	u32 heap_size;		/* Heap size */
-	u32 ugpp_heap_addr;	/* GPP virtual heap address */
+	u32 gpp_heap_addr;	/* GPP virtual heap address */
 	u32 profile_id;		/* Profile ID */
 	u32 num_inputs;
 	u32 num_outputs;
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index ce7360f..d35b2ad 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -215,12 +215,12 @@ int dev_create_device(struct dev_object **device_obj,
 			/* Assume last memory window is for CHNL */
 			io_mgr_attrs.shm_base = host_res->mem_base[1] +
 			    host_res->offset_for_monitor;
-			io_mgr_attrs.usm_length =
+			io_mgr_attrs.sm_length =
 			    host_res->mem_length[1] -
 			    host_res->offset_for_monitor;
 		} else {
 			io_mgr_attrs.shm_base = 0;
-			io_mgr_attrs.usm_length = 0;
+			io_mgr_attrs.sm_length = 0;
 			pr_err("%s: No memory reserved for shared structures\n",
 			       __func__);
 		}
diff --git a/drivers/staging/tidspbridge/pmgr/dspapi.c b/drivers/staging/tidspbridge/pmgr/dspapi.c
index b7ff378..912a1f9 100644
--- a/drivers/staging/tidspbridge/pmgr/dspapi.c
+++ b/drivers/staging/tidspbridge/pmgr/dspapi.c
@@ -569,7 +569,7 @@ u32 mgrwrap_wait_for_bridge_events(union trapped_args *args, void *pr_ctxt)
 		status = mgr_wait_for_bridge_events(anotifications, count,
 							 &index,
 							 args->args_mgr_wait.
-							 utimeout);
+							 timeout);
 	}
 	CP_TO_USR(args->args_mgr_wait.pu_index, &index, status, 1);
 	return status;
@@ -620,7 +620,7 @@ u32 procwrap_ctrl(union trapped_args *args, void *pr_ctxt)
 	    args->args_proc_ctrl.pargs;
 	u8 *pargs = NULL;
 	int status = 0;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (psize) {
 		if (get_user(cb_data_size, psize)) {
@@ -668,7 +668,7 @@ u32 procwrap_enum_node_info(union trapped_args *args, void *pr_ctxt)
 	void *node_tab[MAX_NODES];
 	u32 num_nodes;
 	u32 alloc_cnt;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (!args->args_proc_enumnode_info.node_tab_size)
 		return -EINVAL;
@@ -753,7 +753,7 @@ u32 procwrap_enum_resources(union trapped_args *args, void *pr_ctxt)
 {
 	int status = 0;
 	struct dsp_resourceinfo resource_info;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (args->args_proc_enumresources.resource_info_size <
 	    sizeof(struct dsp_resourceinfo))
@@ -780,7 +780,7 @@ u32 procwrap_get_state(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	struct dsp_processorstate proc_state;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (args->args_proc_getstate.state_info_size <
 	    sizeof(struct dsp_processorstate))
@@ -801,7 +801,7 @@ u32 procwrap_get_trace(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	u8 *pbuf;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
 		return -EINVAL;
@@ -830,7 +830,7 @@ u32 procwrap_load(union trapped_args *args, void *pr_ctxt)
 	char *temp;
 	s32 count = args->args_proc_load.argc_index;
 	u8 **argv = NULL, **envp = NULL;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (count <= 0 || count > MAX_LOADARGS) {
 		status = -EINVAL;
@@ -948,12 +948,12 @@ u32 procwrap_map(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	void *map_addr;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if (!args->args_proc_mapmem.size)
 		return -EINVAL;
 
-	status = proc_map(args->args_proc_mapmem.hprocessor,
+	status = proc_map(args->args_proc_mapmem.processor,
 			  args->args_proc_mapmem.pmpu_addr,
 			  args->args_proc_mapmem.size,
 			  args->args_proc_mapmem.req_addr, &map_addr,
@@ -975,7 +975,7 @@ u32 procwrap_register_notify(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	struct dsp_notification notification;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	/* Initialize the notification data structure */
 	notification.ps_name = NULL;
@@ -997,7 +997,7 @@ u32 procwrap_reserve_memory(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	void *prsv_addr;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	if ((args->args_proc_rsvmem.size <= 0) ||
 	    (args->args_proc_rsvmem.size & (PG_SIZE4K - 1)) != 0)
@@ -1010,7 +1010,7 @@ u32 procwrap_reserve_memory(union trapped_args *args, void *pr_ctxt)
 		if (put_user(prsv_addr, args->args_proc_rsvmem.pp_rsv_addr)) {
 			status = -EINVAL;
 			proc_un_reserve_memory(args->args_proc_rsvmem.
-					       hprocessor, prsv_addr, pr_ctxt);
+					       processor, prsv_addr, pr_ctxt);
 		}
 	}
 	return status;
@@ -1023,7 +1023,7 @@ u32 procwrap_start(union trapped_args *args, void *pr_ctxt)
 {
 	u32 ret;
 
-	ret = proc_start(((struct process_context *)pr_ctxt)->hprocessor);
+	ret = proc_start(((struct process_context *)pr_ctxt)->processor);
 	return ret;
 }
 
@@ -1034,7 +1034,7 @@ u32 procwrap_un_map(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 
-	status = proc_un_map(((struct process_context *)pr_ctxt)->hprocessor,
+	status = proc_un_map(((struct process_context *)pr_ctxt)->processor,
 			     args->args_proc_unmapmem.map_addr, pr_ctxt);
 	return status;
 }
@@ -1045,7 +1045,7 @@ u32 procwrap_un_map(union trapped_args *args, void *pr_ctxt)
 u32 procwrap_un_reserve_memory(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	status = proc_un_reserve_memory(hprocessor,
 					args->args_proc_unrsvmem.prsv_addr,
@@ -1060,7 +1060,7 @@ u32 procwrap_stop(union trapped_args *args, void *pr_ctxt)
 {
 	u32 ret;
 
-	ret = proc_stop(((struct process_context *)pr_ctxt)->hprocessor);
+	ret = proc_stop(((struct process_context *)pr_ctxt)->processor);
 
 	return ret;
 }
@@ -1092,7 +1092,7 @@ u32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)
 	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
 	struct node_res_object *node_res;
 	int nodeid;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	/* Optional argument */
 	if (psize) {
@@ -1378,7 +1378,7 @@ u32 nodewrap_get_message(union trapped_args *args, void *pr_ctxt)
 		return -EFAULT;
 
 	status = node_get_message(node_res->hnode, &msg,
-				  args->args_node_getmessage.utimeout);
+				  args->args_node_getmessage.timeout);
 
 	CP_TO_USR(args->args_node_getmessage.message, &msg, status, 1);
 
@@ -1422,7 +1422,7 @@ u32 nodewrap_put_message(union trapped_args *args, void *pr_ctxt)
 	if (!status) {
 		status =
 		    node_put_message(node_res->hnode, &msg,
-				     args->args_node_putmessage.utimeout);
+				     args->args_node_putmessage.timeout);
 	}
 
 	return status;
@@ -1508,7 +1508,7 @@ u32 nodewrap_get_uuid_props(union trapped_args *args, void *pr_ctxt)
 	int status = 0;
 	struct dsp_uuid node_uuid;
 	struct dsp_ndbprops *pnode_props = NULL;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
 		  1);
@@ -1853,7 +1853,7 @@ u32 strmwrap_select(union trapped_args *args, void *pr_ctxt)
 
 	if (!status) {
 		status = strm_select(strm_tab, args->args_strm_select.strm_num,
-				     &mask, args->args_strm_select.utimeout);
+				     &mask, args->args_strm_select.timeout);
 	}
 	CP_TO_USR(args->args_strm_select.pmask, &mask, status, 1);
 	return status;
@@ -1888,7 +1888,7 @@ u32 cmmwrap_get_handle(union trapped_args *args, void *pr_ctxt)
 {
 	int status = 0;
 	struct cmm_object *hcmm_mgr;
-	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->processor;
 
 	status = cmm_get_handle(hprocessor, &hcmm_mgr);
 
diff --git a/drivers/staging/tidspbridge/pmgr/io.c b/drivers/staging/tidspbridge/pmgr/io.c
index b05a772..65245f3 100644
--- a/drivers/staging/tidspbridge/pmgr/io.c
+++ b/drivers/staging/tidspbridge/pmgr/io.c
@@ -57,7 +57,7 @@ int io_create(struct io_mgr **io_man, struct dev_object *hdev_obj,
 	*io_man = NULL;
 
 	/* A memory base of 0 implies no memory base: */
-	if ((mgr_attrts->shm_base != 0) && (mgr_attrts->usm_length == 0))
+	if ((mgr_attrts->shm_base != 0) && (mgr_attrts->sm_length == 0))
 		status = -EINVAL;
 
 	if (mgr_attrts->word_size == 0)
diff --git a/drivers/staging/tidspbridge/rmgr/dbdcd.c b/drivers/staging/tidspbridge/rmgr/dbdcd.c
index 98b88b1..1e77c12 100644
--- a/drivers/staging/tidspbridge/rmgr/dbdcd.c
+++ b/drivers/staging/tidspbridge/rmgr/dbdcd.c
@@ -1112,14 +1112,14 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		    dsp_resource_reqmts.program_mem_size = atoi(token);
 		token = strsep(&psz_cur, seps);
 		gen_obj->obj_data.node_obj.ndb_props.
-		    dsp_resource_reqmts.uwc_execution_time = atoi(token);
+		    dsp_resource_reqmts.wc_execution_time = atoi(token);
 		token = strsep(&psz_cur, seps);
 		gen_obj->obj_data.node_obj.ndb_props.
-		    dsp_resource_reqmts.uwc_period = atoi(token);
+		    dsp_resource_reqmts.wc_period = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		gen_obj->obj_data.node_obj.ndb_props.
-		    dsp_resource_reqmts.uwc_deadline = atoi(token);
+		    dsp_resource_reqmts.wc_deadline = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		gen_obj->obj_data.node_obj.ndb_props.
@@ -1162,8 +1162,8 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 		    atoi(token);
 		token = strsep(&psz_cur, seps);
 
-		/* u32 utimeout */
-		gen_obj->obj_data.node_obj.ndb_props.utimeout = atoi(token);
+		/* u32 timeout */
+		gen_obj->obj_data.node_obj.ndb_props.timeout = atoi(token);
 		token = strsep(&psz_cur, seps);
 
 		/* char *pstr_create_phase_fxn */
@@ -1221,7 +1221,7 @@ static int get_attrs_from_buf(char *psz_buf, u32 ul_buf_size,
 
 		/* Load type (static, dynamic, or overlay) */
 		if (token) {
-			gen_obj->obj_data.node_obj.us_load_type = atoi(token);
+			gen_obj->obj_data.node_obj.load_type = atoi(token);
 			token = strsep(&psz_cur, seps);
 		}
 
diff --git a/drivers/staging/tidspbridge/rmgr/disp.c b/drivers/staging/tidspbridge/rmgr/disp.c
index e5af59e..d38ea2d 100644
--- a/drivers/staging/tidspbridge/rmgr/disp.c
+++ b/drivers/staging/tidspbridge/rmgr/disp.c
@@ -402,7 +402,7 @@ int disp_node_create(struct disp_object *disp_obj,
 			more_task_args->sysstack_size =
 			    task_arg_obj.sys_stack_size;
 			more_task_args->stack_seg = task_arg_obj.stack_seg;
-			more_task_args->heap_addr = task_arg_obj.udsp_heap_addr;
+			more_task_args->heap_addr = task_arg_obj.dsp_heap_addr;
 			more_task_args->heap_size = task_arg_obj.heap_size;
 			more_task_args->misc = task_arg_obj.dais_arg;
 			more_task_args->num_input_streams =
@@ -410,8 +410,8 @@ int disp_node_create(struct disp_object *disp_obj,
 			total +=
 			    sizeof(struct rms_more_task_args) /
 			    sizeof(rms_word);
-			dev_dbg(bridge, "%s: udsp_heap_addr %x, heap_size %x\n",
-				__func__, task_arg_obj.udsp_heap_addr,
+			dev_dbg(bridge, "%s: dsp_heap_addr %x, heap_size %x\n",
+				__func__, task_arg_obj.dsp_heap_addr,
 				task_arg_obj.heap_size);
 			/* Keep track of pSIOInDef[] and pSIOOutDef[]
 			 * positions in the buffer, since this needs to be
@@ -611,7 +611,7 @@ static int fill_stream_def(rms_word *pdw_buf, u32 *ptotal, u32 offset,
 		strm_def_obj->nbufs = strm_def.num_bufs;
 		strm_def_obj->segid = strm_def.seg_id;
 		strm_def_obj->align = strm_def.buf_alignment;
-		strm_def_obj->timeout = strm_def.utimeout;
+		strm_def_obj->timeout = strm_def.timeout;
 	}
 
 	if (!status) {
diff --git a/drivers/staging/tidspbridge/rmgr/drv.c b/drivers/staging/tidspbridge/rmgr/drv.c
index 9aacbcb..ce5f398 100644
--- a/drivers/staging/tidspbridge/rmgr/drv.c
+++ b/drivers/staging/tidspbridge/rmgr/drv.c
@@ -148,7 +148,7 @@ int drv_remove_all_dmm_res_elements(void *process_ctxt)
 
 	/* Free DMM mapped memory resources */
 	list_for_each_entry_safe(map_obj, temp_map, &ctxt->dmm_map_list, link) {
-		status = proc_un_map(ctxt->hprocessor,
+		status = proc_un_map(ctxt->processor,
 				     (void *)map_obj->dsp_addr, ctxt);
 		if (status)
 			pr_err("%s: proc_un_map failed!"
@@ -157,7 +157,7 @@ int drv_remove_all_dmm_res_elements(void *process_ctxt)
 
 	/* Free DMM reserved memory resources */
 	list_for_each_entry_safe(rsv_obj, temp_rsv, &ctxt->dmm_rsv_list, link) {
-		status = proc_un_reserve_memory(ctxt->hprocessor, (void *)
+		status = proc_un_reserve_memory(ctxt->processor, (void *)
 						rsv_obj->dsp_reserved_addr,
 						ctxt);
 		if (status)
diff --git a/drivers/staging/tidspbridge/rmgr/nldr.c b/drivers/staging/tidspbridge/rmgr/nldr.c
index 7a15f63..e711970 100644
--- a/drivers/staging/tidspbridge/rmgr/nldr.c
+++ b/drivers/staging/tidspbridge/rmgr/nldr.c
@@ -336,7 +336,7 @@ int nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 		 *  Determine if node is a dynamically loaded node from
 		 *  ndb_props.
 		 */
-		if (node_props->us_load_type == NLDR_DYNAMICLOAD) {
+		if (node_props->load_type == NLDR_DYNAMICLOAD) {
 			/* Dynamic node */
 			nldr_node_obj->dynamic = true;
 			/*
@@ -388,7 +388,7 @@ int nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 			 * base image */
 			nldr_node_obj->root.lib = nldr_obj->base_lib;
 			/* Check for overlay node */
-			if (node_props->us_load_type == NLDR_OVLYLOAD)
+			if (node_props->load_type == NLDR_OVLYLOAD)
 				nldr_node_obj->overlay = true;
 
 		}
@@ -1011,7 +1011,7 @@ static int add_ovly_node(struct dsp_uuid *uuid_obj,
 		goto func_end;
 
 	/* If overlay node, add to the list */
-	if (obj_def.obj_data.node_obj.us_load_type == NLDR_OVLYLOAD) {
+	if (obj_def.obj_data.node_obj.load_type == NLDR_OVLYLOAD) {
 		if (nldr_obj->ovly_table == NULL) {
 			nldr_obj->ovly_nodes++;
 		} else {
diff --git a/drivers/staging/tidspbridge/rmgr/node.c b/drivers/staging/tidspbridge/rmgr/node.c
index 2bfbd16..c627560 100644
--- a/drivers/staging/tidspbridge/rmgr/node.c
+++ b/drivers/staging/tidspbridge/rmgr/node.c
@@ -151,9 +151,9 @@ struct node_mgr {
 	u32 chnl_buf_size;	/* Buffer size for data to RMS */
 	int proc_family;	/* eg, 5000 */
 	int proc_type;		/* eg, 5510 */
-	u32 udsp_word_size;	/* Size of DSP word on host bytes */
-	u32 udsp_data_mau_size;	/* Size of DSP data MAU */
-	u32 udsp_mau_size;	/* Size of MAU */
+	u32 dsp_word_size;	/* Size of DSP word on host bytes */
+	u32 dsp_data_mau_size;	/* Size of DSP data MAU */
+	u32 dsp_mau_size;	/* Size of MAU */
 	s32 min_pri;		/* Minimum runtime priority for node */
 	s32 max_pri;		/* Maximum runtime priority for node */
 
@@ -189,13 +189,13 @@ struct stream_chnl {
 struct node_object {
 	struct list_head list_elem;
 	struct node_mgr *node_mgr;	/* The manager of this node */
-	struct proc_object *hprocessor;	/* Back pointer to processor */
+	struct proc_object *processor;	/* Back pointer to processor */
 	struct dsp_uuid node_uuid;	/* Node's ID */
 	s32 prio;		/* Node's current priority */
-	u32 utimeout;		/* Timeout for blocking NODE calls */
+	u32 timeout;		/* Timeout for blocking NODE calls */
 	u32 heap_size;		/* Heap Size */
-	u32 udsp_heap_virt_addr;	/* Heap Size */
-	u32 ugpp_heap_virt_addr;	/* Heap Size */
+	u32 dsp_heap_virt_addr;	/* Heap Size */
+	u32 gpp_heap_virt_addr;	/* Heap Size */
 	enum node_type ntype;	/* Type of node: message, task, etc */
 	enum node_state node_state;	/* NODE_ALLOCATED, NODE_CREATED, ... */
 	u32 num_inputs;		/* Current number of inputs */
@@ -400,17 +400,17 @@ int node_allocate(struct proc_object *hprocessor,
 		goto func_cont;
 
 	pnode->node_uuid = *node_uuid;
-	pnode->hprocessor = hprocessor;
+	pnode->processor = hprocessor;
 	pnode->ntype = pnode->dcd_props.obj_data.node_obj.ndb_props.ntype;
-	pnode->utimeout = pnode->dcd_props.obj_data.node_obj.ndb_props.utimeout;
+	pnode->timeout = pnode->dcd_props.obj_data.node_obj.ndb_props.timeout;
 	pnode->prio = pnode->dcd_props.obj_data.node_obj.ndb_props.prio;
 
 	/* Currently only C64 DSP builds support Node Dynamic * heaps */
 	/* Allocate memory for node heap */
 	pnode->create_args.asa.task_arg_obj.heap_size = 0;
-	pnode->create_args.asa.task_arg_obj.udsp_heap_addr = 0;
-	pnode->create_args.asa.task_arg_obj.udsp_heap_res_addr = 0;
-	pnode->create_args.asa.task_arg_obj.ugpp_heap_addr = 0;
+	pnode->create_args.asa.task_arg_obj.dsp_heap_addr = 0;
+	pnode->create_args.asa.task_arg_obj.dsp_heap_res_addr = 0;
+	pnode->create_args.asa.task_arg_obj.gpp_heap_addr = 0;
 	if (!attr_in)
 		goto func_cont;
 
@@ -426,7 +426,7 @@ int node_allocate(struct proc_object *hprocessor,
 	} else {
 		pnode->create_args.asa.task_arg_obj.heap_size =
 		    attr_in->heap_size;
-		pnode->create_args.asa.task_arg_obj.ugpp_heap_addr =
+		pnode->create_args.asa.task_arg_obj.gpp_heap_addr =
 		    (u32) attr_in->pgpp_virt_addr;
 	}
 	if (status)
@@ -436,7 +436,7 @@ int node_allocate(struct proc_object *hprocessor,
 				     pnode->create_args.asa.task_arg_obj.
 				     heap_size + PAGE_SIZE,
 				     (void **)&(pnode->create_args.asa.
-					task_arg_obj.udsp_heap_res_addr),
+					task_arg_obj.dsp_heap_res_addr),
 				     pr_ctxt);
 	if (status) {
 		pr_err("%s: Failed to reserve memory for heap: 0x%x\n",
@@ -459,20 +459,20 @@ int node_allocate(struct proc_object *hprocessor,
 	status = proc_map(hprocessor, (void *)attr_in->pgpp_virt_addr,
 			  pnode->create_args.asa.task_arg_obj.heap_size,
 			  (void *)pnode->create_args.asa.task_arg_obj.
-			  udsp_heap_res_addr, (void **)&mapped_addr, map_attrs,
+			  dsp_heap_res_addr, (void **)&mapped_addr, map_attrs,
 			  pr_ctxt);
 	if (status)
 		pr_err("%s: Failed to map memory for Heap: 0x%x\n",
 		       __func__, status);
 	else
-		pnode->create_args.asa.task_arg_obj.udsp_heap_addr =
+		pnode->create_args.asa.task_arg_obj.dsp_heap_addr =
 		    (u32) mapped_addr;
 
 func_cont:
 	mutex_unlock(&hnode_mgr->node_mgr_lock);
 	if (attr_in != NULL) {
 		/* Overrides of NBD properties */
-		pnode->utimeout = attr_in->utimeout;
+		pnode->timeout = attr_in->timeout;
 		pnode->prio = attr_in->prio;
 	}
 	/* Create object to manage notifications */
@@ -712,7 +712,7 @@ DBAPI node_alloc_msg_buf(struct node_object *hnode, u32 usize,
 	if (pattr == NULL)
 		pattr = &node_dfltbufattrs;	/* set defaults */
 
-	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	status = proc_get_processor_id(pnode->processor, &proc_id);
 	if (proc_id != DSP_UNIT) {
 		DBC_ASSERT(NULL);
 		goto func_end;
@@ -808,7 +808,7 @@ int node_change_priority(struct node_object *hnode, s32 prio)
 			status = -EBADR;
 			goto func_cont;
 		}
-		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		status = proc_get_processor_id(pnode->processor, &proc_id);
 		if (proc_id == DSP_UNIT) {
 			status =
 			    disp_node_change_priority(hnode_mgr->disp_obj,
@@ -1144,7 +1144,7 @@ int node_create(struct node_object *hnode)
 		status = -EFAULT;
 		goto func_end;
 	}
-	hprocessor = hnode->hprocessor;
+	hprocessor = hnode->processor;
 	status = proc_get_state(hprocessor, &proc_state,
 				sizeof(struct dsp_processorstate));
 	if (status)
@@ -1168,7 +1168,7 @@ int node_create(struct node_object *hnode)
 		status = -EBADR;
 
 	if (!status)
-		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		status = proc_get_processor_id(pnode->processor, &proc_id);
 
 	if (status)
 		goto func_cont2;
@@ -1266,7 +1266,7 @@ func_cont:
 	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
 	if (status >= 0) {
-		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->processor, DSP_NODESTATECHANGE);
 		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 
@@ -1364,8 +1364,8 @@ int node_create_mgr(struct node_mgr **node_man,
 
 	nldr_attrs_obj.ovly = ovly;
 	nldr_attrs_obj.write = mem_write;
-	nldr_attrs_obj.dsp_word_size = node_mgr_obj->udsp_word_size;
-	nldr_attrs_obj.dsp_mau_size = node_mgr_obj->udsp_mau_size;
+	nldr_attrs_obj.dsp_word_size = node_mgr_obj->dsp_word_size;
+	nldr_attrs_obj.dsp_mau_size = node_mgr_obj->dsp_mau_size;
 	node_mgr_obj->loader_init = node_mgr_obj->nldr_fxns.init();
 	status = node_mgr_obj->nldr_fxns.create(&node_mgr_obj->nldr_obj,
 			hdev_obj,
@@ -1418,7 +1418,7 @@ int node_delete(struct node_res_object *noderes,
 	/* create struct dsp_cbdata struct for PWR call */
 	cb_data.cb_data = PWR_TIMEOUT;
 	hnode_mgr = pnode->node_mgr;
-	hprocessor = pnode->hprocessor;
+	hprocessor = pnode->processor;
 	disp_obj = hnode_mgr->disp_obj;
 	node_type = node_get_type(pnode);
 	intf_fxns = hnode_mgr->intf_fxns;
@@ -1433,7 +1433,7 @@ int node_delete(struct node_res_object *noderes,
 	 *  code must be  executed. */
 	if (!(state == NODE_ALLOCATED && pnode->node_env == (u32) NULL) &&
 	    node_type != NODE_DEVICE) {
-		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		status = proc_get_processor_id(pnode->processor, &proc_id);
 		if (status)
 			goto func_cont1;
 
@@ -1638,7 +1638,7 @@ int node_free_msg_buf(struct node_object *hnode, u8 * pbuffer,
 		status = -EFAULT;
 		goto func_end;
 	}
-	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	status = proc_get_processor_id(pnode->processor, &proc_id);
 	if (proc_id == DSP_UNIT) {
 		if (!status) {
 			if (pattr == NULL) {
@@ -1686,11 +1686,11 @@ int node_get_attr(struct node_object *hnode,
 	pattr->in_node_attr_in.cb_struct =
 		sizeof(struct dsp_nodeattrin);
 	pattr->in_node_attr_in.prio = hnode->prio;
-	pattr->in_node_attr_in.utimeout = hnode->utimeout;
+	pattr->in_node_attr_in.timeout = hnode->timeout;
 	pattr->in_node_attr_in.heap_size =
 		hnode->create_args.asa.task_arg_obj.heap_size;
 	pattr->in_node_attr_in.pgpp_virt_addr = (void *)
-		hnode->create_args.asa.task_arg_obj.ugpp_heap_addr;
+		hnode->create_args.asa.task_arg_obj.gpp_heap_addr;
 	pattr->node_attr_inputs = hnode->num_gpp_inputs;
 	pattr->node_attr_outputs = hnode->num_gpp_outputs;
 	/* dsp_nodeinfo */
@@ -1768,7 +1768,7 @@ int node_get_message(struct node_object *hnode,
 		status = -EFAULT;
 		goto func_end;
 	}
-	hprocessor = hnode->hprocessor;
+	hprocessor = hnode->processor;
 	status = proc_get_state(hprocessor, &proc_state,
 				sizeof(struct dsp_processorstate));
 	if (status)
@@ -1802,7 +1802,7 @@ int node_get_message(struct node_object *hnode,
 	tmp_buf = cmm_xlator_translate(hnode->xlator,
 				       (void *)(message->arg1 *
 						hnode->node_mgr->
-						udsp_word_size), CMM_DSPPA2PA);
+						dsp_word_size), CMM_DSPPA2PA);
 	if (tmp_buf != NULL) {
 		/* now convert this GPP Pa to Va */
 		tmp_buf = cmm_xlator_translate(hnode->xlator, tmp_buf,
@@ -1810,7 +1810,7 @@ int node_get_message(struct node_object *hnode,
 		if (tmp_buf != NULL) {
 			/* Adjust SM size in msg */
 			message->arg1 = (u32) tmp_buf;
-			message->arg2 *= hnode->node_mgr->udsp_word_size;
+			message->arg2 *= hnode->node_mgr->dsp_word_size;
 		} else {
 			status = -ESRCH;
 		}
@@ -1873,7 +1873,7 @@ enum nldr_loadtype node_get_load_type(struct node_object *hnode)
 		dev_dbg(bridge, "%s: Failed. hnode: %p\n", __func__, hnode);
 		return -1;
 	} else {
-		return hnode->dcd_props.obj_data.node_obj.us_load_type;
+		return hnode->dcd_props.obj_data.node_obj.load_type;
 	}
 }
 
@@ -1890,7 +1890,7 @@ u32 node_get_timeout(struct node_object *hnode)
 		dev_dbg(bridge, "%s: failed. hnode: %p\n", __func__, hnode);
 		return 0;
 	} else {
-		return hnode->utimeout;
+		return hnode->timeout;
 	}
 }
 
@@ -1950,7 +1950,7 @@ void node_on_exit(struct node_object *hnode, s32 node_status)
 	/* Unblock call to node_terminate */
 	(void)sync_set_event(hnode->sync_done);
 	/* Notify clients */
-	proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+	proc_notify_clients(hnode->processor, DSP_NODESTATECHANGE);
 	ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 }
 
@@ -1982,7 +1982,7 @@ int node_pause(struct node_object *hnode)
 	if (status)
 		goto func_end;
 
-	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	status = proc_get_processor_id(pnode->processor, &proc_id);
 
 	if (proc_id == IVA_UNIT)
 		status = -ENOSYS;
@@ -1999,7 +1999,7 @@ int node_pause(struct node_object *hnode)
 
 		if (status)
 			goto func_cont;
-		hprocessor = hnode->hprocessor;
+		hprocessor = hnode->processor;
 		status = proc_get_state(hprocessor, &proc_state,
 				sizeof(struct dsp_processorstate));
 		if (status)
@@ -2024,7 +2024,7 @@ func_cont:
 		/* Leave critical section */
 		mutex_unlock(&hnode_mgr->node_mgr_lock);
 		if (status >= 0) {
-			proc_notify_clients(hnode->hprocessor,
+			proc_notify_clients(hnode->processor,
 					    DSP_NODESTATECHANGE);
 			ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 		}
@@ -2061,7 +2061,7 @@ int node_put_message(struct node_object *hnode,
 		status = -EFAULT;
 		goto func_end;
 	}
-	hprocessor = hnode->hprocessor;
+	hprocessor = hnode->processor;
 	status = proc_get_state(hprocessor, &proc_state,
 				sizeof(struct dsp_processorstate));
 	if (status)
@@ -2107,15 +2107,15 @@ int node_put_message(struct node_object *hnode,
 					       CMM_VA2DSPPA);
 		if (tmp_buf != NULL) {
 			/* got translation, convert to MAUs in msg */
-			if (hnode->node_mgr->udsp_word_size != 0) {
+			if (hnode->node_mgr->dsp_word_size != 0) {
 				new_msg.arg1 =
 				    (u32) tmp_buf /
-				    hnode->node_mgr->udsp_word_size;
+				    hnode->node_mgr->dsp_word_size;
 				/* MAUs */
 				new_msg.arg2 /= hnode->node_mgr->
-				    udsp_word_size;
+				    dsp_word_size;
 			} else {
-				pr_err("%s: udsp_word_size is zero!\n",
+				pr_err("%s: dsp_word_size is zero!\n",
 				       __func__);
 				status = -EPERM;	/* bad DSPWordSize */
 			}
@@ -2213,7 +2213,7 @@ int node_run(struct node_object *hnode)
 		status = -EFAULT;
 		goto func_end;
 	}
-	hprocessor = hnode->hprocessor;
+	hprocessor = hnode->processor;
 	status = proc_get_state(hprocessor, &proc_state,
 				sizeof(struct dsp_processorstate));
 	if (status)
@@ -2243,7 +2243,7 @@ int node_run(struct node_object *hnode)
 		status = -EBADR;
 
 	if (!status)
-		status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+		status = proc_get_processor_id(pnode->processor, &proc_id);
 
 	if (status)
 		goto func_cont1;
@@ -2299,7 +2299,7 @@ func_cont1:
 	/* Exit critical section */
 	mutex_unlock(&hnode_mgr->node_mgr_lock);
 	if (status >= 0) {
-		proc_notify_clients(hnode->hprocessor, DSP_NODESTATECHANGE);
+		proc_notify_clients(hnode->processor, DSP_NODESTATECHANGE);
 		ntfy_notify(hnode->ntfy_obj, DSP_NODESTATECHANGE);
 	}
 func_end:
@@ -2333,11 +2333,11 @@ int node_terminate(struct node_object *hnode, int *pstatus)
 		status = -EFAULT;
 		goto func_end;
 	}
-	if (pnode->hprocessor == NULL) {
+	if (pnode->processor == NULL) {
 		status = -EFAULT;
 		goto func_end;
 	}
-	status = proc_get_processor_id(pnode->hprocessor, &proc_id);
+	status = proc_get_processor_id(pnode->processor, &proc_id);
 
 	if (!status) {
 		hnode_mgr = hnode->node_mgr;
@@ -2367,7 +2367,7 @@ int node_terminate(struct node_object *hnode, int *pstatus)
 		 *  Send exit message. Do not change state to NODE_DONE
 		 *  here. That will be done in callback.
 		 */
-		status = proc_get_state(pnode->hprocessor, &proc_state,
+		status = proc_get_state(pnode->processor, &proc_state,
 					sizeof(struct dsp_processorstate));
 		if (status)
 			goto func_cont;
@@ -2384,13 +2384,13 @@ int node_terminate(struct node_object *hnode, int *pstatus)
 		killmsg.arg1 = hnode->node_env;
 		intf_fxns = hnode_mgr->intf_fxns;
 
-		if (hnode->utimeout > MAXTIMEOUT)
+		if (hnode->timeout > MAXTIMEOUT)
 			kill_time_out = MAXTIMEOUT;
 		else
-			kill_time_out = (hnode->utimeout) * 2;
+			kill_time_out = (hnode->timeout) * 2;
 
 		status = (*intf_fxns->msg_put) (hnode->msg_queue_obj, &msg,
-						    hnode->utimeout);
+						    hnode->timeout);
 		if (status)
 			goto func_cont;
 
@@ -2406,7 +2406,7 @@ int node_terminate(struct node_object *hnode, int *pstatus)
 			goto func_cont;
 
 		status = (*intf_fxns->msg_put)(hnode->msg_queue_obj,
-						&killmsg, hnode->utimeout);
+						&killmsg, hnode->timeout);
 		if (status)
 			goto func_cont;
 		status = sync_wait_on_event(hnode->sync_done,
@@ -2460,7 +2460,7 @@ static void delete_node(struct node_object *hnode,
 #ifdef DSP_DMM_DEBUG
 	struct dmm_object *dmm_mgr;
 	struct proc_object *p_proc_object =
-	    (struct proc_object *)hnode->hprocessor;
+	    (struct proc_object *)hnode->processor;
 #endif
 	int status;
 	if (!hnode)
@@ -2518,15 +2518,15 @@ static void delete_node(struct node_object *hnode,
 			kfree(task_arg_obj.strm_out_def);
 			task_arg_obj.strm_out_def = NULL;
 		}
-		if (task_arg_obj.udsp_heap_res_addr) {
-			status = proc_un_map(hnode->hprocessor, (void *)
-					     task_arg_obj.udsp_heap_addr,
+		if (task_arg_obj.dsp_heap_res_addr) {
+			status = proc_un_map(hnode->processor, (void *)
+					     task_arg_obj.dsp_heap_addr,
 					     pr_ctxt);
 
-			status = proc_un_reserve_memory(hnode->hprocessor,
+			status = proc_un_reserve_memory(hnode->processor,
 							(void *)
 							task_arg_obj.
-							udsp_heap_res_addr,
+							dsp_heap_res_addr,
 							pr_ctxt);
 #ifdef DSP_DMM_DEBUG
 			status = dmm_get_handle(p_proc_object, &dmm_mgr);
@@ -2691,17 +2691,17 @@ static void fill_stream_def(struct node_object *hnode,
 	if (pattrs != NULL) {
 		pstrm_def->num_bufs = pattrs->num_bufs;
 		pstrm_def->buf_size =
-		    pattrs->buf_size / hnode_mgr->udsp_data_mau_size;
+		    pattrs->buf_size / hnode_mgr->dsp_data_mau_size;
 		pstrm_def->seg_id = pattrs->seg_id;
 		pstrm_def->buf_alignment = pattrs->buf_alignment;
-		pstrm_def->utimeout = pattrs->utimeout;
+		pstrm_def->timeout = pattrs->timeout;
 	} else {
 		pstrm_def->num_bufs = DEFAULTNBUFS;
 		pstrm_def->buf_size =
-		    DEFAULTBUFSIZE / hnode_mgr->udsp_data_mau_size;
+		    DEFAULTBUFSIZE / hnode_mgr->dsp_data_mau_size;
 		pstrm_def->seg_id = DEFAULTSEGID;
 		pstrm_def->buf_alignment = DEFAULTALIGNMENT;
-		pstrm_def->utimeout = DEFAULTTIMEOUT;
+		pstrm_def->timeout = DEFAULTTIMEOUT;
 	}
 }
 
@@ -2915,9 +2915,9 @@ static int get_proc_props(struct node_mgr *hnode_mgr,
 		hnode_mgr->proc_type = 6410;
 		hnode_mgr->min_pri = DSP_NODE_MIN_PRIORITY;
 		hnode_mgr->max_pri = DSP_NODE_MAX_PRIORITY;
-		hnode_mgr->udsp_word_size = DSPWORDSIZE;
-		hnode_mgr->udsp_data_mau_size = DSPWORDSIZE;
-		hnode_mgr->udsp_mau_size = 1;
+		hnode_mgr->dsp_word_size = DSPWORDSIZE;
+		hnode_mgr->dsp_data_mau_size = DSPWORDSIZE;
+		hnode_mgr->dsp_mau_size = 1;
 
 	}
 	return status;
@@ -3067,8 +3067,8 @@ static u32 ovly(void *priv_ref, u32 dsp_run_addr, u32 dsp_load_addr,
 
 	hnode_mgr = hnode->node_mgr;
 
-	ul_size = ul_num_bytes / hnode_mgr->udsp_word_size;
-	ul_timeout = hnode->utimeout;
+	ul_size = ul_num_bytes / hnode_mgr->dsp_word_size;
+	ul_timeout = hnode->timeout;
 
 	/* Call new MemCopy function */
 	intf_fxns = hnode_mgr->intf_fxns;
@@ -3111,7 +3111,7 @@ static u32 mem_write(void *priv_ref, u32 dsp_add, void *pbuf,
 
 	hnode_mgr = hnode->node_mgr;
 
-	ul_timeout = hnode->utimeout;
+	ul_timeout = hnode->timeout;
 	mem_sect_type = (mem_space & DBLL_CODE) ? RMS_CODE : RMS_DATA;
 
 	/* Call new MemWrite function */
diff --git a/drivers/staging/tidspbridge/rmgr/proc.c b/drivers/staging/tidspbridge/rmgr/proc.c
index fddbcea..54f6133 100644
--- a/drivers/staging/tidspbridge/rmgr/proc.c
+++ b/drivers/staging/tidspbridge/rmgr/proc.c
@@ -85,7 +85,7 @@ struct proc_object {
 	struct mgr_object *mgr_obj;	/* Manager Object Handle */
 	u32 attach_count;	/* Processor attach count */
 	u32 processor_id;	/* Processor number */
-	u32 utimeout;		/* Time out count */
+	u32 timeout;		/* Time out count */
 	enum dsp_procstate proc_state;	/* Processor state */
 	u32 unit;		/* DDSP unit number */
 	bool is_already_attached;	/*
@@ -284,8 +284,8 @@ proc_attach(u32 processor_id,
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(ph_processor != NULL);
 
-	if (pr_ctxt->hprocessor) {
-		*ph_processor = pr_ctxt->hprocessor;
+	if (pr_ctxt->processor) {
+		*ph_processor = pr_ctxt->processor;
 		return status;
 	}
 
@@ -324,9 +324,9 @@ proc_attach(u32 processor_id,
 	INIT_LIST_HEAD(&p_proc_object->proc_list);
 
 	if (attr_in)
-		p_proc_object->utimeout = attr_in->utimeout;
+		p_proc_object->timeout = attr_in->timeout;
 	else
-		p_proc_object->utimeout = PROC_DFLT_TIMEOUT;
+		p_proc_object->timeout = PROC_DFLT_TIMEOUT;
 
 	status = dev_get_intf_fxns(hdev_obj, &p_proc_object->intf_fxns);
 	if (!status) {
@@ -373,7 +373,7 @@ proc_attach(u32 processor_id,
 		}
 		if (!status) {
 			*ph_processor = (void *)p_proc_object;
-			pr_ctxt->hprocessor = *ph_processor;
+			pr_ctxt->processor = *ph_processor;
 			(void)proc_notify_clients(p_proc_object,
 						  DSP_PROCESSORATTACH);
 		}
@@ -567,7 +567,7 @@ int proc_detach(struct process_context *pr_ctxt)
 
 	DBC_REQUIRE(refs > 0);
 
-	p_proc_object = (struct proc_object *)pr_ctxt->hprocessor;
+	p_proc_object = (struct proc_object *)pr_ctxt->processor;
 
 	if (p_proc_object) {
 		/* Notify the Client */
@@ -585,7 +585,7 @@ int proc_detach(struct process_context *pr_ctxt)
 					     (u32) p_proc_object);
 		/* Free the Processor Object */
 		kfree(p_proc_object);
-		pr_ctxt->hprocessor = NULL;
+		pr_ctxt->processor = NULL;
 	} else {
 		status = -EFAULT;
 	}
diff --git a/drivers/staging/tidspbridge/rmgr/strm.c b/drivers/staging/tidspbridge/rmgr/strm.c
index 9498b67..cc7370c 100644
--- a/drivers/staging/tidspbridge/rmgr/strm.c
+++ b/drivers/staging/tidspbridge/rmgr/strm.c
@@ -68,7 +68,7 @@ struct strm_object {
 	struct strm_mgr *strm_mgr_obj;
 	struct chnl_object *chnl_obj;
 	u32 dir;		/* DSP_TONODE or DSP_FROMNODE */
-	u32 utimeout;
+	u32 timeout;
 	u32 num_bufs;		/* Max # of bufs allowed in stream */
 	u32 un_bufs_in_strm;	/* Current # of bufs in stream */
 	u32 bytes;		/* bytes transferred since idled */
@@ -77,7 +77,7 @@ struct strm_object {
 	void *user_event;	/* Saved for strm_get_info() */
 	enum dsp_strmmode strm_mode;	/* STRMMODE_[PROCCOPY][ZEROCOPY]... */
 	u32 udma_chnl_id;	/* DMA chnl id */
-	u32 udma_priority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
+	u32 dma_priority;	/* DMA priority:DMAPRI_[LOW][HIGH] */
 	u32 segment_id;		/* >0 is SM segment.=0 is local heap */
 	u32 buf_alignment;	/* Alignment for stream bufs */
 	/* Stream's SM address translator */
@@ -378,7 +378,7 @@ int strm_idle(struct strm_object *stream_obj, bool flush_data)
 		intf_fxns = stream_obj->strm_mgr_obj->intf_fxns;
 
 		status = (*intf_fxns->chnl_idle) (stream_obj->chnl_obj,
-						      stream_obj->utimeout,
+						      stream_obj->timeout,
 						      flush_data);
 	}
 
@@ -494,8 +494,8 @@ int strm_open(struct node_object *hnode, u32 dir, u32 index,
 			strm_obj->strm_state = STREAM_IDLE;
 			strm_obj->user_event = pattr->user_event;
 			if (pattr->stream_attr_in != NULL) {
-				strm_obj->utimeout =
-				    pattr->stream_attr_in->utimeout;
+				strm_obj->timeout =
+				    pattr->stream_attr_in->timeout;
 				strm_obj->num_bufs =
 				    pattr->stream_attr_in->num_bufs;
 				strm_obj->strm_mode =
@@ -506,23 +506,23 @@ int strm_open(struct node_object *hnode, u32 dir, u32 index,
 				    pattr->stream_attr_in->buf_alignment;
 				strm_obj->udma_chnl_id =
 				    pattr->stream_attr_in->udma_chnl_id;
-				strm_obj->udma_priority =
-				    pattr->stream_attr_in->udma_priority;
+				strm_obj->dma_priority =
+				    pattr->stream_attr_in->dma_priority;
 				chnl_attr_obj.uio_reqs =
 				    pattr->stream_attr_in->num_bufs;
 			} else {
-				strm_obj->utimeout = DEFAULTTIMEOUT;
+				strm_obj->timeout = DEFAULTTIMEOUT;
 				strm_obj->num_bufs = DEFAULTNUMBUFS;
 				strm_obj->strm_mode = STRMMODE_PROCCOPY;
 				strm_obj->segment_id = 0;	/* local mem */
 				strm_obj->buf_alignment = 0;
 				strm_obj->udma_chnl_id = 0;
-				strm_obj->udma_priority = 0;
+				strm_obj->dma_priority = 0;
 				chnl_attr_obj.uio_reqs = DEFAULTNUMBUFS;
 			}
 			chnl_attr_obj.reserved1 = NULL;
 			/* DMA chnl flush timeout */
-			chnl_attr_obj.reserved2 = strm_obj->utimeout;
+			chnl_attr_obj.reserved2 = strm_obj->timeout;
 			chnl_attr_obj.event_obj = NULL;
 			if (pattr->user_event != NULL)
 				chnl_attr_obj.event_obj = pattr->user_event;
@@ -632,7 +632,7 @@ int strm_reclaim(struct strm_object *stream_obj, u8 ** buf_ptr,
 
 	status =
 	    (*intf_fxns->chnl_get_ioc) (stream_obj->chnl_obj,
-					    stream_obj->utimeout,
+					    stream_obj->timeout,
 					    &chnl_ioc_obj);
 	if (!status) {
 		*nbytes = chnl_ioc_obj.byte_size;
-- 
1.7.1

