From e68906924d742dfb33564d7eb4ea7db0b4e65ae4 Mon Sep 17 00:00:00 2001
From: Rene Sapiens <rene.sapiens@ti.com>
Date: Fri, 9 Jul 2010 21:23:56 -0500
Subject: [PATCH 034/116] staging: ti dspbridge: Rename words with camel case.

The intention of this patch is to rename the remaining variables with camel
case. Variables will be renamed avoiding camel case and Hungarian notation.
The words to be renamed in this patch are:
========================================
hDevContext to dev_ctxt
hDevExtension to dev_extension
hdevObject to device_obj
hDispObject to disp_obj
hDrVObject to driver_obj
hDRVObject to driver_obj
hMGRHandle to mgr_handle
hNldrObject to nldr
hNode1 to node1
hNode2 to node2
hNodeRes to node_resource
hPCtxt to process_ctxt
hProc to proc
hStreamHandle to stream_handle
========================================

Signed-off-by: Rene Sapiens <rene.sapiens@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/core/io_sm.c           |    8 +-
 drivers/staging/tidspbridge/core/tiomap3430.c      |   94 +++++++-------
 drivers/staging/tidspbridge/core/tiomap_io.c       |   12 +-
 .../staging/tidspbridge/include/dspbridge/dev.h    |    4 +-
 .../staging/tidspbridge/include/dspbridge/disp.h   |   32 +++---
 .../staging/tidspbridge/include/dspbridge/drv.h    |    6 +-
 .../tidspbridge/include/dspbridge/dspdefs.h        |   72 +++++-----
 .../staging/tidspbridge/include/dspbridge/io_sm.h  |   12 +-
 .../staging/tidspbridge/include/dspbridge/mgr.h    |    4 +-
 .../staging/tidspbridge/include/dspbridge/nldr.h   |    2 +-
 .../staging/tidspbridge/include/dspbridge/node.h   |   26 ++--
 .../staging/tidspbridge/include/dspbridge/proc.h   |   12 +-
 .../include/dspbridge/resourcecleanup.h            |   10 +-
 drivers/staging/tidspbridge/pmgr/dev.c             |    4 +-
 drivers/staging/tidspbridge/rmgr/drv.c             |   87 ++++++------
 drivers/staging/tidspbridge/rmgr/drv_interface.c   |    4 +-
 drivers/staging/tidspbridge/rmgr/mgr.c             |    4 +-
 drivers/staging/tidspbridge/rmgr/nldr.c            |    6 +-
 drivers/staging/tidspbridge/rmgr/node.c            |  140 ++++++++++----------
 drivers/staging/tidspbridge/rmgr/proc.c            |   12 +-
 20 files changed, 276 insertions(+), 275 deletions(-)

diff --git a/drivers/staging/tidspbridge/core/io_sm.c b/drivers/staging/tidspbridge/core/io_sm.c
index 06fec86..346f0aa 100644
--- a/drivers/staging/tidspbridge/core/io_sm.c
+++ b/drivers/staging/tidspbridge/core/io_sm.c
@@ -147,9 +147,9 @@ static void input_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
 static void output_msg(struct io_mgr *pio_mgr, struct msg_mgr *hmsg_mgr);
 static u32 find_ready_output(struct chnl_mgr *chnl_mgr_obj,
 			     struct chnl_object *pchnl, u32 mask);
-static u32 read_data(struct bridge_dev_context *hDevContext, void *dest,
+static u32 read_data(struct bridge_dev_context *dev_ctxt, void *dest,
 		     void *pSrc, u32 usize);
-static u32 write_data(struct bridge_dev_context *hDevContext, void *dest,
+static u32 write_data(struct bridge_dev_context *dev_ctxt, void *dest,
 		      void *pSrc, u32 usize);
 
 /* Bus Addr (cached kernel) */
@@ -1701,7 +1701,7 @@ func_end:
  *  ======== read_data ========
  *      Copies buffers from the shared memory to the host buffer.
  */
-static u32 read_data(struct bridge_dev_context *hDevContext, void *dest,
+static u32 read_data(struct bridge_dev_context *dev_ctxt, void *dest,
 		     void *pSrc, u32 usize)
 {
 	memcpy(dest, pSrc, usize);
@@ -1712,7 +1712,7 @@ static u32 read_data(struct bridge_dev_context *hDevContext, void *dest,
  *  ======== write_data ========
  *      Copies buffers from the host side buffer to the shared memory.
  */
-static u32 write_data(struct bridge_dev_context *hDevContext, void *dest,
+static u32 write_data(struct bridge_dev_context *dev_ctxt, void *dest,
 		      void *pSrc, u32 usize)
 {
 	memcpy(dest, pSrc, usize);
diff --git a/drivers/staging/tidspbridge/core/tiomap3430.c b/drivers/staging/tidspbridge/core/tiomap3430.c
index c6afd1e..7ed0382 100644
--- a/drivers/staging/tidspbridge/core/tiomap3430.c
+++ b/drivers/staging/tidspbridge/core/tiomap3430.c
@@ -88,19 +88,19 @@ static int bridge_brd_write(struct bridge_dev_context *dev_context,
 				   IN u8 *pbHostBuf,
 				   u32 dsp_addr, u32 ul_num_bytes,
 				   u32 ulMemType);
-static int bridge_brd_set_state(struct bridge_dev_context *hDevContext,
+static int bridge_brd_set_state(struct bridge_dev_context *dev_ctxt,
 				    u32 ulBrdState);
-static int bridge_brd_mem_copy(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_copy(struct bridge_dev_context *dev_ctxt,
 				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
 				   u32 ul_num_bytes, u32 ulMemType);
 static int bridge_brd_mem_write(struct bridge_dev_context *dev_context,
 				    IN u8 *pbHostBuf, u32 dsp_addr,
 				    u32 ul_num_bytes, u32 ulMemType);
-static int bridge_brd_mem_map(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_map(struct bridge_dev_context *dev_ctxt,
 				  u32 ul_mpu_addr, u32 ulVirtAddr,
 				  u32 ul_num_bytes, u32 ul_map_attr,
 				  struct page **mapped_pages);
-static int bridge_brd_mem_un_map(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_un_map(struct bridge_dev_context *dev_ctxt,
 				     u32 ulVirtAddr, u32 ul_num_bytes);
 static int bridge_dev_create(OUT struct bridge_dev_context
 					**ppDevContext,
@@ -110,12 +110,12 @@ static int bridge_dev_ctrl(struct bridge_dev_context *dev_context,
 				  u32 dw_cmd, IN OUT void *pargs);
 static int bridge_dev_destroy(struct bridge_dev_context *dev_context);
 static u32 user_va2_pa(struct mm_struct *mm, u32 address);
-static int pte_update(struct bridge_dev_context *hDevContext, u32 pa,
+static int pte_update(struct bridge_dev_context *dev_ctxt, u32 pa,
 			     u32 va, u32 size,
 			     struct hw_mmu_map_attrs_t *map_attrs);
 static int pte_set(struct pg_table_attrs *pt, u32 pa, u32 va,
 			  u32 size, struct hw_mmu_map_attrs_t *attrs);
-static int mem_map_vmalloc(struct bridge_dev_context *hDevContext,
+static int mem_map_vmalloc(struct bridge_dev_context *dev_ctxt,
 				  u32 ul_mpu_addr, u32 ulVirtAddr,
 				  u32 ul_num_bytes,
 				  struct hw_mmu_map_attrs_t *hw_attrs);
@@ -260,10 +260,10 @@ void bridge_drv_entry(OUT struct bridge_drv_interface **ppDrvInterface,
  *  Preconditions:
  *      Device in 'OFF' state.
  */
-static int bridge_brd_monitor(struct bridge_dev_context *hDevContext)
+static int bridge_brd_monitor(struct bridge_dev_context *dev_ctxt)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	u32 temp;
 	struct dspbridge_platform_data *pdata =
 				    omap_dspbridge_dev->dev.platform_data;
@@ -303,14 +303,14 @@ static int bridge_brd_monitor(struct bridge_dev_context *hDevContext)
  *  purpose:
  *      Reads buffers for DSP memory.
  */
-static int bridge_brd_read(struct bridge_dev_context *hDevContext,
+static int bridge_brd_read(struct bridge_dev_context *dev_ctxt,
 				  OUT u8 *pbHostBuf, u32 dsp_addr,
 				  u32 ul_num_bytes, u32 ulMemType)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	u32 offset;
-	u32 dsp_base_addr = hDevContext->dw_dsp_base_addr;
+	u32 dsp_base_addr = dev_ctxt->dw_dsp_base_addr;
 
 	if (dsp_addr < dev_context->dw_dsp_start_add) {
 		status = -EPERM;
@@ -335,11 +335,11 @@ static int bridge_brd_read(struct bridge_dev_context *hDevContext,
  *  purpose:
  *      This routine updates the Board status.
  */
-static int bridge_brd_set_state(struct bridge_dev_context *hDevContext,
+static int bridge_brd_set_state(struct bridge_dev_context *dev_ctxt,
 				    u32 ulBrdState)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 
 	dev_context->dw_brd_state = ulBrdState;
 	return status;
@@ -355,11 +355,11 @@ static int bridge_brd_set_state(struct bridge_dev_context *hDevContext,
  *  b) DSP_RST1 is asserted.
  *  b) DSP_RST2 is released.
  */
-static int bridge_brd_start(struct bridge_dev_context *hDevContext,
+static int bridge_brd_start(struct bridge_dev_context *dev_ctxt,
 				   u32 dsp_addr)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	u32 dw_sync_addr = 0;
 	u32 ul_shm_base;	/* Gpp Phys SM base addr(byte) */
 	u32 ul_shm_base_virt;	/* Dsp Virt SM base addr */
@@ -628,10 +628,10 @@ static int bridge_brd_start(struct bridge_dev_context *hDevContext,
  *  Preconditions :
  *  a) None
  */
-static int bridge_brd_stop(struct bridge_dev_context *hDevContext)
+static int bridge_brd_stop(struct bridge_dev_context *dev_ctxt)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	struct pg_table_attrs *pt_attrs;
 	u32 dsp_pwr_state;
 	int clk_status;
@@ -701,10 +701,10 @@ static int bridge_brd_stop(struct bridge_dev_context *hDevContext)
  *  Preconditions :
  *  a) None
  */
-static int bridge_brd_delete(struct bridge_dev_context *hDevContext)
+static int bridge_brd_delete(struct bridge_dev_context *dev_ctxt)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	struct pg_table_attrs *pt_attrs;
 	int clk_status;
 	struct dspbridge_platform_data *pdata =
@@ -752,10 +752,10 @@ static int bridge_brd_delete(struct bridge_dev_context *hDevContext)
  *  ======== bridge_brd_status ========
  *      Returns the board status.
  */
-static int bridge_brd_status(struct bridge_dev_context *hDevContext,
+static int bridge_brd_status(struct bridge_dev_context *dev_ctxt,
 				    int *pdwState)
 {
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	*pdwState = dev_context->dw_brd_state;
 	return 0;
 }
@@ -764,12 +764,12 @@ static int bridge_brd_status(struct bridge_dev_context *hDevContext,
  *  ======== bridge_brd_write ========
  *      Copies the buffers to DSP internal or external memory.
  */
-static int bridge_brd_write(struct bridge_dev_context *hDevContext,
+static int bridge_brd_write(struct bridge_dev_context *dev_ctxt,
 				   IN u8 *pbHostBuf, u32 dsp_addr,
 				   u32 ul_num_bytes, u32 ulMemType)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 
 	if (dsp_addr < dev_context->dw_dsp_start_add) {
 		status = -EPERM;
@@ -777,7 +777,7 @@ static int bridge_brd_write(struct bridge_dev_context *hDevContext,
 	}
 	if ((dsp_addr - dev_context->dw_dsp_start_add) <
 	    dev_context->dw_internal_size) {
-		status = write_dsp_data(hDevContext, pbHostBuf, dsp_addr,
+		status = write_dsp_data(dev_ctxt, pbHostBuf, dsp_addr,
 					ul_num_bytes, ulMemType);
 	} else {
 		status = write_ext_dsp_data(dev_context, pbHostBuf, dsp_addr,
@@ -1014,18 +1014,18 @@ static int bridge_dev_ctrl(struct bridge_dev_context *dev_context,
  *  ======== bridge_dev_destroy ========
  *      Destroys the driver object.
  */
-static int bridge_dev_destroy(struct bridge_dev_context *hDevContext)
+static int bridge_dev_destroy(struct bridge_dev_context *dev_ctxt)
 {
 	struct pg_table_attrs *pt_attrs;
 	int status = 0;
 	struct bridge_dev_context *dev_context = (struct bridge_dev_context *)
-	    hDevContext;
+	    dev_ctxt;
 	struct cfg_hostres *host_res;
 	u32 shm_size;
 	struct drv_data *drv_datap = dev_get_drvdata(bridge);
 
 	/* It should never happen */
-	if (!hDevContext)
+	if (!dev_ctxt)
 		return -EFAULT;
 
 	/* first put the device to stop state */
@@ -1102,11 +1102,11 @@ static int bridge_dev_destroy(struct bridge_dev_context *hDevContext)
 	kfree(drv_datap->base_img);
 	kfree(drv_datap);
 	dev_set_drvdata(bridge, NULL);
-	kfree((void *)hDevContext);
+	kfree((void *)dev_ctxt);
 	return status;
 }
 
-static int bridge_brd_mem_copy(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_copy(struct bridge_dev_context *dev_ctxt,
 				   u32 ulDspDestAddr, u32 ulDspSrcAddr,
 				   u32 ul_num_bytes, u32 ulMemType)
 {
@@ -1116,24 +1116,24 @@ static int bridge_brd_mem_copy(struct bridge_dev_context *hDevContext,
 	u32 copy_bytes = 0;
 	u32 total_bytes = ul_num_bytes;
 	u8 host_buf[BUFFERSIZE];
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	while ((total_bytes > 0) && DSP_SUCCEEDED(status)) {
 		copy_bytes =
 		    total_bytes > BUFFERSIZE ? BUFFERSIZE : total_bytes;
 		/* Read from External memory */
-		status = read_ext_dsp_data(hDevContext, host_buf, src_addr,
+		status = read_ext_dsp_data(dev_ctxt, host_buf, src_addr,
 					   copy_bytes, ulMemType);
 		if (DSP_SUCCEEDED(status)) {
 			if (dest_addr < (dev_context->dw_dsp_start_add +
 					 dev_context->dw_internal_size)) {
 				/* Write to Internal memory */
-				status = write_dsp_data(hDevContext, host_buf,
+				status = write_dsp_data(dev_ctxt, host_buf,
 							dest_addr, copy_bytes,
 							ulMemType);
 			} else {
 				/* Write to External memory */
 				status =
-				    write_ext_dsp_data(hDevContext, host_buf,
+				    write_ext_dsp_data(dev_ctxt, host_buf,
 						       dest_addr, copy_bytes,
 						       ulMemType, false);
 			}
@@ -1146,12 +1146,12 @@ static int bridge_brd_mem_copy(struct bridge_dev_context *hDevContext,
 }
 
 /* Mem Write does not halt the DSP to write unlike bridge_brd_write */
-static int bridge_brd_mem_write(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_write(struct bridge_dev_context *dev_ctxt,
 				    IN u8 *pbHostBuf, u32 dsp_addr,
 				    u32 ul_num_bytes, u32 ulMemType)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	u32 ul_remain_bytes = 0;
 	u32 ul_bytes = 0;
 	ul_remain_bytes = ul_num_bytes;
@@ -1161,10 +1161,10 @@ static int bridge_brd_mem_write(struct bridge_dev_context *hDevContext,
 		if (dsp_addr < (dev_context->dw_dsp_start_add +
 				 dev_context->dw_internal_size)) {
 			status =
-			    write_dsp_data(hDevContext, pbHostBuf, dsp_addr,
+			    write_dsp_data(dev_ctxt, pbHostBuf, dsp_addr,
 					   ul_bytes, ulMemType);
 		} else {
-			status = write_ext_dsp_data(hDevContext, pbHostBuf,
+			status = write_ext_dsp_data(dev_ctxt, pbHostBuf,
 						    dsp_addr, ul_bytes,
 						    ulMemType, true);
 		}
@@ -1184,14 +1184,14 @@ static int bridge_brd_mem_write(struct bridge_dev_context *hDevContext,
  *
  *  TODO: Disable MMU while updating the page tables (but that'll stall DSP)
  */
-static int bridge_brd_mem_map(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_map(struct bridge_dev_context *dev_ctxt,
 				  u32 ul_mpu_addr, u32 ulVirtAddr,
 				  u32 ul_num_bytes, u32 ul_map_attr,
 				  struct page **mapped_pages)
 {
 	u32 attrs;
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	struct hw_mmu_map_attrs_t hw_attrs;
 	struct vm_area_struct *vma;
 	struct mm_struct *mm = current->mm;
@@ -1206,7 +1206,7 @@ static int bridge_brd_mem_map(struct bridge_dev_context *hDevContext,
 
 	dev_dbg(bridge,
 		"%s hDevCtxt %p, pa %x, va %x, size %x, ul_map_attr %x\n",
-		__func__, hDevContext, ul_mpu_addr, ulVirtAddr, ul_num_bytes,
+		__func__, dev_ctxt, ul_mpu_addr, ulVirtAddr, ul_num_bytes,
 		ul_map_attr);
 	if (ul_num_bytes == 0)
 		return -EINVAL;
@@ -1253,7 +1253,7 @@ static int bridge_brd_mem_map(struct bridge_dev_context *hDevContext,
 		hw_attrs.donotlockmpupage = 0;
 
 	if (attrs & DSP_MAPVMALLOCADDR) {
-		return mem_map_vmalloc(hDevContext, ul_mpu_addr, ulVirtAddr,
+		return mem_map_vmalloc(dev_ctxt, ul_mpu_addr, ulVirtAddr,
 				       ul_num_bytes, &hw_attrs);
 	}
 	/*
@@ -1407,7 +1407,7 @@ func_cont:
  *      So, instead of looking up the PTE address for every 4K block,
  *      we clear consecutive PTEs until we unmap all the bytes
  */
-static int bridge_brd_mem_un_map(struct bridge_dev_context *hDevContext,
+static int bridge_brd_mem_un_map(struct bridge_dev_context *dev_ctxt,
 				     u32 ulVirtAddr, u32 ul_num_bytes)
 {
 	u32 l1_base_va;
@@ -1424,7 +1424,7 @@ static int bridge_brd_mem_un_map(struct bridge_dev_context *hDevContext,
 	u32 va_curr;
 	struct page *pg = NULL;
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	struct pg_table_attrs *pt = dev_context->pt_attrs;
 	u32 temp;
 	u32 paddr;
@@ -1435,8 +1435,8 @@ static int bridge_brd_mem_un_map(struct bridge_dev_context *hDevContext,
 	rem_bytes_l2 = 0;
 	l1_base_va = pt->l1_base_va;
 	pte_addr_l1 = hw_mmu_pte_addr_l1(l1_base_va, va_curr);
-	dev_dbg(bridge, "%s hDevContext %p, va %x, NumBytes %x l1_base_va %x, "
-		"pte_addr_l1 %x\n", __func__, hDevContext, ulVirtAddr,
+	dev_dbg(bridge, "%s dev_ctxt %p, va %x, NumBytes %x l1_base_va %x, "
+		"pte_addr_l1 %x\n", __func__, dev_ctxt, ulVirtAddr,
 		ul_num_bytes, l1_base_va, pte_addr_l1);
 
 	while (rem_bytes && (DSP_SUCCEEDED(status))) {
@@ -1632,7 +1632,7 @@ static u32 user_va2_pa(struct mm_struct *mm, u32 address)
  *      This function calculates the optimum page-aligned addresses and sizes
  *      Caller must pass page-aligned values
  */
-static int pte_update(struct bridge_dev_context *hDevContext, u32 pa,
+static int pte_update(struct bridge_dev_context *dev_ctxt, u32 pa,
 			     u32 va, u32 size,
 			     struct hw_mmu_map_attrs_t *map_attrs)
 {
@@ -1641,7 +1641,7 @@ static int pte_update(struct bridge_dev_context *hDevContext, u32 pa,
 	u32 pa_curr = pa;
 	u32 va_curr = va;
 	u32 num_bytes = size;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	int status = 0;
 	u32 page_size[] = { HW_PAGE_SIZE16MB, HW_PAGE_SIZE1MB,
 		HW_PAGE_SIZE64KB, HW_PAGE_SIZE4KB
diff --git a/drivers/staging/tidspbridge/core/tiomap_io.c b/drivers/staging/tidspbridge/core/tiomap_io.c
index ad1be89..945f871 100644
--- a/drivers/staging/tidspbridge/core/tiomap_io.c
+++ b/drivers/staging/tidspbridge/core/tiomap_io.c
@@ -50,12 +50,12 @@ bool symbols_reloaded = true;
  *  ======== read_ext_dsp_data ========
  *      Copies DSP external memory buffers to the host side buffers.
  */
-int read_ext_dsp_data(struct bridge_dev_context *hDevContext,
+int read_ext_dsp_data(struct bridge_dev_context *dev_ctxt,
 			     OUT u8 *pbHostBuf, u32 dsp_addr,
 			     u32 ul_num_bytes, u32 ulMemType)
 {
 	int status = 0;
-	struct bridge_dev_context *dev_context = hDevContext;
+	struct bridge_dev_context *dev_context = dev_ctxt;
 	u32 offset;
 	u32 ul_tlb_base_virt = 0;
 	u32 ul_shm_offset_virt = 0;
@@ -178,13 +178,13 @@ int read_ext_dsp_data(struct bridge_dev_context *hDevContext,
  *  purpose:
  *      Copies buffers to the DSP internal/external memory.
  */
-int write_dsp_data(struct bridge_dev_context *hDevContext,
+int write_dsp_data(struct bridge_dev_context *dev_ctxt,
 			  IN u8 *pbHostBuf, u32 dsp_addr, u32 ul_num_bytes,
 			  u32 ulMemType)
 {
 	u32 offset;
-	u32 dw_base_addr = hDevContext->dw_dsp_base_addr;
-	struct cfg_hostres *resources = hDevContext->resources;
+	u32 dw_base_addr = dev_ctxt->dw_dsp_base_addr;
+	struct cfg_hostres *resources = dev_ctxt->resources;
 	int status = 0;
 	u32 base1, base2, base3;
 	base1 = OMAP_DSP_MEM1_SIZE;
@@ -194,7 +194,7 @@ int write_dsp_data(struct bridge_dev_context *hDevContext,
 	if (!resources)
 		return -EPERM;
 
-	offset = dsp_addr - hDevContext->dw_dsp_start_add;
+	offset = dsp_addr - dev_ctxt->dw_dsp_start_add;
 	if (offset < base1) {
 		dw_base_addr = MEM_LINEAR_ADDRESS(resources->dw_mem_base[2],
 						  resources->dw_mem_length[2]);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dev.h b/drivers/staging/tidspbridge/include/dspbridge/dev.h
index 87c1681..2ee1c41 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dev.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dev.h
@@ -41,7 +41,7 @@
  *      device's bridge_brd_write() function.
  *  Parameters:
  *      pArb:           Handle to a Device Object.
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      dsp_addr:       Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
  *      ul_num_bytes:     Number of bytes to transfer.
@@ -336,7 +336,7 @@ extern int dev_get_dev_node(struct dev_object *hdev_obj,
  *      0:        *phDevNode contains a platform specific device ID;
  *      else:           *phDevNode is NULL.
  */
-extern int dev_get_dev_type(struct dev_object *hdevObject,
+extern int dev_get_dev_type(struct dev_object *device_obj,
 					u8 *dev_type);
 
 /*
diff --git a/drivers/staging/tidspbridge/include/dspbridge/disp.h b/drivers/staging/tidspbridge/include/dspbridge/disp.h
index 2fd14b0..2c63db9 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/disp.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/disp.h
@@ -57,15 +57,15 @@ extern int disp_create(OUT struct disp_object **phDispObject,
  *  Delete the NODE Dispatcher.
  *
  *  Parameters:
- *      hDispObject:  Node Dispatcher object.
+ *      disp_obj:  Node Dispatcher object.
  *  Returns:
  *  Requires:
  *      disp_init(void) called.
- *      Valid hDispObject.
+ *      Valid disp_obj.
  *  Ensures:
- *      hDispObject is invalid.
+ *      disp_obj is invalid.
  */
-extern void disp_delete(struct disp_object *hDispObject);
+extern void disp_delete(struct disp_object *disp_obj);
 
 /*
  *  ======== disp_exit ========
@@ -97,7 +97,7 @@ extern bool disp_init(void);
  *  Change the priority of a node currently running on the target.
  *
  *  Parameters:
- *      hDispObject:            Node Dispatcher object.
+ *      disp_obj:            Node Dispatcher object.
  *      hnode:                  Node object representing a node currently
  *                              allocated or running on the DSP.
  *      ulFxnAddress:           Address of RMS function for changing priority.
@@ -108,12 +108,12 @@ extern bool disp_init(void);
  *      -ETIME:           A timeout occurred before the DSP responded.
  *  Requires:
  *      disp_init(void) called.
- *      Valid hDispObject.
+ *      Valid disp_obj.
  *      hnode != NULL.
  *  Ensures:
  */
 extern int disp_node_change_priority(struct disp_object
-					    *hDispObject,
+					    *disp_obj,
 					    struct node_object *hnode,
 					    u32 ul_fxn_addr,
 					    nodeenv node_env, s32 prio);
@@ -123,7 +123,7 @@ extern int disp_node_change_priority(struct disp_object
  *  Create a node on the DSP by remotely calling the node's create function.
  *
  *  Parameters:
- *      hDispObject:    Node Dispatcher object.
+ *      disp_obj:    Node Dispatcher object.
  *      hnode:          Node handle obtained from node_allocate().
  *      ul_fxn_addr:      Address or RMS create node function.
  *      ul_create_fxn:    Address of node's create function.
@@ -136,14 +136,14 @@ extern int disp_node_change_priority(struct disp_object
  *      -EPERM:      A failure occurred, unable to create node.
  *  Requires:
  *      disp_init(void) called.
- *      Valid hDispObject.
+ *      Valid disp_obj.
  *      pargs != NULL.
  *      hnode != NULL.
  *      pNodeEnv != NULL.
  *      node_get_type(hnode) != NODE_DEVICE.
  *  Ensures:
  */
-extern int disp_node_create(struct disp_object *hDispObject,
+extern int disp_node_create(struct disp_object *disp_obj,
 				   struct node_object *hnode,
 				   u32 ul_fxn_addr,
 				   u32 ul_create_fxn,
@@ -155,7 +155,7 @@ extern int disp_node_create(struct disp_object *hDispObject,
  *  Delete a node on the DSP by remotely calling the node's delete function.
  *
  *  Parameters:
- *      hDispObject:    Node Dispatcher object.
+ *      disp_obj:    Node Dispatcher object.
  *      hnode:          Node object representing a node currently
  *                      loaded on the DSP.
  *      ul_fxn_addr:      Address or RMS delete node function.
@@ -166,11 +166,11 @@ extern int disp_node_create(struct disp_object *hDispObject,
  *      -ETIME:   A timeout occurred before the DSP responded.
  *  Requires:
  *      disp_init(void) called.
- *      Valid hDispObject.
+ *      Valid disp_obj.
  *      hnode != NULL.
  *  Ensures:
  */
-extern int disp_node_delete(struct disp_object *hDispObject,
+extern int disp_node_delete(struct disp_object *disp_obj,
 				   struct node_object *hnode,
 				   u32 ul_fxn_addr,
 				   u32 ul_delete_fxn, nodeenv node_env);
@@ -181,7 +181,7 @@ extern int disp_node_delete(struct disp_object *hDispObject,
  *  that has been suspended (via DISP_NodePause()) on the DSP.
  *
  *  Parameters:
- *      hDispObject:    Node Dispatcher object.
+ *      disp_obj:    Node Dispatcher object.
  *      hnode:          Node object representing a node to be executed
  *                      on the DSP.
  *      ul_fxn_addr:      Address or RMS node execute function.
@@ -192,11 +192,11 @@ extern int disp_node_delete(struct disp_object *hDispObject,
  *      -ETIME:   A timeout occurred before the DSP responded.
  *  Requires:
  *      disp_init(void) called.
- *      Valid hDispObject.
+ *      Valid disp_obj.
  *      hnode != NULL.
  *  Ensures:
  */
-extern int disp_node_run(struct disp_object *hDispObject,
+extern int disp_node_run(struct disp_object *disp_obj,
 				struct node_object *hnode,
 				u32 ul_fxn_addr,
 				u32 ul_execute_fxn, nodeenv node_env);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/drv.h b/drivers/staging/tidspbridge/include/dspbridge/drv.h
index 020bed0..f9b9634 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/drv.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/drv.h
@@ -313,16 +313,16 @@ extern u32 drv_get_next_dev_object(u32 hdev_obj);
  *  Purpose:
  *      Returns the Ptr to the Next Device Extension from the the List
  *  Parameters:
- *      hDevExtension:      Handle to the Device Extension
+ *      dev_extension:      Handle to the Device Extension
  *  Requires:
  *      DRV Initialized
- *      hDevExtension != 0.
+ *      dev_extension != 0.
  *  Returns:
  *      dw_dev_extension:     Ptr to the Next Dev Extension
  *      0:                  If it fail to Get the next Dev Extension
  *  Ensures:
  */
-extern u32 drv_get_next_dev_extension(u32 hDevExtension);
+extern u32 drv_get_next_dev_extension(u32 dev_extension);
 
 /*
  *  ======== drv_init ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
index 23ef1d5..73034c3 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
@@ -55,52 +55,52 @@ struct bridge_dev_context;
  *  Purpose:
  *      Bring the board to the BRD_IDLE (monitor) state.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device context.
+ *      dev_ctxt:    Handle to Bridge driver defined device context.
  *  Returns:
  *      0:        Success.
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL
+ *      dev_ctxt != NULL
  *  Ensures:
  *      0:        Board is in BRD_IDLE state;
  *      else:           Board state is indeterminate.
  */
-typedef int(*fxn_brd_monitor) (struct bridge_dev_context *hDevContext);
+typedef int(*fxn_brd_monitor) (struct bridge_dev_context *dev_ctxt);
 
 /*
  *  ======== fxn_brd_setstate ========
  *  Purpose:
  *      Sets the Bridge driver state
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      ulBrdState:     Board state
  *  Returns:
  *      0:        Success.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *      ulBrdState  <= BRD_LASTSTATE.
  *  Ensures:
  *      ulBrdState  <= BRD_LASTSTATE.
  *  Update the Board state to the specified state.
  */
 typedef int(*fxn_brd_setstate) (struct bridge_dev_context
-				       * hDevContext, u32 ulBrdState);
+				       * dev_ctxt, u32 ulBrdState);
 
 /*
  *  ======== bridge_brd_start ========
  *  Purpose:
  *      Bring board to the BRD_RUNNING (start) state.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device context.
+ *      dev_ctxt:    Handle to Bridge driver defined device context.
  *      dsp_addr:       DSP address at which to start execution.
  *  Returns:
  *      0:        Success.
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL
+ *      dev_ctxt != NULL
  *      Board is in monitor (BRD_IDLE) state.
  *  Ensures:
  *      0:        Board is in BRD_RUNNING state.
@@ -108,7 +108,7 @@ typedef int(*fxn_brd_setstate) (struct bridge_dev_context
  *      else:           Board state is indeterminate.
  */
 typedef int(*fxn_brd_start) (struct bridge_dev_context
-				    * hDevContext, u32 dsp_addr);
+				    * dev_ctxt, u32 dsp_addr);
 
 /*
  *  ======== bridge_brd_mem_copy ========
@@ -131,7 +131,7 @@ typedef int(*fxn_brd_start) (struct bridge_dev_context
  *      else:           Board state is indeterminate.
  */
 typedef int(*fxn_brd_memcopy) (struct bridge_dev_context
-				      * hDevContext,
+				      * dev_ctxt,
 				      u32 ulDspDestAddr,
 				      u32 ulDspSrcAddr,
 				      u32 ul_num_bytes, u32 ulMemType);
@@ -141,7 +141,7 @@ typedef int(*fxn_brd_memcopy) (struct bridge_dev_context
  *      Write a block of host memory into a DSP address, into a given memory
  *      space.  Unlike bridge_brd_write, this API does reset the DSP
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      dsp_addr:       Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
  *      ul_num_bytes:     Number of bytes to transfer.
@@ -151,12 +151,12 @@ typedef int(*fxn_brd_memcopy) (struct bridge_dev_context
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *      pHostBuf != NULL.
  *  Ensures:
  */
 typedef int(*fxn_brd_memwrite) (struct bridge_dev_context
-				       * hDevContext,
+				       * dev_ctxt,
 				       IN u8 *pHostBuf,
 				       u32 dsp_addr, u32 ul_num_bytes,
 				       u32 ulMemType);
@@ -166,7 +166,7 @@ typedef int(*fxn_brd_memwrite) (struct bridge_dev_context
  *  Purpose:
  *      Map a MPU memory region to a DSP/IVA memory space
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      ul_mpu_addr:      MPU memory region start address.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
  *      ul_num_bytes:     Number of bytes to map.
@@ -175,11 +175,11 @@ typedef int(*fxn_brd_memwrite) (struct bridge_dev_context
  *      0:        Success.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *  Ensures:
  */
 typedef int(*fxn_brd_memmap) (struct bridge_dev_context
-				     * hDevContext, u32 ul_mpu_addr,
+				     * dev_ctxt, u32 ul_mpu_addr,
 				     u32 ulVirtAddr, u32 ul_num_bytes,
 				     u32 ulMapAttrs,
 				     struct page **mapped_pages);
@@ -189,18 +189,18 @@ typedef int(*fxn_brd_memmap) (struct bridge_dev_context
  *  Purpose:
  *      UnMap an MPU memory region from DSP/IVA memory space
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      ulVirtAddr:     DSP/IVA memory region u8 address.
  *      ul_num_bytes:     Number of bytes to unmap.
  *  Returns:
  *      0:        Success.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *  Ensures:
  */
 typedef int(*fxn_brd_memunmap) (struct bridge_dev_context
-				       * hDevContext,
+				       * dev_ctxt,
 				       u32 ulVirtAddr, u32 ul_num_bytes);
 
 /*
@@ -208,36 +208,36 @@ typedef int(*fxn_brd_memunmap) (struct bridge_dev_context
  *  Purpose:
  *      Bring board to the BRD_STOPPED state.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device context.
+ *      dev_ctxt:    Handle to Bridge driver defined device context.
  *  Returns:
  *      0:        Success.
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL
+ *      dev_ctxt != NULL
  *  Ensures:
  *      0:        Board is in BRD_STOPPED (stop) state;
  *                      Interrupts to the PC are disabled.
  *      else:           Board state is indeterminate.
  */
-typedef int(*fxn_brd_stop) (struct bridge_dev_context *hDevContext);
+typedef int(*fxn_brd_stop) (struct bridge_dev_context *dev_ctxt);
 
 /*
  *  ======== bridge_brd_status ========
  *  Purpose:
  *      Report the current state of the board.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device context.
+ *      dev_ctxt:    Handle to Bridge driver defined device context.
  *      pdwState:       Ptr to BRD status variable.
  *  Returns:
  *      0:
  *  Requires:
  *      pdwState != NULL;
- *      hDevContext != NULL
+ *      dev_ctxt != NULL
  *  Ensures:
  *      *pdwState is one of {BRD_STOPPED, BRD_IDLE, BRD_RUNNING, BRD_UNKNOWN};
  */
-typedef int(*fxn_brd_status) (struct bridge_dev_context *hDevContext,
+typedef int(*fxn_brd_status) (struct bridge_dev_context *dev_ctxt,
 				     int *pdwState);
 
 /*
@@ -246,7 +246,7 @@ typedef int(*fxn_brd_status) (struct bridge_dev_context *hDevContext,
  *      Read a block of DSP memory, from a given memory space, into a host
  *      buffer.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      pHostBuf:       Pointer to host buffer (Destination).
  *      dsp_addr:       Address on DSP board (Source).
  *      ul_num_bytes:     Number of bytes to transfer.
@@ -256,12 +256,12 @@ typedef int(*fxn_brd_status) (struct bridge_dev_context *hDevContext,
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *      pHostBuf != NULL.
  *  Ensures:
  *  Will not write more than ul_num_bytes bytes into pHostBuf.
  */
-typedef int(*fxn_brd_read) (struct bridge_dev_context *hDevContext,
+typedef int(*fxn_brd_read) (struct bridge_dev_context *dev_ctxt,
 				   OUT u8 *pHostBuf,
 				   u32 dsp_addr,
 				   u32 ul_num_bytes, u32 ulMemType);
@@ -272,7 +272,7 @@ typedef int(*fxn_brd_read) (struct bridge_dev_context *hDevContext,
  *      Write a block of host memory into a DSP address, into a given memory
  *      space.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      dsp_addr:       Address on DSP board (Destination).
  *      pHostBuf:       Pointer to host buffer (Source).
  *      ul_num_bytes:     Number of bytes to transfer.
@@ -282,11 +282,11 @@ typedef int(*fxn_brd_read) (struct bridge_dev_context *hDevContext,
  *      -ETIMEDOUT:  Timeout occured waiting for a response from hardware.
  *      -EPERM:      Other, unspecified error.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *      pHostBuf != NULL.
  *  Ensures:
  */
-typedef int(*fxn_brd_write) (struct bridge_dev_context *hDevContext,
+typedef int(*fxn_brd_write) (struct bridge_dev_context *dev_ctxt,
 				    IN u8 *pHostBuf,
 				    u32 dsp_addr,
 				    u32 ul_num_bytes, u32 ulMemType);
@@ -690,7 +690,7 @@ typedef int(*fxn_dev_create) (OUT struct bridge_dev_context
  *  Purpose:
  *      Bridge driver specific interface.
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device info.
+ *      dev_ctxt:    Handle to Bridge driver defined device info.
  *      dw_cmd:          Bridge driver defined command code.
  *      pargs:          Pointer to an arbitrary argument structure.
  *  Returns:
@@ -701,7 +701,7 @@ typedef int(*fxn_dev_create) (OUT struct bridge_dev_context
  *      IOCTL completion routines provided.
  *  Ensures:
  */
-typedef int(*fxn_dev_ctrl) (struct bridge_dev_context *hDevContext,
+typedef int(*fxn_dev_ctrl) (struct bridge_dev_context *dev_ctxt,
 				   u32 dw_cmd, IN OUT void *pargs);
 
 /*
@@ -712,16 +712,16 @@ typedef int(*fxn_dev_ctrl) (struct bridge_dev_context *hDevContext,
  *      No calls to other Bridge driver functions may subsequently
  *      occur, except for bridge_dev_create().
  *  Parameters:
- *      hDevContext:    Handle to Bridge driver defined device information.
+ *      dev_ctxt:    Handle to Bridge driver defined device information.
  *  Returns:
  *      0:        Success.
  *      -EPERM:      Failed to release a resource previously acquired.
  *  Requires:
- *      hDevContext != NULL;
+ *      dev_ctxt != NULL;
  *  Ensures:
  *      0: Device context is freed.
  */
-typedef int(*fxn_dev_destroy) (struct bridge_dev_context *hDevContext);
+typedef int(*fxn_dev_destroy) (struct bridge_dev_context *dev_ctxt);
 
 /*
  *  ======== bridge_io_create ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/io_sm.h b/drivers/staging/tidspbridge/include/dspbridge/io_sm.h
index 8b03d4f..62899f2 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/io_sm.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/io_sm.h
@@ -270,21 +270,21 @@ extern int io_sh_msetting(struct io_mgr *hio_mgr, u8 desc, void *pargs);
 /* Maximum channel bufsize that can be used. */
 extern u32 io_buf_size(struct io_mgr *hio_mgr);
 
-extern u32 io_read_value(struct bridge_dev_context *hDevContext, u32 dsp_addr);
+extern u32 io_read_value(struct bridge_dev_context *dev_ctxt, u32 dsp_addr);
 
-extern void io_write_value(struct bridge_dev_context *hDevContext,
+extern void io_write_value(struct bridge_dev_context *dev_ctxt,
 			   u32 dsp_addr, u32 value);
 
-extern u32 io_read_value_long(struct bridge_dev_context *hDevContext,
+extern u32 io_read_value_long(struct bridge_dev_context *dev_ctxt,
 			      u32 dsp_addr);
 
-extern void io_write_value_long(struct bridge_dev_context *hDevContext,
+extern void io_write_value_long(struct bridge_dev_context *dev_ctxt,
 				u32 dsp_addr, u32 value);
 
-extern void io_or_set_value(struct bridge_dev_context *hDevContext,
+extern void io_or_set_value(struct bridge_dev_context *dev_ctxt,
 			    u32 dsp_addr, u32 value);
 
-extern void io_and_set_value(struct bridge_dev_context *hDevContext,
+extern void io_and_set_value(struct bridge_dev_context *dev_ctxt,
 			     u32 dsp_addr, u32 value);
 
 extern void io_intr_dsp2(IN struct io_mgr *pio_mgr, IN u16 mb_val);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/mgr.h b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
index ce418ae..e225845 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/mgr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
@@ -173,7 +173,7 @@ extern void mgr_exit(void);
  *  Purpose:
  *      Retrieves the MGR handle. Accessor Function
  *  Parameters:
- *      hMGRHandle:     Handle to the Manager Object
+ *      mgr_handle:     Handle to the Manager Object
  *      phDCDHandle:    Ptr to receive the DCD Handle.
  *  Returns:
  *      0:        Sucess
@@ -186,7 +186,7 @@ extern void mgr_exit(void);
  *      -EPERM and *phDCDHandle == NULL
  */
 extern int mgr_get_dcd_handle(IN struct mgr_object
-				     *hMGRHandle, OUT u32 *phDCDHandle);
+				     *mgr_handle, OUT u32 *phDCDHandle);
 
 /*
  *  ======== mgr_init ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/nldr.h b/drivers/staging/tidspbridge/include/dspbridge/nldr.h
index b1dbccd..492c826 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/nldr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/nldr.h
@@ -41,7 +41,7 @@ extern void nldr_exit(void);
 extern int nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
 				    char *pstrFxn, u32 * pulAddr);
 
-extern int nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+extern int nldr_get_rmm_manager(struct nldr_object *nldr,
 				       OUT struct rmm_target_obj **phRmmMgr);
 
 extern bool nldr_init(void);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/node.h b/drivers/staging/tidspbridge/include/dspbridge/node.h
index e9d8439..5358d77 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/node.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/node.h
@@ -118,32 +118,32 @@ extern int node_change_priority(struct node_object *hnode, s32 prio);
  *      Delete all nodes whose owning processor is being destroyed.
  *  Parameters:
  *      hnode_mgr:       Node manager object.
- *      hProc:          Handle to processor object being destroyed.
+ *      proc:          Handle to processor object being destroyed.
  *  Returns:
  *      0:        Success.
- *      -EPERM:      Unable to delete all nodes belonging to hProc.
+ *      -EPERM:      Unable to delete all nodes belonging to proc.
  *  Requires:
  *      Valid hnode_mgr.
- *      hProc != NULL.
+ *      proc != NULL.
  *  Ensures:
  */
 extern int node_close_orphans(struct node_mgr *hnode_mgr,
-				     struct proc_object *hProc);
+				     struct proc_object *proc);
 
 /*
  *  ======== node_connect ========
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP. In the
  *      case that the connnection is being made between a node on the DSP and
- *      the GPP, one of the node handles (either hNode1 or hNode2) must be
+ *      the GPP, one of the node handles (either node1 or node2) must be
  *      the constant NODE_HGPPNODE.
  *  Parameters:
- *      hNode1:         Handle of first node to connect to second node. If
- *                      this is a connection from the GPP to hNode2, hNode1
- *                      must be the constant NODE_HGPPNODE. Otherwise, hNode1
+ *      node1:         Handle of first node to connect to second node. If
+ *                      this is a connection from the GPP to node2, node1
+ *                      must be the constant NODE_HGPPNODE. Otherwise, node1
  *                      must be a node handle returned from a successful call
  *                      to Node_Allocate().
- *      hNode2:         Handle of second node. Must be either NODE_HGPPNODE
+ *      node2:         Handle of second node. Must be either NODE_HGPPNODE
  *                      if this is a connection from DSP node to GPP, or a
  *                      node handle returned from a successful call to
  *                      node_allocate().
@@ -163,12 +163,12 @@ extern int node_close_orphans(struct node_mgr *hnode_mgr,
  *                      pass binary data.
  *  Returns:
  *      0:                Success.
- *      -EFAULT:            Invalid hNode1 or hNode2.
+ *      -EFAULT:            Invalid node1 or node2.
  *      -ENOMEM:            Insufficient host memory.
  *      -EINVAL:             A stream index parameter is invalid.
  *      -EISCONN:  A connection already exists for one of the
  *                              indices uStream1 or uStream2.
- *      -EBADR:        Either hNode1 or hNode2 is not in the
+ *      -EBADR:        Either node1 or node2 is not in the
  *                              NODE_ALLOCATED state.
  *      -ECONNREFUSED: No more connections available.
  *      -EPERM:              Attempt to make an illegal connection (eg,
@@ -178,9 +178,9 @@ extern int node_close_orphans(struct node_mgr *hnode_mgr,
  *      node_init(void) called.
  *  Ensures:
  */
-extern int node_connect(struct node_object *hNode1,
+extern int node_connect(struct node_object *node1,
 			       u32 uStream1,
-			       struct node_object *hNode2,
+			       struct node_object *node2,
 			       u32 uStream2,
 			       OPTIONAL IN struct dsp_strmattr *pattrs,
 			       OPTIONAL IN struct dsp_cbdata
diff --git a/drivers/staging/tidspbridge/include/dspbridge/proc.h b/drivers/staging/tidspbridge/include/dspbridge/proc.h
index 230828c..11fdc97 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/proc.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/proc.h
@@ -364,7 +364,7 @@ extern int proc_register_notify(void *hprocessor,
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
- *      hProc       :   The processor handle.
+ *      proc       :   The processor handle.
  *      uEvents     :   Event to be notified about.
  *  Returns:
  *      0     :   Success.
@@ -372,18 +372,18 @@ extern int proc_register_notify(void *hprocessor,
  *      -EPERM   :   Failure to Set or Reset the Event
  *  Requires:
  *      uEvents is Supported or Valid type of Event
- *      hProc is a valid handle
+ *      proc is a valid handle
  *      PROC Initialized.
  *  Ensures:
  */
-extern int proc_notify_clients(void *hProc, u32 uEvents);
+extern int proc_notify_clients(void *proc, u32 uEvents);
 
 /*
  *  ======== proc_notify_all_clients ========
  *  Purpose:
  *      Notify the Processor Clients
  *  Parameters:
- *      hProc       :   The processor handle.
+ *      proc       :   The processor handle.
  *      uEvents     :   Event to be notified about.
  *  Returns:
  *      0     :   Success.
@@ -391,14 +391,14 @@ extern int proc_notify_clients(void *hProc, u32 uEvents);
  *      -EPERM   :   Failure to Set or Reset the Event
  *  Requires:
  *      uEvents is Supported or Valid type of Event
- *      hProc is a valid handle
+ *      proc is a valid handle
  *      PROC Initialized.
  *  Ensures:
  *  Details:
  *      NODE And STRM would use this function to notify their clients
  *      about the state changes in NODE or STRM.
  */
-extern int proc_notify_all_clients(void *hProc, u32 uEvents);
+extern int proc_notify_all_clients(void *proc, u32 uEvents);
 
 /*
  *  ======== proc_start ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/resourcecleanup.h b/drivers/staging/tidspbridge/include/dspbridge/resourcecleanup.h
index b452a71..1fa7d13 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/resourcecleanup.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/resourcecleanup.h
@@ -20,8 +20,8 @@
 extern int drv_get_proc_ctxt_list(struct process_context **pPctxt,
 					 struct drv_object *hdrv_obj);
 
-extern int drv_insert_proc_context(struct drv_object *hDrVObject,
-					  void *hPCtxt);
+extern int drv_insert_proc_context(struct drv_object *driver_obj,
+					  void *process_ctxt);
 
 extern int drv_remove_all_dmm_res_elements(void *ctxt);
 
@@ -31,7 +31,7 @@ extern int drv_proc_set_pid(void *ctxt, s32 process);
 
 extern int drv_remove_all_resources(void *pPctxt);
 
-extern int drv_remove_proc_context(struct drv_object *hDRVObject,
+extern int drv_remove_proc_context(struct drv_object *driver_obj,
 					  void *pr_ctxt);
 
 extern int drv_get_node_res_element(void *hnode, void *node_res,
@@ -40,11 +40,11 @@ extern int drv_get_node_res_element(void *hnode, void *node_res,
 extern int drv_insert_node_res_element(void *hnode, void *node_res,
 					      void *ctxt);
 
-extern void drv_proc_node_update_heap_status(void *hNodeRes, s32 status);
+extern void drv_proc_node_update_heap_status(void *node_resource, s32 status);
 
 extern int drv_remove_node_res_element(void *node_res, void *status);
 
-extern void drv_proc_node_update_status(void *hNodeRes, s32 status);
+extern void drv_proc_node_update_status(void *node_resource, s32 status);
 
 extern int drv_proc_update_strm_res(u32 num_bufs, void *strm_res);
 
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index 2c31f31..aac448e 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -1038,10 +1038,10 @@ int dev_remove_proc_object(struct dev_object *hdev_obj, u32 proc_obj)
 	return status;
 }
 
-int dev_get_dev_type(struct dev_object *hdevObject, u8 *dev_type)
+int dev_get_dev_type(struct dev_object *device_obj, u8 *dev_type)
 {
 	int status = 0;
-	struct dev_object *dev_obj = (struct dev_object *)hdevObject;
+	struct dev_object *dev_obj = (struct dev_object *)device_obj;
 
 	*dev_type = dev_obj->dev_type;
 
diff --git a/drivers/staging/tidspbridge/rmgr/drv.c b/drivers/staging/tidspbridge/rmgr/drv.c
index 72e2804..36ddfdf 100644
--- a/drivers/staging/tidspbridge/rmgr/drv.c
+++ b/drivers/staging/tidspbridge/rmgr/drv.c
@@ -73,16 +73,16 @@ static int request_bridge_resources(struct cfg_hostres *res);
 
 /* GPP PROCESS CLEANUP CODE */
 
-static int drv_proc_free_node_res(void *hPCtxt);
+static int drv_proc_free_node_res(void *process_ctxt);
 
 /* Allocate and add a node resource element
 * This function is called from .Node_Allocate. */
-int drv_insert_node_res_element(void *hnode, void *hNodeRes,
-				       void *hPCtxt)
+int drv_insert_node_res_element(void *hnode, void *node_resource,
+				       void *process_ctxt)
 {
 	struct node_res_object **node_res_obj =
-	    (struct node_res_object **)hNodeRes;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	    (struct node_res_object **)node_resource;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct node_res_object *temp_node_res = NULL;
 
@@ -113,11 +113,11 @@ int drv_insert_node_res_element(void *hnode, void *hNodeRes,
 
 /* Release all Node resources and its context
 * This is called from .Node_Delete. */
-int drv_remove_node_res_element(void *hNodeRes, void *hPCtxt)
+int drv_remove_node_res_element(void *node_resource, void *process_ctxt)
 {
 	struct node_res_object *node_res_obj =
-	    (struct node_res_object *)hNodeRes;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	    (struct node_res_object *)node_resource;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	struct node_res_object *temp_node;
 	int status = 0;
 
@@ -140,9 +140,9 @@ int drv_remove_node_res_element(void *hNodeRes, void *hPCtxt)
 }
 
 /* Actual Node De-Allocation */
-static int drv_proc_free_node_res(void *hPCtxt)
+static int drv_proc_free_node_res(void *process_ctxt)
 {
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct node_res_object *node_list = NULL;
 	struct node_res_object *node_res_obj = NULL;
@@ -169,9 +169,9 @@ static int drv_proc_free_node_res(void *hPCtxt)
 }
 
 /* Release all Mapped and Reserved DMM resources */
-int drv_remove_all_dmm_res_elements(void *hPCtxt)
+int drv_remove_all_dmm_res_elements(void *process_ctxt)
 {
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct dmm_map_object *temp_map, *map_obj;
 	struct dmm_rsv_object *temp_rsv, *rsv_obj;
@@ -198,29 +198,29 @@ int drv_remove_all_dmm_res_elements(void *hPCtxt)
 }
 
 /* Update Node allocation status */
-void drv_proc_node_update_status(void *hNodeRes, s32 status)
+void drv_proc_node_update_status(void *node_resource, s32 status)
 {
 	struct node_res_object *node_res_obj =
-	    (struct node_res_object *)hNodeRes;
-	DBC_ASSERT(hNodeRes != NULL);
+	    (struct node_res_object *)node_resource;
+	DBC_ASSERT(node_resource != NULL);
 	node_res_obj->node_allocated = status;
 }
 
 /* Update Node Heap status */
-void drv_proc_node_update_heap_status(void *hNodeRes, s32 status)
+void drv_proc_node_update_heap_status(void *node_resource, s32 status)
 {
 	struct node_res_object *node_res_obj =
-	    (struct node_res_object *)hNodeRes;
-	DBC_ASSERT(hNodeRes != NULL);
+	    (struct node_res_object *)node_resource;
+	DBC_ASSERT(node_resource != NULL);
 	node_res_obj->heap_allocated = status;
 }
 
 /* Release all Node resources and its context
 * This is called from .bridge_release.
  */
-int drv_remove_all_node_res_elements(void *hPCtxt)
+int drv_remove_all_node_res_elements(void *process_ctxt)
 {
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct node_res_object *temp_node2 = NULL;
 	struct node_res_object *temp_node = NULL;
@@ -237,11 +237,12 @@ int drv_remove_all_node_res_elements(void *hPCtxt)
 }
 
 /* Getting the node resource element */
-int drv_get_node_res_element(void *hnode, void *hNodeRes,
-				    void *hPCtxt)
+int drv_get_node_res_element(void *hnode, void *node_resource,
+				    void *process_ctxt)
 {
-	struct node_res_object **node_res = (struct node_res_object **)hNodeRes;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct node_res_object **node_res =
+				     (struct node_res_object **)node_resource;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct node_res_object *temp_node2 = NULL;
 	struct node_res_object *temp_node = NULL;
@@ -268,12 +269,12 @@ int drv_get_node_res_element(void *hnode, void *hNodeRes,
 /* Allocate the STRM resource element
 * This is called after the actual resource is allocated
  */
-int drv_proc_insert_strm_res_element(void *hStreamHandle,
-					    void *hstrm_res, void *hPCtxt)
+int drv_proc_insert_strm_res_element(void *stream_handle,
+					    void *hstrm_res, void *process_ctxt)
 {
 	struct strm_res_object **pstrm_res =
 	    (struct strm_res_object **)hstrm_res;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct strm_res_object *temp_strm_res = NULL;
 
@@ -286,7 +287,7 @@ int drv_proc_insert_strm_res_element(void *hStreamHandle,
 			kfree(*pstrm_res);
 			return -EPERM;
 		}
-		(*pstrm_res)->hstream = hStreamHandle;
+		(*pstrm_res)->hstream = stream_handle;
 		if (ctxt->pstrm_list != NULL) {
 			temp_strm_res = ctxt->pstrm_list;
 			while (temp_strm_res->next != NULL)
@@ -304,10 +305,10 @@ int drv_proc_insert_strm_res_element(void *hStreamHandle,
 /* Release Stream resource element context
 * This function called after the actual resource is freed
  */
-int drv_proc_remove_strm_res_element(void *hstrm_res, void *hPCtxt)
+int drv_proc_remove_strm_res_element(void *hstrm_res, void *process_ctxt)
 {
 	struct strm_res_object *pstrm_res = (struct strm_res_object *)hstrm_res;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	struct strm_res_object *temp_strm_res;
 	int status = 0;
 
@@ -333,9 +334,9 @@ int drv_proc_remove_strm_res_element(void *hstrm_res, void *hPCtxt)
 /* Release all Stream resources and its context
 * This is called from .bridge_release.
  */
-int drv_remove_all_strm_res_elements(void *hPCtxt)
+int drv_remove_all_strm_res_elements(void *process_ctxt)
 {
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct strm_res_object *strm_res = NULL;
 	struct strm_res_object *strm_tmp = NULL;
@@ -375,11 +376,11 @@ int drv_remove_all_strm_res_elements(void *hPCtxt)
 
 /* Getting the stream resource element */
 int drv_get_strm_res_element(void *hStrm, void *hstrm_res,
-				    void *hPCtxt)
+				    void *process_ctxt)
 {
 	struct strm_res_object **strm_res =
 	    (struct strm_res_object **)hstrm_res;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	int status = 0;
 	struct strm_res_object *temp_strm2 = NULL;
 	struct strm_res_object *temp_strm;
@@ -486,10 +487,10 @@ void drv_exit(void)
  *  purpose:
  *      Invoked during bridge de-initialization
  */
-int drv_destroy(struct drv_object *hDRVObject)
+int drv_destroy(struct drv_object *driver_obj)
 {
 	int status = 0;
-	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
+	struct drv_object *pdrv_object = (struct drv_object *)driver_obj;
 
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(pdrv_object);
@@ -621,19 +622,19 @@ u32 drv_get_next_dev_object(u32 hdev_obj)
  *      called drv_get_first_dev_extension() and zero or more
  *      drv_get_next_dev_extension().
  */
-u32 drv_get_next_dev_extension(u32 hDevExtension)
+u32 drv_get_next_dev_extension(u32 dev_extension)
 {
 	u32 dw_dev_extension = 0;
 	struct drv_object *pdrv_obj;
 
-	DBC_REQUIRE(hDevExtension != 0);
+	DBC_REQUIRE(dev_extension != 0);
 
 	if (DSP_SUCCEEDED(cfg_get_object((u32 *) &pdrv_obj, REG_DRV_OBJECT))) {
 		if ((pdrv_obj->dev_node_string != NULL) &&
 		    !LST_IS_EMPTY(pdrv_obj->dev_node_string)) {
 			dw_dev_extension =
 			    (u32) lst_next(pdrv_obj->dev_node_string,
-					   (struct list_head *)hDevExtension);
+					   (struct list_head *)dev_extension);
 		}
 	}
 
@@ -664,11 +665,11 @@ int drv_init(void)
  *  Purpose:
  *      Insert a DevObject into the list of Manager object.
  */
-int drv_insert_dev_object(struct drv_object *hDRVObject,
+int drv_insert_dev_object(struct drv_object *driver_obj,
 				 struct dev_object *hdev_obj)
 {
 	int status = 0;
-	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
+	struct drv_object *pdrv_object = (struct drv_object *)driver_obj;
 
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(hdev_obj != NULL);
@@ -689,11 +690,11 @@ int drv_insert_dev_object(struct drv_object *hDRVObject,
  *      Search for and remove a DeviceObject from the given list of DRV
  *      objects.
  */
-int drv_remove_dev_object(struct drv_object *hDRVObject,
+int drv_remove_dev_object(struct drv_object *driver_obj,
 				 struct dev_object *hdev_obj)
 {
 	int status = -EPERM;
-	struct drv_object *pdrv_object = (struct drv_object *)hDRVObject;
+	struct drv_object *pdrv_object = (struct drv_object *)driver_obj;
 	struct list_head *cur_elem;
 
 	DBC_REQUIRE(refs > 0);
diff --git a/drivers/staging/tidspbridge/rmgr/drv_interface.c b/drivers/staging/tidspbridge/rmgr/drv_interface.c
index 27db842..b0fd38e 100644
--- a/drivers/staging/tidspbridge/rmgr/drv_interface.c
+++ b/drivers/staging/tidspbridge/rmgr/drv_interface.c
@@ -628,10 +628,10 @@ static int bridge_mmap(struct file *filp, struct vm_area_struct *vma)
 
 /* To remove all process resources before removing the process from the
  * process context list */
-int drv_remove_all_resources(void *hPCtxt)
+int drv_remove_all_resources(void *process_ctxt)
 {
 	int status = 0;
-	struct process_context *ctxt = (struct process_context *)hPCtxt;
+	struct process_context *ctxt = (struct process_context *)process_ctxt;
 	drv_remove_all_strm_res_elements(ctxt);
 	drv_remove_all_node_res_elements(ctxt);
 	drv_remove_all_dmm_res_elements(ctxt);
diff --git a/drivers/staging/tidspbridge/rmgr/mgr.c b/drivers/staging/tidspbridge/rmgr/mgr.c
index b1a68ac..52d7865 100644
--- a/drivers/staging/tidspbridge/rmgr/mgr.c
+++ b/drivers/staging/tidspbridge/rmgr/mgr.c
@@ -303,11 +303,11 @@ void mgr_exit(void)
  *  ======== mgr_get_dcd_handle ========
  *      Retrieves the MGR handle. Accessor Function.
  */
-int mgr_get_dcd_handle(struct mgr_object *hMGRHandle,
+int mgr_get_dcd_handle(struct mgr_object *mgr_handle,
 			      OUT u32 *phDCDHandle)
 {
 	int status = -EPERM;
-	struct mgr_object *pmgr_obj = (struct mgr_object *)hMGRHandle;
+	struct mgr_object *pmgr_obj = (struct mgr_object *)mgr_handle;
 
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(phDCDHandle != NULL);
diff --git a/drivers/staging/tidspbridge/rmgr/nldr.c b/drivers/staging/tidspbridge/rmgr/nldr.c
index 0757d9b..91b32cb 100644
--- a/drivers/staging/tidspbridge/rmgr/nldr.c
+++ b/drivers/staging/tidspbridge/rmgr/nldr.c
@@ -774,14 +774,14 @@ int nldr_get_fxn_addr(struct nldr_nodeobject *nldr_node_obj,
  *  ======== nldr_get_rmm_manager ========
  *  Given a NLDR object, retrieve RMM Manager Handle
  */
-int nldr_get_rmm_manager(struct nldr_object *hNldrObject,
+int nldr_get_rmm_manager(struct nldr_object *nldr,
 				OUT struct rmm_target_obj **phRmmMgr)
 {
 	int status = 0;
-	struct nldr_object *nldr_obj = hNldrObject;
+	struct nldr_object *nldr_obj = nldr;
 	DBC_REQUIRE(phRmmMgr != NULL);
 
-	if (hNldrObject) {
+	if (nldr) {
 		*phRmmMgr = nldr_obj->rmm;
 	} else {
 		*phRmmMgr = NULL;
diff --git a/drivers/staging/tidspbridge/rmgr/node.c b/drivers/staging/tidspbridge/rmgr/node.c
index 1870b80..aaea5bb 100644
--- a/drivers/staging/tidspbridge/rmgr/node.c
+++ b/drivers/staging/tidspbridge/rmgr/node.c
@@ -241,8 +241,8 @@ static struct dsp_bufferattr node_dfltbufattrs = {
 static void delete_node(struct node_object *hnode,
 			struct process_context *pr_ctxt);
 static void delete_node_mgr(struct node_mgr *hnode_mgr);
-static void fill_stream_connect(struct node_object *hNode1,
-				struct node_object *hNode2, u32 uStream1,
+static void fill_stream_connect(struct node_object *node1,
+				struct node_object *node2, u32 uStream1,
 				u32 uStream2);
 static void fill_stream_def(struct node_object *hnode,
 			    struct node_strmdef *pstrm_def,
@@ -833,8 +833,8 @@ func_end:
  *  Purpose:
  *      Connect two nodes on the DSP, or a node on the DSP to the GPP.
  */
-int node_connect(struct node_object *hNode1, u32 uStream1,
-			struct node_object *hNode2,
+int node_connect(struct node_object *node1, u32 uStream1,
+			struct node_object *node2,
 			u32 uStream2, OPTIONAL IN struct dsp_strmattr *pattrs,
 			OPTIONAL IN struct dsp_cbdata *conn_param)
 {
@@ -855,33 +855,33 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 	int status = 0;
 	DBC_REQUIRE(refs > 0);
 
-	if ((hNode1 != (struct node_object *)DSP_HGPPNODE && !hNode1) ||
-	    (hNode2 != (struct node_object *)DSP_HGPPNODE && !hNode2))
+	if ((node1 != (struct node_object *)DSP_HGPPNODE && !node1) ||
+	    (node2 != (struct node_object *)DSP_HGPPNODE && !node2))
 		status = -EFAULT;
 
 	if (DSP_SUCCEEDED(status)) {
 		/* The two nodes must be on the same processor */
-		if (hNode1 != (struct node_object *)DSP_HGPPNODE &&
-		    hNode2 != (struct node_object *)DSP_HGPPNODE &&
-		    hNode1->hnode_mgr != hNode2->hnode_mgr)
+		if (node1 != (struct node_object *)DSP_HGPPNODE &&
+		    node2 != (struct node_object *)DSP_HGPPNODE &&
+		    node1->hnode_mgr != node2->hnode_mgr)
 			status = -EPERM;
 		/* Cannot connect a node to itself */
-		if (hNode1 == hNode2)
+		if (node1 == node2)
 			status = -EPERM;
 
 	}
 	if (DSP_SUCCEEDED(status)) {
 		/* node_get_type() will return NODE_GPP if hnode =
 		 * DSP_HGPPNODE. */
-		node1_type = node_get_type(hNode1);
-		node2_type = node_get_type(hNode2);
+		node1_type = node_get_type(node1);
+		node2_type = node_get_type(node2);
 		/* Check stream indices ranges */
 		if ((node1_type != NODE_GPP && node1_type != NODE_DEVICE &&
-		     uStream1 >= MAX_OUTPUTS(hNode1)) || (node2_type != NODE_GPP
+		     uStream1 >= MAX_OUTPUTS(node1)) || (node2_type != NODE_GPP
 							  && node2_type !=
 							  NODE_DEVICE
 							  && uStream2 >=
-							  MAX_INPUTS(hNode2)))
+							  MAX_INPUTS(node2)))
 			status = -EINVAL;
 	}
 	if (DSP_SUCCEEDED(status)) {
@@ -911,19 +911,19 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 		goto func_end;
 
 	if (node1_type != NODE_GPP) {
-		hnode_mgr = hNode1->hnode_mgr;
+		hnode_mgr = node1->hnode_mgr;
 	} else {
-		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
-		hnode_mgr = hNode2->hnode_mgr;
+		DBC_ASSERT(node2 != (struct node_object *)DSP_HGPPNODE);
+		hnode_mgr = node2->hnode_mgr;
 	}
 	/* Enter critical section */
 	mutex_lock(&hnode_mgr->node_mgr_lock);
 
 	/* Nodes must be in the allocated state */
-	if (node1_type != NODE_GPP && node_get_state(hNode1) != NODE_ALLOCATED)
+	if (node1_type != NODE_GPP && node_get_state(node1) != NODE_ALLOCATED)
 		status = -EBADR;
 
-	if (node2_type != NODE_GPP && node_get_state(hNode2) != NODE_ALLOCATED)
+	if (node2_type != NODE_GPP && node_get_state(node2) != NODE_ALLOCATED)
 		status = -EBADR;
 
 	if (DSP_SUCCEEDED(status)) {
@@ -931,7 +931,7 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 		 *  are not already be used. (Device nodes checked later) */
 		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
 			output =
-			    &(hNode1->create_args.asa.
+			    &(node1->create_args.asa.
 			      task_arg_obj.strm_out_def[uStream1]);
 			if (output->sz_device != NULL)
 				status = -EISCONN;
@@ -939,7 +939,7 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 		}
 		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
 			input =
-			    &(hNode2->create_args.asa.
+			    &(node2->create_args.asa.
 			      task_arg_obj.strm_in_def[uStream2]);
 			if (input->sz_device != NULL)
 				status = -EISCONN;
@@ -956,10 +956,10 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 		if (pipe_id == GB_NOBITS) {
 			status = -ECONNREFUSED;
 		} else {
-			hNode1->outputs[uStream1].type = NODECONNECT;
-			hNode2->inputs[uStream2].type = NODECONNECT;
-			hNode1->outputs[uStream1].dev_id = pipe_id;
-			hNode2->inputs[uStream2].dev_id = pipe_id;
+			node1->outputs[uStream1].type = NODECONNECT;
+			node2->inputs[uStream2].type = NODECONNECT;
+			node1->outputs[uStream1].dev_id = pipe_id;
+			node2->inputs[uStream2].dev_id = pipe_id;
 			output->sz_device = kzalloc(PIPENAMELEN + 1,
 							GFP_KERNEL);
 			input->sz_device = kzalloc(PIPENAMELEN + 1, GFP_KERNEL);
@@ -1050,13 +1050,13 @@ int node_connect(struct node_object *hNode1, u32 uStream1,
 		status = -ENOMEM;
 func_cont2:
 		if (DSP_SUCCEEDED(status)) {
-			if (hNode1 == (struct node_object *)DSP_HGPPNODE) {
-				hNode2->inputs[uStream2].type = HOSTCONNECT;
-				hNode2->inputs[uStream2].dev_id = chnl_id;
+			if (node1 == (struct node_object *)DSP_HGPPNODE) {
+				node2->inputs[uStream2].type = HOSTCONNECT;
+				node2->inputs[uStream2].dev_id = chnl_id;
 				input->sz_device = pstr_dev_name;
 			} else {
-				hNode1->outputs[uStream1].type = HOSTCONNECT;
-				hNode1->outputs[uStream1].dev_id = chnl_id;
+				node1->outputs[uStream1].type = HOSTCONNECT;
+				node1->outputs[uStream1].dev_id = chnl_id;
 				output->sz_device = pstr_dev_name;
 			}
 			sprintf(pstr_dev_name, "%s%d", HOSTPREFIX, chnl_id);
@@ -1067,15 +1067,15 @@ func_cont2:
 				      (node2_type == NODE_DEVICE))) {
 		if (node2_type == NODE_DEVICE) {
 			/* node1 == > device */
-			dev_node_obj = hNode2;
-			hnode = hNode1;
-			pstream = &(hNode1->outputs[uStream1]);
+			dev_node_obj = node2;
+			hnode = node1;
+			pstream = &(node1->outputs[uStream1]);
 			pstrm_def = output;
 		} else {
 			/* device == > node2 */
-			dev_node_obj = hNode1;
-			hnode = hNode2;
-			pstream = &(hNode2->inputs[uStream2]);
+			dev_node_obj = node1;
+			hnode = node2;
+			pstream = &(node2->inputs[uStream2]);
 			pstrm_def = input;
 		}
 		/* Set up create args */
@@ -1106,35 +1106,35 @@ func_cont2:
 	if (DSP_SUCCEEDED(status)) {
 		/* Fill in create args */
 		if (node1_type == NODE_TASK || node1_type == NODE_DAISSOCKET) {
-			hNode1->create_args.asa.task_arg_obj.num_outputs++;
-			fill_stream_def(hNode1, output, pattrs);
+			node1->create_args.asa.task_arg_obj.num_outputs++;
+			fill_stream_def(node1, output, pattrs);
 		}
 		if (node2_type == NODE_TASK || node2_type == NODE_DAISSOCKET) {
-			hNode2->create_args.asa.task_arg_obj.num_inputs++;
-			fill_stream_def(hNode2, input, pattrs);
+			node2->create_args.asa.task_arg_obj.num_inputs++;
+			fill_stream_def(node2, input, pattrs);
 		}
-		/* Update hNode1 and hNode2 stream_connect */
+		/* Update node1 and node2 stream_connect */
 		if (node1_type != NODE_GPP && node1_type != NODE_DEVICE) {
-			hNode1->num_outputs++;
-			if (uStream1 > hNode1->max_output_index)
-				hNode1->max_output_index = uStream1;
+			node1->num_outputs++;
+			if (uStream1 > node1->max_output_index)
+				node1->max_output_index = uStream1;
 
 		}
 		if (node2_type != NODE_GPP && node2_type != NODE_DEVICE) {
-			hNode2->num_inputs++;
-			if (uStream2 > hNode2->max_input_index)
-				hNode2->max_input_index = uStream2;
+			node2->num_inputs++;
+			if (uStream2 > node2->max_input_index)
+				node2->max_input_index = uStream2;
 
 		}
-		fill_stream_connect(hNode1, hNode2, uStream1, uStream2);
+		fill_stream_connect(node1, node2, uStream1, uStream2);
 	}
 	/* end of sync_enter_cs */
 	/* Exit critical section */
 	mutex_unlock(&hnode_mgr->node_mgr_lock);
 func_end:
-	dev_dbg(bridge, "%s: hNode1: %p uStream1: %d hNode2: %p uStream2: %d"
-		"pattrs: %p status: 0x%x\n", __func__, hNode1,
-		uStream1, hNode2, uStream2, pattrs, status);
+	dev_dbg(bridge, "%s: node1: %p uStream1: %d node2: %p uStream2: %d"
+		"pattrs: %p status: 0x%x\n", __func__, node1,
+		uStream1, node2, uStream2, pattrs, status);
 	return status;
 }
 
@@ -2699,8 +2699,8 @@ static void delete_node_mgr(struct node_mgr *hnode_mgr)
  *  Purpose:
  *      Fills stream information.
  */
-static void fill_stream_connect(struct node_object *hNode1,
-				struct node_object *hNode2,
+static void fill_stream_connect(struct node_object *node1,
+				struct node_object *node2,
 				u32 uStream1, u32 uStream2)
 {
 	u32 strm_index;
@@ -2709,35 +2709,35 @@ static void fill_stream_connect(struct node_object *hNode1,
 	enum node_type node1_type = NODE_TASK;
 	enum node_type node2_type = NODE_TASK;
 
-	node1_type = node_get_type(hNode1);
-	node2_type = node_get_type(hNode2);
-	if (hNode1 != (struct node_object *)DSP_HGPPNODE) {
+	node1_type = node_get_type(node1);
+	node2_type = node_get_type(node2);
+	if (node1 != (struct node_object *)DSP_HGPPNODE) {
 
 		if (node1_type != NODE_DEVICE) {
-			strm_index = hNode1->num_inputs +
-			    hNode1->num_outputs - 1;
-			strm1 = &(hNode1->stream_connect[strm_index]);
+			strm_index = node1->num_inputs +
+			    node1->num_outputs - 1;
+			strm1 = &(node1->stream_connect[strm_index]);
 			strm1->cb_struct = sizeof(struct dsp_streamconnect);
 			strm1->this_node_stream_index = uStream1;
 		}
 
-		if (hNode2 != (struct node_object *)DSP_HGPPNODE) {
+		if (node2 != (struct node_object *)DSP_HGPPNODE) {
 			/* NODE == > NODE */
 			if (node1_type != NODE_DEVICE) {
-				strm1->connected_node = hNode2;
-				strm1->ui_connected_node_id = hNode2->node_uuid;
+				strm1->connected_node = node2;
+				strm1->ui_connected_node_id = node2->node_uuid;
 				strm1->connected_node_stream_index = uStream2;
 				strm1->connect_type = CONNECTTYPE_NODEOUTPUT;
 			}
 			if (node2_type != NODE_DEVICE) {
-				strm_index = hNode2->num_inputs +
-				    hNode2->num_outputs - 1;
-				strm2 = &(hNode2->stream_connect[strm_index]);
+				strm_index = node2->num_inputs +
+				    node2->num_outputs - 1;
+				strm2 = &(node2->stream_connect[strm_index]);
 				strm2->cb_struct =
 				    sizeof(struct dsp_streamconnect);
 				strm2->this_node_stream_index = uStream2;
-				strm2->connected_node = hNode1;
-				strm2->ui_connected_node_id = hNode1->node_uuid;
+				strm2->connected_node = node1;
+				strm2->ui_connected_node_id = node1->node_uuid;
 				strm2->connected_node_stream_index = uStream1;
 				strm2->connect_type = CONNECTTYPE_NODEINPUT;
 			}
@@ -2745,9 +2745,9 @@ static void fill_stream_connect(struct node_object *hNode1,
 			strm1->connect_type = CONNECTTYPE_GPPOUTPUT;
 	} else {
 		/* GPP == > NODE */
-		DBC_ASSERT(hNode2 != (struct node_object *)DSP_HGPPNODE);
-		strm_index = hNode2->num_inputs + hNode2->num_outputs - 1;
-		strm2 = &(hNode2->stream_connect[strm_index]);
+		DBC_ASSERT(node2 != (struct node_object *)DSP_HGPPNODE);
+		strm_index = node2->num_inputs + node2->num_outputs - 1;
+		strm2 = &(node2->stream_connect[strm_index]);
 		strm2->cb_struct = sizeof(struct dsp_streamconnect);
 		strm2->this_node_stream_index = uStream2;
 		strm2->connect_type = CONNECTTYPE_GPPINPUT;
diff --git a/drivers/staging/tidspbridge/rmgr/proc.c b/drivers/staging/tidspbridge/rmgr/proc.c
index 8bcb128..03497e2 100644
--- a/drivers/staging/tidspbridge/rmgr/proc.c
+++ b/drivers/staging/tidspbridge/rmgr/proc.c
@@ -1873,10 +1873,10 @@ static char **prepend_envp(char **new_envp, char **envp, s32 envp_elems,
  *  Purpose:
  *      Notify the processor the events.
  */
-int proc_notify_clients(void *hProc, u32 uEvents)
+int proc_notify_clients(void *proc, u32 uEvents)
 {
 	int status = 0;
-	struct proc_object *p_proc_object = (struct proc_object *)hProc;
+	struct proc_object *p_proc_object = (struct proc_object *)proc;
 
 	DBC_REQUIRE(p_proc_object);
 	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
@@ -1897,10 +1897,10 @@ func_end:
  *      Notify the processor the events. This includes notifying all clients
  *      attached to a particulat DSP.
  */
-int proc_notify_all_clients(void *hProc, u32 uEvents)
+int proc_notify_all_clients(void *proc, u32 uEvents)
 {
 	int status = 0;
-	struct proc_object *p_proc_object = (struct proc_object *)hProc;
+	struct proc_object *p_proc_object = (struct proc_object *)proc;
 
 	DBC_REQUIRE(IS_VALID_PROC_EVENT(uEvents));
 	DBC_REQUIRE(refs > 0);
@@ -1921,10 +1921,10 @@ func_end:
  *  Purpose:
  *      Retrieves the processor ID.
  */
-int proc_get_processor_id(void *hProc, u32 * procID)
+int proc_get_processor_id(void *proc, u32 * procID)
 {
 	int status = 0;
-	struct proc_object *p_proc_object = (struct proc_object *)hProc;
+	struct proc_object *p_proc_object = (struct proc_object *)proc;
 
 	if (p_proc_object)
 		*procID = p_proc_object->processor_id;
-- 
1.7.1

