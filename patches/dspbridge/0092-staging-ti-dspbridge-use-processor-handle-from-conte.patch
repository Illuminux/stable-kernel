From 6bcc9beed2d46c0db479a3750af4b2cbd7a92401 Mon Sep 17 00:00:00 2001
From: Ernesto Ramos <ernesto@ti.com>
Date: Wed, 28 Jul 2010 16:04:55 -0500
Subject: [PATCH 92/94] staging: ti dspbridge: use processor handle from context instead of user's

Make sure dspbridge driver uses a valid processor handle by
using the handle stored in process context.

Signed-off-by: Ernesto Ramos <ernesto@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/pmgr/dspapi.c |   50 +++++++++++++++++------------
 1 files changed, 29 insertions(+), 21 deletions(-)

diff --git a/drivers/staging/tidspbridge/pmgr/dspapi.c b/drivers/staging/tidspbridge/pmgr/dspapi.c
index f46aaf6..d7613eb 100644
--- a/drivers/staging/tidspbridge/pmgr/dspapi.c
+++ b/drivers/staging/tidspbridge/pmgr/dspapi.c
@@ -616,6 +616,7 @@ u32 procwrap_ctrl(union trapped_args *args, void *pr_ctxt)
 	    args->args_proc_ctrl.pargs;
 	u8 *pargs = NULL;
 	int status = 0;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (psize) {
 		if (get_user(cb_data_size, psize)) {
@@ -633,7 +634,7 @@ u32 procwrap_ctrl(union trapped_args *args, void *pr_ctxt)
 			  cb_data_size);
 	}
 	if (!status) {
-		status = proc_ctrl(args->args_proc_ctrl.hprocessor,
+		status = proc_ctrl(hprocessor,
 				   args->args_proc_ctrl.dw_cmd,
 				   (struct dsp_cbdata *)pargs);
 	}
@@ -663,11 +664,12 @@ u32 procwrap_enum_node_info(union trapped_args *args, void *pr_ctxt)
 	void *node_tab[MAX_NODES];
 	u32 num_nodes;
 	u32 alloc_cnt;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (!args->args_proc_enumnode_info.node_tab_size)
 		return -EINVAL;
 
-	status = proc_enum_nodes(args->args_proc_enumnode_info.hprocessor,
+	status = proc_enum_nodes(hprocessor,
 				 node_tab,
 				 args->args_proc_enumnode_info.node_tab_size,
 				 &num_nodes, &alloc_cnt);
@@ -747,13 +749,14 @@ u32 procwrap_enum_resources(union trapped_args *args, void *pr_ctxt)
 {
 	int status = 0;
 	struct dsp_resourceinfo resource_info;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (args->args_proc_enumresources.resource_info_size <
 	    sizeof(struct dsp_resourceinfo))
 		return -EINVAL;
 
 	status =
-	    proc_get_resource_info(args->args_proc_enumresources.hprocessor,
+	    proc_get_resource_info(hprocessor,
 				   args->args_proc_enumresources.resource_type,
 				   &resource_info,
 				   args->args_proc_enumresources.
@@ -773,13 +776,13 @@ u32 procwrap_get_state(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	struct dsp_processorstate proc_state;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (args->args_proc_getstate.state_info_size <
 	    sizeof(struct dsp_processorstate))
 		return -EINVAL;
 
-	status =
-	    proc_get_state(args->args_proc_getstate.hprocessor, &proc_state,
+	status = proc_get_state(hprocessor, &proc_state,
 			   args->args_proc_getstate.state_info_size);
 	CP_TO_USR(args->args_proc_getstate.proc_state_obj, &proc_state, status,
 		  1);
@@ -794,14 +797,14 @@ u32 procwrap_get_trace(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	u8 *pbuf;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (args->args_proc_gettrace.max_size > MAX_TRACEBUFLEN)
 		return -EINVAL;
 
 	pbuf = kzalloc(args->args_proc_gettrace.max_size, GFP_KERNEL);
 	if (pbuf != NULL) {
-		status = proc_get_trace(args->args_proc_gettrace.hprocessor,
-					pbuf,
+		status = proc_get_trace(hprocessor, pbuf,
 					args->args_proc_gettrace.max_size);
 	} else {
 		status = -ENOMEM;
@@ -823,6 +826,7 @@ u32 procwrap_load(union trapped_args *args, void *pr_ctxt)
 	char *temp;
 	s32 count = args->args_proc_load.argc_index;
 	u8 **argv = NULL, **envp = NULL;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (count <= 0 || count > MAX_LOADARGS) {
 		status = -EINVAL;
@@ -905,7 +909,7 @@ u32 procwrap_load(union trapped_args *args, void *pr_ctxt)
 	}
 
 	if (!status) {
-		status = proc_load(args->args_proc_load.hprocessor,
+		status = proc_load(hprocessor,
 				   args->args_proc_load.argc_index,
 				   (const char **)argv, (const char **)envp);
 	}
@@ -936,6 +940,7 @@ u32 procwrap_map(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	void *map_addr;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if (!args->args_proc_mapmem.ul_size)
 		return -EINVAL;
@@ -948,8 +953,7 @@ u32 procwrap_map(union trapped_args *args, void *pr_ctxt)
 	if (!status) {
 		if (put_user(map_addr, args->args_proc_mapmem.pp_map_addr)) {
 			status = -EINVAL;
-			proc_un_map(args->args_proc_mapmem.hprocessor,
-				    map_addr, pr_ctxt);
+			proc_un_map(hprocessor, map_addr, pr_ctxt);
 		}
 
 	}
@@ -963,13 +967,13 @@ u32 procwrap_register_notify(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	struct dsp_notification notification;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	/* Initialize the notification data structure */
 	notification.ps_name = NULL;
 	notification.handle = NULL;
 
-	status =
-	    proc_register_notify(args->args_proc_register_notify.hprocessor,
+	status = proc_register_notify(hprocessor,
 				 args->args_proc_register_notify.event_mask,
 				 args->args_proc_register_notify.notify_type,
 				 &notification);
@@ -985,12 +989,13 @@ u32 procwrap_reserve_memory(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 	void *prsv_addr;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	if ((args->args_proc_rsvmem.ul_size <= 0) ||
 	    (args->args_proc_rsvmem.ul_size & (PG_SIZE4K - 1)) != 0)
 		return -EINVAL;
 
-	status = proc_reserve_memory(args->args_proc_rsvmem.hprocessor,
+	status = proc_reserve_memory(hprocessor,
 				     args->args_proc_rsvmem.ul_size, &prsv_addr,
 				     pr_ctxt);
 	if (!status) {
@@ -1010,7 +1015,7 @@ u32 procwrap_start(union trapped_args *args, void *pr_ctxt)
 {
 	u32 ret;
 
-	ret = proc_start(args->args_proc_start.hprocessor);
+	ret = proc_start(((struct process_context *)pr_ctxt)->hprocessor);
 	return ret;
 }
 
@@ -1021,7 +1026,7 @@ u32 procwrap_un_map(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
 
-	status = proc_un_map(args->args_proc_unmapmem.hprocessor,
+	status = proc_un_map(((struct process_context *)pr_ctxt)->hprocessor,
 			     args->args_proc_unmapmem.map_addr, pr_ctxt);
 	return status;
 }
@@ -1032,8 +1037,9 @@ u32 procwrap_un_map(union trapped_args *args, void *pr_ctxt)
 u32 procwrap_un_reserve_memory(union trapped_args *args, void *pr_ctxt)
 {
 	int status;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
-	status = proc_un_reserve_memory(args->args_proc_unrsvmem.hprocessor,
+	status = proc_un_reserve_memory(hprocessor,
 					args->args_proc_unrsvmem.prsv_addr,
 					pr_ctxt);
 	return status;
@@ -1046,7 +1052,7 @@ u32 procwrap_stop(union trapped_args *args, void *pr_ctxt)
 {
 	u32 ret;
 
-	ret = proc_stop(args->args_proc_stop.hprocessor);
+	ret = proc_stop(((struct process_context *)pr_ctxt)->hprocessor);
 
 	return ret;
 }
@@ -1078,6 +1084,7 @@ u32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)
 	struct dsp_nodeattrin proc_attr_in, *attr_in = NULL;
 	struct node_res_object *node_res;
 	int nodeid;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	/* Optional argument */
 	if (psize) {
@@ -1108,7 +1115,7 @@ u32 nodewrap_allocate(union trapped_args *args, void *pr_ctxt)
 
 	}
 	if (!status) {
-		status = node_allocate(args->args_node_allocate.hprocessor,
+		status = node_allocate(hprocessor,
 				       &node_uuid, (struct dsp_cbdata *)pargs,
 				       attr_in, &node_res, pr_ctxt);
 	}
@@ -1493,6 +1500,7 @@ u32 nodewrap_get_uuid_props(union trapped_args *args, void *pr_ctxt)
 	int status = 0;
 	struct dsp_uuid node_uuid;
 	struct dsp_ndbprops *pnode_props = NULL;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
 	CP_FM_USR(&node_uuid, args->args_node_getuuidprops.node_id_ptr, status,
 		  1);
@@ -1501,8 +1509,7 @@ u32 nodewrap_get_uuid_props(union trapped_args *args, void *pr_ctxt)
 	pnode_props = kmalloc(sizeof(struct dsp_ndbprops), GFP_KERNEL);
 	if (pnode_props != NULL) {
 		status =
-		    node_get_uuid_props(args->args_node_getuuidprops.hprocessor,
-					&node_uuid, pnode_props);
+		    node_get_uuid_props(hprocessor, &node_uuid, pnode_props);
 		CP_TO_USR(args->args_node_getuuidprops.node_props, pnode_props,
 			  status, 1);
 	} else
@@ -1788,8 +1795,9 @@ u32 cmmwrap_get_handle(union trapped_args *args, void *pr_ctxt)
 {
 	int status = 0;
 	struct cmm_object *hcmm_mgr;
+	void *hprocessor = ((struct process_context *)pr_ctxt)->hprocessor;
 
-	status = cmm_get_handle(args->args_cmm_gethandle.hprocessor, &hcmm_mgr);
+	status = cmm_get_handle(hprocessor, &hcmm_mgr);
 
 	CP_TO_USR(args->args_cmm_gethandle.ph_cmm_mgr, &hcmm_mgr, status, 1);
 
-- 
1.7.0.4

