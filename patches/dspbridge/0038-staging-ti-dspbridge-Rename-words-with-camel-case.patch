From e436d07db9db374105daa6c15d853e3f13a37104 Mon Sep 17 00:00:00 2001
From: Rene Sapiens <rene.sapiens@ti.com>
Date: Fri, 9 Jul 2010 21:24:00 -0500
Subject: [PATCH 038/116] staging: ti dspbridge: Rename words with camel case

The intention of this patch is to rename the remaining variables with camel
case. Variables will be renamed avoiding camel case and Hungarian notation.
The words to be renamed in this patch are:
========================================
phDevContext to device_ctx
phDevNode to dev_nde
phDevObject to device_obj
phDispObject to dispatch_obj
phDmmMgr to dmm_manager
phDrvObject to drv_obj
phDRVObject to drv_obj
phIOMgr to io_man
phLoader to loader
phManager to manager
phMgrObject to mgr_obj
phMgr to mgr
phMsgMgr to msg_man
phMsgQueue to msgq
phNldrNode to nldr_nodeobj
========================================

Signed-off-by: Rene Sapiens <rene.sapiens@ti.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/staging/tidspbridge/core/io_sm.c           |   10 +-
 drivers/staging/tidspbridge/core/msg_sm.c          |   16 ++--
 .../staging/tidspbridge/include/dspbridge/cfg.h    |    2 +-
 .../staging/tidspbridge/include/dspbridge/cod.h    |   10 +-
 .../staging/tidspbridge/include/dspbridge/dev.h    |   82 ++++++++++----------
 .../staging/tidspbridge/include/dspbridge/disp.h   |   10 +-
 .../staging/tidspbridge/include/dspbridge/dmm.h    |    4 +-
 .../staging/tidspbridge/include/dspbridge/drv.h    |   18 ++--
 .../tidspbridge/include/dspbridge/dspdefs.h        |   26 +++---
 .../staging/tidspbridge/include/dspbridge/dspio.h  |    2 +-
 .../staging/tidspbridge/include/dspbridge/dspmsg.h |    4 +-
 drivers/staging/tidspbridge/include/dspbridge/io.h |    4 +-
 .../staging/tidspbridge/include/dspbridge/mgr.h    |    6 +-
 .../staging/tidspbridge/include/dspbridge/msg.h    |    6 +-
 .../staging/tidspbridge/include/dspbridge/nldr.h   |    2 +-
 .../tidspbridge/include/dspbridge/nldrdefs.h       |   10 +-
 .../staging/tidspbridge/include/dspbridge/proc.h   |   14 ++--
 drivers/staging/tidspbridge/pmgr/cod.c             |   14 ++--
 drivers/staging/tidspbridge/pmgr/dev.c             |   74 +++++++++---------
 drivers/staging/tidspbridge/pmgr/dmm.c             |   14 ++--
 drivers/staging/tidspbridge/pmgr/io.c              |    8 +-
 drivers/staging/tidspbridge/pmgr/msg.c             |    8 +-
 drivers/staging/tidspbridge/rmgr/disp.c            |   12 ++--
 drivers/staging/tidspbridge/rmgr/drv.c             |   14 ++--
 drivers/staging/tidspbridge/rmgr/mgr.c             |    6 +-
 drivers/staging/tidspbridge/rmgr/nldr.c            |   12 ++--
 drivers/staging/tidspbridge/rmgr/proc.c            |   12 ++--
 27 files changed, 200 insertions(+), 200 deletions(-)

diff --git a/drivers/staging/tidspbridge/core/io_sm.c b/drivers/staging/tidspbridge/core/io_sm.c
index 81b81e1..7f34510 100644
--- a/drivers/staging/tidspbridge/core/io_sm.c
+++ b/drivers/staging/tidspbridge/core/io_sm.c
@@ -161,7 +161,7 @@ static int register_shm_segs(struct io_mgr *hio_mgr,
  *  ======== bridge_io_create ========
  *      Create an IO manager object.
  */
-int bridge_io_create(OUT struct io_mgr **phIOMgr,
+int bridge_io_create(OUT struct io_mgr **io_man,
 			    struct dev_object *hdev_obj,
 			    IN CONST struct io_attrs *pMgrAttrs)
 {
@@ -174,7 +174,7 @@ int bridge_io_create(OUT struct io_mgr **phIOMgr,
 	u8 dev_type;
 
 	/* Check requirements */
-	if (!phIOMgr || !pMgrAttrs || pMgrAttrs->word_size == 0) {
+	if (!io_man || !pMgrAttrs || pMgrAttrs->word_size == 0) {
 		status = -EFAULT;
 		goto func_end;
 	}
@@ -243,12 +243,12 @@ func_end:
 	if (DSP_FAILED(status)) {
 		/* Cleanup */
 		bridge_io_destroy(pio_mgr);
-		if (phIOMgr)
-			*phIOMgr = NULL;
+		if (io_man)
+			*io_man = NULL;
 	} else {
 		/* Return IO manager object to caller... */
 		hchnl_mgr->hio_mgr = pio_mgr;
-		*phIOMgr = pio_mgr;
+		*io_man = pio_mgr;
 	}
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/core/msg_sm.c b/drivers/staging/tidspbridge/core/msg_sm.c
index 0a68df9..22e1898 100644
--- a/drivers/staging/tidspbridge/core/msg_sm.c
+++ b/drivers/staging/tidspbridge/core/msg_sm.c
@@ -48,7 +48,7 @@ static void free_msg_list(struct lst_list *msg_list);
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-int bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+int bridge_msg_create(OUT struct msg_mgr **msg_man,
 			     struct dev_object *hdev_obj,
 			     msg_onexit msg_callback)
 {
@@ -56,7 +56,7 @@ int bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 	struct io_mgr *hio_mgr;
 	int status = 0;
 
-	if (!phMsgMgr || !msg_callback || !hdev_obj) {
+	if (!msg_man || !msg_callback || !hdev_obj) {
 		status = -EFAULT;
 		goto func_end;
 	}
@@ -65,7 +65,7 @@ int bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 		status = -EFAULT;
 		goto func_end;
 	}
-	*phMsgMgr = NULL;
+	*msg_man = NULL;
 	/* Allocate msg_ctrl manager object */
 	msg_mgr_obj = kzalloc(sizeof(struct msg_mgr), GFP_KERNEL);
 
@@ -103,7 +103,7 @@ int bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
 			sync_init_event(msg_mgr_obj->sync_event);
 
 		if (DSP_SUCCEEDED(status))
-			*phMsgMgr = msg_mgr_obj;
+			*msg_man = msg_mgr_obj;
 		else
 			delete_msg_mgr(msg_mgr_obj);
 
@@ -120,7 +120,7 @@ func_end:
  *      on the DSP.
  */
 int bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
-				OUT struct msg_queue **phMsgQueue,
+				OUT struct msg_queue **msgq,
 				u32 msgq_id, u32 max_msgs, void *arg)
 {
 	u32 i;
@@ -128,12 +128,12 @@ int bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 	struct msg_queue *msg_q;
 	int status = 0;
 
-	if (!hmsg_mgr || phMsgQueue == NULL || !hmsg_mgr->msg_free_list) {
+	if (!hmsg_mgr || msgq == NULL || !hmsg_mgr->msg_free_list) {
 		status = -EFAULT;
 		goto func_end;
 	}
 
-	*phMsgQueue = NULL;
+	*msgq = NULL;
 	/* Allocate msg_queue object */
 	msg_q = kzalloc(sizeof(struct msg_queue), GFP_KERNEL);
 	if (!msg_q) {
@@ -217,7 +217,7 @@ int bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
 		} else {
 			lst_put_tail(hmsg_mgr->queue_list,
 				     (struct list_head *)msg_q);
-			*phMsgQueue = msg_q;
+			*msgq = msg_q;
 			/* Signal that free frames are now available */
 			if (!LST_IS_EMPTY(hmsg_mgr->msg_free_list))
 				sync_set_event(hmsg_mgr->sync_event);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/cfg.h b/drivers/staging/tidspbridge/include/dspbridge/cfg.h
index 29f9024..6fdd229 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/cfg.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/cfg.h
@@ -82,7 +82,7 @@ extern int cfg_get_cd_version(OUT u32 *version);
  *      value:          Ptr to location to store the value.
  *  Returns:
  *      0:                Success.
- *      -EFAULT: dev_node_obj is invalid or phDevObject is invalid.
+ *      -EFAULT: dev_node_obj is invalid or device_obj is invalid.
  *      -ENODATA: The resource is not available.
  *  Requires:
  *      CFG initialized.
diff --git a/drivers/staging/tidspbridge/include/dspbridge/cod.h b/drivers/staging/tidspbridge/include/dspbridge/cod.h
index 92f3cf7..63bb874 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/cod.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/cod.h
@@ -77,7 +77,7 @@ extern void cod_close(struct cod_libraryobj *lib);
  *      Symbol table information is managed by this object and can be retrieved
  *      using the cod_get_sym_value() function.
  *  Parameters:
- *      phManager:      created manager object
+ *      manager:        created manager object
  *      pstrZLFile:     ZL DLL filename, of length < COD_MAXPATHLENGTH.
  *      attrs:          attributes to be used by this object. A NULL value
  *                      will cause default attrs to be used.
@@ -91,7 +91,7 @@ extern void cod_close(struct cod_libraryobj *lib);
  *      pstrZLFile != NULL
  *  Ensures:
  */
-extern int cod_create(OUT struct cod_manager **phManager,
+extern int cod_create(OUT struct cod_manager **manager,
 			     char *pstrZLFile,
 			     IN OPTIONAL CONST struct cod_attrs *attrs);
 
@@ -187,17 +187,17 @@ extern int cod_get_entry(struct cod_manager *cod_mgr_obj,
  *      Get handle to the DBL loader.
  *  Parameters:
  *      cod_mgr_obj:   handle of manager to be deleted
- *      phLoader:   location to store loader handle on output.
+ *      loader:     location to store loader handle on output.
  *  Returns:
  *      0:    Success.
  *  Requires:
  *      COD module initialized.
  *      valid cod_mgr_obj.
- *      phLoader != NULL.
+ *      loader != NULL.
  *  Ensures:
  */
 extern int cod_get_loader(struct cod_manager *cod_mgr_obj,
-				 struct dbll_tar_obj **phLoader);
+				 struct dbll_tar_obj **loader);
 
 /*
  *  ======== cod_get_section ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dev.h b/drivers/staging/tidspbridge/include/dspbridge/dev.h
index 3d7a08a..68aa0b1 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dev.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dev.h
@@ -64,7 +64,7 @@ extern u32 dev_brd_write_fxn(void *arb,
  *      Called by the operating system to load the Bridge Driver for a
  *      'Bridge device.
  *  Parameters:
- *      phDevObject:    Ptr to location to receive the device object handle.
+ *      device_obj:     Ptr to location to receive the device object handle.
  *      driver_file_name: Name of Bridge driver PE DLL file to load.  If the
  *                      absolute path is not provided, the file is loaded
  *                      through 'Bridge's module search path.
@@ -80,17 +80,17 @@ extern u32 dev_brd_write_fxn(void *arb,
  *      -ESPIPE:   Unable to load ZL DLL.
  *  Requires:
  *      DEV Initialized.
- *      phDevObject != NULL.
+ *      device_obj != NULL.
  *      driver_file_name != NULL.
  *      pHostConfig != NULL.
  *      pDspConfig != NULL.
  *  Ensures:
- *      0:  *phDevObject will contain handle to the new device object.
+ *      0:  *device_obj will contain handle to the new device object.
  *      Otherwise, does not create the device object, ensures the Bridge driver
- *      module is unloaded, and sets *phDevObject to NULL.
+ *      module is unloaded, and sets *device_obj to NULL.
  */
 extern int dev_create_device(OUT struct dev_object
-				    **phDevObject,
+				    **device_obj,
 				    IN CONST char *driver_file_name,
 				    struct cfg_devnode *dev_node_obj);
 
@@ -99,7 +99,7 @@ extern int dev_create_device(OUT struct dev_object
  *  Purpose:
  *      Called by the operating system to load the Bridge Driver for IVA.
  *  Parameters:
- *      phDevObject:    Ptr to location to receive the device object handle.
+ *      device_obj:     Ptr to location to receive the device object handle.
  *      driver_file_name: Name of Bridge driver PE DLL file to load.  If the
  *                      absolute path is not provided, the file is loaded
  *                      through 'Bridge's module search path.
@@ -115,17 +115,17 @@ extern int dev_create_device(OUT struct dev_object
  *      -ESPIPE:   Unable to load ZL DLL.
  *  Requires:
  *      DEV Initialized.
- *      phDevObject != NULL.
+ *      device_obj != NULL.
  *      driver_file_name != NULL.
  *      pHostConfig != NULL.
  *      pDspConfig != NULL.
  *  Ensures:
- *      0:  *phDevObject will contain handle to the new device object.
+ *      0:  *device_obj will contain handle to the new device object.
  *      Otherwise, does not create the device object, ensures the Bridge driver
- *      module is unloaded, and sets *phDevObject to NULL.
+ *      module is unloaded, and sets *device_obj to NULL.
  */
 extern int dev_create_iva_device(OUT struct dev_object
-					**phDevObject,
+					**device_obj,
 					IN CONST char *driver_file_name,
 					IN CONST struct cfg_hostres
 					*pHostConfig,
@@ -195,20 +195,20 @@ extern int dev_destroy_device(struct dev_object
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      *phMgr:         Ptr to location to store handle.
+ *      *mgr:           Ptr to location to store handle.
  *  Returns:
  *      0:        Success.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phMgr != NULL.
+ *      mgr != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phMgr contains a handle to a channel manager object,
+ *      0:        *mgr contains a handle to a channel manager object,
  *                      or NULL.
- *      else:           *phMgr is NULL.
+ *      else:           *mgr is NULL.
  */
 extern int dev_get_chnl_mgr(struct dev_object *hdev_obj,
-				   OUT struct chnl_mgr **phMgr);
+				   OUT struct chnl_mgr **mgr);
 
 /*
  *  ======== dev_get_cmm_mgr ========
@@ -218,20 +218,20 @@ extern int dev_get_chnl_mgr(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      *phMgr:         Ptr to location to store handle.
+ *      *mgr:           Ptr to location to store handle.
  *  Returns:
  *      0:        Success.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phMgr != NULL.
+ *      mgr != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phMgr contains a handle to a channel manager object,
+ *      0:        *mgr contains a handle to a channel manager object,
  *                      or NULL.
- *      else:           *phMgr is NULL.
+ *      else:           *mgr is NULL.
  */
 extern int dev_get_cmm_mgr(struct dev_object *hdev_obj,
-				  OUT struct cmm_object **phMgr);
+				  OUT struct cmm_object **mgr);
 
 /*
  *  ======== dev_get_dmm_mgr ========
@@ -241,20 +241,20 @@ extern int dev_get_cmm_mgr(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      *phMgr:         Ptr to location to store handle.
+ *      *mgr:           Ptr to location to store handle.
  *  Returns:
  *      0:        Success.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phMgr != NULL.
+ *      mgr != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phMgr contains a handle to a channel manager object,
+ *      0:        *mgr contains a handle to a channel manager object,
  *                      or NULL.
- *      else:           *phMgr is NULL.
+ *      else:           *mgr is NULL.
  */
 extern int dev_get_dmm_mgr(struct dev_object *hdev_obj,
-				  OUT struct dmm_object **phMgr);
+				  OUT struct dmm_object **mgr);
 
 /*
  *  ======== dev_get_cod_mgr ========
@@ -304,19 +304,19 @@ extern int dev_get_deh_mgr(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      phDevNode:      Ptr to location to get the device node handle.
+ *      dev_nde:        Ptr to location to get the device node handle.
  *  Returns:
  *      0:        Returns a DEVNODE in *dev_node_obj.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phDevNode != NULL.
+ *      dev_nde != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phDevNode contains a platform specific device ID;
- *      else:           *phDevNode is NULL.
+ *      0:        *dev_nde contains a platform specific device ID;
+ *      else:           *dev_nde is NULL.
  */
 extern int dev_get_dev_node(struct dev_object *hdev_obj,
-				   OUT struct cfg_devnode **phDevNode);
+				   OUT struct cfg_devnode **dev_nde);
 
 /*
  *  ======== dev_get_dev_type ========
@@ -325,16 +325,16 @@ extern int dev_get_dev_node(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      phDevNode:      Ptr to location to get the device node handle.
+ *      dev_nde:        Ptr to location to get the device node handle.
  *  Returns:
  *      0:        Success
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phDevNode != NULL.
+ *      dev_nde != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phDevNode contains a platform specific device ID;
- *      else:           *phDevNode is NULL.
+ *      0:        *dev_nde contains a platform specific device ID;
+ *      else:           *dev_nde is NULL.
  */
 extern int dev_get_dev_type(struct dev_object *device_obj,
 					u8 *dev_type);
@@ -389,19 +389,19 @@ extern int dev_get_intf_fxns(struct dev_object *hdev_obj,
  *  Parameters:
  *      hdev_obj:     Handle to device object created with
  *                      dev_create_device().
- *      *phMgr:         Ptr to location to store handle.
+ *      *mgr:           Ptr to location to store handle.
  *  Returns:
  *      0:        Success.
  *      -EFAULT:    Invalid hdev_obj.
  *  Requires:
- *      phMgr != NULL.
+ *      mgr != NULL.
  *      DEV Initialized.
  *  Ensures:
- *      0:        *phMgr contains a handle to an IO manager object.
- *      else:           *phMgr is NULL.
+ *      0:        *mgr contains a handle to an IO manager object.
+ *      else:           *mgr is NULL.
  */
 extern int dev_get_io_mgr(struct dev_object *hdev_obj,
-				 OUT struct io_mgr **phMgr);
+				 OUT struct io_mgr **mgr);
 
 /*
  *  ======== dev_get_next ========
@@ -434,7 +434,7 @@ extern struct dev_object *dev_get_next(struct dev_object
  *      Retrieve the msg_ctrl Manager Handle from the DevObject.
  *  Parameters:
  *      hdev_obj: Handle to the Dev Object
- *      phMsgMgr:   Location where msg_ctrl Manager handle will be returned.
+ *      msg_man:    Location where msg_ctrl Manager handle will be returned.
  *  Returns:
  *  Requires:
  *      DEV Initialized.
@@ -443,7 +443,7 @@ extern struct dev_object *dev_get_next(struct dev_object
  *  Ensures:
  */
 extern void dev_get_msg_mgr(struct dev_object *hdev_obj,
-			    OUT struct msg_mgr **phMsgMgr);
+			    OUT struct msg_mgr **msg_man);
 
 /*
  *  ========= dev_get_node_manager ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/disp.h b/drivers/staging/tidspbridge/include/dspbridge/disp.h
index 59fb431..03467bb 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/disp.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/disp.h
@@ -32,7 +32,7 @@
  *  Manager object should have exactly one NODE Dispatcher.
  *
  *  Parameters:
- *      phDispObject:   Location to store node dispatcher object on output.
+ *      dispatch_obj:   Location to store node dispatcher object on output.
  *      hdev_obj:     Device for this processor.
  *      disp_attrs:     Node dispatcher attributes.
  *  Returns:
@@ -43,12 +43,12 @@
  *      disp_init(void) called.
  *      disp_attrs != NULL.
  *      hdev_obj != NULL.
- *      phDispObject != NULL.
+ *      dispatch_obj != NULL.
  *  Ensures:
- *      0:        IS_VALID(*phDispObject).
- *      error:          *phDispObject == NULL.
+ *      0:        IS_VALID(*dispatch_obj).
+ *      error:          *dispatch_obj == NULL.
  */
-extern int disp_create(OUT struct disp_object **phDispObject,
+extern int disp_create(OUT struct disp_object **dispatch_obj,
 			      struct dev_object *hdev_obj,
 			      IN CONST struct disp_attr *disp_attrs);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dmm.h b/drivers/staging/tidspbridge/include/dspbridge/dmm.h
index 1ce1b65..9be892f 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dmm.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dmm.h
@@ -39,7 +39,7 @@ struct dmm_mgrattrs {
  */
 
 extern int dmm_get_handle(void *hprocessor,
-				 OUT struct dmm_object **phDmmMgr);
+				 OUT struct dmm_object **dmm_manager);
 
 extern int dmm_reserve_memory(struct dmm_object *dmm_mgr,
 				     u32 size, u32 *prsv_addr);
@@ -57,7 +57,7 @@ extern int dmm_destroy(struct dmm_object *dmm_mgr);
 
 extern int dmm_delete_tables(struct dmm_object *dmm_mgr);
 
-extern int dmm_create(OUT struct dmm_object **phDmmMgr,
+extern int dmm_create(OUT struct dmm_object **dmm_manager,
 			     struct dev_object *hdev_obj,
 			     IN CONST struct dmm_mgrattrs *pMgrAttrs);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/drv.h b/drivers/staging/tidspbridge/include/dspbridge/drv.h
index 14bb4a5..2f9d8d8 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/drv.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/drv.h
@@ -183,16 +183,16 @@ struct process_context {
  *      Creates the Driver Object. This is done during the driver loading.
  *      There is only one Driver Object in the DSP/BIOS Bridge.
  *  Parameters:
- *      phDrvObject:    Location to store created DRV Object handle.
+ *      drv_obj:        Location to store created DRV Object handle.
  *  Returns:
  *      0:        Sucess
  *      -ENOMEM:    Failed in Memory allocation
  *      -EPERM:      General Failure
  *  Requires:
  *      DRV Initialized (refs > 0 )
- *      phDrvObject != NULL.
+ *      drv_obj != NULL.
  *  Ensures:
- *      0:        - *phDrvObject is a valid DRV interface to the device.
+ *      0:        - *drv_obj is a valid DRV interface to the device.
  *                      - List of DevObject Created and Initialized.
  *                      - List of dev_node String created and intialized.
  *                      - Registry is updated with the DRV Object.
@@ -204,7 +204,7 @@ struct process_context {
  *      Also it can hold other neccessary
  *      information in its storage area.
  */
-extern int drv_create(struct drv_object **phDrvObject);
+extern int drv_create(struct drv_object **drv_obj);
 
 /*
  *  ======== drv_destroy ========
@@ -274,23 +274,23 @@ extern u32 drv_get_first_dev_extension(void);
  *      Given a index, returns a handle to DevObject from the list
  *  Parameters:
  *      hdrv_obj:     Handle to the Manager
- *      phDevObject:    Location to store the Dev Handle
+ *      device_obj:     Location to store the Dev Handle
  *  Requires:
  *      DRV Initialized
  *      index >= 0
  *      hdrv_obj is not NULL and Valid DRV Object
- *      phDevObject is not NULL
+ *      device_obj is not NULL
  *      Device Object List not Empty
  *  Returns:
  *      0:        Success
  *      -EPERM:      Failed to Get the Dev Object
  *  Ensures:
- *      0:        *phDevObject != NULL
- *      -EPERM:      *phDevObject = NULL
+ *      0:        *device_obj != NULL
+ *      -EPERM:      *device_obj = NULL
  */
 extern int drv_get_dev_object(u32 index,
 				     struct drv_object *hdrv_obj,
-				     struct dev_object **phDevObject);
+				     struct dev_object **device_obj);
 
 /*
  *  ======== drv_get_next_dev_object ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
index f8146cc..42930cc 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspdefs.h
@@ -648,7 +648,7 @@ typedef int(*fxn_chnl_registernotify)
  *  Purpose:
  *      Complete creation of the device object for this board.
  *  Parameters:
- *      phDevContext:   Ptr to location to store a Bridge device context.
+ *      device_ctx:     Ptr to location to store a Bridge device context.
  *      hdev_obj:     Handle to a Device Object, created and managed by DSP API.
  *      config_param:        Ptr to configuration parameters provided by the
  *                      Configuration Manager during device loading.
@@ -658,7 +658,7 @@ typedef int(*fxn_chnl_registernotify)
  *      0:            Success.
  *      -ENOMEM:        Unable to allocate memory for device context.
  *  Requires:
- *      phDevContext != NULL;
+ *      device_ctx != NULL;
  *      hdev_obj != NULL;
  *      config_param != NULL;
  *      pDspConfig != NULL;
@@ -680,7 +680,7 @@ typedef int(*fxn_chnl_registernotify)
  *      structure.
  */
 typedef int(*fxn_dev_create) (OUT struct bridge_dev_context
-				     **phDevContext,
+				     **device_ctx,
 				     struct dev_object
 				     * hdev_obj,
 				     IN struct cfg_hostres
@@ -729,7 +729,7 @@ typedef int(*fxn_dev_destroy) (struct bridge_dev_context *dev_ctxt);
  *  Purpose:
  *      Create an object that manages I/O between CHNL and msg_ctrl.
  *  Parameters:
- *      phIOMgr:        Location to store IO manager on output.
+ *      io_man:         Location to store IO manager on output.
  *      hchnl_mgr:       Handle to channel manager.
  *      hmsg_mgr:        Handle to message manager.
  *  Returns:
@@ -741,10 +741,10 @@ typedef int(*fxn_dev_destroy) (struct bridge_dev_context *dev_ctxt);
  *      Channel manager already created;
  *      Message manager already created;
  *      pMgrAttrs != NULL;
- *      phIOMgr != NULL;
+ *      io_man != NULL;
  *  Ensures:
  */
-typedef int(*fxn_io_create) (OUT struct io_mgr **phIOMgr,
+typedef int(*fxn_io_create) (OUT struct io_mgr **io_man,
 				    struct dev_object *hdev_obj,
 				    IN CONST struct io_attrs *pMgrAttrs);
 
@@ -805,20 +805,20 @@ typedef int(*fxn_io_getprocload) (struct io_mgr *hio_mgr,
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  *  Parameters:
- *      phMsgMgr:           Location to store msg_ctrl manager on output.
+ *      msg_man:            Location to store msg_ctrl manager on output.
  *      hdev_obj:         Handle to a device object.
  *      msg_callback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *      0:            Success.
  *      -ENOMEM:        Insufficient memory.
  *  Requires:
- *      phMsgMgr != NULL.
+ *      msg_man != NULL.
  *      msg_callback != NULL.
  *      hdev_obj != NULL.
  *  Ensures:
  */
 typedef int(*fxn_msg_create)
- (OUT struct msg_mgr **phMsgMgr,
+ (OUT struct msg_mgr **msg_man,
   struct dev_object *hdev_obj, msg_onexit msg_callback);
 
 /*
@@ -829,7 +829,7 @@ typedef int(*fxn_msg_create)
  *  Parameters:
  *      hmsg_mgr:            msg_ctrl queue manager handle returned from
  *                          bridge_msg_create.
- *      phMsgQueue:         Location to store msg_ctrl queue on output.
+ *      msgq:               Location to store msg_ctrl queue on output.
  *      msgq_id:	    Identifier for messages (node environment pointer).
  *      max_msgs:           Max number of simultaneous messages for the node.
  *      h:                  Handle passed to hmsg_mgr->msg_callback().
@@ -837,15 +837,15 @@ typedef int(*fxn_msg_create)
  *      0:            Success.
  *      -ENOMEM:        Insufficient memory.
  *  Requires:
- *      phMsgQueue != NULL.
+ *      msgq != NULL.
  *      h != NULL.
  *      max_msgs > 0.
  *  Ensures:
- *      phMsgQueue !=NULL <==> 0.
+ *      msgq !=NULL <==> 0.
  */
 typedef int(*fxn_msg_createqueue)
  (struct msg_mgr *hmsg_mgr,
-  OUT struct msg_queue **phMsgQueue, u32 msgq_id, u32 max_msgs, void *h);
+  OUT struct msg_queue **msgq, u32 msgq_id, u32 max_msgs, void *h);
 
 /*
  *  ======== bridge_msg_delete ========
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspio.h b/drivers/staging/tidspbridge/include/dspbridge/dspio.h
index 275697a..7b33563 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspio.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspio.h
@@ -26,7 +26,7 @@
 #include <dspbridge/devdefs.h>
 #include <dspbridge/iodefs.h>
 
-extern int bridge_io_create(OUT struct io_mgr **phIOMgr,
+extern int bridge_io_create(OUT struct io_mgr **io_man,
 				   struct dev_object *hdev_obj,
 				   IN CONST struct io_attrs *pMgrAttrs);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/dspmsg.h b/drivers/staging/tidspbridge/include/dspbridge/dspmsg.h
index 18f56e1..a40b0ff 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/dspmsg.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/dspmsg.h
@@ -26,12 +26,12 @@
 
 #include <dspbridge/msgdefs.h>
 
-extern int bridge_msg_create(OUT struct msg_mgr **phMsgMgr,
+extern int bridge_msg_create(OUT struct msg_mgr **msg_man,
 				    struct dev_object *hdev_obj,
 				    msg_onexit msg_callback);
 
 extern int bridge_msg_create_queue(struct msg_mgr *hmsg_mgr,
-				       OUT struct msg_queue **phMsgQueue,
+				       OUT struct msg_queue **msgq,
 				       u32 msgq_id, u32 max_msgs, void *h);
 
 extern void bridge_msg_delete(struct msg_mgr *hmsg_mgr);
diff --git a/drivers/staging/tidspbridge/include/dspbridge/io.h b/drivers/staging/tidspbridge/include/dspbridge/io.h
index 123cf03..aa24535 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/io.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/io.h
@@ -45,11 +45,11 @@
  *               Invalid base address for DSP communications.
  *  Requires:
  *      io_init(void) called.
- *      phIOMgr != NULL.
+ *      io_man != NULL.
  *      pMgrAttrs != NULL.
  *  Ensures:
  */
-extern int io_create(OUT struct io_mgr **phIOMgr,
+extern int io_create(OUT struct io_mgr **io_man,
 			    struct dev_object *hdev_obj,
 			    IN CONST struct io_attrs *pMgrAttrs);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/mgr.h b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
index 90e174c..b90457b 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/mgr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/mgr.h
@@ -49,7 +49,7 @@ int mgr_wait_for_bridge_events(struct dsp_notification
  *      Creates the Manager Object. This is done during the driver loading.
  *      There is only one Manager Object in the DSP/BIOS Bridge.
  *  Parameters:
- *      phMgrObject:    Location to store created MGR Object handle.
+ *      mgr_obj:        Location to store created MGR Object handle.
  *      dev_node_obj:       Device object as known to the system.
  *  Returns:
  *      0:        Success
@@ -57,9 +57,9 @@ int mgr_wait_for_bridge_events(struct dsp_notification
  *      -EPERM:      General Failure
  *  Requires:
  *      MGR Initialized (refs > 0 )
- *      phMgrObject != NULL.
+ *      mgr_obj != NULL.
  *  Ensures:
- *      0:        *phMgrObject is a valid MGR interface to the device.
+ *      0:        *mgr_obj is a valid MGR interface to the device.
  *                      MGR Object stores the DCD Manager Handle.
  *                      MGR Object stored in the Regsitry.
  *      !0:       MGR Object not created
diff --git a/drivers/staging/tidspbridge/include/dspbridge/msg.h b/drivers/staging/tidspbridge/include/dspbridge/msg.h
index 973bce2..007bb73 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/msg.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/msg.h
@@ -29,18 +29,18 @@
  *      can exist per device object. The msg_ctrl manager must be created before
  *      the IO Manager.
  *  Parameters:
- *      phMsgMgr:           Location to store msg_ctrl manager handle on output.
+ *      msg_man:            Location to store msg_ctrl manager handle on output.
  *      hdev_obj:         The device object.
  *      msg_callback:        Called whenever an RMS_EXIT message is received.
  *  Returns:
  *  Requires:
  *      msg_mod_init(void) called.
- *      phMsgMgr != NULL.
+ *      msg_man != NULL.
  *      hdev_obj != NULL.
  *      msg_callback != NULL.
  *  Ensures:
  */
-extern int msg_create(OUT struct msg_mgr **phMsgMgr,
+extern int msg_create(OUT struct msg_mgr **msg_man,
 			     struct dev_object *hdev_obj,
 			     msg_onexit msg_callback);
 
diff --git a/drivers/staging/tidspbridge/include/dspbridge/nldr.h b/drivers/staging/tidspbridge/include/dspbridge/nldr.h
index 492c826..3482fe3 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/nldr.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/nldr.h
@@ -28,7 +28,7 @@
 extern int nldr_allocate(struct nldr_object *nldr_obj,
 				void *priv_ref, IN CONST struct dcd_nodeprops
 				*node_props,
-				OUT struct nldr_nodeobject **phNldrNode,
+				OUT struct nldr_nodeobject **nldr_nodeobj,
 				IN bool *pf_phase_split);
 
 extern int nldr_create(OUT struct nldr_object **phNldr,
diff --git a/drivers/staging/tidspbridge/include/dspbridge/nldrdefs.h b/drivers/staging/tidspbridge/include/dspbridge/nldrdefs.h
index d53b43e..17c5d70 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/nldrdefs.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/nldrdefs.h
@@ -112,7 +112,7 @@ enum nldr_phase {
  *      nldr_obj:          Handle of loader that will load the node.
  *      priv_ref:       Handle to identify the node.
  *      node_props:     Pointer to a dcd_nodeprops for the node.
- *      phNldrNode:     Location to store node handle on output. This handle
+ *      nldr_nodeobj:   Location to store node handle on output. This handle
  *                      will be passed to nldr_load/nldr_unload.
  *      pf_phase_split:   pointer to int variable referenced in node.c
  *  Returns:
@@ -122,17 +122,17 @@ enum nldr_phase {
  *      nldr_init(void) called.
  *      Valid nldr_obj.
  *      node_props != NULL.
- *      phNldrNode != NULL.
+ *      nldr_nodeobj != NULL.
  *  Ensures:
- *      0:        IsValidNode(*phNldrNode).
- *      error:          *phNldrNode == NULL.
+ *      0:        IsValidNode(*nldr_nodeobj).
+ *      error:          *nldr_nodeobj == NULL.
  */
 typedef int(*nldr_allocatefxn) (struct nldr_object *nldr_obj,
 				       void *priv_ref,
 				       IN CONST struct dcd_nodeprops
 				       * node_props,
 				       OUT struct nldr_nodeobject
-				       **phNldrNode,
+				       **nldr_nodeobj,
 				       OUT bool *pf_phase_split);
 
 /*
diff --git a/drivers/staging/tidspbridge/include/dspbridge/proc.h b/drivers/staging/tidspbridge/include/dspbridge/proc.h
index 11fdc97..cbd26dc 100644
--- a/drivers/staging/tidspbridge/include/dspbridge/proc.h
+++ b/drivers/staging/tidspbridge/include/dspbridge/proc.h
@@ -208,19 +208,19 @@ extern void proc_exit(void);
  *      Returns the DEV Hanlde for a given Processor handle
  *  Parameters:
  *      hprocessor  :   Processor Handle
- *      phDevObject :   Location to store the DEV Handle.
+ *      device_obj :    Location to store the DEV Handle.
  *  Returns:
- *      0     :   Success; *phDevObject has Dev handle
- *      -EPERM   :   Failure; *phDevObject is zero.
+ *      0     :   Success; *device_obj has Dev handle
+ *      -EPERM   :   Failure; *device_obj is zero.
  *  Requires:
- *      phDevObject is not NULL
+ *      device_obj is not NULL
  *      PROC Initialized.
  *  Ensures:
- *      0     :   *phDevObject is not NULL
- *      -EPERM   :   *phDevObject is NULL.
+ *      0     :   *device_obj is not NULL
+ *      -EPERM   :   *device_obj is NULL.
  */
 extern int proc_get_dev_object(void *hprocessor,
-				      struct dev_object **phDevObject);
+				      struct dev_object **device_obj);
 
 /*
  *  ======== proc_init ========
diff --git a/drivers/staging/tidspbridge/pmgr/cod.c b/drivers/staging/tidspbridge/pmgr/cod.c
index 8317d03..e8d5b7e 100644
--- a/drivers/staging/tidspbridge/pmgr/cod.c
+++ b/drivers/staging/tidspbridge/pmgr/cod.c
@@ -215,7 +215,7 @@ void cod_close(struct cod_libraryobj *lib)
  *      dynamically loaded object files.
  *
  */
-int cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
+int cod_create(OUT struct cod_manager **mgr, char *pstrDummyFile,
 		      IN OPTIONAL CONST struct cod_attrs *attrs)
 {
 	struct cod_manager *mgr_new;
@@ -223,10 +223,10 @@ int cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMgr != NULL);
+	DBC_REQUIRE(mgr != NULL);
 
 	/* assume failure */
-	*phMgr = NULL;
+	*mgr = NULL;
 
 	/* we don't support non-default attrs yet */
 	if (attrs != NULL)
@@ -271,7 +271,7 @@ int cod_create(OUT struct cod_manager **phMgr, char *pstrDummyFile,
 	}
 
 	/* return the new manager */
-	*phMgr = mgr_new;
+	*mgr = mgr_new;
 
 	return 0;
 }
@@ -377,15 +377,15 @@ int cod_get_entry(struct cod_manager *cod_mgr_obj, u32 *pulEntry)
  *      Get handle to the DBLL loader.
  */
 int cod_get_loader(struct cod_manager *cod_mgr_obj,
-			  struct dbll_tar_obj **phLoader)
+			  struct dbll_tar_obj **loader)
 {
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(IS_VALID(cod_mgr_obj));
-	DBC_REQUIRE(phLoader != NULL);
+	DBC_REQUIRE(loader != NULL);
 
-	*phLoader = (struct dbll_tar_obj *)cod_mgr_obj->target;
+	*loader = (struct dbll_tar_obj *)cod_mgr_obj->target;
 
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/pmgr/dev.c b/drivers/staging/tidspbridge/pmgr/dev.c
index 1cb891f..f93d096 100644
--- a/drivers/staging/tidspbridge/pmgr/dev.c
+++ b/drivers/staging/tidspbridge/pmgr/dev.c
@@ -131,7 +131,7 @@ u32 dev_brd_write_fxn(void *arb, u32 ulDspAddr, void *pHostBuf,
  *      Called by the operating system to load the PM Bridge Driver for a
  *      PM board (device).
  */
-int dev_create_device(OUT struct dev_object **phDevObject,
+int dev_create_device(OUT struct dev_object **device_obj,
 			     IN CONST char *driver_file_name,
 			     struct cfg_devnode *dev_node_obj)
 {
@@ -145,7 +145,7 @@ int dev_create_device(OUT struct dev_object **phDevObject,
 	struct drv_object *hdrv_obj = NULL;
 	int status = 0;
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(device_obj != NULL);
 	DBC_REQUIRE(driver_file_name != NULL);
 
 	status = drv_request_bridge_res_dsp((void *)&host_res);
@@ -262,7 +262,7 @@ leave:
 	/*  If all went well, return a handle to the dev object;
 	 *  else, cleanup and return NULL in the OUT parameter. */
 	if (DSP_SUCCEEDED(status)) {
-		*phDevObject = dev_obj;
+		*device_obj = dev_obj;
 	} else {
 		if (dev_obj) {
 			kfree(dev_obj->proc_list);
@@ -273,11 +273,11 @@ leave:
 			kfree(dev_obj);
 		}
 
-		*phDevObject = NULL;
+		*device_obj = NULL;
 	}
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDevObject) ||
-		   (DSP_FAILED(status) && !*phDevObject));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *device_obj) ||
+		   (DSP_FAILED(status) && !*device_obj));
 	return status;
 }
 
@@ -420,23 +420,23 @@ int dev_destroy_device(struct dev_object *hdev_obj)
  *      device.
  */
 int dev_get_chnl_mgr(struct dev_object *hdev_obj,
-			    OUT struct chnl_mgr **phMgr)
+			    OUT struct chnl_mgr **mgr)
 {
 	int status = 0;
 	struct dev_object *dev_obj = hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMgr != NULL);
+	DBC_REQUIRE(mgr != NULL);
 
 	if (hdev_obj) {
-		*phMgr = dev_obj->hchnl_mgr;
+		*mgr = dev_obj->hchnl_mgr;
 	} else {
-		*phMgr = NULL;
+		*mgr = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-					     (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
+					     (*mgr == NULL)));
 	return status;
 }
 
@@ -447,23 +447,23 @@ int dev_get_chnl_mgr(struct dev_object *hdev_obj,
  *      device.
  */
 int dev_get_cmm_mgr(struct dev_object *hdev_obj,
-			   OUT struct cmm_object **phMgr)
+			   OUT struct cmm_object **mgr)
 {
 	int status = 0;
 	struct dev_object *dev_obj = hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMgr != NULL);
+	DBC_REQUIRE(mgr != NULL);
 
 	if (hdev_obj) {
-		*phMgr = dev_obj->hcmm_mgr;
+		*mgr = dev_obj->hcmm_mgr;
 	} else {
-		*phMgr = NULL;
+		*mgr = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-					     (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
+					     (*mgr == NULL)));
 	return status;
 }
 
@@ -474,23 +474,23 @@ int dev_get_cmm_mgr(struct dev_object *hdev_obj,
  *      device.
  */
 int dev_get_dmm_mgr(struct dev_object *hdev_obj,
-			   OUT struct dmm_object **phMgr)
+			   OUT struct dmm_object **mgr)
 {
 	int status = 0;
 	struct dev_object *dev_obj = hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMgr != NULL);
+	DBC_REQUIRE(mgr != NULL);
 
 	if (hdev_obj) {
-		*phMgr = dev_obj->dmm_mgr;
+		*mgr = dev_obj->dmm_mgr;
 	} else {
-		*phMgr = NULL;
+		*mgr = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phMgr != NULL) &&
-					     (*phMgr == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((mgr != NULL) &&
+					     (*mgr == NULL)));
 	return status;
 }
 
@@ -546,23 +546,23 @@ int dev_get_deh_mgr(struct dev_object *hdev_obj,
  *      Retrieve the platform specific device ID for this device.
  */
 int dev_get_dev_node(struct dev_object *hdev_obj,
-			    OUT struct cfg_devnode **phDevNode)
+			    OUT struct cfg_devnode **dev_nde)
 {
 	int status = 0;
 	struct dev_object *dev_obj = hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDevNode != NULL);
+	DBC_REQUIRE(dev_nde != NULL);
 
 	if (hdev_obj) {
-		*phDevNode = dev_obj->dev_node_obj;
+		*dev_nde = dev_obj->dev_node_obj;
 	} else {
-		*phDevNode = NULL;
+		*dev_nde = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE(DSP_SUCCEEDED(status) || ((phDevNode != NULL) &&
-					     (*phDevNode == NULL)));
+	DBC_ENSURE(DSP_SUCCEEDED(status) || ((dev_nde != NULL) &&
+					     (*dev_nde == NULL)));
 	return status;
 }
 
@@ -612,18 +612,18 @@ int dev_get_intf_fxns(struct dev_object *hdev_obj,
  *  ========= dev_get_io_mgr ========
  */
 int dev_get_io_mgr(struct dev_object *hdev_obj,
-			  OUT struct io_mgr **phIOMgr)
+			  OUT struct io_mgr **io_man)
 {
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(io_man != NULL);
 	DBC_REQUIRE(hdev_obj);
 
 	if (hdev_obj) {
-		*phIOMgr = hdev_obj->hio_mgr;
+		*io_man = hdev_obj->hio_mgr;
 	} else {
-		*phIOMgr = NULL;
+		*io_man = NULL;
 		status = -EFAULT;
 	}
 
@@ -652,13 +652,13 @@ struct dev_object *dev_get_next(struct dev_object *hdev_obj)
 /*
  *  ========= dev_get_msg_mgr ========
  */
-void dev_get_msg_mgr(struct dev_object *hdev_obj, OUT struct msg_mgr **phMsgMgr)
+void dev_get_msg_mgr(struct dev_object *hdev_obj, OUT struct msg_mgr **msg_man)
 {
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(msg_man != NULL);
 	DBC_REQUIRE(hdev_obj);
 
-	*phMsgMgr = hdev_obj->hmsg_mgr;
+	*msg_man = hdev_obj->hmsg_mgr;
 }
 
 /*
diff --git a/drivers/staging/tidspbridge/pmgr/dmm.c b/drivers/staging/tidspbridge/pmgr/dmm.c
index e0be8e0..96af2cc 100644
--- a/drivers/staging/tidspbridge/pmgr/dmm.c
+++ b/drivers/staging/tidspbridge/pmgr/dmm.c
@@ -117,21 +117,21 @@ int dmm_create_tables(struct dmm_object *dmm_mgr, u32 addr, u32 size)
  *  Purpose:
  *      Create a dynamic memory manager object.
  */
-int dmm_create(OUT struct dmm_object **phDmmMgr,
+int dmm_create(OUT struct dmm_object **dmm_manager,
 		      struct dev_object *hdev_obj,
 		      IN CONST struct dmm_mgrattrs *pMgrAttrs)
 {
 	struct dmm_object *dmm_obj = NULL;
 	int status = 0;
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDmmMgr != NULL);
+	DBC_REQUIRE(dmm_manager != NULL);
 
-	*phDmmMgr = NULL;
+	*dmm_manager = NULL;
 	/* create, zero, and tag a cmm mgr object */
 	dmm_obj = kzalloc(sizeof(struct dmm_object), GFP_KERNEL);
 	if (dmm_obj != NULL) {
 		spin_lock_init(&dmm_obj->dmm_lock);
-		*phDmmMgr = dmm_obj;
+		*dmm_manager = dmm_obj;
 	} else {
 		status = -ENOMEM;
 	}
@@ -197,20 +197,20 @@ void dmm_exit(void)
  *      Return the dynamic memory manager object for this device.
  *      This is typically called from the client process.
  */
-int dmm_get_handle(void *hprocessor, OUT struct dmm_object **phDmmMgr)
+int dmm_get_handle(void *hprocessor, OUT struct dmm_object **dmm_manager)
 {
 	int status = 0;
 	struct dev_object *hdev_obj;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDmmMgr != NULL);
+	DBC_REQUIRE(dmm_manager != NULL);
 	if (hprocessor != NULL)
 		status = proc_get_dev_object(hprocessor, &hdev_obj);
 	else
 		hdev_obj = dev_get_first();	/* default */
 
 	if (DSP_SUCCEEDED(status))
-		status = dev_get_dmm_mgr(hdev_obj, phDmmMgr);
+		status = dev_get_dmm_mgr(hdev_obj, dmm_manager);
 
 	return status;
 }
diff --git a/drivers/staging/tidspbridge/pmgr/io.c b/drivers/staging/tidspbridge/pmgr/io.c
index c6ad203..fdd3390 100644
--- a/drivers/staging/tidspbridge/pmgr/io.c
+++ b/drivers/staging/tidspbridge/pmgr/io.c
@@ -46,7 +46,7 @@ static u32 refs;
  *      Create an IO manager object, responsible for managing IO between
  *      CHNL and msg_ctrl
  */
-int io_create(OUT struct io_mgr **phIOMgr, struct dev_object *hdev_obj,
+int io_create(OUT struct io_mgr **io_man, struct dev_object *hdev_obj,
 		     IN CONST struct io_attrs *pMgrAttrs)
 {
 	struct bridge_drv_interface *intf_fxns;
@@ -55,10 +55,10 @@ int io_create(OUT struct io_mgr **phIOMgr, struct dev_object *hdev_obj,
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phIOMgr != NULL);
+	DBC_REQUIRE(io_man != NULL);
 	DBC_REQUIRE(pMgrAttrs != NULL);
 
-	*phIOMgr = NULL;
+	*io_man = NULL;
 
 	/* A memory base of 0 implies no memory base: */
 	if ((pMgrAttrs->shm_base != 0) && (pMgrAttrs->usm_length == 0))
@@ -80,7 +80,7 @@ int io_create(OUT struct io_mgr **phIOMgr, struct dev_object *hdev_obj,
 			pio_mgr->hdev_obj = hdev_obj;
 
 			/* Return the new channel manager handle: */
-			*phIOMgr = hio_mgr;
+			*io_man = hio_mgr;
 		}
 	}
 
diff --git a/drivers/staging/tidspbridge/pmgr/msg.c b/drivers/staging/tidspbridge/pmgr/msg.c
index 6122cd4..3903c41 100644
--- a/drivers/staging/tidspbridge/pmgr/msg.c
+++ b/drivers/staging/tidspbridge/pmgr/msg.c
@@ -45,7 +45,7 @@ static u32 refs;		/* module reference count */
  *      Create an object to manage message queues. Only one of these objects
  *      can exist per device object.
  */
-int msg_create(OUT struct msg_mgr **phMsgMgr,
+int msg_create(OUT struct msg_mgr **msg_man,
 		      struct dev_object *hdev_obj, msg_onexit msg_callback)
 {
 	struct bridge_drv_interface *intf_fxns;
@@ -54,11 +54,11 @@ int msg_create(OUT struct msg_mgr **phMsgMgr,
 	int status = 0;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phMsgMgr != NULL);
+	DBC_REQUIRE(msg_man != NULL);
 	DBC_REQUIRE(msg_callback != NULL);
 	DBC_REQUIRE(hdev_obj != NULL);
 
-	*phMsgMgr = NULL;
+	*msg_man = NULL;
 
 	dev_get_intf_fxns(hdev_obj, &intf_fxns);
 
@@ -73,7 +73,7 @@ int msg_create(OUT struct msg_mgr **phMsgMgr,
 		msg_mgr_obj->intf_fxns = intf_fxns;
 
 		/* Finally, return the new message manager handle: */
-		*phMsgMgr = hmsg_mgr;
+		*msg_man = hmsg_mgr;
 	} else {
 		status = -EPERM;
 	}
diff --git a/drivers/staging/tidspbridge/rmgr/disp.c b/drivers/staging/tidspbridge/rmgr/disp.c
index 5f51d50..9ebdf1e 100644
--- a/drivers/staging/tidspbridge/rmgr/disp.c
+++ b/drivers/staging/tidspbridge/rmgr/disp.c
@@ -87,7 +87,7 @@ static int send_message(struct disp_object *disp_obj, u32 timeout,
  *  ======== disp_create ========
  *  Create a NODE Dispatcher object.
  */
-int disp_create(OUT struct disp_object **phDispObject,
+int disp_create(OUT struct disp_object **dispatch_obj,
 		       struct dev_object *hdev_obj,
 		       IN CONST struct disp_attr *disp_attrs)
 {
@@ -99,11 +99,11 @@ int disp_create(OUT struct disp_object **phDispObject,
 	u8 dev_type;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDispObject != NULL);
+	DBC_REQUIRE(dispatch_obj != NULL);
 	DBC_REQUIRE(disp_attrs != NULL);
 	DBC_REQUIRE(hdev_obj != NULL);
 
-	*phDispObject = NULL;
+	*dispatch_obj = NULL;
 
 	/* Allocate Node Dispatcher object */
 	disp_obj = kzalloc(sizeof(struct disp_object), GFP_KERNEL);
@@ -166,12 +166,12 @@ int disp_create(OUT struct disp_object **phDispObject,
 	}
 func_cont:
 	if (DSP_SUCCEEDED(status))
-		*phDispObject = disp_obj;
+		*dispatch_obj = disp_obj;
 	else
 		delete_disp(disp_obj);
 
-	DBC_ENSURE(((DSP_FAILED(status)) && ((*phDispObject == NULL))) ||
-				((DSP_SUCCEEDED(status)) && *phDispObject));
+	DBC_ENSURE(((DSP_FAILED(status)) && ((*dispatch_obj == NULL))) ||
+				((DSP_SUCCEEDED(status)) && *dispatch_obj));
 	return status;
 }
 
diff --git a/drivers/staging/tidspbridge/rmgr/drv.c b/drivers/staging/tidspbridge/rmgr/drv.c
index 78211a6..b08341b 100644
--- a/drivers/staging/tidspbridge/rmgr/drv.c
+++ b/drivers/staging/tidspbridge/rmgr/drv.c
@@ -422,12 +422,12 @@ int drv_proc_update_strm_res(u32 num_bufs, void *hstrm_res)
  *  Purpose:
  *      DRV Object gets created only once during Driver Loading.
  */
-int drv_create(OUT struct drv_object **phDRVObject)
+int drv_create(OUT struct drv_object **drv_obj)
 {
 	int status = 0;
 	struct drv_object *pdrv_object = NULL;
 
-	DBC_REQUIRE(phDRVObject != NULL);
+	DBC_REQUIRE(drv_obj != NULL);
 	DBC_REQUIRE(refs > 0);
 
 	pdrv_object = kzalloc(sizeof(struct drv_object), GFP_KERNEL);
@@ -456,7 +456,7 @@ int drv_create(OUT struct drv_object **phDRVObject)
 	if (DSP_SUCCEEDED(status))
 		status = cfg_set_object((u32) pdrv_object, REG_DRV_OBJECT);
 	if (DSP_SUCCEEDED(status)) {
-		*phDRVObject = pdrv_object;
+		*drv_obj = pdrv_object;
 	} else {
 		kfree(pdrv_object->dev_list);
 		kfree(pdrv_object->dev_node_string);
@@ -515,7 +515,7 @@ int drv_destroy(struct drv_object *driver_obj)
  *      Given a index, returns a handle to DevObject from the list.
  */
 int drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
-			      struct dev_object **phDevObject)
+			      struct dev_object **device_obj)
 {
 	int status = 0;
 #ifdef CONFIG_TIDSPBRIDGE_DEBUG
@@ -525,7 +525,7 @@ int drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
 	struct dev_object *dev_obj;
 	u32 i;
 	DBC_REQUIRE(pdrv_obj);
-	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(device_obj != NULL);
 	DBC_REQUIRE(index >= 0);
 	DBC_REQUIRE(refs > 0);
 	DBC_ASSERT(!(LST_IS_EMPTY(pdrv_obj->dev_list)));
@@ -536,9 +536,9 @@ int drv_get_dev_object(u32 index, struct drv_object *hdrv_obj,
 		    (struct dev_object *)drv_get_next_dev_object((u32) dev_obj);
 	}
 	if (dev_obj) {
-		*phDevObject = (struct dev_object *)dev_obj;
+		*device_obj = (struct dev_object *)dev_obj;
 	} else {
-		*phDevObject = NULL;
+		*device_obj = NULL;
 		status = -EPERM;
 	}
 
diff --git a/drivers/staging/tidspbridge/rmgr/mgr.c b/drivers/staging/tidspbridge/rmgr/mgr.c
index 43be669..3f52660 100644
--- a/drivers/staging/tidspbridge/rmgr/mgr.c
+++ b/drivers/staging/tidspbridge/rmgr/mgr.c
@@ -52,13 +52,13 @@ static u32 refs;
  *  Purpose:
  *      MGR Object gets created only once during driver Loading.
  */
-int mgr_create(OUT struct mgr_object **phMgrObject,
+int mgr_create(OUT struct mgr_object **mgr_obj,
 		      struct cfg_devnode *dev_node_obj)
 {
 	int status = 0;
 	struct mgr_object *pmgr_obj = NULL;
 
-	DBC_REQUIRE(phMgrObject != NULL);
+	DBC_REQUIRE(mgr_obj != NULL);
 	DBC_REQUIRE(refs > 0);
 
 	pmgr_obj = kzalloc(sizeof(struct mgr_object), GFP_KERNEL);
@@ -68,7 +68,7 @@ int mgr_create(OUT struct mgr_object **phMgrObject,
 			/* If succeeded store the handle in the MGR Object */
 			status = cfg_set_object((u32) pmgr_obj, REG_MGR_OBJECT);
 			if (DSP_SUCCEEDED(status)) {
-				*phMgrObject = pmgr_obj;
+				*mgr_obj = pmgr_obj;
 			} else {
 				dcd_destroy_manager(pmgr_obj->hdcd_mgr);
 				kfree(pmgr_obj);
diff --git a/drivers/staging/tidspbridge/rmgr/nldr.c b/drivers/staging/tidspbridge/rmgr/nldr.c
index 51b9d03..6129306 100644
--- a/drivers/staging/tidspbridge/rmgr/nldr.c
+++ b/drivers/staging/tidspbridge/rmgr/nldr.c
@@ -325,7 +325,7 @@ static u32 find_gcf(u32 a, u32 b);
  */
 int nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 			 IN CONST struct dcd_nodeprops *node_props,
-			 OUT struct nldr_nodeobject **phNldrNode,
+			 OUT struct nldr_nodeobject **nldr_nodeobj,
 			 IN bool *pf_phase_split)
 {
 	struct nldr_nodeobject *nldr_node_obj = NULL;
@@ -333,11 +333,11 @@ int nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 
 	DBC_REQUIRE(refs > 0);
 	DBC_REQUIRE(node_props != NULL);
-	DBC_REQUIRE(phNldrNode != NULL);
+	DBC_REQUIRE(nldr_nodeobj != NULL);
 	DBC_REQUIRE(nldr_obj);
 
 	/* Initialize handle in case of failure */
-	*phNldrNode = NULL;
+	*nldr_nodeobj = NULL;
 	/* Allocate node object */
 	nldr_node_obj = kzalloc(sizeof(struct nldr_nodeobject), GFP_KERNEL);
 
@@ -410,14 +410,14 @@ int nldr_allocate(struct nldr_object *nldr_obj, void *priv_ref,
 				nldr_node_obj->overlay = true;
 
 		}
-		*phNldrNode = (struct nldr_nodeobject *)nldr_node_obj;
+		*nldr_nodeobj = (struct nldr_nodeobject *)nldr_node_obj;
 	}
 	/* Cleanup on failure */
 	if (DSP_FAILED(status) && nldr_node_obj)
 		kfree(nldr_node_obj);
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *phNldrNode)
-		   || (DSP_FAILED(status) && *phNldrNode == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *nldr_nodeobj)
+		   || (DSP_FAILED(status) && *nldr_nodeobj == NULL));
 	return status;
 }
 
diff --git a/drivers/staging/tidspbridge/rmgr/proc.c b/drivers/staging/tidspbridge/rmgr/proc.c
index 03497e2..20f887b 100644
--- a/drivers/staging/tidspbridge/rmgr/proc.c
+++ b/drivers/staging/tidspbridge/rmgr/proc.c
@@ -936,24 +936,24 @@ void proc_exit(void)
  *
  */
 int proc_get_dev_object(void *hprocessor,
-			       struct dev_object **phDevObject)
+			       struct dev_object **device_obj)
 {
 	int status = -EPERM;
 	struct proc_object *p_proc_object = (struct proc_object *)hprocessor;
 
 	DBC_REQUIRE(refs > 0);
-	DBC_REQUIRE(phDevObject != NULL);
+	DBC_REQUIRE(device_obj != NULL);
 
 	if (p_proc_object) {
-		*phDevObject = p_proc_object->hdev_obj;
+		*device_obj = p_proc_object->hdev_obj;
 		status = 0;
 	} else {
-		*phDevObject = NULL;
+		*device_obj = NULL;
 		status = -EFAULT;
 	}
 
-	DBC_ENSURE((DSP_SUCCEEDED(status) && *phDevObject != NULL) ||
-		   (DSP_FAILED(status) && *phDevObject == NULL));
+	DBC_ENSURE((DSP_SUCCEEDED(status) && *device_obj != NULL) ||
+		   (DSP_FAILED(status) && *device_obj == NULL));
 
 	return status;
 }
-- 
1.7.1

