diff -urN linux-2.6.32-rc6.old/drivers/net/ks8851.c linux-2.6.32-rc6.new/drivers/net/ks8851.c
--- linux-2.6.32-rc6.old/drivers/net/ks8851.c	2009-11-03 11:37:49.000000000 -0800
+++ linux-2.6.32-rc6.new/drivers/net/ks8851.c	2009-11-06 12:40:29.000000000 -0800
@@ -1,4 +1,4 @@
-/* drivers/net/ks8651.c
+/* drivers/net/ks8851.c
  *
  * Copyright 2009 Simtec Electronics
  *	http://www.simtec.co.uk/
@@ -111,11 +111,13 @@
 	struct mii_if_info	mii;
 	struct ks8851_rxctrl	rxctrl;
 
+	struct work_struct	tx_check;
 	struct work_struct	tx_work;
 	struct work_struct	irq_work;
 	struct work_struct	rxctrl_work;
 
 	struct sk_buff_head	txq;
+	int			tx_len;
 
 	struct spi_message	spi_msg1;
 	struct spi_message	spi_msg2;
@@ -396,7 +398,9 @@
 {
 	struct ks8851_net *ks = pw;
 
+#if 0
 	disable_irq_nosync(irq);
+#endif
 	schedule_work(&ks->irq_work);
 	return IRQ_HANDLED;
 }
@@ -504,9 +508,11 @@
 
 		if (rxlen > 0) {
 			skb = netdev_alloc_skb(ks->netdev, rxlen + 2 + 8);
+#if 0
 			if (!skb) {
 				/* todo - dump frame and move on */
 			}
+#endif
 
 			/* two bytes to ensure ip is aligned, and four bytes
 			 * for the status header and 4 bytes of garbage */
@@ -573,6 +579,7 @@
 	if (status & IRQ_RXPSI)
 		handled |= IRQ_RXPSI;
 
+#if 0
 	if (status & IRQ_TXI) {
 		handled |= IRQ_TXI;
 
@@ -585,6 +592,7 @@
 		if (netif_msg_intr(ks))
 			ks_dbg(ks, "%s: txspace %d\n", __func__, ks->tx_space);
 	}
+#endif
 
 	if (status & IRQ_RXI)
 		handled |= IRQ_RXI;
@@ -623,10 +631,12 @@
 
 	mutex_unlock(&ks->lock);
 
+#if 0
 	if (status & IRQ_TXI)
 		netif_wake_queue(ks->netdev);
 
 	enable_irq(ks->netdev->irq);
+#endif
 }
 
 /**
@@ -703,6 +713,17 @@
 	dev_kfree_skb(txb);
 }
 
+static void ks8851_tx_check(struct work_struct *work)
+{
+	struct ks8851_net *ks = container_of(work, struct ks8851_net, tx_check);
+
+	ks->tx_space = ks8851_rdreg16(ks, KS_TXMIR);
+	if (ks->tx_space > ks->tx_len)
+		netif_wake_queue(ks->netdev);
+	else
+		schedule_work(&ks->tx_check);
+}
+
 /**
  * ks8851_tx_work - process tx packet(s)
  * @work: The work strucutre what was scheduled.
@@ -714,7 +735,7 @@
 {
 	struct ks8851_net *ks = container_of(work, struct ks8851_net, tx_work);
 	struct sk_buff *txb;
-	bool last = false;
+	bool last = skb_queue_empty(&ks->txq);
 
 	mutex_lock(&ks->lock);
 
@@ -794,6 +815,7 @@
 	ks8851_wrreg16(ks, KS_RXCR1, (RXCR1_RXPAFMA | /*  from mac filter */
 				      RXCR1_RXFCE | /* enable flow control */
 				      RXCR1_RXBE | /* broadcast enable */
+				      RXCR1_RXME | /* multicast enable */
 				      RXCR1_RXUE | /* unicast enable */
 				      RXCR1_RXE)); /* enable rx block */
 
@@ -814,7 +836,6 @@
 	/* clear then enable interrupts */
 
 #define STD_IRQ (IRQ_LCI |	/* Link Change */	\
-		 IRQ_TXI |	/* TX done */		\
 		 IRQ_RXI |	/* RX done */		\
 		 IRQ_SPIBEI |	/* SPI bus error */	\
 		 IRQ_TXPSI |	/* TX process stop */	\
@@ -830,6 +851,7 @@
 		ks_dbg(ks, "network device %s up\n", dev->name);
 
 	mutex_unlock(&ks->lock);
+	ks8851_write_mac_addr(dev);
 	return 0;
 }
 
@@ -854,6 +876,7 @@
 
 	/* stop any outstanding work */
 	flush_work(&ks->irq_work);
+	flush_work(&ks->tx_check);
 	flush_work(&ks->tx_work);
 	flush_work(&ks->rxctrl_work);
 
@@ -912,14 +935,16 @@
 
 	if (needed > ks->tx_space) {
 		netif_stop_queue(dev);
+		ks->tx_len = needed;
+		schedule_work(&ks->tx_check);
 		ret = NETDEV_TX_BUSY;
 	} else {
 		ks->tx_space -= needed;
 		skb_queue_tail(&ks->txq, skb);
+		schedule_work(&ks->tx_work);
 	}
 
 	spin_unlock(&ks->statelock);
-	schedule_work(&ks->tx_work);
 
 	return ret;
 }
@@ -939,7 +964,8 @@
  */
 static void ks8851_rxctrl_work(struct work_struct *work)
 {
-	struct ks8851_net *ks = container_of(work, struct ks8851_net, rxctrl_work);
+	struct ks8851_net *ks =
+		container_of(work, struct ks8851_net, rxctrl_work);
 
 	mutex_lock(&ks->lock);
 
@@ -963,7 +989,7 @@
 	} else if (dev->flags & IFF_ALLMULTI) {
 		/* accept all multicast packets */
 
-		rxctrl.rxcr1 = (RXCR1_RXME | RXCR1_RXAE |
+		rxctrl.rxcr1 = (RXCR1_RXAE |
 				RXCR1_RXPAFMA | RXCR1_RXMAFMA);
 	} else if (dev->flags & IFF_MULTICAST && dev->mc_count > 0) {
 		struct dev_mc_list *mcptr = dev->mc_list;
@@ -980,7 +1006,7 @@
 			mcptr = mcptr->next;
 		}
 
-		rxctrl.rxcr1 = RXCR1_RXME | RXCR1_RXPAFMA;
+		rxctrl.rxcr1 = RXCR1_RXPAFMA;
 	} else {
 		/* just accept broadcast / unicast */
 		rxctrl.rxcr1 = RXCR1_RXPAFMA;
@@ -988,6 +1014,7 @@
 
 	rxctrl.rxcr1 |= (RXCR1_RXUE | /* unicast enable */
 			 RXCR1_RXBE | /* broadcast enable */
+			 RXCR1_RXME | /* multicast enable */
 			 RXCR1_RXE | /* RX process enable */
 			 RXCR1_RXFCE); /* enable flow control */
 
@@ -1229,6 +1256,7 @@
 	mutex_init(&ks->lock);
 	spin_lock_init(&ks->statelock);
 
+	INIT_WORK(&ks->tx_check, ks8851_tx_check);
 	INIT_WORK(&ks->tx_work, ks8851_tx_work);
 	INIT_WORK(&ks->irq_work, ks8851_irq_work);
 	INIT_WORK(&ks->rxctrl_work, ks8851_rxctrl_work);
@@ -1281,8 +1309,9 @@
 
 	ks8851_read_selftest(ks);
 	ks8851_init_mac(ks);
+	ks->tx_space = ks8851_rdreg16(ks, KS_TXMIR);
 
-	ret = request_irq(spi->irq, ks8851_irq, IRQF_TRIGGER_LOW,
+	ret = request_irq(spi->irq, ks8851_irq, IRQF_TRIGGER_FALLING,
 			  ndev->name, ks);
 	if (ret < 0) {
 		dev_err(&spi->dev, "failed to get irq\n");
